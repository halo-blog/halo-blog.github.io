<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Docker | HALO</title><meta name="author" content="HALO"><meta name="copyright" content="HALO"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="初识 Docker 什么是 Docker 微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。  分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题  应用部署的环境问题 大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：   依赖关系复杂，容易出现兼容性问题   开发、测试、生产环境有差异">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/B_Docker%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="HALO">
<meta property="og:description" content="初识 Docker 什么是 Docker 微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。  分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题  应用部署的环境问题 大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：   依赖关系复杂，容易出现兼容性问题   开发、测试、生产环境有差异">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg">
<meta property="article:published_time" content="2021-09-20T05:57:08.806Z">
<meta property="article:modified_time" content="2021-09-20T05:58:11.275Z">
<meta property="article:author" content="HALO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg"><link rel="shortcut icon" href="/img/favicon6.png"><link rel="canonical" href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/B_Docker%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?874122390435717e6f6a55f14b9d7271";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-8ZMD16RCP5"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-8ZMD16RCP5');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-09-20 13:58:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/css/bilibili-banner.css"  media="defer" onload="this.media='screen'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="HALO" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://img.imgdb.cn/item/608289f3d1a9ae528feb09a8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">137</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">35</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i><span> 反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/page/about/"><i class="fa-fw fas fa-bookmark"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/137f30002b2fd221da0e9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HALO</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/page/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/page/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/page/message/"><i class="fa-fw fas fa-envelope"></i><span> 反馈</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/page/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/page/toolsLink/"><i class="fa-fw fas fa-link"></i><span> 实用工具</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/page/about/"><i class="fa-fw fas fa-bookmark"></i><span> 关于</span></a></div></div><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="winterBanner"><div class="view"><img class="morning" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-view-1.png" alt=""><img class="afternoon" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-view-2.png" alt=""><video class="evening" autoplay="" loop="" muted=""><source src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-view-3.webm" type="video/webm"></video><img class="window-cover" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-view-3-snow.png" alt=""></div><div class="tree"><img class="morning" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-tree-1.png" alt=""><img class="afternoon" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-tree-2.png" alt=""><img class="evening" src="https://halo-blog-img.oss-cn-hangzhou.aliyuncs.com/BiliBiliBanner/winter/bilibili-winter-tree-3.png" alt=""></div></div><script async data-pjax src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/bilibiliBanner.js"></script><div id="post-info"><h1 class="post-title">Docker<a class="post-edit-link" href="https://github.com/halo-blog/halo-blog-hexo/tree/main/source/_posts/WebBackEnd/微服务/B_Docker入门.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-20T05:57:08.806Z" title="发表于 2021-09-20 13:57:08">2021-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-09-20T05:58:11.275Z" title="更新于 2021-09-20 13:58:11">2021-09-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="初识-Docker"><a class="header-anchor" href="#初识-Docker"></a>初识 Docker</h2>
<h3 id="什么是-Docker"><a class="header-anchor" href="#什么是-Docker"></a>什么是 Docker</h3>
<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h4 id="应用部署的环境问题"><a class="header-anchor" href="#应用部署的环境问题"></a>应用部署的环境问题</h4>
<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li>
<p>依赖关系复杂，容易出现兼容性问题</p>
</li>
<li>
<p>开发、测试、生产环境有差异</p>
</li>
</ul>
<p>例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h4 id="Docker-解决依赖兼容问题"><a class="header-anchor" href="#Docker-解决依赖兼容问题"></a>Docker 解决依赖兼容问题</h4>
<p>而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？</p>
<p>Docker 为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li>
<p>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>
</li>
<li>
<p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>
</li>
</ul>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h4 id="Docker-解决操作系统环境差异"><a class="header-anchor" href="#Docker-解决操作系统环境差异"></a>Docker 解决操作系统环境差异</h4>
<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。计算机系统结构如下：</p>
<ul>
<li>计算机硬件：例如 CPU、内存、磁盘等</li>
<li>系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<ul>
<li>应用调用操作系统应用（函数库），实现各种功能</li>
<li>系统函数库是对内核指令集的封装，会调用内核指令</li>
<li>内核指令操作计算机硬件</li>
</ul>
<p>Ubuntu 和 CentOS 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异。此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了。</p>
<p>Docker 如何解决不同系统环境的问题？</p>
<ul>
<li>Docker 将用户程序与所需要调用的系统（比如 Ubuntu）函数库一起打包</li>
<li>Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li>
</ul>
<h4 id="什么是-Docker-小结"><a class="header-anchor" href="#什么是-Docker-小结"></a>什么是 Docker 小结</h4>
<p>Docker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker 允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker 应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行</li>
</ul>
<p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h3 id="Docker-和虚拟机的区别"><a class="header-anchor" href="#Docker-和虚拟机的区别"></a>Docker 和虚拟机的区别</h3>
<p>Docker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。</p>
<p>Docker 仅仅是封装函数库，并没有模拟完整的操作系统</p>
<p>两者有什么差异呢？</p>
<ul>
<li>
<p>Docker 是一个系统进程；虚拟机是在操作系统中的操作系统</p>
</li>
<li>
<p>Docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>
</li>
</ul>
<h3 id="Docker-基本知识"><a class="header-anchor" href="#Docker-基本知识"></a>Docker 基本知识</h3>
<h4 id="镜像和容器"><a class="header-anchor" href="#镜像和容器"></a>镜像和容器</h4>
<p>Docker 中有几个重要的概念：</p>
<ul>
<li>镜像（Image）：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</li>
<li>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是 Docker 会给容器进程做隔离，对外不可见。</li>
</ul>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<ul>
<li>镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</li>
<li>容器，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。</li>
</ul>
<p>因此一个镜像可以启动多次，形成多个容器进程。</p>
<h4 id="DockerHub"><a class="header-anchor" href="#DockerHub"></a>DockerHub</h4>
<p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。</p>
<ul>
<li>
<p>DockerHub ：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。</p>
</li>
<li>
<p>国内也有类似于 DockerHub 的公开服务，比如 <a target="_blank" rel="noopener" href="https://c.163yun.com/hub">网易云镜像服务</a>、<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/">阿里云镜像库</a> 等。</p>
</li>
</ul>
<h4 id="Docker-架构"><a class="header-anchor" href="#Docker-架构"></a>Docker 架构</h4>
<p>我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。</p>
<p>Docker 是一个 CS 架构的程序，由两部分组成：</p>
<ul>
<li>
<p>服务端（server）：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</p>
</li>
<li>
<p>客户端（client）：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E6%9E%B6%E6%9E%84.4alzm4dto2g0.svg" alt="Docker架构"></p>
<h2 id="配置-Docker"><a class="header-anchor" href="#配置-Docker"></a>配置 Docker</h2>
<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>
<p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>
<p>官方网站上有各种环境下的 <a target="_blank" rel="noopener" href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p>
<h3 id="CentOS-安装-Docker"><a class="header-anchor" href="#CentOS-安装-Docker"></a>CentOS 安装 Docker</h3>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在 CentOS 7 安装 Docker。</p>
<h4 id="卸载-Docker（可选）"><a class="header-anchor" href="#卸载-Docker（可选）"></a>卸载 Docker（可选）</h4>
<p>如果之前安装过旧版本的 Docker，可以使用下面命令卸载：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure>
<h4 id="安装-Docker"><a class="header-anchor" href="#安装-Docker"></a>安装 Docker</h4>
<p>安装 yum 工具</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure>
<p>然后更新本地镜像源：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i <span class="string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>
<p>然后输入命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>
<p>docker-ce 为社区免费版本。稍等片刻，docker 即可安装成功。</p>
<h3 id="启动-Docker"><a class="header-anchor" href="#启动-Docker"></a>启动 Docker</h3>
<p>Docker 应用需要用到各种端口，逐一去修改防火墙设置。学习时可以直接关闭防火墙。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>
<p>通过命令启动 Docker：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure>
<p>然后输入命令，可以查看 Docker 版本：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<h3 id="配置镜像加速"><a class="header-anchor" href="#配置镜像加速"></a>配置镜像加速</h3>
<p>Docker 官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>
<p>参考阿里云的镜像加速文档：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<p>通过修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://578xeysa.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h2 id="Docker-的基本操作"><a class="header-anchor" href="#Docker-的基本操作"></a>Docker 的基本操作</h2>
<h3 id="镜像操作"><a class="header-anchor" href="#镜像操作"></a>镜像操作</h3>
<h4 id="镜像名称"><a class="header-anchor" href="#镜像名称"></a>镜像名称</h4>
<p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li>
</ul>
<h4 id="镜像命令"><a class="header-anchor" href="#镜像命令"></a>镜像命令</h4>
<p>常见的镜像操作命令如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.71pfsgm3nn00.svg" alt="Docker镜像操作命令"></p>
<h4 id="拉取、查看镜像"><a class="header-anchor" href="#拉取、查看镜像"></a>拉取、查看镜像</h4>
<p>需求：从 DockerHub 中拉取一个 Nginx 镜像并查看</p>
<ol>
<li>首先去镜像仓库搜索 Nginx 镜像，比如 <a target="_blank" rel="noopener" href="https://hub.docker.com/">DockerHub</a>:</li>
<li>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<code>docker pull nginx</code></li>
<li>通过命令：<code>docker images</code> 查看拉取到的镜像</li>
</ol>
<h4 id="保存镜像"><a class="header-anchor" href="#保存镜像"></a>保存镜像</h4>
<p>需求：利用 docker save 将 Nginx 镜像导出磁盘，然后再通过 load 加载回来</p>
<p>利用 <code>docker xx --help</code> 命令查看 <code>docker save</code> 和 <code>docker load</code> 的语法。例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>命令格式：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker save</code> 导出镜像到磁盘，运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>
<h4 id="导入镜像"><a class="header-anchor" href="#导入镜像"></a>导入镜像</h4>
<p>先删除本地的 Nginx 镜像：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>
<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>
<h3 id="容器操作"><a class="header-anchor" href="#容器操作"></a>容器操作</h3>
<h4 id="容器相关命令"><a class="header-anchor" href="#容器相关命令"></a>容器相关命令</h4>
<p>容器操作的命令如图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.54kd7pt4p2w0.svg" alt="Docker容器相关命令"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU 不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU 等资源</li>
</ul>
<p>其中：</p>
<ul>
<li><code>docker run</code>：创建并运行一个容器，处于运行状态</li>
<li><code>docker pause</code>：让一个运行的容器暂停</li>
<li><code>docker unpause</code>：让一个容器从暂停状态恢复运行</li>
<li><code>docker stop</code>：停止一个运行的容器</li>
<li><code>docker start</code>：让一个停止的容器再次运行</li>
<li><code>docker rm</code>：删除一个容器</li>
<li><code>docker logs</code> ：查看容器日志的命令，添加 <code>-f</code> 参数可以持续查看日志</li>
<li><code>docker ps</code> ：查看容器状态，<code>-a</code> 查看所有容器，包括已经停止的</li>
</ul>
<h4 id="创建并运行一个容器"><a class="header-anchor" href="#创建并运行一个容器"></a>创建并运行一个容器</h4>
<p>创建并运行 Nginx 容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name haloNginx -p 81:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li><code>docker run</code> ：创建并运行一个容器</li>
<li><code>--name</code> : 给容器起一个名字，比如叫做 haloNginx</li>
<li><code>-p</code> ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li><code>-d</code>：后台运行容器</li>
<li><code>nginx</code>：镜像名称，例如 nginx</li>
</ul>
<p>这里的 <code>-p</code> 参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的 81 端口，肯定访问不到容器中的 Nginx。</p>
<p>现在，将容器的 80 与宿主机的 81 关联起来，当我们访问宿主机的 81 端口时，就会被映射到容器的80，这样就能访问到 Nginx 了</p>
<h4 id="进入容器并修改文件"><a class="header-anchor" href="#进入容器并修改文件"></a>进入容器并修改文件</h4>
<p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加“Halo World!”</p>
<blockquote>
<p>提示：进入容器要用到 <code>docker exec</code> 命令。</p>
</blockquote>
<p>① 进入容器。进入我们刚刚创建的 Nginx 容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it haloNginx bash</span><br></pre></td></tr></table></figure>
<p>命令解读：</p>
<ul>
<li>
<p><code>docker exec</code> ：进入容器内部，执行一个命令</p>
</li>
<li>
<p><code>-it</code> : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>
</li>
<li>
<p><code>haloNginx</code>：要进入的容器的名称</p>
</li>
<li>
<p><code>bash</code>：进入容器后执行的命令，bash 是一个 Linux 终端交互命令</p>
</li>
</ul>
<p>② 进入 Nginx 的 HTML 所在目录 /usr/share/nginx/html</p>
<p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 Linux 服务器一样</p>
<p>Nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p>
<p>查看 DockerHub 网站中的 Nginx 页面，可以知道 Nginx 的 html 目录位置在 <code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>
<p>③ 修改 index.html 的内容</p>
<p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#Halo World!#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>
<h3 id="数据卷（容器数据管理）"><a class="header-anchor" href="#数据卷（容器数据管理）"></a>数据卷（容器数据管理）</h3>
<p>在之前的 Nginx 案例中，修改 Nginx 的 html 页面时，需要进入 Nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。容器与数据耦合的问题：</p>
<ul>
<li>不便于修改：当我们要修改 Nginx 的 html 内容时，需要进入容器内部修改，很不方便。</li>
<li>数据不可复用：在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li>
<li>升级维护困难：数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li>
</ul>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h4 id="什么是数据卷"><a class="header-anchor" href="#什么是数据卷"></a>什么是数据卷</h4>
<p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了</p>
<h4 id="数据集操作命令"><a class="header-anchor" href="#数据集操作命令"></a>数据集操作命令</h4>
<p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>
<p><code>docker volume</code> 命令是数据卷操作，根据命令后跟随的 <code>command</code> 来确定下一步的操作：</p>
<ul>
<li><code>create</code> ：创建一个 volume</li>
<li><code>inspect</code> ：显示一个或多个 volume 的信息</li>
<li><code>ls</code> ：列出所有的 volume</li>
<li><code>prune</code> ：删除未使用的 volume</li>
<li><code>rm</code> ：删除一个或多个指定的 volume</li>
</ul>
<h4 id="创建和查看数据卷"><a class="header-anchor" href="#创建和查看数据卷"></a>创建和查看数据卷</h4>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create nginx-html</span><br></pre></td></tr></table></figure>
<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nginx-html</span><br></pre></td></tr></table></figure>
<p>可以看到，我们创建的 nginx-html 这个数据卷关联的宿主机目录为 <code>/var/lib/docker/volumes/nginx-html/_data</code> 目录。</p>
<h4 id="挂载数据卷"><a class="header-anchor" href="#挂载数据卷"></a>挂载数据卷</h4>
<p>我们在创建容器时，可以通过 <code>-v</code> 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name halo-nginx \</span><br><span class="line">  -v nginx-html:/usr/share/nginx/html \</span><br><span class="line">  -p 81:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>
<p>这里的 <code>-v</code> 就是挂载数据卷的命令。<code>-v nginx-html:/root/htm</code> ：把 nginx-html 数据卷挂载到容器内的 /root/html 这个目录中</p>
<p>需求：创建一个 Nginx 容器，修改容器内的 html 目录内的 index.html 内容</p>
<p>分析：上个案例中，我们进入 Nginx 容器内部，已经知道 Nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p>
<p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name halo-nginx -v nginx-html:/usr/share/nginx/html -p 81:80 -d nginx</span><br></pre></td></tr></table></figure>
<p>② 进入 nginx-html 数据卷所在位置，并修改 HTML 内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect nginx-html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/nginx-html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据卷不存在会自动创建</p>
</blockquote>
<h4 id="挂载本地目录"><a class="header-anchor" href="#挂载本地目录"></a>挂载本地目录</h4>
<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 → 数据卷 → 容器内目录</li>
<li>直接挂载模式：宿主机目录 → 容器内目录</li>
</ul>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li><code>-v [宿主机目录]:[容器内目录]</code></li>
<li><code>-v [宿主机文件]:[容器内文件]</code></li>
</ul>
<p>需求：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p>
<ol>
<li>
<p>拉取 MySQL 镜像</p>
</li>
<li>
<p>创建目录 /develop/docker-volumes/halo-mysql/data</p>
</li>
<li>
<p>创建目录 /develop/docker-volumes/halo-mysql/conf ，并在其中创建 halo.conf，内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">server-id&#x3D;1000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进行挂载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name halo-mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD&#x3D;halo \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -v &#x2F;develop&#x2F;docker-volumes&#x2F;halo-mysql&#x2F;conf&#x2F;halo.conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;halo.conf \</span><br><span class="line">  -v &#x2F;develop&#x2F;docker-volumes&#x2F;halo-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">  -d \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Dockerfile-自定义镜像"><a class="header-anchor" href="#Dockerfile-自定义镜像"></a>Dockerfile 自定义镜像</h2>
<h3 id="镜像结构"><a class="header-anchor" href="#镜像结构"></a>镜像结构</h3>
<p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<ul>
<li>基础镜像（Base Image）：应用依赖的系统函数库、环境、配置、文件等</li>
<li>层（ Layer ）：在 Base Image 基础上添加安装包、依赖、配置等，每次操作都形成新的一层。</li>
<li>入口（Entry Point）：镜像运行入口，一般是程序启动的脚本和参数</li>
</ul>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h3 id="Dockerfile-语法"><a class="header-anchor" href="#Dockerfile-语法"></a>Dockerfile 语法</h3>
<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些 Base Image、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是 Dockerfile 文件。</p>
<p>Dockerfile 就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td>指定基础镜像</td>
<td><code>FROM centos:6</code></td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量，可在后面指令使用</td>
<td><code>ENV key value</code></td>
</tr>
<tr>
<td>COPY</td>
<td>拷贝本地文件到镜像的指定目录</td>
<td><code>COPY ./mysql-5.7.rpm /tmp</code></td>
</tr>
<tr>
<td>RUN</td>
<td>执行 Linux 的 shell 命令，一般是安装过程的命令</td>
<td><code>RUN yum install gcc</code></td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器运行时监听的端口，是给镜像使用者看的</td>
<td><code>EXPOSE 8080</code></td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>镜像中应用的启动命令，容器运行时调用</td>
<td><code>ENTRYPOINT java -jar xx.jar</code></td>
</tr>
</tbody>
</table>
<p>更新详细语法说明，请参考官网文档： <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h3 id="直接构建-Java-项目"><a class="header-anchor" href="#直接构建-Java-项目"></a>直接构建 Java 项目</h3>
<p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 Java 项目</p>
<ol>
<li>
<p>Linux 下新建一个空文件夹 docker-demo</p>
</li>
<li>
<p>拷贝 docker-demo.jar 文件到 docker-demo 这个目录</p>
</li>
<li>
<p>拷贝 jdk8.tar.gz 文件到 docker-demo 这个目录</p>
</li>
<li>
<p>拷贝 Dockerfile 到 docker-demo 这个目录，其中的内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入 docker-demo ，运行命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行测试</p>
</li>
</ol>
<h3 id="基于-java8-alpine-构建-Java-项目"><a class="header-anchor" href="#基于-java8-alpine-构建-Java-项目"></a>基于 java8-alpine  构建 Java 项目</h3>
<p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>
<p>例如，构建 Java 项目的镜像，可以在已经准备了JDK 的基础镜像基础上构建。</p>
<p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p>
<p>实现思路如下：</p>
<ul>
<li>
<p>新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</p>
</li>
<li>
<p>拷贝 docker-demo.jar 到这个目录中</p>
</li>
<li>
<p>编写 Dockerfile 文件，内容如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入 docker-demo ，运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:2.0 .</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Dockerfile-小结"><a class="header-anchor" href="#Dockerfile-小结"></a>Dockerfile 小结</h3>
<ol>
<li>
<p>Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程</p>
</li>
<li>
<p>Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建</p>
</li>
<li>
<p>基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>
</li>
</ol>
<h2 id="Docker-Compose"><a class="header-anchor" href="#Docker-Compose"></a>Docker Compose</h2>
<p>Docker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器。</p>
<h3 id="初识-Docker-Compose"><a class="header-anchor" href="#初识-Docker-Compose"></a>初识 Docker Compose</h3>
<p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: 123 </span><br><span class="line">    volumes:</span><br><span class="line">     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;8090:8090&quot;</span><br></pre></td></tr></table></figure>
<p>上面的 Compose 文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于 <code>mysql:5.7.25</code> 镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于 <code>docker build</code> 临时构建的镜像容器，映射端口时 8090</li>
</ul>
<p>Docker Compose 的详细语法参考官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实 Docker Compose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p>
<h3 id="安装-Docker-Compose"><a class="header-anchor" href="#安装-Docker-Compose"></a>安装 Docker Compose</h3>
<ol>
<li>
<p>下载 docker-compose，Linux 下需要通过命令下载（速度较慢）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改文件权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置 Base 自动补全命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>
<p>如果这里出现错误，需要修改自己的 hosts 文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
<h3 id="部署微服务集群"><a class="header-anchor" href="#部署微服务集群"></a>部署微服务集群</h3>
<p>需求：将之前学习的 spring-cloud-demo 微服务集群利用 Docker Compose 部署</p>
<p>实现思路：</p>
<ol>
<li>编写 docker-compose 文件</li>
<li>修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</li>
<li>使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</li>
<li>将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中</li>
<li>到 cloud-demo 目录，利用 <code>docker-compose up -d</code> 来部署</li>
</ol>
<h2 id="Docker-镜像仓库"><a class="header-anchor" href="#Docker-镜像仓库"></a>Docker 镜像仓库</h2>
<h3 id="搭建私有镜像仓库"><a class="header-anchor" href="#搭建私有镜像仓库"></a>搭建私有镜像仓库</h3>
<p>搭建镜像仓库可以基于 Docker 官方提供的 Docker Registry 来实现。</p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p>
<h4 id="简化版镜像仓库"><a class="header-anchor" href="#简化版镜像仓库"></a>简化版镜像仓库</h4>
<p>Docker 官方的 Docker Registry 是一个基础版本的 Docker 镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>
<p>搭建方式比较简单，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry	\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>
<p>命令中挂载了一个数据卷 registry-data 到容器内的 /var/lib/registry 目录，这是私有镜像库存放数据的目录。</p>
<p>访问 <a target="_blank" rel="noopener" href="http://halo:5000/v2/_catalog">http://halo:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p>
<h4 id="带有图形化界面版本"><a class="header-anchor" href="#带有图形化界面版本"></a>带有图形化界面版本</h4>
<p>使用 Docker Compose 部署带有图象界面的 Docker Registry，命令如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8181</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=Halo-Docker-Registry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure>
<p>配置 Docker 信任地址，私服采用的是 http 协议，默认不被 Docker 信任，所以需要做一个配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://halo:8181&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="推送、拉取镜像"><a class="header-anchor" href="#推送、拉取镜像"></a>推送、拉取镜像</h3>
<p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p>
<p>① 重新 tag 本地镜像，名称前缀为私有仓库的地址：halo:8181/</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest halo:8181/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>② 推送镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push halo:8181/nginx:1.0 </span><br></pre></td></tr></table></figure>
<p>③ 拉取镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull halo:8181&#x2F;nginx:1.0 </span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Docker"><span class="toc-number">1.</span> <span class="toc-text">初识 Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Docker"><span class="toc-number">1.1.</span> <span class="toc-text">什么是 Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2%E7%9A%84%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">应用部署的环境问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">Docker 解决依赖兼容问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E8%A7%A3%E5%86%B3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E5%B7%AE%E5%BC%82"><span class="toc-number">1.1.3.</span> <span class="toc-text">Docker 解决操作系统环境差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Docker-%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">什么是 Docker 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">Docker 和虚拟机的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Docker-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.</span> <span class="toc-text">Docker 基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">镜像和容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DockerHub"><span class="toc-number">1.3.2.</span> <span class="toc-text">DockerHub</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Docker-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">Docker 架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-Docker"><span class="toc-number">2.</span> <span class="toc-text">配置 Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CentOS-%E5%AE%89%E8%A3%85-Docker"><span class="toc-number">2.1.</span> <span class="toc-text">CentOS 安装 Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD-Docker%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">卸载 Docker（可选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Docker"><span class="toc-number">2.1.2.</span> <span class="toc-text">安装 Docker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-Docker"><span class="toc-number">2.2.</span> <span class="toc-text">启动 Docker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">2.3.</span> <span class="toc-text">配置镜像加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">Docker 的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">镜像操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">镜像名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">镜像命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%8F%96%E3%80%81%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">拉取、查看镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">保存镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%95%9C%E5%83%8F"><span class="toc-number">3.1.5.</span> <span class="toc-text">导入镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.1.</span> <span class="toc-text">容器相关命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">创建并运行一个容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E5%B9%B6%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">进入容器并修改文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%88%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">数据卷（容器数据管理）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.3.2.</span> <span class="toc-text">数据集操作命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">3.3.3.</span> <span class="toc-text">创建和查看数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">3.3.4.</span> <span class="toc-text">挂载数据卷</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E6%9C%AC%E5%9C%B0%E7%9B%AE%E5%BD%95"><span class="toc-number">3.3.5.</span> <span class="toc-text">挂载本地目录</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">Dockerfile 自定义镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">镜像结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">Dockerfile 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%9E%84%E5%BB%BA-Java-%E9%A1%B9%E7%9B%AE"><span class="toc-number">4.3.</span> <span class="toc-text">直接构建 Java 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-java8-alpine-%E6%9E%84%E5%BB%BA-Java-%E9%A1%B9%E7%9B%AE"><span class="toc-number">4.4.</span> <span class="toc-text">基于 java8-alpine  构建 Java 项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dockerfile-%E5%B0%8F%E7%BB%93"><span class="toc-number">4.5.</span> <span class="toc-text">Dockerfile 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Compose"><span class="toc-number">5.</span> <span class="toc-text">Docker Compose</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86-Docker-Compose"><span class="toc-number">5.1.</span> <span class="toc-text">初识 Docker Compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-Docker-Compose"><span class="toc-number">5.2.</span> <span class="toc-text">安装 Docker Compose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9B%86%E7%BE%A4"><span class="toc-number">5.3.</span> <span class="toc-text">部署微服务集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">6.</span> <span class="toc-text">Docker 镜像仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">6.1.</span> <span class="toc-text">搭建私有镜像仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%89%88%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">6.1.1.</span> <span class="toc-text">简化版镜像仓库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E7%89%88%E6%9C%AC"><span class="toc-number">6.1.2.</span> <span class="toc-text">带有图形化界面版本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E9%80%81%E3%80%81%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">6.2.</span> <span class="toc-text">推送、拉取镜像</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By HALO</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflyutils.js"></script><script src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-resources@latest/js/butterflymain.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'riyCk4EApl1wsxKEIiYclBix-gzGzoHsz',
      appKey: '2Tt5IzvbGUivnrNTR3X4a8u5',
      placeholder: '在此评论，支持 markdown',
      avatar: 'mp',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer src="/js/butterfly.js"></script><script defer src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>