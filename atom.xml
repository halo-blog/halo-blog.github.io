<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="https://whl123456.top/atom.xml" rel="self"/>
  
  <link href="https://whl123456.top/"/>
  <updated>2021-09-20T06:00:11.456Z</updated>
  <id>https://whl123456.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务学习指南</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/README/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/README/</id>
    <published>2021-09-20T05:57:08.868Z</published>
    <updated>2021-09-20T06:00:11.456Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18E411x7eT">视频链接</a></p><p><a href="https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A#list/path=%2F%E5%B0%9A%E7%A1%85%E8%B0%B7Java%E5%AD%A6%E7%A7%91%E5%85%A8%E5%A5%97%E6%95%99%E7%A8%8B%EF%BC%88%E6%80%BB207.77GB%EF%BC%89%2F2.%E5%B0%9A%E7%A1%85%E8%B0%B7%E5%85%A8%E5%A5%97JAVA%E6%95%99%E7%A8%8B--%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A0%B8%E5%BF%83%EF%BC%8846.39GB%EF%BC%89%2F%E5%B0%9A%E7%A1%85%E8%B0%B7SpringCloud%EF%BC%88Alibaba%EF%BC%89&amp;parentPath=%2F">资料</a> 提取码：8op3</p><hr><p>微服务：</p><ul><li>服务注册与发现：Eureka 的替代产品 Zookeeper、Consul、Nacos（推荐）</li><li>服务调用：Ribbon 的替代产品 LoadBalancer；Feign 的替代产品 OpenFeign</li><li>服务熔断</li><li>负载均衡</li><li>服务降级：Hystrix 的替代产品 Sentinel</li><li>服务消息队列</li><li>配置中心管理：Config 的替代产品 Nacos</li><li>服务网关：Zuul 的替代产品 Gateway</li><li>服务监控</li><li>全链路追踪</li><li>自动化构建部署</li><li>服务定时任务调度操作</li></ul><h2 id="Spring-Cloud"><a class="header-anchor" href="#Spring-Cloud"></a>Spring Cloud</h2><p>Spring Cloud 是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p><p>Spring Cloud 集成相关优质项目：</p><ul><li>Spring Cloud Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git 以及 Subversion。</li><li>Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</li><li>Eureka：云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。（过时）</li><li><a href="https://nacos.io/zh-cn/">Nacos</a>：支持基于 DNS 和基于 RPC 的服务发现（可以作为 Spring Cloud 的注册中心）、动态配置服务（可以做配置中心）、动态 DNS 服务。</li><li>Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</li><li>Zuul：Zuul 是在云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</li><li>Archaius：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li><li>Consul：封装了Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。</li><li>Spring Cloud for Cloud Foundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。</li><li>Spring Cloud Sleuth：日志收集工具包，封装了Dapper 和 log-based 追踪以及 Zipkin 和 HTrace 操作，为 SpringCloud 应用实现了一种分布式追踪解决方案。</li><li>Spring Cloud Data Flow：大数据操作工具，作为 Spring XD 的替代产品，它是一个混合计算模型，结合了流数据与批量数据的处理方式。</li><li>Spring Cloud Security：基于 spring security 的安全工具包，为你的应用程序添加安全控制。</li><li>Spring Cloud Zookeeper：操作 Zookeeper 的工具包，用于使用 zookeeper 方式的服务发现和配置管理。</li><li>Spring Cloud Stream：数据流操作开发包，封装了与 Redis、Rabbit、Kafka 等发送接收消息。</li><li>Spring Cloud CLI：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</li><li>Ribbon：提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。</li><li>Turbine：Turbine 是聚合服务器发送事件流数据的一个工具，用来监控集群下 hystrix 的 metrics 情况。</li><li>Feign：Feign 是一种声明式、模板化的 HTTP 客户端。</li><li>Spring Cloud Task：提供云端计划任务管理、任务调度。</li><li>Spring Cloud Connectors：便于云端应用程序在各种 PaaS 平台连接到后端，如：数据库和消息代理服务。</li><li>Spring Cloud Cluster：提供 Leadership 选举，如：Zookeeper，Redis，Hazelcast，Consul 等常见状态模式的抽象和实现。</li><li>Spring Cloud Starters：Spring Boot 式的启动项目，为 Spring Cloud 提供开箱即用的依赖管理。</li></ul><h2 id="版本选择"><a class="header-anchor" href="#版本选择"></a>版本选择</h2><p><img src="https://pic.imgdb.cn/item/6133818144eaada739d722b1.jpg" alt="SpringBoot与SpringCloud"></p><p><a href="https://spring.io/projects/spring-cloud">官网地址</a></p><p>学习时使用的版本：</p><ul><li>Spring Cloud：Hoxton.SR1</li><li>Spring Boot：2.2.2.RELEASE</li><li>Spring Cloud Alibaba：2.1.0.RELEASE</li><li>Java：Java 8</li><li>Maven：3.5+</li><li>MySQL：5.7+</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV18E411x7eT&quot;&gt;视频链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A#list/path=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多级缓存</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/I_%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/I_%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2021-09-20T05:57:08.853Z</published>
    <updated>2021-09-20T06:00:20.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是多级缓存"><a class="header-anchor" href="#什么是多级缓存"></a>什么是多级缓存</h2><p>传统的缓存策略一般是请求到达 Tomcat 后，先查询 Redis，如果未命中则查询数据库。会存在下面的问题：</p><ul><li>请求要经过 Tomcat 处理，Tomcat 的性能成为整个系统的瓶颈</li><li>Redis 缓存失效时，会对数据库产生冲击</li></ul><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻 Tomcat 压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（Ajax查询数据）时，访问服务端</li><li>请求到达 Nginx 后，优先读取 Nginx 本地缓存</li><li>如果 Nginx 本地缓存未命中，则去直接查询 Redis（不经过 Tomcat）</li><li>如果 Redis 查询未命中，则查询 Tomcat</li><li>请求进入 Tomcat 后，优先查询 JVM 进程缓存</li><li>如果 JVM 进程缓存未命中，则查询数据库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.4wo03x7ehfs0.svg" alt="多级缓存"></p><p>在多级缓存架构中，Nginx 内部需要编写本地缓存查询、Redis 查询、Tomcat 查询的业务逻辑，因此这样的 Nginx 服务不再是一个反向代理服务器，而是一个编写业务的 Web 服务器了。</p><p>因此这样的业务 Nginx 服务也需要搭建集群来提高并发，再有专门的 Nginx 服务来做反向代理，另外，我们的 Tomcat 服务将来也会部署为集群模式</p><p>可见，多级缓存的关键有两个：</p><ul><li><p>一个是在 Nginx 中编写业务，实现 Nginx 本地缓存、Redis、Tomcat 的查询</p></li><li><p>另一个就是在 Tomcat 中实现 JVM 进程缓存</p></li></ul><p>其中 Nginx 编程则会用到 OpenResty 框架结合 Lua 这样的语言。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是多级缓存&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是多级缓存&quot;&gt;&lt;/a&gt;什么是多级缓存&lt;/h2&gt;
&lt;p&gt;传统的缓存策略一般是请求到达 Tomcat 后，先查询 Redis，如果未命中则查询数据库。会存在下面的问题：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式缓存</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/H_%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/H_%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</id>
    <published>2021-09-20T05:57:08.853Z</published>
    <updated>2021-09-20T06:00:30.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单点-Redis-的问题"><a class="header-anchor" href="#单点-Redis-的问题"></a>单点 Redis 的问题</h2><ul><li>数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据 → 实现 Redis 数据持久化</li><li>并发能力问题：单节点 Redis 并发能力虽然不错，但也无法满足如双十一这样的高并发场景 → 搭建主从集群，实现读写分离</li><li>故障恢复问题：如果 Redis 宕机，则服务不可用，需要一种自动的故障恢复手段 → 利用 Redis 哨兵，实现健康检测和自动恢复</li><li>存储能力问题：Redis 基于内存，单节点能存储的数据量难以满足海量数据需求 → 搭建分片集群，利用插槽机制实现动态扩容</li></ul><h2 id="Redis-持久化"><a class="header-anchor" href="#Redis-持久化"></a>Redis 持久化</h2><h3 id="RDB-持久化"><a class="header-anchor" href="#RDB-持久化"></a>RDB 持久化</h3><p>RDB 全称 Redis Database Backup file（Redis 数据备份文件），也被叫做 Redis 数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当 Redis 实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为 RDB 文件，默认是保存在当前运行目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># redis-cil</span><br><span class="line">&gt; save   # 由 Redis 主进程来执行 RDB，会阻塞所有命令</span><br><span class="line">&gt; bgsave # 开启子进程执行 RDB, 避免主进程受到</span><br></pre></td></tr></table></figure><p>Redis 停机时会执行一次 RDB</p><p>Redis 内部有触发 RDB 的机制，可以在 redis.conf 文件中找到，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 900秒内，如果至少有1个key被修改，则执行 bgsave ， 如果是 save &quot;&quot; 则表示禁用RDB</span><br><span class="line">save 900 1  </span><br><span class="line">save 300 10  </span><br><span class="line">save 60 10000 </span><br></pre></td></tr></table></figure><p>RDB 的其它配置也可以在 redis.conf 文件中设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># RDB 文件名称</span><br><span class="line">dbfilename dump.rdb  </span><br><span class="line"></span><br><span class="line"># 文件保存的路径目录</span><br><span class="line">dir .&#x2F; </span><br></pre></td></tr></table></figure><p>bgsave 开始时会 fork 主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件。</p><p>fork 采用的是 copy-on-write 技术：</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RDBfork.6lsdm1x9i7w0.svg" alt="RDBfork"></p><p>RDB 方式 bgsave 的基本流程：</p><ul><li>fork 主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的 RDB 文件</li><li>用新 RDB 文件替换旧的 RDB 文件。</li></ul><p>RDB 会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时。</li><li>代表 60 秒内至少执行 1000 次修改则触发 RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险</li><li>fork 子进程、压缩、写出 RDB 文件都比较耗时</li></ul><h3 id="AOF-持久化"><a class="header-anchor" href="#AOF-持久化"></a>AOF 持久化</h3><p>AOF 全称为 Append Only File（追加文件）。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。</p><p>AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启 AOF：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 是否开启AOF功能，默认是no</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF文件的名称</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure><p>AOF 的命令记录的频率也可以通过 redis.conf 文件来配：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 表示每执行一次写命令，立即记录到AOF文件</span><br><span class="line">appendfsync always </span><br><span class="line"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span><br><span class="line">appendfsync everysec </span><br><span class="line"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>同步刷盘</td><td>可靠性高，几乎不丢数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失 1 秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性较差，可能丢失大量数据</td></tr></tbody></table><p>因为是记录命令，AOF 文件会比 RDB 文件大的多。而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。通过执行 <code>bgrewriteaof</code> 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。</p><p>Redis 也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 redis.conf 中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># AOF文件体积最小多大以上才触发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br></pre></td></tr></table></figure><h3 id="Redis-持久化小结"><a class="header-anchor" href="#Redis-持久化小结"></a>Redis 持久化小结</h3><p>RDB 和 AOF 各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如 AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量 CPU 和内存消耗</td><td>低，主要是磁盘 IO 资源，但 AOF 重写时会占用大量 CPU 和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高常见</td></tr></tbody></table><h2 id="Redis-主从集群"><a class="header-anchor" href="#Redis-主从集群"></a>Redis 主从集群</h2><h3 id="搭建主从架构"><a class="header-anchor" href="#搭建主从架构"></a>搭建主从架构</h3><p>单节点 Redis 的并发能力是有上限的，要进一步提高 Redis 的并发能力，就需要搭建主从集群，实现读写分离。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84.1yy9qyf3d7z4.svg" alt="redis主从架构"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启 3 个 Redis 实例，模拟主从集群，信息如下：</p><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">PORT</th><th style="text-align:center">角色</th></tr></thead><tbody><tr><td style="text-align:center">halo</td><td style="text-align:center">7001</td><td style="text-align:center">master</td></tr><tr><td style="text-align:center">halo</td><td style="text-align:center">7002</td><td style="text-align:center">slave</td></tr><tr><td style="text-align:center">halo</td><td style="text-align:center">7003</td><td style="text-align:center">slave</td></tr></tbody></table><h3 id="准备实例和配置"><a class="header-anchor" href="#准备实例和配置"></a>准备实例和配置</h3><p>要在同一台虚拟机开启 3 个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>创建三个文件夹，名字分别叫 7001、7002、7003</p><p>修改 redis-6.2.4/redis.conf 文件，将其中的持久化模式改为默认的 RDB 模式，AOF 保持关闭状态。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 开启RDB</span></span><br><span class="line"><span class="comment"># save &quot;&quot;</span></span><br><span class="line"><span class="attr">save</span> <span class="string">3600 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 100</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭AOF</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">no</span></span><br></pre></td></tr></table></figure><p>拷贝配置文件到每个实例目录，然后将 redis-6.2.4/redis.conf 文件拷贝到三个目录中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line">cp redis-6.2.4/redis.conf 7001</span><br><span class="line">cp redis-6.2.4/redis.conf 7002</span><br><span class="line">cp redis-6.2.4/redis.conf 7003</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf</span><br></pre></td></tr></table></figure><p>修改每个文件夹内的配置文件，将端口分别修改为 7001、7002、7003，将 rdb 文件保存位置都修改为自己所在目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/6379/7001/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/develop\/redis\/7001\//g&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7002/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/develop\/redis\/7002\//g&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/6379/7003/g&#x27;</span> -e <span class="string">&#x27;s/dir .\//dir \/develop\/redis\/7003\//g&#x27;</span> 7003/redis.conf</span><br></pre></td></tr></table></figure><p>修改每个实例的声明 IP，虚拟机本身有多个 IP，为了避免将来混乱，我们需要在 redis.conf 文件中指定每一个实例的绑定 ip 信息，格式如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis实例的声明 IP</span></span><br><span class="line"><span class="meta">replica-announce-ip</span> <span class="string">81.70.151.52</span></span><br></pre></td></tr></table></figure><p>每个目录都要改，我们一键完成修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逐一执行</span></span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 81.70.151.52&#x27;</span> 7001/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 81.70.151.52&#x27;</span> 7002/redis.conf</span><br><span class="line">sed -i <span class="string">&#x27;1a replica-announce-ip 81.70.151.52&#x27;</span> 7003/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者一键修改</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;1a replica-announce-ip 81.70.151.52&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><p>为了方便查看日志，我们打开 3 个 ssh 窗口，分别启动 3 个 redis 实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server 7001/redis.conf</span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line">redis-server 7003/redis.conf</span><br></pre></td></tr></table></figure><p>如果要一键停止，可以运行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure><h3 id="开启主从关系"><a class="header-anchor" href="#开启主从关系"></a>开启主从关系</h3><p>现在三个实例还没有任何关系，要配置主从可以使用 replicaof 或者 slaveof（5.0 以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效），在 redis.conf 中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>使用 redis-cli 客户端连接到 redis 服务，执行 slaveof 命令（重启后失效）：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li></ul><p>注意：在 5.0 以后新增命令 replicaof，与 slaveof 效果一致。</p><p>通过 redis-cli 命令连接 7002，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7002</span></span><br><span class="line">redis-cli -p 7002</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 81.70.151.52 7001</span><br></pre></td></tr></table></figure><p>通过 redis-cli 命令连接 7003，执行下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7003</span></span><br><span class="line">redis-cli -p 7003</span><br><span class="line"><span class="comment"># 执行slaveof</span></span><br><span class="line">slaveof 81.70.151.52 7001</span><br></pre></td></tr></table></figure><p>然后连接 7001 节点，查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 7001</span></span><br><span class="line">redis-cli -p 7001</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.163o7jdikeg0.png" alt="image"></p><p>执行下列操作以测试：</p><ul><li><p>利用 redis-cli 连接 7001，执行 <code>set num 123</code></p></li><li><p>利用 redis-cli 连接 7002，执行 <code>get num</code>，再执行 <code>set num 666</code></p></li><li><p>利用 redis-cli 连接 7003，执行 <code>get num</code>，再执行 <code>set num 888</code></p></li></ul><p>可以发现，只有在 7001 这个 master 节点上可以执行写操作，7002 和 7003 这两个 slave 节点只能执行读操作。</p><h3 id="主从数据同步原理"><a class="header-anchor" href="#主从数据同步原理"></a>主从数据同步原理</h3><p>主从第一次同步是全量同步：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.3j3fw2lkmda0.svg" alt="主从数据同步原理"></p><p>master 如何判断 slave 是不是第一次来同步数据？这里会用到两个很重要的概：</p><ul><li>Replication Id：简称 replid，是数据集的标记，id 一致则说明是同一数据集。每一个master 都有唯一的 replid，slave 则会继承 master 节点的 replid</li><li>offset：偏移量，随着记录在 <code>repl_baklog</code> 中的数据增多而逐渐增大。slave 完成同步时也会记录当前同步的 offset。如果 slave 的 offset 小于 master 的 offset，说明 slave 数据落后于 master，需要更新。</li></ul><p>因此 slave 做数据同步，必须向 master 声明自己的 replication id 和 offset，master 才可以判断到底需要同步哪些数据</p><p>简述全量同步的流程：</p><ul><li>slave 节点请求增量同步</li><li>master 节点判断 replid，发现不一致，拒绝增量同步</li><li>master 将完整内存数据生成 RDB，发送 RDB 到 slave</li><li>slave 清空本地数据，加载 master 的 RDB</li><li>master 将 RDB 期间的命令记录在 <code>repl_baklog</code>，并持续将 log 中的命令发送给 slave</li><li>slave 执行接收到的命令，保持与 master 之间的同步</li></ul><p>主从第一次同步是全量同步，但如果 slave 重启后同步，则执行增量同步</p><blockquote><p><code>repl_baklog</code> 大小有上限，写满后会覆盖最早的数据。如果 slave 断开时间过久，导致尚未备份的数据被覆盖，则无法基于 log 做增量同步，只能再次全量同步。</p></blockquote><p>可以从以下几个方面来优化 Redis 主从就集群：</p><ul><li>在 master 中配置 <code>repl-diskless-sync yes</code> 启用无磁盘复制，避免全量同步时的磁盘 IO。</li><li>Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘 IO</li><li>适当提高 <code>repl_baklog</code> 的大小，发现 slave 宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个 master 上的 slave 节点数量，如果实在是太多 slave，则可以采用主-从-从链式结构，减少 master 压力</li></ul><h3 id="Redis-主从集群小结"><a class="header-anchor" href="#Redis-主从集群小结"></a>Redis 主从集群小结</h3><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master 将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在 <code>repl_baklog</code>，逐个发送给 slave。</li><li>增量同步：slave 提交自己的 offset 到 master，master 获取 <code>repl_baklog</code> 中从 offset 之后的命令给 slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave 节点第一次连接 master 节点时</li><li>slave 节点断开时间太久，<code>repl_baklog</code> 中的 offset 已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave 节点断开又恢复，并且在 <code>repl_baklog</code> 中能找到 offset 时</li></ul><h2 id="Redis-哨兵"><a class="header-anchor" href="#Redis-哨兵"></a>Redis 哨兵</h2><h3 id="哨兵的作用和原理"><a class="header-anchor" href="#哨兵的作用和原理"></a>哨兵的作用和原理</h3><p>slave 节点宕机恢复后可以找 master 节点同步数据，那 master 节点宕机怎么办？</p><p>Redis 提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Redis%E5%93%A8%E5%85%B5.4jsq9xke4h60.svg" alt="Redis哨兵"></p><h4 id="哨兵的作用"><a class="header-anchor" href="#哨兵的作用"></a>哨兵的作用</h4><ul><li>监控：Sentinel 会不断检查 master 和 slave 是否按预期工作</li><li>自动故障恢复：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主</li><li>通知：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端</li></ul><h4 id="服务状态监控"><a class="header-anchor" href="#服务状态监控"></a>服务状态监控</h4><p>Sentinel 基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送 ping 命令：</p><ul><li>主观下线：如果某 Sentinel 节点发现某实例未在规定时间响应，则认为该实例主观下线。</li><li>客观下线：若超过指定数量（quorum）的 Sentinel 都认为该实例主观下线，则该实例客观下线。quorum 值最好超过 Sentinel 实例数量的一半。</li></ul><h4 id="选举新的-master"><a class="header-anchor" href="#选举新的-master"></a>选举新的 master</h4><p>一旦发现 master 故障，Sentinel 需要在 salve 中选择一个作为新的 master，选择依据是这样的：</p><ul><li>首先会判断 slave 节点与 master 节点断开时间长短，如果超过指定值（<code>down-after-milliseconds * 10</code>）则会排除该 slave 节点</li><li>然后判断 slave 节点的 slave-priority 值，越小优先级越高，如果是 0 则永不参与选举</li><li>如果 slave-priority 一样，则判断 slave 节点的 offset 值，越大说明数据越新，优先级越高</li><li>最后是判断 slave 节点的运行 id 大小，越小优先级越高。</li></ul><h4 id="如何实现故障转移"><a class="header-anchor" href="#如何实现故障转移"></a>如何实现故障转移</h4><p>当选中了其中一个 slave 为新的 master 后（例如 slave1），故障的转移的步骤如下：</p><ul><li>Sentinel 给备选的 slave1 节点发送 slaveof no one 命令，让该节点成为 master</li><li>Sentinel 给所有其它 slave 发送 slaveof ip port 命令，让这些 slave 成为新 master 的从节点，开始从新的 master 上同步数据。</li><li>最后，Sentinel 将故障节点标记为 slave，当故障节点恢复后会自动成为新的 master 的 slave 节点</li></ul><h4 id="哨兵的作用和原理小结"><a class="header-anchor" href="#哨兵的作用和原理小结"></a>哨兵的作用和原理小结</h4><p>Sentinel 的三个作用是什么？</p><ul><li>监控</li><li>故障转移</li><li>通知</li></ul><p>Sentinel 如何判断一个 redis 实例是否健康？</p><ul><li>每隔 1 秒发送一次 ping 命令，如果超过一定时间没有相向则认为是主观下线</li><li>如果大多数 sentinel 都认为实例主观下线，则判定服务下线</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先选定一个 slave 作为新的 master，执行 slaveof no one</li><li>然后让所有节点都执行 slaveof 新 master</li><li>修改故障节点配置，添加 slaveof 新 master</li></ul><h3 id="搭建哨兵集群"><a class="header-anchor" href="#搭建哨兵集群"></a>搭建哨兵集群</h3><p>三个 Sentinel 实例信息如下：</p><table><thead><tr><th>节点</th><th style="text-align:center">IP</th><th style="text-align:center">PORT</th></tr></thead><tbody><tr><td>s1</td><td style="text-align:center">public-ip</td><td style="text-align:center">27001</td></tr><tr><td>s2</td><td style="text-align:center">public-ip</td><td style="text-align:center">27002</td></tr><tr><td>s3</td><td style="text-align:center">public-ip</td><td style="text-align:center">27003</td></tr></tbody></table><h4 id="准备实例和配置-v2"><a class="header-anchor" href="#准备实例和配置-v2"></a>准备实例和配置</h4><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入&#x2F;sentinel 目录</span><br><span class="line">cd &#x2F;sentinel</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir s1 s2 s3</span><br></pre></td></tr></table></figure><p>然后我们在 s1 目录创建一个 sentinel.conf 文件，添加下面的内容：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">27001</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">announce-ip 81.70.151.52</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor mymaster 81.70.151.52 7001 2</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">down-after-milliseconds mymaster 5000</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">failover-timeout mymaster 60000</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">&quot;/develop/redis/sentinel/s1&quot;</span></span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>port 27001</code>：是当前 sentinel 实例的端口</li><li><code>sentinel monitor mymaster 81.70.151.52 7001 2</code>：指定主节点信息<ul><li><code>mymaster</code>：主节点名称，自定义，任意写</li><li><code>public-ip 7001</code>：主节点的 ip 和端口</li><li><code>2</code>：选举 master 时的 quorum 值</li></ul></li></ul><p>然后将 s1/sentinel.conf 文件拷贝到 s2、s3 两个目录中（在 /sentinel 目录执行下列命令）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式一：逐个拷贝</span></span><br><span class="line">cp s1/sentinel.conf s2</span><br><span class="line">cp s1/sentinel.conf s3</span><br><span class="line"><span class="comment"># 方式二：管道组合命令，一键拷贝</span></span><br><span class="line"><span class="built_in">echo</span> s2 s3 | xargs -t -n 1 cp s1/sentinel.conf</span><br></pre></td></tr></table></figure><p>修改 s2、s3 两个文件夹内的配置文件，将端口分别修改为 27002、27003：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s/27001/27002/g&#x27;</span> -e <span class="string">&#x27;s/s1/s2/g&#x27;</span> s2/sentinel.conf</span><br><span class="line">sed -i -e <span class="string">&#x27;s/27001/27003/g&#x27;</span> -e <span class="string">&#x27;s/s1/s3/g&#x27;</span> s3/sentinel.conf</span><br></pre></td></tr></table></figure><h4 id="启动"><a class="header-anchor" href="#启动"></a>启动</h4><p>为了方便查看日志，我们打开 3 个 ssh 窗口，分别启动 3 个 redis 实例，启动命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1个</span></span><br><span class="line">redis-sentinel s1/sentinel.conf</span><br><span class="line"><span class="comment"># 第2个</span></span><br><span class="line">redis-sentinel s2/sentinel.conf</span><br><span class="line"><span class="comment"># 第3个</span></span><br><span class="line">redis-sentinel s3/sentinel.conf</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4mzu19ficpw0.png" alt="image"></p><h3 id="Redis-Template-的哨兵模式"><a class="header-anchor" href="#Redis-Template-的哨兵模式"></a>Redis Template 的哨兵模式</h3><p>在 Sentinel 集群监管下的 Redis 主从集群，其节点会因为自动故障转移而发生变化，Redis 的客户端必须感知这种变化，及时更新连接信息。Spring 的 Redis Template 底层利用 lettuce 实现了节点的感知和自动切换。</p><p>初始化工程：<a href="https://github.com/Lanqilu/HaloSpringCloud/commit/21a1e151dd294acabd648989d4638f39ad6bf625">链接</a></p><p>首先，在 pom 文件中引入 redis 的 starter 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在配置文件 application.yml 中指定 sentinel 相关信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span> <span class="comment"># 指定master名称</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="comment"># 指定redis-sentinel集群信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:27001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:27002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:27003</span></span><br></pre></td></tr></table></figure><p>最后，配置主从读写分离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title">configurationBuilderCustomizer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> configBuilder -&gt; configBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>ReadFrom</code> 是配置 Redis 的读取策略，是一个枚举，包括下面选择：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从 master 节点读取，master 不可用才读取 replica</li><li>REPLICA：从 slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从 slave（replica）节点读取，所有的 slave 都不可用才读取 master</li></ul><h2 id="Redis-分片集群"><a class="header-anchor" href="#Redis-分片集群"></a>Redis 分片集群</h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li>海量数据存储问题</li><li>高并发写的问题</li></ul><p>使用分片集群可以解决上述问题，分片集群特征：</p><ul><li>集群中有多个 master，每个 master 保存不同数据</li><li>每个 master 都可以有多个 slave 节点</li><li>master 之间通过 ping 监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4.3bscfw32y2g0.svg" alt="redis分片集群"></p><h3 id="搭建分片集群"><a class="header-anchor" href="#搭建分片集群"></a>搭建分片集群</h3><h4 id="集群结构"><a class="header-anchor" href="#集群结构"></a>集群结构</h4><p>分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含 3 个 master 节点，每个 master 包含一个 slave 节点</p><p>这里我们会在同一台虚拟机中开启 6 个 redis 实例，模拟分片集群，信息如下：</p><table><thead><tr><th style="text-align:center">IP</th><th style="text-align:center">PORT</th><th style="text-align:center">角色</th></tr></thead><tbody><tr><td style="text-align:center">public-ip</td><td style="text-align:center">7001</td><td style="text-align:center">master</td></tr><tr><td style="text-align:center">public-ip</td><td style="text-align:center">7002</td><td style="text-align:center">master</td></tr><tr><td style="text-align:center">public-ip</td><td style="text-align:center">7003</td><td style="text-align:center">master</td></tr><tr><td style="text-align:center">public-ip</td><td style="text-align:center">8001</td><td style="text-align:center">slave</td></tr><tr><td style="text-align:center">public-ip</td><td style="text-align:center">8002</td><td style="text-align:center">slave</td></tr><tr><td style="text-align:center">public-ip</td><td style="text-align:center">8003</td><td style="text-align:center">slave</td></tr></tbody></table><h4 id="准备实例和配置-v3"><a class="header-anchor" href="#准备实例和配置-v3"></a>准备实例和配置</h4><p>删除之前的 7001、7002、7003 这几个目录，重新创建出 7001、7002、7003、8001、8002、8003 目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入/tmp目录</span></span><br><span class="line"><span class="built_in">cd</span> /redis</span><br><span class="line"><span class="comment"># 删除旧的，避免配置干扰</span></span><br><span class="line">rm -rf 7001 7002 7003</span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">mkdir 7001 7002 7003 8001 8002 8003</span><br></pre></td></tr></table></figure><p>在 /redis 下准备一个新的 redis.conf 文件，内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 开启集群功能</span></span><br><span class="line"><span class="meta">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class="line"><span class="meta">cluster-config-file</span> <span class="string">/develop/redis/6379/nodes.conf</span></span><br><span class="line"><span class="comment"># 节点心跳失败的超时时间</span></span><br><span class="line"><span class="meta">cluster-node-timeout</span> <span class="string">5000</span></span><br><span class="line"><span class="comment"># 持久化文件存放目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/develop/redis/6379</span></span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 让redis后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 注册的实例ip</span></span><br><span class="line"><span class="meta">replica-announce-ip</span> <span class="string">81.70.151.52</span></span><br><span class="line"><span class="comment"># 保护模式</span></span><br><span class="line"><span class="meta">protected-mode</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 数据库数量</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">/develop/redis/6379/run.log</span></span><br></pre></td></tr></table></figure><p>将这个文件拷贝到每个目录下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行拷贝</span></span><br><span class="line"><span class="built_in">echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf</span><br></pre></td></tr></table></figure><p>修改每个目录下的 redis.conf，将其中的 6379 修改为与所在目录一致：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t sed -i <span class="string">&#x27;s/6379/&#123;&#125;/g&#x27;</span> &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><h4 id="启动-v2"><a class="header-anchor" href="#启动-v2"></a>启动</h4><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一键启动所有服务</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-server &#123;&#125;/redis.conf</span><br></pre></td></tr></table></figure><p>通过 ps 查看状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>如果要关闭所有进程，可以执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span></span><br></pre></td></tr></table></figure><p>或者（推荐这种方式）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> 7001 7002 7003 8001 8002 8003 | xargs -I&#123;&#125; -t redis-cli -p &#123;&#125; shutdown</span><br></pre></td></tr></table></figure><h4 id="创建集群"><a class="header-anchor" href="#创建集群"></a>创建集群</h4><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p><p>我们需要执行命令来创建集群，在 Redis 5.0 之前创建集群比较麻烦，5.0 之后集群管理命令都集成到了redis-cli 中。</p><p>我们使用的是 Redis 6.2.4 版本，集群管理以及集成到了 redis-cli 中，格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 81.70.151.52:7001 81.70.151.52:7002 81.70.151.52:7003 81.70.151.52:8001 81.70.151.52:8002 81.70.151.52:8003</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>redis-cli --cluster</code> 或者 <code>./redis-trib.rb</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code> 或者 <code>--cluster-replicas 1</code> ：指定集群中每个 master 的副本个数为1，此时 <code>节点总数 ÷ (replicas + 1)</code> 得到的就是 master 的数量。因此节点列表中的前 n 个就是 master，其它节点都是 slave 节点，随机分配到不同 master</li></ul><p>运行后的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2kex1iskkag0.png" alt="image"></p><p>这里输入 yes，则集群开始创建。</p><p>注意，如果出现 Waiting for the cluster to join 问题，说明这里需要开放端口，端口号为 1700x 和 1800x。<a href="https://blog.csdn.net/XIANZHIXIANZHIXIAN/article/details/82392172">参考链接</a></p><p>通过命令可以查看集群状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.24itacoigij.png" alt="image"></p><h3 id="散列插槽"><a class="header-anchor" href="#散列插槽"></a>散列插槽</h3><p>Redis 会把每一个 master 节点映射到 0~16383 共 16384 个插槽（hash slot）上，查看集群信息时就能看到。</p><p>数据 key 不是与节点绑定，而是与插槽绑定。redis 会根据 key 的有效部分计算插槽值，分两种情况：</p><ul><li>key 中包含 <code>&#123;&#125;</code>，且 <code>&#123;&#125;</code> 中至少包含 1 个字符，<code>&#123;&#125;</code> 中的部分是有效部分</li><li>key 中不包含 <code>&#123;&#125;</code>，整个 key 都是有效部分</li></ul><p>例如：</p><ul><li>key 是 <code>num</code>，那么就根据 <code>num</code> 计算</li><li>key 是 <code>&#123;halo&#125;num</code>，则根据 <code>halo</code> 计算。</li><li>计算方式是利用 CRC16 算法得到一个 hash 值，然后对 16384 取余，得到的结果就是 slot 值。</li></ul><p>使用 <code>redis-cli -c -p 7001</code> 测试</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2p5uncp37x00.png" alt="image"></p><p>Redis 如何判断某个 key 应该在哪个实例？</p><ul><li>将 16384 个插槽分配到不同的实例</li><li>根据 key 的有效部分计算哈希值，对 16384 取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个 Redis 实例？</p><ul><li>这一类数据使用相同的有效部分，例如 key 都以 <code>&#123;typeId&#125;</code> 为前缀</li></ul><p>Redis 为什么设置 16384 个槽。CRC16 算法产生的 hash 值有 16bit，该算法可以产生 2<sup>16</sup> = 65536 个值。换句话说，值是分布在 0 到 65535 之间。那作者在做 <code>mod</code> 运算的时候，为什么不 <code>mod</code> 65536，而选择 <code>mod</code> 16384？</p><ul><li>如果槽位为 65536，发送心跳信息的消息头达 8k，发送的心跳包过于庞大。在消息头中，最占空间的是 <code>myslots[CLUSTER_SLOTS/8]</code>。 当槽位为 65536 时，这块的大小是： <code>65536÷8÷1024=8kb</code> 因为每秒钟，Redis 节点需要发送一定数量的 ping 消息作为心跳包，如果槽位为 65536，这个 ping 消息的消息头太大了，浪费带宽。16384 块的大小是：<code>16384÷8÷1024=2kb</code></li><li>Redis 的集群主节点数量基本不可能超过1000个。集群节点越多，心跳包的消息体内携带的数据越多。如果节点过 1000 个，也会导致网络拥堵。因此 Redis 作者，不建议 redis cluster 节点数量超过 1000 个。 那么，对于节点数在 1000 以内的 redis cluster 集群，16384 个槽位够用了。没有必要拓展到 65536 个。</li><li>槽位越小，节点少的情况下，压缩比高。</li></ul><h3 id="集群伸缩"><a class="header-anchor" href="#集群伸缩"></a>集群伸缩</h3><h4 id="添加一个节点到集群"><a class="header-anchor" href="#添加一个节点到集群"></a>添加一个节点到集群</h4><p><code>redis-cli --cluster</code> 提供了很多操作集群的命令，可以通过 <code>redis-cli --cluster help</code> 进行查看</p><p>比如，添加节点的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">               --cluster-slave</span><br><span class="line">               --cluster-master-id &lt;arg&gt;</span><br></pre></td></tr></table></figure><p>案例：向集群中添加一个新的 master 节点，并向其中存储 <code>num = 10</code></p><p>需求：</p><ul><li>启动一个新的 redis 实例，端口为 7004</li><li>添加 7004 到之前的集群，并作为一个 master 节点</li><li>给 7004 节点分配插槽，使得 num 这个 key 可以存储到 7004 实例</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir 7004</span><br><span class="line">cp redis.conf 7004</span><br><span class="line">sed -i s&#x2F;6379&#x2F;7004&#x2F;g 7004&#x2F;redis.conf</span><br><span class="line">redis-server 7004&#x2F;redis.conf</span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 81.70.151.52:7004 81.70.151.52:7001</span><br><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p>记得设置放行防火墙的 7004 和 17004 端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 81.70.151.52:7001</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/pic.3j8k7rbwya20.jpg" alt="pic"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5f5wxyam21o0.png" alt="image"></p><h4 id="删除集群中的一个节点"><a class="header-anchor" href="#删除集群中的一个节点"></a>删除集群中的一个节点</h4><p>需求：删除 7004 节点</p><p>首先移动插槽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 81.70.151.52:7004</span><br></pre></td></tr></table></figure><p>然后删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 81.70.151.52:7004 a163eeb5bca08ecb1df92b4835c388a73d2a6ea3</span><br><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><h3 id="故障转移"><a class="header-anchor" href="#故障转移"></a>故障转移</h3><h4 id="测试故障转移"><a class="header-anchor" href="#测试故障转移"></a>测试故障转移</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002 shutdown</span><br><span class="line">redis-server 7002&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>当集群中有一个 master 宕机会发生什么呢？</p><ul><li>首先是该实例与其它实例失去连接</li><li>然后是疑似宕机</li><li>最后是确定下线，自动提升一个 slave 为新的 master</li></ul><h4 id="数据迁移"><a class="header-anchor" href="#数据迁移"></a>数据迁移</h4><p>利用 cluster failover 命令可以手动让集群中的某个 master 宕机，切换到执行 cluster failover 命令的这个 slave 节点，实现无感知的数据迁移。其流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.5hub7i7gnx00.svg" alt="数据迁移"></p><p>手动的 failover 支持三种不同模式：</p><ul><li>缺省：默认的流程，如图 1~6 步</li><li>force：省略了对 offset 的一致性校验</li><li>takeover：直接执行第 5 步，忽略数据一致性、忽略 master 状态和其它 master 的意见</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7002</span><br><span class="line">&gt; cluster failover</span><br></pre></td></tr></table></figure><h3 id="Redis-Template-访问分片集群"><a class="header-anchor" href="#Redis-Template-访问分片集群"></a>Redis Template 访问分片集群</h3><p>Redis Template 底层同样基于 lettuce 实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><ul><li>引入 redis 的 starter 依赖</li><li>配置分片集群地址</li><li>配置读写分离</li></ul><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:7001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:7002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:7003</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:8001</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:8002</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">redis:8003</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单点-Redis-的问题&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#单点-Redis-的问题&quot;&gt;&lt;/a&gt;单点 Redis 的问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据丢失问题：Redis 是内存存储，服务重启可能会丢失数据 → 实现 Redis</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Seata入门</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/G_Seata%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/G_Seata%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.837Z</published>
    <updated>2021-09-20T06:00:41.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式事务理论基础"><a class="header-anchor" href="#分布式事务理论基础"></a>分布式事务理论基础</h2><p>事务的 ACID 原则：</p><ul><li>A 原子性： 事务中的所有操作，要么全部成功，要么全部失败</li><li>C 一致性：要保证数据库内部完整性约束、声明性约束</li><li>I 隔离性：对同一资源操作的事务不能同时发生</li><li>D 持久性：对数据库做的一切修改将永久保存，不管是否出现故障</li></ul><p>分布式服务的事务问题：在分布式系统下，一个业务跨越多个服务或数据源，每个服务都是一个分支事务，要保证所有分支事务最终状态一致，这样的事务就是分布式事务。</p><h3 id="CAP-定理"><a class="header-anchor" href="#CAP-定理"></a>CAP 定理</h3><p>1998 年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标：</p><ul><li>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</li><li>Availability（可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝</li><li>Partition tolerance （分区容错性）：<ul><li>Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</li><li>Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务</li></ul></li></ul><p>Eric Brewer 认为，分布式系统无法同时满足这三个指标。这个结论就叫做 CAP 定理。</p><p>分布式系统节点通过网络连接，一定会出现分区问题（P）当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</p><p>思考：ElasticSearch 集群是 CP 还是 AP？</p><p>ES 集群出现分区时，故障节点会被剔除集群，数据分片会重新分配到其它节点，保证数据一致。因此是低可用性，高一致性，属于 CP。</p><h3 id="BASE-理论"><a class="header-anchor" href="#BASE-理论"></a>BASE 理论</h3><p>BASE 理论是对 CAP 的一种解决思路，包含三个思想：</p><ul><li>Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li><li>Soft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。</li><li>Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</li></ul><h3 id="分布式系统理论基础小结"><a class="header-anchor" href="#分布式系统理论基础小结"></a>分布式系统理论基础小结</h3><p>而分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴 CAP 定理和 BASE 理论：</p><ul><li>AP 模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。</li><li>CP 模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。</li></ul><p>解决分布式事务，各个子系统之间必须能感知到彼此的事务状态，才能保证状态一致，因此需要一个事务协调者来协调每一个事务的参与者（子系统事务）。</p><p>这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务</p><p>解决分布式事务的思想和模型：</p><ul><li>全局事务：整个分布式事务</li><li>分支事务：分布式事务中包含的每个子系统的事务</li><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚</li></ul><h2 id="初识-Seata"><a class="header-anchor" href="#初识-Seata"></a>初识 Seata</h2><p>Seata 是 2019 年 1 月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。致力于提供高性能和简单易用的分布式事务服务，为用户打造一站式的分布式解决方案。</p><p>官网地址：<a href="http://seata.io/%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E3%80%81%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%82">http://seata.io/，其中的文档、博客中提供了大量的使用说明、源码分析。</a></p><h3 id="Seata-架构"><a class="header-anchor" href="#Seata-架构"></a>Seata 架构</h3><p>Seata 事务管理中有三个重要的角色：</p><ul><li>TC（Transaction Coordinator）：事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li>TM（Transaction Manager）：事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li>RM（Resource Manager）：资源管理器：管理分支事务处理的资源，与 TC 交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Seata%E6%9E%B6%E6%9E%84.i269crb2d34.svg" alt="Seata架构"></p><p>Seata 提供了四种不同的分布式事务解决方案：</p><ul><li>XA 模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</li><li>TCC 模式：最终一致的分阶段事务模式，有业务侵入</li><li>AT 模式：最终一致的分阶段事务模式，无业务侵入，也是 Seata 的默认模式</li><li>SAGA模式：长事务模式，有业务侵入</li></ul><h3 id="部署-TC-服务"><a class="header-anchor" href="#部署-TC-服务"></a>部署 TC 服务</h3><h4 id="下载解压配置"><a class="header-anchor" href="#下载解压配置"></a>下载解压配置</h4><p>首先我们要下载 seata-server 包，地址在 <a href="http://seata.io/zh-cn/blog/download.html">http</a><a href="http://seata.io/zh-cn/blog/download.html">://seata.io/zh-cn/blog/download</a><a href="http://seata.io/zh-cn/blog/download.html">.</a><a href="http://seata.io/zh-cn/blog/download.html">html</a></p><p>下载完成后解压，修改配置 conf 目录下的 registry.conf 文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    # seata tc 服务注册到 nacos的服务名称，可以自定义</span></span><br><span class="line">    <span class="attr">application</span> = <span class="string">&quot;seata-tc-server&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;nacos:8848&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;HZ&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line"><span class="comment">  # 配置nacos地址等信息</span></span><br><span class="line">  <span class="attr">nacos</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;nacos:8848&quot;</span></span><br><span class="line">    <span class="attr">namespace</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">group</span> = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    <span class="attr">username</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">    <span class="attr">dataId</span> = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="在-Nacos-添加配置"><a class="header-anchor" href="#在-Nacos-添加配置"></a>在 Nacos 添加配置</h4><p>特别注意，为了让 TC 服务的集群可以共享配置，我们选择了 Nacos 作为统一配置中心。因此服务端配置文件 seataServer.properties 文件需要在 Nacos 中配好。</p><p>配置内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据存储方式，db代表数据库</span></span><br><span class="line"><span class="meta">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="meta">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="meta">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">store.db.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">store.db.url</span>=<span class="string">jdbc:mysql://mysql:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line"><span class="meta">store.db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">store.db.password</span>=<span class="string">mogu2018</span></span><br><span class="line"><span class="meta">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="meta">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="meta">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="meta">store.db.maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="comment"># 事务、日志等配置</span></span><br><span class="line"><span class="meta">server.recovery.committingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.asynCommittingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.rollbackingRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.recovery.timeoutRetryPeriod</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.maxCommitRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">server.maxRollbackRetryTimeout</span>=<span class="string">-1</span></span><br><span class="line"><span class="meta">server.rollbackRetryTimeoutUnlockEnable</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">server.undo.logSaveDays</span>=<span class="string">7</span></span><br><span class="line"><span class="meta">server.undo.logDeletePeriod</span>=<span class="string">86400000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端与服务端传输方式</span></span><br><span class="line"><span class="meta">transport.serialization</span>=<span class="string">seata</span></span><br><span class="line"><span class="meta">transport.compressor</span>=<span class="string">none</span></span><br><span class="line"><span class="comment"># 关闭metrics功能，提高性能</span></span><br><span class="line"><span class="meta">metrics.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">metrics.registryType</span>=<span class="string">compact</span></span><br><span class="line"><span class="meta">metrics.exporterList</span>=<span class="string">prometheus</span></span><br><span class="line"><span class="meta">metrics.exporterPrometheusPort</span>=<span class="string">9898</span></span><br></pre></td></tr></table></figure><blockquote><p>其中的数据库地址、用户名、密码都需要修改成你自己的数据库信息。可能需要删除注释和空行</p></blockquote><h4 id="创建数据库表"><a class="header-anchor" href="#创建数据库表"></a>创建数据库表</h4><p>特别注意：TC 服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。</p><p>这些表主要记录全局事务、分支事务、全局锁信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 分支事务表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `branch_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `branch_table`  (</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_group_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource_id` <span class="type">varchar</span>(<span class="number">256</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `branch_type` <span class="type">varchar</span>(<span class="number">8</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `client_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime(<span class="number">6</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime(<span class="number">6</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`branch_id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- 全局事务表</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `global_table`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `global_table`  (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_service_group` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `transaction_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `timeout` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `begin_time` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `application_data` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h4 id="启动-TC-服务"><a class="header-anchor" href="#启动-TC-服务"></a>启动 TC 服务</h4><p>进入 bin 目录，运行其中的 seata-server.bat 即可，启动成功后，seata-server 应该已经注册到 nacos 注册中心了。</p><p>打开浏览器，访问 nacos 地址：<a href="http://localhost:8848">http://localhost:8848</a>，然后进入服务列表页面，可以看到 seata-tc-server 的信息</p><h4 id="微服务集成-Seata"><a class="header-anchor" href="#微服务集成-Seata"></a>微服务集成 Seata</h4><p>首先，引入 Seata 相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，配置 application.yml，让微服务通过注册中心找到 seata-tc-server</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取 tc 服务地址</span></span><br><span class="line">    <span class="comment"># 参考 tc 服务自己的 registry.conf 中的配置，</span></span><br><span class="line">    <span class="comment"># 包括：地址、namespace、group、application-name 、cluster</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span> <span class="comment"># tc</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">nacos:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;45e30304-1b64-4c21-8c83-22309949af10&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-tc-server</span> <span class="comment"># TC 服务在 nacos 中的服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">seata-demo</span> <span class="comment"># 事务组，根据这个获取 TC 服务的 cluster 名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与 TC 服务 cluster 的映射关系</span></span><br><span class="line">      <span class="attr">seata-demo:</span> <span class="string">HZ</span></span><br></pre></td></tr></table></figure><h2 id="使用-Seata"><a class="header-anchor" href="#使用-Seata"></a>使用 Seata</h2><h3 id="XA-模式"><a class="header-anchor" href="#XA-模式"></a>XA 模式</h3><h4 id="XA-规范"><a class="header-anchor" href="#XA-规范"></a>XA 规范</h4><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的 TM 与局部的 RM 之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/XA%E5%8E%9F%E7%90%86.62tx9ng7qqc0.svg" alt="XA原理"></p><h4 id="Seata-的-XA-模式"><a class="header-anchor" href="#Seata-的-XA-模式"></a>Seata 的 XA 模式</h4><p>Seata 的 XA 模式做了一些调整，但大体相似：</p><p>RM 一阶段的工作：</p><ul><li>注册分支事务到 TC</li><li>执行分支业务 SQL 但不提交</li><li>报告执行状态到 TC</li></ul><p>TC 二阶段的工作：</p><ul><li>TC 检测各分支事务执行状态</li><li>如果都成功，通知所有 RM 提交事务</li><li>如果有失败，通知所有 RM 回滚事务</li></ul><p>RM 二阶段的工作：</p><ul><li>接收 TC 指令，提交或回滚事务</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Seata%E7%9A%84XA%E6%A8%A1%E5%BC%8F.5kzn5v50ro40.svg" alt="Seata的XA模式"></p><p>XA 模式的优点：</p><ul><li>事务的强一致性，满足 ACID 原则。</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p>XA 模式的缺点：</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="Seata-实现-XA-模式"><a class="header-anchor" href="#Seata-实现-XA-模式"></a>Seata 实现 XA 模式</h4><p>Seata 的 starter 已经完成了 XA 模式的自动装配，实现非常简单，步骤如下：</p><p>修改 application.yml 文件（每个参与事务的微服务），开启 XA 模式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span> <span class="comment"># 开启数据源代理的XA模式</span></span><br></pre></td></tr></table></figure><p>给发起全局事务的入口方法添加 <code>@GlobalTransactional</code> 注解，本例中是<code>SeataOrderServiceImpl</code> 中的 <code>create</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">create</span><span class="params">(SeataOrder order)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    orderMapper.insert(order);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 扣用户余额</span></span><br><span class="line">        accountClient.deduct(order.getUserId(), order.getMoney());</span><br><span class="line">        <span class="comment">// 扣库存</span></span><br><span class="line">        storageClient.deduct(order.getCommodityCode(), order.getCount());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FeignException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;下单失败，原因:&#123;&#125;&quot;</span>, e.contentUTF8(), e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.contentUTF8(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务并测试</p><h3 id="AT-模式"><a class="header-anchor" href="#AT-模式"></a>AT 模式</h3><h4 id="AT-模式介绍"><a class="header-anchor" href="#AT-模式介绍"></a>AT 模式介绍</h4><p>AT 模式同样是分阶段提交的事务模型，不过缺弥补了 XA 模型中资源锁定周期过长的缺陷。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/AT%E6%A8%A1%E5%BC%8F.7bkzptrwvm40.svg" alt="AT模式"></p><p>阶段一 RM 的工作：</p><ul><li>注册分支事务</li><li>记录 undo-log（数据快照）</li><li>执行业务 SQL 并提交</li><li>报告事务状态</li></ul><p>阶段二提交时 RM 的工作：</p><ul><li>删除 undo-log 即可</li></ul><p>阶段二回滚时 RM 的工作：</p><ul><li>根据 undo-log 恢复数据到更新前</li></ul><p>简述 AT 模式与 XA 模式最大的区别是什么？</p><ul><li>XA 模式一阶段不提交事务，锁定资源；AT 模式一阶段直接提交，不锁定资源。</li><li>XA 模式依赖数据库机制实现回滚；AT 模式利用数据快照实现数据回滚。</li><li>XA 模式强一致；AT 模式最终一致</li></ul><h4 id="AT-模式的脏写问题"><a class="header-anchor" href="#AT-模式的脏写问题"></a>AT 模式的脏写问题</h4><p>因为事务之间没有隔离，存在脏写问题</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%84%8F%E5%86%99%E9%97%AE%E9%A2%98.2wajoxbl9sa0.svg" alt="AT模式的脏写问题"></p><p>解决方法：</p><p>全局锁：由 TC 记录当前正在操作某行数据的事务，该事务持有全局锁，具备执行权。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/AT%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%86%99%E9%9A%94%E7%A6%BB.5nlh9kqblx00.svg" alt="AT模式的写隔离"></p><p>对于非 Seata 管理的业务</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/AT%E6%A8%A1%E5%BC%8F%E5%AF%B9%E4%BA%8E%E9%9D%9ESeata%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1.4f39u8p9n5i0.svg" alt="AT模式对于非Seata管理的全局事务"></p><p>AT 模式的优点：</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能比较好</li><li>利用全局锁实现读写隔离</li><li>没有代码侵入，框架自动完成回滚和提交</li></ul><p>AT 模式的缺点：</p><ul><li>两阶段之间属于软状态，属于最终一致</li><li>框架的快照功能会影响性能，但比 XA 模式要好很多</li></ul><h4 id="Seata-实现-AT-模式"><a class="header-anchor" href="#Seata-实现-AT-模式"></a>Seata 实现 AT 模式</h4><p>AT 模式中的快照生成、回滚等动作都是由框架自动完成，没有任何代码侵入，因此实现非常简单。</p><ol><li><p>导入 SQL 文件：<a href="https://github.com/Lanqilu/HaloSpringCloud/blob/master/seata-demo/db/seata-at.sql">seata-at.sql</a>，其中 lock_table 导入到 TC 服务关联的数据库，undo_log 表导入到微服务关联的数据库</p></li><li><p>修改 application.yml 文件，将事务模式修改为 AT 模式即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span> <span class="comment"># 开启数据源代理的AT模式</span></span><br></pre></td></tr></table></figure></li><li><p>服务添加 <code>@GlobalTransactional</code> 注解</p></li><li><p>重启服务并测试</p></li></ol><h3 id="TCC-模式"><a class="header-anchor" href="#TCC-模式"></a>TCC 模式</h3><h4 id="TCC-模式介绍"><a class="header-anchor" href="#TCC-模式介绍"></a>TCC 模式介绍</h4><p>TCC 模式与 AT 模式非常相似，每阶段都是独立事务，不同的是 TCC 通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li>Try：资源的检测和预留；</li><li>Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。</li><li>Cancel：预留资源释放，可以理解为 Try 的反向操作。</li></ul><p>举例，一个扣减用户余额的业务。假设账户 A 原来余额是 100，需要余额扣减 30 元。</p><ul><li>阶段一（ Try ）：检查余额是否充足，如果充足则冻结金额增加 30 元，可用余额扣除 30</li><li>阶段二：假如要提交（Confirm），则冻结金额扣减 30</li><li>阶段二：如果要回滚（Cancel），则冻结金额扣减 30，可用余额增加 30</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/TCC%E6%A8%A1%E5%BC%8F.5947loh7hrc0.svg" alt="TCC模式"></p><p>TCC 模式的每个阶段是做什么的？</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC 的优点是什么？</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比 AT 模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC 的缺点是什么？</p><ul><li>有代码侵入，需要人为编写 Try、Confirm 和 Cancel 接口，太麻烦</li><li>软状态，事务是最终一致</li></ul><p>需要考虑 Confirm 和 Cancel 的失败情况，做好幂等处理</p><h4 id="实现-TCC-模式"><a class="header-anchor" href="#实现-TCC-模式"></a>实现 TCC 模式</h4><p>改造 account-service 服务，利用 TCC 实现分布式事务</p><p>需求如下：</p><ul><li>修改 account-service，编写 try、confirm、cancel 逻辑</li><li>try 业务：添加冻结金额，扣减可用金额</li><li>confirm 业务：删除冻结金额</li><li>cancel 业务：删除冻结金额，恢复可用金额</li><li>保证 confirm、cancel 接口的幂等性（重复调用效果相同）</li><li>允许空回滚</li><li>拒绝业务悬挂</li></ul><p>TCC 的空回滚和业务悬挂</p><ul><li>当某分支事务的 try 阶段阻塞时，可能导致全局事务超时而触发二阶段的 cancel 操作。在未执行 try 操作时先执行了 cancel 操作，这时 cancel 不能做回滚，就是空回滚。</li><li>对于已经空回滚的业务，如果以后继续执行 try，就永远不可能 confirm 或 cancel，这就是业务悬挂。应当阻止执行空回滚后的 try 操作，避免悬挂。</li></ul><p>为了实现空回滚、防止业务悬挂，以及幂等性要求。我们必须在数据库记录冻结金额的同时，记录当前事务 id 和执行状态，为此我们设计了一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account_freeze_tbl` (</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `freeze_money` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;冻结金额&#x27;</span>,</span><br><span class="line">  `state` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;事务状态，0:try，1:confirm，2:cancel&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`xid`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ROW_FORMAT<span class="operator">=</span>COMPACT;</span><br></pre></td></tr></table></figure><ul><li>Try 业务：记录冻结金额和事务状态到 account_freeze 表，扣减 account 表可用金额</li><li>Confirm 业务：根据 xid 删除 account_freeze 表的冻结记录</li><li>Cancel 业务：修改 account_freeze 表，冻结金额为 0，state 为 2；修改 account 表，恢复可用金额</li><li>如何判断是否空回滚：Cancel 业务中，根据 xid 查询 account_freeze，如果为 null 则说明 Try 还没做，需要空回滚</li><li>如何避免业务悬挂：Try 业务中，根据 xid 查询 account_freeze ，如果已经存在则证明Cancel 已经执行，拒绝执行 Try 业务</li></ul><p>声明 TCC 接口：Try、Confirm、Cancel 方法都需要在接口中基于注解来声明，语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TCCService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Try逻辑，<span class="doctag">@TwoPhaseBusinessAction</span>中的name属性要与当前方法名一致，用于指定Try逻辑对应的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;prepare&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;param&quot;)</span> String param)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二阶段confirm确认方法、可以另命名，但要保证与commitMethod一致 </span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> context 上下文,可以传递try方法的参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> boolean 执行是否成功</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">confirm</span> <span class="params">(BusinessActionContext context)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二阶段回滚方法，要保证与rollbackMethod一致</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(BusinessActionContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seata-demo 数据库中引入 <a href="https://github.com/Lanqilu/HaloSpringCloud/blob/master/seata-demo/db/account_freeze_tbl.sql">account_freeze_tbl.sql</a> 数据表，创建对应实体类和Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;account_freeze_tbl&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountFreeze</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> String xid;</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line">    <span class="keyword">private</span> Integer freezeMoney;</span><br><span class="line">    <span class="keyword">private</span> Integer state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TRY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CONFIRM = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CANCEL = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建接口，使用 <code>@TwoPhaseBusinessAction</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从用户账户中扣款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TwoPhaseBusinessAction(name = &quot;deduct&quot;, commitMethod = &quot;confirm&quot;, rollbackMethod = &quot;cancel&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deduct</span><span class="params">(<span class="meta">@BusinessActionContextParameter(paramName = &quot;userId&quot;)</span> String userId,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@BusinessActionContextParameter(paramName = &quot;money&quot;)</span> <span class="keyword">int</span> money)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">confirm</span> <span class="params">(BusinessActionContext context)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span> <span class="params">(BusinessActionContext context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口和业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTCCServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountTCCService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountFreezeMapper freezeMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deduct</span><span class="params">(String userId, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事务id</span></span><br><span class="line">        String xid = RootContext.getXID();</span><br><span class="line">        <span class="comment">// 判断 freeze 是否有冻结记录</span></span><br><span class="line">        AccountFreeze oldFreeze = freezeMapper.selectById(xid);</span><br><span class="line">        <span class="keyword">if</span> (oldFreeze != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 已经处理过一次 CANCEL，无需重复处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 扣减可以余额</span></span><br><span class="line">        accountMapper.deduct(userId, money);</span><br><span class="line">        <span class="comment">// 2. 记录冻结余额，事务状态</span></span><br><span class="line">        AccountFreeze freeze = <span class="keyword">new</span> AccountFreeze();</span><br><span class="line">        freeze.setUserId(userId);</span><br><span class="line">        freeze.setFreezeMoney(money);</span><br><span class="line">        freeze.setState(AccountFreeze.State.TRY);</span><br><span class="line">        freeze.setXid(xid);</span><br><span class="line">        freezeMapper.insert(freeze);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">(BusinessActionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取事务id</span></span><br><span class="line">        String xid = context.getXid();</span><br><span class="line">        <span class="comment">// 根据 id 删除冻结记录</span></span><br><span class="line">        <span class="keyword">return</span> freezeMapper.deleteById(xid) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(BusinessActionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询冻结记录</span></span><br><span class="line">        String xid = context.getXid();</span><br><span class="line">        AccountFreeze freeze = freezeMapper.selectById(xid);</span><br><span class="line">        <span class="comment">// 空回滚判断</span></span><br><span class="line">        <span class="keyword">if</span> (freeze == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要空回滚</span></span><br><span class="line">            freeze.setUserId(context.getActionContext(<span class="string">&quot;userId&quot;</span>).toString());</span><br><span class="line">            freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">            freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">            freeze.setXid(xid);</span><br><span class="line">            freezeMapper.insert(freeze);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 幂等判断</span></span><br><span class="line">        <span class="keyword">if</span> (freeze.getState() == AccountFreeze.State.CANCEL) &#123;</span><br><span class="line">            <span class="comment">// 已经处理过了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复可用余额</span></span><br><span class="line">        accountMapper.refund(freeze.getUserId(), freeze.getFreezeMoney());</span><br><span class="line">        <span class="comment">// 将冻结余额清零</span></span><br><span class="line">        freeze.setFreezeMoney(<span class="number">0</span>);</span><br><span class="line">        freeze.setState(AccountFreeze.State.CANCEL);</span><br><span class="line">        <span class="keyword">return</span> freezeMapper.updateById(freeze) == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Controller 中使用的 Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AccountTCCService accountService;</span><br></pre></td></tr></table></figure><h3 id="SAGA-模式"><a class="header-anchor" href="#SAGA-模式"></a>SAGA 模式</h3><p>Saga 模式是 Seata 提供的长事务解决方案。也分为两个阶段：</p><ul><li>一阶段：直接提交本地事务</li><li>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</li></ul><p>Saga 模式优点：</p><ul><li>事务参与者可以基于事件驱动实现异步调用，吞吐高</li><li>一阶段直接提交事务，无锁，性能好</li><li>不用编写TCC中的三个阶段，实现简单</li></ul><p>缺点：</p><ul><li>软状态持续时间不确定，时效性差</li><li>没有锁，没有事务隔离，会有脏写</li></ul><h3 id="四种模式对比"><a class="header-anchor" href="#四种模式对比"></a>四种模式对比</h3><table><thead><tr><th>对比内容</th><th>XA</th><th>AT</th><th>TCC</th><th>SAGA</th></tr></thead><tbody><tr><td>一致性</td><td>强一致</td><td>弱一致</td><td>弱一致</td><td>最终一致</td></tr><tr><td>隔离性</td><td>完全隔离</td><td>基于全局锁隔离</td><td>基于资源预留隔离</td><td>无隔离</td></tr><tr><td>代码侵入</td><td>无</td><td>无</td><td>有，要编写三个接口</td><td>有，要编写状态机和补偿业务</td></tr><tr><td>性能</td><td>差</td><td>好</td><td>非常好</td><td>非常好</td></tr><tr><td>场景</td><td>对一致性、隔离性有高要求的业务</td><td>基于关系型数据库的大多数分布式事务场景都可以</td><td>对性能要求较高的事务。有非关系型数据库要参与的事务。</td><td>业务流程长、业务流程多。参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分布式事务理论基础&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#分布式事务理论基础&quot;&gt;&lt;/a&gt;分布式事务理论基础&lt;/h2&gt;
&lt;p&gt;事务的 ACID 原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 原子性： 事务中的所有操作，要么全部成功，要么全部失败&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sentinel入门</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/F_Sentinel%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/F_Sentinel%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.837Z</published>
    <updated>2021-09-20T06:00:52.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识-Sentinel"><a class="header-anchor" href="#初识-Sentinel"></a>初识 Sentinel</h2><h3 id="雪崩问题及解决方案"><a class="header-anchor" href="#雪崩问题及解决方案"></a>雪崩问题及解决方案</h3><h4 id="雪崩问题"><a class="header-anchor" href="#雪崩问题"></a>雪崩问题</h4><p>微服务中，服务间调用关系错综复杂，一个微服务往往依赖于多个其它微服务。</p><p>如果服务提供者 I 发生了故障，当前的应用的部分业务因为依赖于服务 I，因此也会被阻塞。此时，其它不依赖于服务 I 的业务似乎不受影响。</p><p>但是，依赖服务 I 的业务请求被阻塞，用户不会得到响应，则 tomcat 的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞</p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，那么当前服务也就不可用了。</p><p>那么，依赖于当前服务的其它服务随着时间的推移，最终也都会变的不可用，形成级联失败，雪崩就发生了</p><p>微服务调用链路中的某个服务故障，引起整个链路中的所有微服务都不可用，这就是雪崩。</p><h4 id="雪崩问题解决方式"><a class="header-anchor" href="#雪崩问题解决方式"></a>雪崩问题解决方式</h4><p>解决雪崩问题的常见方式有四种：</p><ul><li><p>超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待。如果请求速度大于释放速度最后仍会产生雪崩，只能缓解问题，不能解决问题。</p></li><li><p>仓壁模式：仓壁模式来源于船舱的设计：船舱都会被隔板分离为多个独立空间，当船体破损时，只会导致部分空间进入，将故障控制在一定范围内，避免整个船体都被淹没。限定每个业务能使用的线程数，避免耗尽整个 tomcat 的资源，因此也叫线程隔离。</p></li><li><p>断路器模式：由断路器统计业务执行的异常比例，如果超出阈值则会熔断该业务，拦截访问该业务的一切请求。</p><p>断路器会统计访问某个服务的请求数量，异常比例，当发现访问服务 D 的请求异常比例过高时，认为服务 D 有导致雪崩的风险，会拦截访问服务 D 的一切请求，形成熔断。</p></li><li><p>流量控制：限制业务访问的 QPS（每秒请求数量），避免服务因流量的突增而故障。</p></li></ul><h4 id="雪崩问题总结"><a class="header-anchor" href="#雪崩问题总结"></a>雪崩问题总结</h4><p>什么是雪崩问题？</p><p>微服务之间相互调用，因为调用链中的一个服务故障，引起整个链路都无法访问的情况。</p><p>雪崩问题解决方式：</p><ul><li><strong>限流</strong>是对服务的保护，避免因瞬间高并发流量而导致服务故障，进而避免雪崩。是一种<strong>预防</strong>措施。</li><li><strong>超时处理、线程隔离、降级熔断</strong>是在部分服务故障时，将故障控制在一定范围，避免雪崩。是一种<strong>补救</strong>措施。</li></ul><h3 id="服务保护技术对比"><a class="header-anchor" href="#服务保护技术对比"></a>服务保护技术对比</h3><p>在 Spring Cloud 当中支持多种服务保护技术：</p><ul><li><a href="https://github.com/Netflix/Hystrix">Netfix Hystrix</a></li><li><a href="https://github.com/alibaba/Sentinel">Sentinel</a></li><li><a href="https://github.com/resilience4j/resilience4j">Resilience4J</a></li></ul><p>早期比较流行的是 Hystrix 框架，但目前国内实用最广泛的还是阿里巴巴的 Sentinel 框架，这里我们做下对比：</p><table><thead><tr><th></th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于慢调用比例或异常比例</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>基于注解的支持</td><td>支持</td><td>支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速排队模式</td><td>不支持</td></tr><tr><td>系统自适应保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC  等</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h3 id="Sentinel-介绍和安装"><a class="header-anchor" href="#Sentinel-介绍和安装"></a>Sentinel 介绍和安装</h3><h4 id="初识-Sentinel-v2"><a class="header-anchor" href="#初识-Sentinel-v2"></a>初识 Sentinel</h4><p>Sentinel 是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><p>Sentinel 具有以下特征:</p><p>•丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>•完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>•广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p><p>•<strong>完善的</strong> SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><h4 id="安装-Sentinel"><a class="header-anchor" href="#安装-Sentinel"></a>安装 Sentinel</h4><p>Sentinel 官方提供了UI控制台，方便我们对系统做限流设置。大家可以在 <a href="https://github.com/alibaba/Sentinel/releases">GitHub</a> 下载。</p><p>将 jar 包放到任意非中文目录，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure><p>如果要修改 Sentinel 的默认端口、账户、密码，可以通过下列配置：</p><table><thead><tr><th>配置项</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>server.port</code></td><td>8080</td><td>服务端口</td></tr><tr><td><code>sentinel.dashboard.auth.username</code></td><td>sentinel</td><td>默认用户名</td></tr><tr><td><code>sentinel.dashboard.auth.password</code></td><td>sentinel</td><td>默认密码</td></tr></tbody></table><p>例如，修改端口：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dserver.port=8090 -jar sentinel-dashboard-1.8.1.jar</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:8080">http://localhost:8080</a> 页面，就可以看到 Sentinel 的控制台了：</p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，发现一片空白，什么都没有，这是因为我们还没有与微服务整合。</p><h3 id="微服务整合-Sentinel"><a class="header-anchor" href="#微服务整合-Sentinel"></a>微服务整合 Sentinel</h3><p>我们在 order-service 中整合 sentinel，并连接 sentinel 的控制台，步骤如下：</p><p>引入 sentinel 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置控制台，修改 application.yaml 文件，添加下面内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">sentinel:8092</span></span><br></pre></td></tr></table></figure><p>访问 order-service 的任意端点</p><p>打开浏览器，访问 <a href="http://localhost:8088/order/101%EF%BC%8C%E8%BF%99%E6%A0%B7%E6%89%8D%E8%83%BD%E8%A7%A6%E5%8F%91">http://localhost:8088/order/101，这样才能触发</a> sentinel 的监控。</p><p>然后再访问 sentinel 的控制台，查看效果</p><h2 id="流量控制"><a class="header-anchor" href="#流量控制"></a>流量控制</h2><p>雪崩问题虽然有四种方案，但是限流是避免服务因突发的流量而发生故障，是对微服务雪崩问题的预防。我们先学习这种模式。</p><h3 id="簇点链路"><a class="header-anchor" href="#簇点链路"></a>簇点链路</h3><p>簇点链路：就是项目内的调用链路，链路中被监控的每个接口就是一个资源。</p><p>当请求进入微服务时，首先会访问 <code>DispatcherServlet</code>，然后进入 Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个<strong>资源</strong>。</p><p>默认情况下 sentinel 会监控 SpringMVC 的每一个端点（Endpoint，也就是 controller 中的方法），因此 Spring MVC 的每一个端点（Endpoint）就是调用链路中的一个资源。</p><p>例如，我们刚才访问的 order-service 中的 <code>OrderController</code> 中的端点：<code>/order/&#123;orderId&#125;</code></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2bkadnwmts7w.png" alt="image"></p><p>流控、熔断等都是针对簇点链路中的资源来设置的，因此我们可以点击对应资源后面的按钮来设置规则：</p><ul><li>流控：流量控制</li><li>降级：降级熔断</li><li>热点：热点参数限流，是限流的一种</li><li>授权：请求的权限控制</li></ul><h3 id="快速入门"><a class="header-anchor" href="#快速入门"></a>快速入门</h3><p>点击资源 <code>/order/&#123;orderId&#125;</code> 后面的流控按钮，就可以弹出表单。</p><p>表单中可以填写限流规则，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.70ekiexb0i00.png" alt="image"></p><p>其含义是限制 <code>/order/&#123;orderId&#125;</code> 这个资源的单机 QPS 为 1，即每秒只允许 1 次请求，超出的请求会被拦截并报错。</p><p>需求：给 <code>/order/&#123;orderId&#125;</code> 这个资源设置流控规则，QPS 不能超过  5，然后利用 JMeter  测试。</p><h3 id="流控模式"><a class="header-anchor" href="#流控模式"></a>流控模式</h3><p>在添加限流规则时，点击高级选项，可以选择三种流控模式：</p><ul><li>直接：统计当前资源的请求，触发阈值时对当前资源直接限流，也是默认的模式</li><li>关联：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</li><li>链路：统计从指定链路访问到本资源的请求，触发阈值时，对指定链路限流</li></ul><p>快速入门测试的就是直接模式。</p><h4 id="关联模式"><a class="header-anchor" href="#关联模式"></a>关联模式</h4><p>关联模式：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>使用场景：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p>配置规则：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2fazj95c9jgg.png" alt="image"></p><p>语法说明：当 /write 资源访问量触发阈值时，就会对 /read 资源限流，避免影响 /write 资源。</p><p>需求说明：</p><ul><li><p>在 <code>OrderController</code> 新建两个端点：/order/query 和 /order/update，无需实现业务</p></li><li><p>配置流控规则，当 /order/update 资源被访问的 QPS 超过 5 时，对 /order/query 请求限流</p></li></ul><p>定义 /order/query 端点，模拟订单查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 /order/update 端点，模拟订单更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;更新订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，查看 sentinel 控制台的簇点链路</p><p>配置流控规则，对哪个端点限流，就点击哪个端点后面的按钮。我们是对订单查询 /order/query 限流，因此点击它后面的按钮，在表单中填写流控规则：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.8syzbd74gco.png" alt="image"></p><p>在 JMeter 测试</p><p>满足下面条件可以使用关联模式：</p><ul><li>两个有竞争关系的资源</li><li>一个优先级较高，一个优先级较低</li></ul><h4 id="链路模式"><a class="header-anchor" href="#链路模式"></a>链路模式</h4><p>链路模式：只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。</p><p>配置示例：</p><p>例如有两条请求链路：</p><ul><li><p>/test1 → /common</p></li><li><p>/test2 → /common</p></li></ul><p>如果只希望统计从 /test2 进入到 /common 的请求，则可以这样配置：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3pgkf0xop5s0.png" alt="image"></p><p>案例需求：有查询订单和创建订单业务，两者都需要查询商品。针对从查询订单进入到查询商品的请求统计，并设置限流。</p><p>步骤：</p><ol><li><p>在 <code>OrderService</code> 中添加一个 <code>queryGoods</code> 方法，不用实现业务</p></li><li><p>在 <code>OrderController</code> 中，改造 /order/query 端点，调用 <code>OrderService</code> 中的 <code>queryGoods</code> 方法</p></li><li><p>在 <code>OrderController</code> 中添加一个 /order/save 的端点，调用 <code>OrderService</code> 的 <code>queryGoods</code> 方法</p></li><li><p>给 <code>queryGoods</code> 设置限流规则，从 /order/query 进入 <code>queryGoods</code> 的方法限制QPS必须小于2</p></li></ol><p>添加查询商品方法，在 order-service 服务中，给 <code>OrderService</code> 类添加一个 <code>queryGoods</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询订单时，查询商品，在 order-service 的 <code>OrderController</code> 中，修改 /order/query 端点的业务逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/query&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增订单，查询商品，在 order-service 的 <code>OrderController</code> 中，添加 /order/save 端点，模拟新增订单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询商品</span></span><br><span class="line">    orderService.queryGoods();</span><br><span class="line">    <span class="comment">// 查询订单</span></span><br><span class="line">    System.err.println(<span class="string">&quot;新增订单&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;新增订单成功&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给查询商品添加资源标记，默认情况下，<code>OrderService</code> 中的方法是不被 Sentinel 监控的，需要我们自己通过注解来标记要监控的方法。给 <code>OrderService</code> 的 <code>queryGoods</code> 方法添加 <code>@SentinelResource</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;goods&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;查询商品&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链路模式中，是对不同来源的两个链路做监控。但是 Sentinel 默认会给进入 Spring MVC 的所有请求设置同一个 root 资源，会导致链路模式失效。我们需要关闭这种对 Spring MVC 的资源聚合，修改 order-service 服务的 application.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 关闭context整合</span></span><br></pre></td></tr></table></figure><p>重启服务，访问 /order/query 和 /order/save，可以查看到 Sentinel 的簇点链路规则中，出现了新的资源：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1ed4rdp6vmm8.png" alt="image"></p><p>添加流控规则，点击 goods 资源后面的流控按钮，在弹出的表单中填写下面信息：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.sax6d8udqkg.png" alt="image"></p><p>只统计从 /order/query 进入 /goods 的资源，QPS 阈值为 2，超出则被限流。最后使用 JMeter 测试。</p><h4 id="流控模式总结"><a class="header-anchor" href="#流控模式总结"></a>流控模式总结</h4><ul><li>直接：对当前资源限流</li><li>关联：高优先级资源触发阈值，对低优先级资源限流。</li><li>链路：阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</li></ul><h3 id="流控效果"><a class="header-anchor" href="#流控效果"></a>流控效果</h3><p>在流控的高级选项中，还有一个流控效果选项：</p><p>流控效果是指请求达到流控阈值时应该采取的措施，包括三种：</p><ul><li><p>快速失败：达到阈值后，新的请求会被立即拒绝并抛出 <code>FlowException</code> 异常。是默认的处理方式。</p></li><li><p>Warm Up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值。</p></li><li><p>排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p></li></ul><h4 id="Warm-Up"><a class="header-anchor" href="#Warm-Up"></a>Warm Up</h4><p>阈值一般是一个微服务能承担的最大 QPS，但是一个服务刚刚启动时，一切资源尚未初始化（冷启动），如果直接将 QPS 跑到最大值，可能导致服务瞬间宕机。</p><p>Warm Up 也叫预热模式，是应对服务冷启动的一种方案。请求阈值初始值是 <code>maxThreshold / coldFactor</code>，持续指定时长后，逐渐提高到 <code>maxThreshold</code> 值。而 <code>coldFactor</code> 的默认值是 3 。</p><p>例如，我设置 QPS 的 <code>maxThreshold</code> 为 10，预热时间为 5 秒，那么初始阈值就是 10 / 3 ，也就是 3，然后在 5 秒后逐渐增长到 10。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.578rh9uf2hs0.png" alt="image"></p><p>案例需求：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用 Warm Up 效果，预热时长为 5 秒</p><h4 id="排队等待"><a class="header-anchor" href="#排队等待"></a>排队等待</h4><p>当请求超过 QPS 阈值时，快速失败和 Warm Up 会拒绝新的请求并抛出异常。</p><p>而排队等待则是让所有请求进入一个队列中，然后按照阈值允许的时间间隔依次执行。后来的请求必须等待前面执行完成，如果请求预期的等待时间超出最大时长，则会被拒绝。</p><p>工作原理</p><p>例如：QPS = 5，意味着每 200ms 处理一个队列中的请求；timeout = 2000，意味着预期等待时长超过 2000ms 的请求会被拒绝并抛出异常。</p><p>那什么叫做预期等待时长呢？</p><p>比如现在一下子来了 12 个请求，因为每 200ms 执行一个请求，那么：</p><ul><li>第 6 个请求的<strong>预期等待时长</strong> =  200 * (6 - 1) = 1000ms</li><li>第 12 个请求的预期等待时长 = 200 * (12-1) = 2200ms</li></ul><p>现在，第 1 秒同时接收到 10 个请求，但第 2 秒只有 1 个请求，此时 QPS 的曲线这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.41n82oeep1g0.png" alt="image"></p><p>如果使用队列模式做流控，所有进入的请求都要排队，以固定的 200ms 的间隔执行，QPS 会变的很平滑</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6aqz6pt0zqo0.png" alt="image"></p><p>平滑的 QPS 曲线，对于服务器来说是更友好的。</p><p>案例需求：给 /order/{orderId} 这个资源设置限流，最大 QPS 为 10，利用排队的流控效果，超时时长设置为 5s</p><h4 id="流控效果总结"><a class="header-anchor" href="#流控效果总结"></a>流控效果总结</h4><ul><li><p>快速失败：QPS 超过阈值时，拒绝新的请求</p></li><li><p>Warm Up： QPS 超过阈值时，拒绝新的请求；QPS 阈值是逐渐提升的，可以避免冷启动时高并发导致服务宕机。</p></li><li><p>排队等待：请求会进入队列，按照阈值允许的时间间隔依次执行请求；如果请求预期等待时长大于超时时间，直接拒绝</p></li></ul><h3 id="热点参数限流"><a class="header-anchor" href="#热点参数限流"></a>热点参数限流</h3><p>之前的限流是统计访问某个资源的所有请求，判断是否超过 QPS 阈值。而热点参数限流是分别统计参数值相同的请求，判断是否超过 QPS 阈值。</p><h4 id="全局参数限流"><a class="header-anchor" href="#全局参数限流"></a>全局参数限流</h4><p>例如，一个根据 id 查询商品的接口，访问 /goods/{id} 的请求中，id 参数值会有变化，热点参数限流会根据<strong>参数值</strong>分别统计 QPS，统计结果：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.44ql4uo7cfi0.png" alt="image"></p><p>当 id=1 的请求触发阈值被限流时，id 值不为 1 的请求不受影响。</p><p>配置示例：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.qkaqtkxdxio.png" alt="image"></p><p>代表的含义是：对 hot 这个资源的 0 号参数（第一个参数）做统计，每 1 秒相同参数值的请求数不能超过 5</p><h4 id="热点参数限流-v2"><a class="header-anchor" href="#热点参数限流-v2"></a>热点参数限流</h4><p>刚才的配置中，对查询商品这个接口的所有商品一视同仁，QPS 都限定为 5。</p><p>而在实际开发中，可能部分商品是热点商品，例如秒杀商品，我们希望这部分商品的 QPS 限制与其它商品不一样，高一些。那就需要配置热点参数限流的高级选项了：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6bhk98olbio0.png" alt="image"></p><p>结合上一个配置，这里的含义是对 0 号的 long 类型参数限流，每 1 秒相同参数的 QPS 不能超过 5，有两个例外：</p><ul><li>如果参数值是 100，则每 1 秒允许的 QPS 为 10</li><li>如果参数值是 101，则每 1 秒允许的 QPS 为 15</li></ul><h4 id="示范案例"><a class="header-anchor" href="#示范案例"></a>示范案例</h4><p>案例需求：给 /order/{orderId} 这个资源添加热点参数限流，规则如下：</p><ul><li>默认的热点参数规则是每 1 秒请求量不超过 2</li><li>给 102 这个参数设置例外：每 1 秒请求量不超过 4</li><li>给 103 这个参数设置例外：每 1 秒请求量不超过 10</li></ul><p>注意事项：热点参数限流对默认的 Spring MVC 资源无效，需要利用 <code>@SentinelResource</code> 注解标记资源</p><p>标记资源，给 order-service 中的 <code>OrderController</code> 中的 /order/{orderId} 资源添加注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SentinelResource(&quot;hot&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;&#123;orderId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">queryOrderByUserId</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 id 查询订单并返回</span></span><br><span class="line">    <span class="keyword">return</span> orderService.queryOrderById(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>热点参数限流规则，访问该接口，可以看到我们标记的 hot 资源出现了，这里不要点击 hot 后面的按钮，页面有Bug，没有高级选项，点击左侧菜单中热点规则菜单：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7dbpozbwj1s0.png" alt="image"></p><p>点击新增，填写表单：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.62qkqxkatd40.png" alt="image"></p><h2 id="隔离和降级"><a class="header-anchor" href="#隔离和降级"></a>隔离和降级</h2><p>限流是一种预防措施，虽然限流可以尽量避免因高并发而引起的服务故障，但服务还会因为其它原因而故障。</p><p>而要将这些故障控制在一定范围，避免雪崩，就要靠线程隔离（舱壁模式）和熔断降级手段了。</p><p>线程隔离之前讲到过：调用者在调用服务提供者时，给每个调用的请求分配独立线程池，出现故障时，最多消耗这个线程池内资源，避免把调用者的所有资源耗尽。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4hs9dg5qave0.png" alt="image"></p><p>熔断降级：是在调用方这边加入断路器，统计对服务提供者的调用，如果调用的失败比例过高，则熔断该业务，不允许访问该服务的提供者了。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4m9qos5euys0.png" alt="image"></p><p>可以看到，不管是线程隔离还是熔断降级，都是对客户端（调用方）的保护。需要在<strong>调用方</strong> 发起远程调用时做线程隔离、或者服务熔断。</p><p>而我们的微服务远程调用都是基于 Feign 来完成的，因此我们需要将 Feign 与 Sentinel 整合，在 Feign 里面实现线程隔离和服务熔断。</p><h3 id="Feign-Client-整合-Sentinel"><a class="header-anchor" href="#Feign-Client-整合-Sentinel"></a>Feign Client 整合 Sentinel</h3><p>Spring Cloud 中，微服务调用都是通过 Feign 来实现的，因此做客户端保护必须整合 Feign 和 Sentinel。</p><h4 id="修改-Feign-配置开启-Sentinel-功能"><a class="header-anchor" href="#修改-Feign-配置开启-Sentinel-功能"></a>修改 Feign 配置开启 Sentinel 功能</h4><p>修改 <code>OrderService</code> 的 application.yml 文件，开启 Feign 的 Sentinel 功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><h4 id="编写失败降级逻辑"><a class="header-anchor" href="#编写失败降级逻辑"></a>编写失败降级逻辑</h4><p>业务失败后，不能直接报错，而应该返回用户一个友好提示或者默认结果，这个就是失败降级逻辑。</p><p>给 Feign Client 编写失败后的降级逻辑，有两种实现方式：</p><ul><li><code>FallbackClass</code>，无法对远程调用的异常做处理</li><li><code>FallbackFactory</code>，可以对远程调用的异常做处理（我们选择这种）</li></ul><p>步骤一：在 feign-api 项目中定义类，实现 <code>FallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.feign.clients.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.clients.UserClient;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.feign.pojo.User;</span><br><span class="line"><span class="keyword">import</span> feign.hystrix.FallbackFactory;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">UserClient</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserClient <span class="title">create</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserClient() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">findById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询用户异常&quot;</span>, throwable);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤二：在 feign-api 项目中的 <code>DefaultFeignConfiguration</code> 类中将 <code>UserClientFallbackFactory</code> 注册为一个 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserClientFallbackFactory <span class="title">userClientFallbackFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserClientFallbackFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤三</strong>：在 feign-api 项目中的 UserClient 接口中使用 <code>UserClientFallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;, fallbackFactory = UserClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Feign-Client-整合-Sentinel-总结"><a class="header-anchor" href="#Feign-Client-整合-Sentinel-总结"></a>Feign Client 整合 Sentinel 总结</h4><p>Sentinel支持的雪崩解决方案：</p><ul><li>线程隔离（仓壁模式）</li><li>降级熔断</li></ul><p>Feign 整合 Sentinel 的步骤：</p><ul><li>在application.yml中配置：<code>feign.sentienl.enable=true</code></li><li>给 FeignClient 编写 <code>FallbackFactory</code> 并注册为Bean</li><li>将 <code>FallbackFactory</code> 配置到 FeignClient</li></ul><h3 id="线程隔离（舱壁模式）"><a class="header-anchor" href="#线程隔离（舱壁模式）"></a>线程隔离（舱壁模式）</h3><h4 id="线程隔离的实现方式"><a class="header-anchor" href="#线程隔离的实现方式"></a>线程隔离的实现方式</h4><p>线程隔离有两种方式实现：</p><ul><li><p>线程池隔离</p></li><li><p>信号量隔离（Sentinel 默认采用）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7cx1j6s3zxk0.png" alt="image"></p><p>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</p><ul><li>优点：支持主动超时，支持异步调用</li><li>缺点：线程的额外开销比较大</li><li>场景：低扇出（Fanout）</li></ul><p>信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</p><ul><li>优点：轻量级，无额外开销</li><li>缺点：不支持主动超时，不支持异步调用</li><li>场景：高频调用，高扇出</li></ul><h4 id="Sentinel-的线程隔离"><a class="header-anchor" href="#Sentinel-的线程隔离"></a>Sentinel 的线程隔离</h4><p>在添加限流规则时，可以选择两种阈值类型：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.xp3c06ky0cg.png" alt="image"></p><ul><li><p>QPS：就是每秒的请求数，在快速入门中已经演示过</p></li><li><p>线程数：是该资源能使用用的 tomcat 线程数的最大值。也就是通过限制线程数量，实现<strong>线程隔离</strong>（舱壁模式）。</p></li></ul><p>案例需求：给 order-service 服务中的 UserClient 的查询用户接口设置流控规则，线程数不能超过 2。然后利用 JMeter 测试。</p><h3 id="熔断降级"><a class="header-anchor" href="#熔断降级"></a>熔断降级</h3><p>熔断降级是解决雪崩问题的重要手段。其思路是由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则会熔断该服务。即拦截访问该服务的一切请求；而当服务恢复时，断路器会放行访问该服务的请求。</p><p>断路器控制熔断和放行是通过状态机来完成的：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6y5xecv9u000.png" alt="image"></p><p>状态机包括三个状态：</p><ul><li>closed：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到 open 状态</li><li>open：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。open 状态 5 秒后会进入 half-open 状态</li><li>half-open：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到 closed 状态</li><li>请求失败：则切换到 open 状态</li></ul></li></ul><p>断路器熔断策略有三种：慢调用、异常比例、异常数</p><h4 id="慢调用比例"><a class="header-anchor" href="#慢调用比例"></a>慢调用比例</h4><p>慢调用比例：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2cyb37owkqtc.png" alt="image"></p><p>解读：RT 超过 500ms 的调用是慢调用，统计最近 10000ms 内的请求，如果请求量超过 10 次，并且慢调用比例不低于 0.5，则触发熔断，熔断时长为 5 秒。然后进入 half-open 状态，放行一次请求做测试。</p><p>案例需求：给 UserClient 的查询用户接口设置降级规则，慢调用的 RT 阈值为 50ms ，统计时间为 1 秒，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5</p><p>设置慢调用，修改 user-service 中的 /user/{id} 这个接口的业务。通过休眠模拟一个延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// id 为 1 时触发慢调用</span></span><br><span class="line">        Thread.sleep(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置熔断规则，下面，给 feign 接口设置降级规则：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.cnbag9i3h2w.png" alt="image"></p><p>超过 50ms 的请求都会被认为是慢请求</p><h4 id="异常比例、异常数"><a class="header-anchor" href="#异常比例、异常数"></a>异常比例、异常数</h4><p>异常比例或异常数：统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值（或超过指定异常数），则触发熔断。</p><p>例如，一个异常比例设置：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.62u0t9cfx4c0.png" alt="image"></p><p>解读：统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 0.4，则触发熔断。</p><p>一个异常数设置：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5l93gd0ccps0.png" alt="image"></p><p>解读：统计最近 1000ms 内的请求，如果请求量超过 10 次，并且异常比例不低于 2 次，则触发熔断。</p><p>案例需求：给 UserClient 的查询用户接口设置降级规则，统计时间为 1 秒，最小请求数量为 5，失败阈值比例为 0.4，熔断时长为 5s</p><p>设置异常请求，首先，修改 user-service 中的 /user/{id} 这个接口的业务。手动抛出异常，以触发异常比例的熔断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// id 为 1 时触发慢调用</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;故意出错，触发熔断&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置熔断规则，下面给 feign 接口设置降级规则：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.ovuaoitoy0w.png" alt="image"></p><p>在 5 次请求中，只要异常比例超过 0.4，也就是有 2 次以上的异常，就会触发熔断。</p><h2 id="授权规则"><a class="header-anchor" href="#授权规则"></a>授权规则</h2><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是 flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p><h3 id="基本规则"><a class="header-anchor" href="#基本规则"></a>基本规则</h3><p>授权规则可以对调用方的来源做控制，有白名单和黑名单两种方式。</p><ul><li><p>白名单：来源（origin）在白名单内的调用者允许访问</p></li><li><p>黑名单：来源（origin）在黑名单内的调用者不允许访问</p></li></ul><p>点击左侧菜单的授权，可以看到授权规则：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1dwl90cub8zk.png" alt="image"></p><ul><li><p>资源名：就是受保护的资源，例如 /order/{orderId}</p></li><li><p>流控应用：是来源者的名单，</p><ul><li>如果是勾选白名单，则名单中的来源被许可访问。</li><li>如果是勾选黑名单，则名单中的来源被禁止访问。</li></ul></li></ul><p>我们允许请求从 gateway 到 order-service，不允许浏览器访问 order-service，那么白名单中就要填写网关的来源名称（origin）。</p><h3 id="如何获取-origin"><a class="header-anchor" href="#如何获取-origin"></a>如何获取 origin</h3><p>Sentinel 是通过 <code>RequestOriginParser</code> 这个接口的 <code>parseOrigin</code> 来获取请求的来源的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestOriginParser</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从请求request对象中获取origin，获取方式自定义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">parseOrigin</span><span class="params">(HttpServletRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用就是从 request 对象中，获取请求者的 origin 值并返回。</p><p>默认情况下，sentinel 不管请求者从哪里来，返回值永远是 default，也就是说一切请求的来源都被认为是一样的值 default。</p><p>因此，我们需要自定义这个接口的实现，让不同的请求，返回不同的 origin。</p><p>例如 order-service 服务中，我们定义一个 <code>RequestOriginParser</code> 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderOriginParser</span> <span class="keyword">implements</span> <span class="title">RequestOriginParser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseOrigin</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头</span></span><br><span class="line">        String origin = request.getHeader(<span class="string">&quot;origin&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(origin)) &#123;</span><br><span class="line">            origin = <span class="string">&quot;blank&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会尝试从 request-header 中获取 origin 值。</p><h3 id="给网关添加请求头"><a class="header-anchor" href="#给网关添加请求头"></a>给网关添加请求头</h3><p>既然获取请求 origin 的方式是从 reques-header 中获取 origin 值，我们必须让所有从 gateway 路由到微服务的请求都带上origin头。</p><p>这个需要利用之前学习的一个 GatewayFilter 来实现，<code>AddRequestHeaderGatewayFilter</code>。</p><p>修改 gateway 服务中的 application.yml，添加一个 defaultFilter：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=origin,gateway</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">       <span class="comment"># ...略</span></span><br></pre></td></tr></table></figure><p>这样，从 gateway 路由的所有请求都会带上 origin 头，值为 gateway。而从其它地方到达微服务的请求则没有这个头。</p><h3 id="配置授权规则"><a class="header-anchor" href="#配置授权规则"></a>配置授权规则</h3><p>接下来，我们添加一个授权规则，放行 origin 值为 gateway 的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.422hi4klpiq0.png" alt="image"></p><h3 id="自定义异常结果"><a class="header-anchor" href="#自定义异常结果"></a>自定义异常结果</h3><p>默认情况下，发生限流、降级、授权拦截时，都会抛出异常到调用方。异常结果都是 flow limmiting（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。</p><h4 id="异常类型"><a class="header-anchor" href="#异常类型"></a>异常类型</h4><p>而如果要自定义异常时的返回结果，需要实现 <code>BlockExceptionHandler</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有三个参数：</p><ul><li><code>HttpServletRequest request</code>：request 对象</li><li><code>HttpServletResponse response</code>：response 对象</li><li><code>BlockException e</code>：被 sentinel 拦截时抛出的异常</li></ul><p>这里的 <code>BlockException</code> 包含多个不同的子类：</p><table><thead><tr><th>异常</th><th>说明</th></tr></thead><tbody><tr><td><code>FlowException</code></td><td>限流异常</td></tr><tr><td><code>ParamFlowException</code></td><td>热点参数限流的异常</td></tr><tr><td><code>DegradeException</code></td><td>降级异常</td></tr><tr><td><code>AuthorityException</code></td><td>授权规则异常</td></tr><tr><td><code>SystemBlockException</code></td><td>系统规则异常</td></tr></tbody></table><h4 id="自定义异常处理"><a class="header-anchor" href="#自定义异常处理"></a>自定义异常处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelExceptionHandler</span> <span class="keyword">implements</span> <span class="title">BlockExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;未知异常&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">429</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">            status = <span class="number">401</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setStatus(status);</span><br><span class="line">        response.getWriter().println(<span class="string">&quot;&#123;\&quot;msg\&quot;: &quot;</span> + msg + <span class="string">&quot;, \&quot;status\&quot;: &quot;</span> + status + <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启测试，在不同场景下，会返回不同的异常消息。</p><h2 id="规则持久化"><a class="header-anchor" href="#规则持久化"></a>规则持久化</h2><p>现在，sentinel 的所有规则都是内存存储，重启后所有规则都会丢失。在生产环境下，我们必须确保这些规则的持久化，避免丢失。</p><h3 id="规则管理模式"><a class="header-anchor" href="#规则管理模式"></a>规则管理模式</h3><p>规则是否能持久化，取决于规则管理模式，Sentinel 支持三种规则管理模式：</p><ul><li>原始模式：Sentinel 的默认模式，将规则保存在内存，重启服务会丢失。</li><li>pull 模式</li><li>push 模式</li></ul><h4 id="pull-模式"><a class="header-anchor" href="#pull-模式"></a>pull 模式</h4><p>pull 模式：控制台将配置的规则推送到 Sentinel 客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5260ibjzz300.png" alt="image"></p><p>存在时效性问题，客户端之间规则不统一</p><h4 id="push-模式"><a class="header-anchor" href="#push-模式"></a>push 模式</h4><p>push 模式：控制台将配置规则推送到远程配置中心，例如 Nacos。Sentinel 客户端监听 Nacos，获取配置变更的推送消息，完成本地配置更新。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3xqps4wiyim0.png" alt="image"></p><h3 id="实现-push-模式"><a class="header-anchor" href="#实现-push-模式"></a>实现 push 模式</h3><h4 id="修改-order-service-服务"><a class="header-anchor" href="#修改-order-service-服务"></a>修改 order-service 服务</h4><p>引入依赖，在 order-service 中引入 sentinel 监听 nacos 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 nacos 地址，在 order-service 中的 application.yml 文件配置 nacos 地址及监听的配置信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">halo:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">orderservice-flow-rules</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">SENTINEL_GROUP</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> <span class="comment"># 还可以是：degrade、authority、param-flow</span></span><br></pre></td></tr></table></figure><h4 id="修改-sentinel-dashboard-源码"><a class="header-anchor" href="#修改-sentinel-dashboard-源码"></a>修改 sentinel-dashboard 源码</h4><p>修改完成后，重新打包运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dnacos.addr=halo:8848 -DServer.port=8090 sentinel-dashboard.jar</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识-Sentinel&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#初识-Sentinel&quot;&gt;&lt;/a&gt;初识 Sentinel&lt;/h2&gt;
&lt;h3 id=&quot;雪崩问题及解决方案&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#雪崩</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ElasticaSeach 入门</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/E_Elasticsearch%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/E_Elasticsearch%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.821Z</published>
    <updated>2021-09-20T06:00:59.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识-ElasticSearch"><a class="header-anchor" href="#初识-ElasticSearch"></a>初识 ElasticSearch</h2><h3 id="了解-ElasticSearch"><a class="header-anchor" href="#了解-ElasticSearch"></a>了解 ElasticSearch</h3><h4 id="ElasticSearch-的作用"><a class="header-anchor" href="#ElasticSearch-的作用"></a>ElasticSearch 的作用</h4><p>ElasticSearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p><h4 id="ELK-技术栈"><a class="header-anchor" href="#ELK-技术栈"></a>ELK 技术栈</h4><p>ElasticSearch 结合 Kibana、Logstash、Beats，也就是 Elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。</p><h4 id="ElasticSearch-和-Lucene"><a class="header-anchor" href="#ElasticSearch-和-Lucene"></a>ElasticSearch 和 Lucene</h4><p>ElasticSearch 底层是基于 Lucene 来实现的。</p><p>Lucene 是一个 Java 语言的搜索引擎类库，是 Apache 公司的顶级项目，由 DougCutting 于 1999 年研发。</p><p>Lucene 官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p>Lucene 的优势：易扩展、高性能（基于倒排索引）</p><p>Lucene 的缺点：只限于 Java 语言开发、学习曲线陡峭、不支持水平扩展</p><p>ElasticSearch 的发展历史：</p><ul><li>2004 年 Shay Banon 基于 Lucene 开发了 Compass</li><li>2010 年 Shay Banon 重写了 Compass，取名为 ElasticSearch。</li></ul><p>ElasticSearch 官网地址: <a href="https://www.elastic.co/cn/">https://www.elastic.co/cn/</a></p><p>相比与 Lucene ，ElasticSearch 具备下列优势：</p><ul><li>支持分布式，可水平扩展</li><li>提供 Restful 接口，可被任何语言调用</li></ul><h3 id="倒排索引"><a class="header-anchor" href="#倒排索引"></a>倒排索引</h3><p>倒排索引的概念是基于 MySQL 这样的正向索引而言的。</p><h4 id="正向索引"><a class="header-anchor" href="#正向索引"></a>正向索引</h4><p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p><ol><li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li><li>逐行获取数据，比如 id 为 1 的数据</li><li>判断数据中的 title 是否符合用户搜索条件</li><li>如果符合则放入结果集，不符合则丢弃。回到步骤 1</li></ol><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h4 id="倒排索引-v2"><a class="header-anchor" href="#倒排索引-v2"></a>倒排索引</h4><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p>创建倒排索引是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li></ul><p>如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5jp2imzxno00.png" alt="image"></p><p>倒排索引的搜索流程如下（以搜索“华为手机”为例）：</p><ol><li>用户输入条件 <code>&quot;华为手机&quot;</code> 进行搜索。</li><li>对用户输入内容分词，得到词条：<code>华为</code>、<code>手机</code>。</li><li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id：1、2、3。</li><li>拿着文档 id 到正向索引中查找具体文档。</li></ol><p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档 id 都建立了索引，查询速度非常快！无需全表扫描。</p><h4 id="正向和倒排"><a class="header-anchor" href="#正向和倒排"></a>正向和倒排</h4><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><p>正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。</p></li><li><p>倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的 id，然后根据 id 获取文档。是根据词条找文档的过程。</p></li></ul><p>正向索引</p><ul><li>优点：可以给多个字段创建索引、根据索引字段搜索、排序速度非常快</li></ul><ul><li>缺点：根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul><p>倒排索引：</p><ul><li>优点：根据词条搜索、模糊搜索时，速度非常快</li><li>缺点：只能给词条创建索引，而不是字段、无法根据字段做排序</li></ul><h3 id="ElasticSearch-中的一些概念"><a class="header-anchor" href="#ElasticSearch-中的一些概念"></a>ElasticSearch 中的一些概念</h3><p>ElasticSearch 中有很多独有的概念，与 MySQL 中略有差别，但也有相似之处。</p><h4 id="文档和字段"><a class="header-anchor" href="#文档和字段"></a>文档和字段</h4><p>ElasticSearch 是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 JSON 格式后存储在 ElasticSearch 中：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.lwpnpfcxvds.png" alt="image"></p><p>而 JSON 文档中往往包含很多的字段（Field），类似于数据库中的列。</p><h4 id="索引和映射"><a class="header-anchor" href="#索引和映射"></a>索引和映射</h4><p>索引（Index），就是相同类型的文档的集合。例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%B4%A2%E5%BC%95.67l5ib0vvgo0.svg" alt="索引"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。</p><h4 id="MySQL-与-ElasticSearch"><a class="header-anchor" href="#MySQL-与-ElasticSearch"></a>MySQL 与 ElasticSearch</h4><p>我们统一的把 MySQL 与 ElasticSearch 的概念做一下对比：</p><table><thead><tr><th>MySQL</th><th>Elasticsearch</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引（index），就是文档的集合，类似数据库的表（table）</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是 JSON 文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是 ElasticSearch 提供的 JSON 风格的请求语句，用来操作 ElasticSearch，实现 CRUD</td></tr></tbody></table><ul><li><p>MySQL ：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>ElasticSearch：擅长海量数据的搜索、分析、计算</p></li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用 MySQL 实现</li><li>对查询性能要求较高的搜索需求，使用 ElasticSearch 实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ElasticSearch.4koj7qwgqge0.svg" alt="ElasticSearch"></p><h3 id="安装-ElasticSearch-、Kibana"><a class="header-anchor" href="#安装-ElasticSearch-、Kibana"></a>安装 ElasticSearch 、Kibana</h3><h4 id="创建网络"><a class="header-anchor" href="#创建网络"></a>创建网络</h4><p>因为我们还需要部署 Kibana 容器，因此需要让 ElasticSearch 和 Kibana 容器互联。这里先创建一个网络：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create halo-es-net</span><br></pre></td></tr></table></figure><h4 id="拉取或加载镜像"><a class="header-anchor" href="#拉取或加载镜像"></a>拉取或加载镜像</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.14.1</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kibana:7.14.1</span><br></pre></td></tr></table></figure><h4 id="运行（单点）"><a class="header-anchor" href="#运行（单点）"></a>运行（单点）</h4><p>运行 docker 命令，部署单点 ElasticSearch ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name halo-es \</span><br><span class="line">    -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">    -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">    -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    --privileged \</span><br><span class="line">    --network halo-es-net \</span><br><span class="line">    -p 9200:9200 \</span><br><span class="line">    -p 9300:9300 \</span><br><span class="line">elasticsearch:7.14.1</span><br></pre></td></tr></table></figure><p>命令解释：</p><ul><li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li><li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定 ElasticSearch 的数据目录</li><li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定 ElasticSearch 的日志目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定 ElasticSearch 的插件目录</li><li><code>--privileged</code>：授予逻辑卷访问权</li><li><code>--network halo-es-net</code> ：加入一个名为 halo-es-net 的网络中</li><li><code>-p 9200:9200</code>：端口映射配置</li></ul><p>在浏览器中输入：<a href="http://halo:9200">http://halo:9200</a> 即可看到 ElasticSearch 的响应结果：</p><p>运行 docker 命令，部署 Kibana</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name halo-kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://halo-es:9200 \</span><br><span class="line">--network halo-es-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.14.1</span><br></pre></td></tr></table></figure><ul><li><code>--network es-net</code> ：加入一个名为es-net的网络中，与 elasticsearch 在同一个网络中</li><li><code>-e ELASTICSEARCH_HOSTS=http://halo-es:9200&quot;</code>：设置 elasticsearch 的地址，因为 kibana 已经与elasticsearch 在一个网络，因此可以用容器名（halo-es）直接访问 elasticsearch</li><li><code>-p 5601:5601</code>：端口映射配置</li></ul><p>kibana 启动一般比较慢，需要多等待一会，可以通过命令查看日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f kibana</span><br></pre></td></tr></table></figure><p>在浏览器输入地址访问：<a href="http://halo:5601">http://halo:5601</a>，即可看到结果</p><h3 id="安装-IK-分词器"><a class="header-anchor" href="#安装-IK-分词器"></a>安装 IK 分词器</h3><p>ElasticSearch 在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。</p><p>我们在 Kibana 的 DevTools 中测试：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;你好,世界! Hello,World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法说明：</p><ul><li>POST：请求方式</li><li>/_analyze：请求路径，这里省略了 <a href="http://halo:9200">http://halo:9200</a>，有 kibana 帮我们补充</li><li>请求参数，JSON 风格：<code>analyzer</code>：分词器类型，这里是默认的 standard 分词器；<code>text</code>：要分词的内容</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;你&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;好&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;世&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;界&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;IDEOGRAPHIC&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">12</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;world&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">13</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">18</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;&lt;ALPHANUM&gt;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理中文分词，一般会使用 IK 分词器。<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p><h4 id="在线安装-IK-插件"><a class="header-anchor" href="#在线安装-IK-插件"></a>在线安装 IK 插件</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it elasticsearch /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在线下载并安装</span></span><br><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.1/elasticsearch-analysis-ik-7.14.1.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><h4 id="离线安装-IK-插件"><a class="header-anchor" href="#离线安装-IK-插件"></a>离线安装 IK 插件</h4><p>查看数据卷目录</p><p>安装插件需要知道 elasticsearch 的 plugins 目录位置，而我们用了数据卷挂载，因此需要查看 elasticsearch 的数据卷目录，通过下面命令查看:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect es-plugins</span><br></pre></td></tr></table></figure><p>显示结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2021-09-11T12:50:57+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;es-plugins&#x2F;_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;es-plugins&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>说明 plugins 目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code> 这个目录中。</p><p>将 ik 分词器解压缩，重命名为 ik，上传到 es 容器的插件数据卷中后重启容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart halo-es</span><br></pre></td></tr></table></figure><h4 id="测试分词器"><a class="header-anchor" href="#测试分词器"></a>测试分词器</h4><p>IK 分词器包含两种模式：</p><ul><li><p><code>ik_smart</code> ：最少切分，粗粒度</p></li><li><p><code>ik_max_word</code> ：最细切分，细粒度</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;你好,我的世界! Hello,World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;我&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;的&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;世界&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">9</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ENGLISH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;world&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">20</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ENGLISH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扩展和停用词词典"><a class="header-anchor" href="#扩展和停用词词典"></a>扩展和停用词词典</h4><p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。</p><p>所以我们的词汇也需要不断的更新，IK 分词器提供了扩展词汇的功能。</p><p>打开 IK 分词器 config 目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/es-plugins/_data/ik/config</span><br></pre></td></tr></table></figure><p>在 IKAnalyzer.cfg.xml 配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">properties</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>stopwort.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新建一个 ext.dic，可以参考 config 目录下复制一个配置文件进行修改</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">我的世界</span></span><br></pre></td></tr></table></figure><p>stopwort.dic 添加</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">的</span></span><br></pre></td></tr></table></figure><p>重启 ElasticSearch</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><p>日志中已经成功加载 ext.dic 配置文件</p><p>测试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;你好,我的世界! Hello,World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;你好&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;我的世界&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">3</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;世界&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">7</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">9</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">14</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ENGLISH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;world&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">15</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">20</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;ENGLISH&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意当前文件的编码必须是 UTF-8 格式，严禁使用 Windows 记事本编辑</p></blockquote><h2 id="DSL-索引库操作"><a class="header-anchor" href="#DSL-索引库操作"></a>DSL 索引库操作</h2><p>索引库就类似数据库表，mapping 映射就类似表的结构。我们要向 es 中存储数据，必须先创建“库”和“表”。</p><h3 id="mapping-映射属性"><a class="header-anchor" href="#mapping-映射属性"></a>mapping 映射属性</h3><p>mapping 是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip 地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为 true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的 JSON 文档：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">&quot;weight&quot;</span>: <span class="number">52.1</span>,</span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;score&quot;</span>: [<span class="number">99.1</span>, <span class="number">99.5</span>, <span class="number">98.9</span>],</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要 index 为 true；无需分词器</li><li>weight：类型为 float；参与搜索，因此需要 index 为 true；无需分词器</li><li>isMarried：类型为 boolean；参与搜索，因此需要 index 为 true；无需分词器</li><li>info：类型为字符串，需要分词，因此是 text；参与搜索，因此需要 index 为 true；分词器可以用 ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，因此需要 index 为 false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为 float；参与搜索，因此需要 index 为 true；无需分词器</li><li>name：类型为 object，需要定义多个子属性<ul><li>name.firstName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器</li><li>name.lastName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器</li></ul></li></ul><h3 id="索引库的-CRUD"><a class="header-anchor" href="#索引库的-CRUD"></a>索引库的 CRUD</h3><p>这里统一使用 Kibana 编写 DSL 的方式来演示。</p><h4 id="创建索引库和映射"><a class="header-anchor" href="#创建索引库和映射"></a>创建索引库和映射</h4><p>基本语法：</p><ul><li>请求方式：PUT</li><li>请求路径：/索引库名，可以自定义</li><li>请求参数：mapping 映射</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /heima</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;info&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;email&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="string">&quot;falsae&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ... 略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查询索引库"><a class="header-anchor" href="#查询索引库"></a>查询索引库</h4><p>基本语法：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;索引库名</span><br></pre></td></tr></table></figure><h4 id="删除索引库"><a class="header-anchor" href="#删除索引库"></a>删除索引库</h4><p>语法：</p><ul><li><p>请求方式：DELETE</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;索引库名</span><br></pre></td></tr></table></figure><h4 id="修改索引库"><a class="header-anchor" href="#修改索引库"></a>修改索引库</h4><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改 mapping。</p><p>虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，因为不会对倒排索引产生影响。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引库的-CRUD-小结"><a class="header-anchor" href="#索引库的-CRUD-小结"></a>索引库的 CRUD 小结</h4><ul><li>创建索引库：PUT /索引库名</li><li>查询索引库：GET /索引库名</li><li>删除索引库：DELETE /索引库名</li><li>添加字段：PUT /索引库名/_mapping</li></ul><h2 id="DSL-文档操作"><a class="header-anchor" href="#DSL-文档操作"></a>DSL 文档操作</h2><h3 id="新增文档"><a class="header-anchor" href="#新增文档"></a>新增文档</h3><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span>: <span class="string">&quot;值3&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span>: <span class="string">&quot;值4&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /halo/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员Java讲师&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a class="header-anchor" href="#查询文档"></a>查询文档</h3><p>根据 rest 风格，新增是 post，查询应该是 get，不过查询一般都需要条件，这里我们把文档 id 带上。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引库名称&#125;&#x2F;_doc&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure><p>通过 kibana 查看数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;halo&#x2F;_doc&#x2F;1</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a class="header-anchor" href="#删除文档"></a>删除文档</h3><p>删除使用 DELETE 请求，同样，需要根据 id 进行删除：</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;&#123;索引库名&#125;&#x2F;_doc&#x2F;id值</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;halo&#x2F;_doc&#x2F;1</span><br></pre></td></tr></table></figure><h3 id="修改文档"><a class="header-anchor" href="#修改文档"></a>修改文档</h3><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h4 id="全量修改"><a class="header-anchor" href="#全量修改"></a>全量修改</h4><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的 id 删除文档</li><li>新增一个相同 id 的文档</li></ul><blockquote><p>注意：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p></blockquote><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /&#123;索引库名&#125;/_doc/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span>: <span class="string">&quot;值1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span>: <span class="string">&quot;值2&quot;</span>,</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /halo/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;黑马程序员高级Java讲师2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span>: <span class="string">&quot;zy@itcast.cn&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;firstName&quot;</span>: <span class="string">&quot;云&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastName&quot;</span>: <span class="string">&quot;赵&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增量修改"><a class="header-anchor" href="#增量修改"></a>增量修改</h4><p>增量修改是只修改指定 id 匹配的文档中的部分字段。</p><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_update/文档id</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;doc&quot;</span>: &#123;</span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span>: <span class="string">&quot;新的值&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;halo&#x2F;_update&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档操作总结"><a class="header-anchor" href="#文档操作总结"></a>文档操作总结</h3><ul><li>创建文档：POST /{索引库名}/_doc/文档id   { JSON 文档 }</li><li>查询文档：GET /{索引库名}/_doc/文档id</li><li>删除文档：DELETE /{索引库名}/_doc/文档id</li><li>修改文档：<ul><li>全量修改：PUT /{索引库名}/_doc/文档id { JSON 文档 }</li><li>增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}}</li></ul></li></ul><h2 id="Rest-Client-索引库操作"><a class="header-anchor" href="#Rest-Client-索引库操作"></a>Rest Client 索引库操作</h2><p>ElasticSearch 官方提供了各种不同语言的客户端，用来操作 ElasticSearch。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ElasticSearch。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的 Java Rest Client 又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p>我们学习的是 Java HighLevel Rest Client 客户端 API</p><h3 id="创建测试环境"><a class="header-anchor" href="#创建测试环境"></a>创建测试环境</h3><h4 id="初始化项目"><a class="header-anchor" href="#初始化项目"></a>初始化项目</h4><p>创建数据库，建立数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_hotel`  (</span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店id&#x27;</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店名称&#x27;</span>,</span><br><span class="line">    `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店地址&#x27;</span>,</span><br><span class="line">    `price` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店价格&#x27;</span>,</span><br><span class="line">    `score` <span class="type">int</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店评分&#x27;</span>,</span><br><span class="line">    `brand` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店品牌&#x27;</span>,</span><br><span class="line">    `city` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;所在城市&#x27;</span>,</span><br><span class="line">    `star_name` <span class="type">varchar</span>(<span class="number">16</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店星级，1星到5星，1钻到5钻&#x27;</span>,</span><br><span class="line">    `business` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商圈&#x27;</span>,</span><br><span class="line">    `latitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;纬度&#x27;</span>,</span><br><span class="line">    `longitude` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;经度&#x27;</span>,</span><br><span class="line">    `pic` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;酒店图片&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8mb4 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="operator">=</span> Compact;</span><br></pre></td></tr></table></figure><p>导入数据库数据：<a href="https://github.com/Lanqilu/HaloElasticSearch/blob/master/doc/database/tb_hotel.sql">链接</a></p><p>初始项目代码：<a href="https://github.com/Lanqilu/HaloElasticSearch/commit/d64b305ccf9ca67b8a18bafee3df7163e7dd8246">链接</a></p><h4 id="mapping-映射分析"><a class="header-anchor" href="#mapping-映射分析"></a>mapping 映射分析</h4><p>创建索引库，最关键的是 mapping 映射，而 mapping 映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用 ik_max_word</li></ul><p>来看下酒店数据的索引库结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;score&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;brand&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;starName&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;business&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;pic&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用 copy_to 合并，提供给用户搜索</li></ul><p>ES 中支持两种地理坐标数据类型：</p><p>•geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：“32.8752345, 120.2981576”</p><p>•geo_shape：有多个geo_point组成的复杂几何图形。例如一条直线，“LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</p><p>字段拷贝可以使用 copy_to 属性将当前字段拷贝到指定字段。示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;all&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;brand&quot;: &#123;</span><br><span class="line">  &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">  &quot;copy_to&quot;: &quot;all&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-RestClient"><a class="header-anchor" href="#初始化-RestClient"></a>初始化 RestClient</h4><p>在 ElasticSearch 提供的 API 中，与 ElasticSearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 ElasticSearch 的连接。</p><p>分为三步：</p><p>① 引入 ElasticSearch 的 RestHighLevelClient 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 因为 SpringBoot 默认的 ElasticSearch 版本是 7.6.2，所以我们需要覆盖默认的 ElasticSearch 版本，与 ElasticSearch 版本保持一致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.14.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>③ 初始化 RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class="string">&quot;http://halo:9200&quot;</span>)));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelIndexTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client = &quot;</span> + client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class="string">&quot;http://halo:9200&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建索引库"><a class="header-anchor" href="#创建索引库"></a>创建索引库</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.zlx2xrhd54w.png" alt="image"></p><p>代码分为三步：</p><ol><li>创建 Request 对象。因为是创建索引库的操作，因此 Request 是 CreateIndexRequest</li><li>添加请求参数，其实就是 DSL 的 JSON 参数部分。因为 JSON 字符串很长，这里是定义了静态字符串常量 MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>发送请求，<code>client.indices()</code> 方法的返回值是 IndicesClient 类型，封装了所有与索引库操作有关的方法。</li></ol><p>在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除索引库-v2"><a class="header-anchor" href="#删除索引库-v2"></a>删除索引库</h3><p>删除索引库的 DSL 语句非常简单：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel</span><br></pre></td></tr></table></figure><p>与创建索引库相比：</p><ul><li>请求方式从 PUT 变为 DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在 Request 对象上。依然是三步走：</p><ul><li>创建 Request 对象。这次是 DeleteIndexRequest 对象</li><li>准备参数。这里是无参</li><li>发送请求。改用 delete 方法</li></ul><p>在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断索引库是否存在"><a class="header-anchor" href="#判断索引库是否存在"></a>判断索引库是否存在</h3><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的 Java 代码流程是类似的。依然是三步走：</p><ul><li>创建 Request 对象。这次是 GetIndexRequest 对象</li><li>准备参数。这里是无参</li><li>发送请求。改用 exists 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RestAPI-小结"><a class="header-anchor" href="#RestAPI-小结"></a>RestAPI 小结</h3><p>JavaRestClient 操作 ElasticSearch 的流程基本类似。核心是 <code>client.indices()</code> 方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化 RestHighLevelClient</li><li>创建 XxxIndexRequest。Xxx 是Create、Get、Delete</li><li>准备 DSL（ Create时需要，其它是无参）</li><li>发送请求。调用 <code>RestHighLevelClient#indices().xxx()</code> 方法，xxx 是  create、exists、delete</li></ul><h2 id="Rest-Client-文档操作"><a class="header-anchor" href="#Rest-Client-文档操作"></a>Rest Client 文档操作</h2><p>去数据库查询酒店数据，导入到 hotel 索引库，实现酒店数据的 CRUD。基本步骤如下：</p><ul><li>初始化 JavaRestClient</li><li>利用 JavaRestClient 新增酒店数据</li><li>利用 JavaRestClient 根据id查询酒店数据</li><li>利用 JavaRestClient 删除酒店数据</li><li>利用 JavaRestClient 修改酒店数据</li></ul><h3 id="初始化-JavaRestClient"><a class="header-anchor" href="#初始化-JavaRestClient"></a>初始化 JavaRestClient</h3><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p><ul><li>初始化 RestHighLevelClient，同上</li><li>我们的酒店数据在数据库，需要利用 IHotelService 去查询，所以注入这个接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDocumentTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class="string">&quot;http://halo:9200&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增文档-v2"><a class="header-anchor" href="#新增文档-v2"></a>新增文档</h3><p>我们要将数据库的酒店数据查询出来，写入 ElasticSearch 中。</p><h4 id="索引库实体类"><a class="header-anchor" href="#索引库实体类"></a>索引库实体类</h4><p>数据库查询后的结果是一个 Hotel 类型的对象。结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;tb_hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hotel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String longitude;</span><br><span class="line">    <span class="keyword">private</span> String latitude;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude 和 latitude 需要合并为 location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="语法说明"><a class="header-anchor" href="#语法说明"></a>语法说明</h4><p>新增文档的 DSL 语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /&#123;索引库名&#125;/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 Java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testIndexDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;indexName&quot;</span>).id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备JSON文档</span></span><br><span class="line">    request.source(<span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;Jack\&quot;, \&quot;age\&quot;: 21&#125;&quot;</span>, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>创建 Request 对象</li><li>准备请求参数，也就是 DSL 中的 JSON 文档</li><li>发送请求</li></ul><p>变化的地方在于，这里直接使用 <code>client.xxx()</code> 的 API，不再需要 <code>client.indices()</code> 了。</p><h4 id="完整代码"><a class="header-anchor" href="#完整代码"></a>完整代码</h4><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到 Hotel 对象</li><li>Hotel 对象需要转为 HotelDoc对象</li><li>HotelDoc 需要序列化为 JSON 格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>根据 id 查询酒店数据 Hotel</li><li>将 Hotel 封装为 HotelDoc</li><li>将 HotelDoc 序列化为 JSON</li><li>创建 IndexRequest，指定索引库名和 id</li><li>准备请求参数，也就是 JSON 文档</li><li>发送请求</li></ul><p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询酒店数据</span></span><br><span class="line">    Hotel hotel = hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line">    <span class="comment">// 3.将HotelDoc转json</span></span><br><span class="line">    String json = JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>).id(hotelDoc.getId().toString());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档-v2"><a class="header-anchor" href="#查询文档-v2"></a>查询文档</h3><h4 id="语法说明-v2"><a class="header-anchor" href="#语法说明-v2"></a>语法说明</h4><p>查询的 DSL 语句如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备 Request 对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为 HotelDoc，因此难点是结果的解析。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">&quot;indexName&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到结果</span></span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析结果</span></span><br><span class="line">    String json = response.getSourceAsString();</span><br><span class="line">    System.out.println(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，结果是一个 JSON，其中文档放在一个 <code>_source</code> 属性中，因此解析就是拿到 <code>_source</code>，反序列化为 Java 对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>准备 Request 对象。这次是查询，所以是 GetRequest</li><li>发送请求，得到结果。因为是查询，这里调用 <code>client.get()</code> 方法</li><li>解析结果，就是对 JSON 做反序列化</li></ul><h4 id="完整代码-v2"><a class="header-anchor" href="#完整代码-v2"></a>完整代码</h4><p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    GetResponse response = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果</span></span><br><span class="line">    String json = response.getSourceAsString();</span><br><span class="line">    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档-v2"><a class="header-anchor" href="#修改文档-v2"></a>修改文档</h3><h4 id="语法说明-v3"><a class="header-anchor" href="#语法说明-v3"></a>语法说明</h4><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID：</p><ul><li>如果新增时，ID 已经存在，则修改</li><li>如果新增时，ID 不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建request对象</span></span><br><span class="line">    UpdateRequest request = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;indexName&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备参数，每2个参数为一对 key value    </span></span><br><span class="line">    request.doc(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.更新文档</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前类似，也是三步走：</p><ul><li>准备 Request 对象。这次是修改，所以是 UpdateRequest</li><li>准备参数。也就是 JSON 文档，里面包含要修改的字段</li><li>更新文档。这里调用 <code>client.update()</code> 方法</li></ul><h4 id="完整代码-v3"><a class="header-anchor" href="#完整代码-v3"></a>完整代码</h4><p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    UpdateRequest request = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">&quot;price&quot;</span>, <span class="string">&quot;952&quot;</span>,</span><br><span class="line">        <span class="string">&quot;starName&quot;</span>, <span class="string">&quot;四钻&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档-v2"><a class="header-anchor" href="#删除文档-v2"></a>删除文档</h3><p>删除的 DSL 为是这样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel/_doc/&#123;id&#125;</span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从 DELETE 变成 GET，可以想象 Java 代码应该依然是三步走：</p><ul><li>准备 Request 对象，因为是删除，这次是 DeleteRequest 对象。要指定索引库名和 id</li><li>准备参数，无参</li><li>发送请求。因为是删除，所以是 <code>client.delete()</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;hotel&quot;</span>, <span class="string">&quot;61083&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="批量导入文档"><a class="header-anchor" href="#批量导入文档"></a>批量导入文档</h3><p>案例需求：利用 BulkRequest 批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li><p>利用 mybatis-plus 查询酒店数据</p></li><li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p></li><li><p>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</p></li></ul><h4 id="语法说明-v4"><a class="header-anchor" href="#语法说明-v4"></a>语法说明</h4><p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p><p>其中提供了一个 add 方法，用来添加其他请求：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此 Bulk 中添加了多个 IndexRequest，就是批量新增功能了。示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Bulk请求</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="comment">// 2.添加要批量提交的请求：这里添加了两个新增文档的请求</span></span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;101&quot;</span>).source(<span class="string">&quot;json source&quot;</span>, XContentType.JSON));</span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                .id(<span class="string">&quot;102&quot;</span>).source(<span class="string">&quot;json source2&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="comment">// 3.发起bulk请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还是三步走：</p><ul><li>创建 Request 对象。这里是 BulkRequest</li><li>准备参数。批处理的参数，就是其它 Request 对象，这里就是多个 IndexRequest</li><li>发起请求。这里是批处理，调用的方法为 <code>client.bulk()</code> 方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成 for 循环处理即可。</p><h4 id="完整代码-v4"><a class="header-anchor" href="#完整代码-v4"></a>完整代码</h4><p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建 Request</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="comment">// 2.准备参数，添加多个新增的 Request</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : hotels) &#123;</span><br><span class="line">        <span class="comment">// 2.1.转换为文档类型 HotelDoc</span></span><br><span class="line">        HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line">        <span class="comment">// 2.2.创建新增文档的 Request 对象</span></span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>)</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，批量查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;hotel&#x2F;_search</span><br></pre></td></tr></table></figure><h3 id="Rest-Client-文档操作小结"><a class="header-anchor" href="#Rest-Client-文档操作小结"></a>Rest Client 文档操作小结</h3><p>文档操作的基本步骤：</p><ul><li>初始化 RestHighLevelClient</li><li>创建 XxxRequest。Xxx 是 Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用 <code>RestHighLevelClient#.xxx()</code> 方法，xxx 是 index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul><h2 id="DSL-查询文档"><a class="header-anchor" href="#DSL-查询文档"></a>DSL 查询文档</h2><p>ElasticSearch 的查询依然是基于 JSON 风格的 DSL 来实现的。</p><h3 id="DSL-查询分类"><a class="header-anchor" href="#DSL-查询分类"></a>DSL 查询分类</h3><p>ElasticSearch 提供了基于 JSON 的 DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p>查询所有：查询出所有数据，一般测试用。例如：match_all</p></li><li><p>全文检索查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p>精确查询：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p>地理（geo）查询：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;查询条件&quot;</span>: <span class="string">&quot;条件值&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为 match_all</li><li>没有查询条件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它查询无非就是查询类型、查询条件的变化。</p><h3 id="全文检索查询"><a class="header-anchor" href="#全文检索查询"></a>全文检索查询</h3><h4 id="使用场景"><a class="header-anchor" href="#使用场景"></a>使用场景</h4><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档 id</li><li>根据文档 id 找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的 text 类型的字段。</p><h4 id="基本语法"><a class="header-anchor" href="#基本语法"></a>基本语法</h4><p>常见的全文检索查询包括：</p><ul><li>match 查询：单字段查询</li><li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match 查询语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mulit_match 语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;TEXT&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;FIELD1&quot;</span>, <span class="string">&quot; FIELD12&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用示例"><a class="header-anchor" href="#使用示例"></a>使用示例</h4><p>match 查询示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>: <span class="string">&quot;如家外滩&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multi_match 查询示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;如家外滩&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;brand&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;business&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将 brand、name、business 值都利用 copy_to 复制到了 all 字段中。因此你根据三个字段搜索，和根据 all 字段搜索效果当然一样了。</p><p>但是，搜索字段越多，对查询性能影响越大，因此建议采用 copy_to，然后单字段查询的方式。</p><p>match 和 multi_match 的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h3 id="精准查询"><a class="header-anchor" href="#精准查询"></a>精准查询</h3><p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以不会对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h4 id="term-查询"><a class="header-anchor" href="#term-查询"></a>term 查询</h4><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;VALUE&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;上海&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;上海杭州&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="range-查询"><a class="header-anchor" href="#range-查询"></a>range 查询</h4><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">10</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">20</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>gte 代表大于等于，gt 则代表大于</li><li>lte 代表小于等于，lt 则代表小于</li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;gte&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">3000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="精准查询小结"><a class="header-anchor" href="#精准查询小结"></a>精准查询小结</h4><p>精确查询常见的有哪些？</p><ul><li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li><li>range 查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h3 id="地理坐标查询"><a class="header-anchor" href="#地理坐标查询"></a>地理坐标查询</h3><p>所谓的地理坐标查询，其实就是根据经纬度查询，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">官方文档</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><h4 id="矩形范围查询"><a class="header-anchor" href="#矩形范围查询"></a>矩形范围查询</h4><p>矩形范围查询，也就是 geo_bounding_box 查询，查询坐标落在某个矩形范围的所有文档：</p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_bounding_box&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;top_left&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">31.1</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.5</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;bottom_right&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">30.9</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.7</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附近查询"><a class="header-anchor" href="#附近查询"></a>附近查询</h4><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;15km&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;31.21,121.5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先搜索陆家嘴附近 15km 的酒店：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;2km&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>: <span class="string">&quot;31.21,121.5&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复合查询"><a class="header-anchor" href="#复合查询"></a>复合查询</h3><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h4 id="相关性算分"><a class="header-anchor" href="#相关性算分"></a>相关性算分</h4><p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">17.850193</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;虹桥如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">12.259849</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;外滩如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;_score&quot;</span> : <span class="number">11.91091</span>,</span><br><span class="line">    <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;迪士尼如家酒店真不错&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在 ElasticSearch 中，早期使用的打分算法是 <a href="https://www.ruanyifeng.com/blog/2013/03/tf-idf.html">TF-IDF 算法</a>，在后来的 5.1 版本升级中，ElasticSearch 将算法改进为 <a href="https://www.jianshu.com/p/1e498888f505">BM25 算法</a></p><p>TF-IDF 算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而 BM25 则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.32gad6dlyzu0.png" alt="image"></p><h4 id="算分函数查询"><a class="header-anchor" href="#算分函数查询"></a>算分函数查询</h4><p>根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。要想认为控制相关性算分，就需要利用 ElasticSearch 中的 function score 查询了。</p><p>语法说明：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%AE%97%E5%88%86%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2.epggagjz1ts.svg" alt="算分函数查询"></p><p>function score 查询中包含四部分内容：</p><ul><li>原始查询条件：query 部分，基于这个条件搜索文档，并且基于 BM25 算法给文档打分，原始算分（query score)</li><li>过滤条件：filter 部分，符合该条件的文档才会重新算分</li><li>算分函数：符合 filter 条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li>运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用 function score 替换 query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score 的运行流程如下：</p><ul><li>根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）</li><li>根据过滤条件，过滤文档</li><li>符合<strong>过滤条件</strong>的文档，基于算分函数运算，得到函数算分（function score）</li><li>将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><p>示例</p><p>需求：给“如家”这个品牌的酒店排名靠前一些。翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand = “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的 DSL 语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;all&quot;</span>: <span class="string">&quot;外滩&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;functions&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;weight&quot;</span>: <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;boost_mode&quot;</span>: <span class="string">&quot;sum&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔查询"><a class="header-anchor" href="#布尔查询"></a>布尔查询</h4><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，不参与算分</li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤。</p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool 查询了。</p><p>需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li><li>其它过滤条件，采用 filter 查询。不参与算分</li></ul><p>语法示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;上海&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;should&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;皇冠假日&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;华美达&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;lte&quot;</span>: <span class="number">500</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;score&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;gte&quot;</span>: <span class="number">45</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例示例：</p><p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到 must 中</li><li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分。放到 must_not 中</li><li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分。放到 filter 中</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;gt&quot;</span>: <span class="number">400</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;geo_distance&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;distance&quot;</span>: <span class="string">&quot;10km&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;location&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;lat&quot;</span>: <span class="number">31.21</span>,</span><br><span class="line">              <span class="attr">&quot;lon&quot;</span>: <span class="number">121.5</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bool 查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h2 id="DSL-搜索结果处理"><a class="header-anchor" href="#DSL-搜索结果处理"></a>DSL 搜索结果处理</h2><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h3 id="排序"><a class="header-anchor" href="#排序"></a>排序</h3><p>ElasticSearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等。</p><h4 id="普通字段排序"><a class="header-anchor" href="#普通字段排序"></a>普通字段排序</h4><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;desc&quot;</span>  <span class="comment">// 排序字段、排序方式ASC、DESC</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score）降序排序，评价相同的按照价格（price）升序排序</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;score&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="地理坐标排序"><a class="header-anchor" href="#地理坐标排序"></a>地理坐标排序</h4><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>, <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>, <span class="comment">// 排序方式</span></span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是 geo_point 类型）的坐标到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;location&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;lat&quot;</span>: <span class="number">31.034661</span>,</span><br><span class="line">          <span class="attr">&quot;lon&quot;</span>: <span class="number">121.612282</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;unit&quot;</span>: <span class="string">&quot;km&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页"><a class="header-anchor" href="#分页"></a>分页</h3><p>ElasticSearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。ElasticSearch中通过修改 from、size 参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于 MySQL 中的 <code>limit ?, ?</code></p><h4 id="基本的分页"><a class="header-anchor" href="#基本的分页"></a>基本的分页</h4><p>分页的基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: <span class="string">&quot;asc&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度分页问题"><a class="header-anchor" href="#深度分页问题"></a>深度分页问题</h4><p>现在，我要查询 990~1000 的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">990</span>, <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">10</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;<span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是查询 990 开始的数据，也就是 第 990~1000 条 数据。</p><p>不过，ElasticSearch 内部分页时，必须先查询 0~1000 条，然后截取其中的 990 ~ 1000 的这 10 条：</p><p>查询 top 1000，如果 ElasticSearch 是单点模式，这并无太大影响。</p><p>但是 ElasticSearch 将来一定是集群，例如我集群有 5 个节点，我要查询 top 1000 的数据，并不是每个节点查询 200 条就可以了。</p><p>因为节点 A 的 top 200，在另一个节点可能排到 10000 名以外了。</p><p>因此要想获取整个集群的 top 1000，必须先查询出每个节点的 top 1000，汇总结果后，重新排名，重新截取 top 1000。</p><p>那如果我要查询 9900~10000 的数据呢？是不是要先查询 top 10000呢？那每个节点都要查询 10000 条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和 CPU 会产生非常大的压力，因此 ElasticSearch 会禁止 from + size 超过 10000 的请求。</p><p>针对深度分页，ElasticSearch 提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档 id 形成快照，保存在内存。官方已经不推荐使用。</li></ul><h4 id="分页小结"><a class="header-anchor" href="#分页小结"></a>分页小结</h4><p>分页查询的常见实现方案以及优缺点：</p><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是 10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的 size 不超过 10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的 size 不超过 10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从 ES 7.1开始不推荐，建议用 after search 方案。</li></ul></li></ul><h3 id="高亮"><a class="header-anchor" href="#高亮"></a>高亮</h3><p>高亮显示的实现分为两步：</p><ul><li>给文档中的所有关键字都添加一个标签，例如 <code>&lt;em&gt;</code> 标签</li><li>页面给 <code>&lt;em&gt;</code> 标签编写 CSS 样式</li></ul><p>高亮的语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;TEXT&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。</li><li>默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性： <code>&quot;require_field_match&quot;: &quot;false&quot;</code></li></ul><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;require_field_match&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索结果处理小结"><a class="header-anchor" href="#搜索结果处理小结"></a>搜索结果处理小结</h3><p>查询的 DSL 是一个大的 JSON 对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from 和 size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>, <span class="comment">// 分页开始的位置</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">20</span>, <span class="comment">// 期望获取的文档总数</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [ </span><br><span class="line">    &#123;  <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span> &#125;, <span class="comment">// 普通排序</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123; <span class="comment">// 距离排序</span></span><br><span class="line">          <span class="attr">&quot;location&quot;</span> : <span class="string">&quot;31.040699,121.618075&quot;</span>, </span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123; <span class="comment">// 高亮字段</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span>: <span class="string">&quot;&lt;em&gt;&quot;</span>,  <span class="comment">// 用来标记高亮字段的前置标签</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span>: <span class="string">&quot;&lt;/em&gt;&quot;</span> <span class="comment">// 用来标记高亮字段的后置标签</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rest-Client-查询文档"><a class="header-anchor" href="#Rest-Client-查询文档"></a>Rest Client 查询文档</h2><p>文档的查询同样适用 RestHighLevelClient 对象，基本步骤包括：</p><ul><li>准备 Request 对象</li><li>准备请求参数</li><li>发起请求</li><li>解析响应</li></ul><h3 id="快速入门"><a class="header-anchor" href="#快速入门"></a>快速入门</h3><p>我们以 match_all 查询为例</p><h4 id="发起查询请求"><a class="header-anchor" href="#发起查询请求"></a>发起查询请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织DSL参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求，得到响应结果</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// ...解析响应结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><ul><li><p>第一步，创建 <code>SearchRequest</code> 对象，指定索引库名</p></li><li><p>第二步，利用 <code>request.source()</code> 构建 DSL，DSL 中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li></ul></li><li><p>第三步，利用 <code>client.search()</code> 发送请求，得到响应</p></li></ul><p>这里关键的 API 有两个：</p><ul><li>一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能。</li><li>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询：</li></ul><h4 id="解析响应"><a class="header-anchor" href="#解析响应"></a>解析响应</h4><p>ElasticSearch 返回的结果是一个 JSON 字符串，结构包含：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;took&quot;</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;heima&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;_score&quot;</span> : <span class="number">1.0</span>,</span><br><span class="line">        <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;info&quot;</span> : <span class="string">&quot;Java讲师&quot;</span>, <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;赵云&quot;</span>,</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的 value 是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个 JSON 对象<ul><li><code>_source</code>：文档中的原始数据，也是 JSON 对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// 4.解析结果</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.查询的总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.查询的结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 4.3.得到source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.4.打印</span></span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SearchHits</code>：通过 <code>response.getHits()</code> 获取，就是 JSON 中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取 SearchHit 数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的 JSON 文档数据</li></ul></li></ul></li></ul><h4 id="完整代码-v5"><a class="header-anchor" href="#完整代码-v5"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备 Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织 DSL 参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求，得到响应结果</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析结果</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.查询的总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    System.err.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    <span class="comment">// 4.2.查询的结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 4.3.得到source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 4.4.打印</span></span><br><span class="line">        System.out.println(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速入门小结"><a class="header-anchor" href="#快速入门小结"></a>快速入门小结</h4><p>查询的基本步骤是：</p><ol><li>创建 SearchRequest 对象</li><li>准备 <code>Request.source()</code>，也就是 DSL。<ul><li>QueryBuilders 来构建查询条件</li><li>传入 <code>Request.source()</code> 的 <code>query()</code> 方法</li></ul></li><li>发送请求，得到结果</li><li>解析结果（参考 JSON 结果，从外到内，逐层解析）</li></ol><h3 id="match-查询"><a class="header-anchor" href="#match-查询"></a>match 查询</h3><p>全文检索的 match 和 multi_match 查询与 match_all 的 API 基本一致。差别是查询条件，也就是 query 的部分。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;如家&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;fields&quot;</span>: [<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;name&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java 代码上的差异主要是 <code>request.source().query()</code> 中的参数了。同样是利用 QueryBuilders 提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单字段查询</span></span><br><span class="line">QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>);</span><br><span class="line"><span class="comment">// 多字段查询</span></span><br><span class="line">QueryBuilders.multiMatchQuery(<span class="string">&quot;如家&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;business&quot;</span>);</span><br></pre></td></tr></table></figure><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA 代码抽取 Ctrl + Alt + M</p></blockquote><h3 id="精确查询"><a class="header-anchor" href="#精确查询"></a>精确查询</h3><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;杭州&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;gte&quot;</span>: <span class="number">100</span>, <span class="attr">&quot;lte&quot;</span>: <span class="number">150</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询条件构造的 API 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 词条查询</span></span><br><span class="line">QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>); </span><br><span class="line"><span class="comment">// 范围查询</span></span><br><span class="line">QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">100</span>).lte(<span class="number">150</span>);</span><br></pre></td></tr></table></figure><h3 id="布尔查询-v2"><a class="header-anchor" href="#布尔查询-v2"></a>布尔查询</h3><p>布尔查询是用 must、must_not、filter 等方式组合其它查询，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建布尔查询</span></span><br><span class="line">BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line"><span class="comment">// 添加must条件</span></span><br><span class="line">boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;杭州&quot;</span>)); </span><br><span class="line"><span class="comment">// 添加filter条件</span></span><br><span class="line">boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bool&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;must&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;term&quot;</span>: &#123; <span class="attr">&quot;city&quot;</span>: <span class="string">&quot;杭州&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;price&quot;</span>: &#123; <span class="attr">&quot;lte&quot;</span>: <span class="number">250</span> &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，API 与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;上海&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">250</span>));</span><br><span class="line">    </span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rest-Client-搜索结果处理"><a class="header-anchor" href="#Rest-Client-搜索结果处理"></a>Rest Client 搜索结果处理</h2><h3 id="排序与分页"><a class="header-anchor" href="#排序与分页"></a>排序与分页</h3><p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p><p>对应的 API 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询 </span></span><br><span class="line">request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line"><span class="comment">// 分页</span></span><br><span class="line">request.source().from(<span class="number">0</span>).size(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;from&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">5</span>, </span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;FIELD&quot;</span>: <span class="string">&quot;desc&quot;</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高亮-v2"><a class="header-anchor" href="#高亮-v2"></a>高亮</h3><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li><li>结果解析：结果除了要解析 _source 文档数据，还要解析高亮结果</li></ul><h4 id="高亮请求构建"><a class="header-anchor" href="#高亮请求构建"></a>高亮请求构建</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;fields&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;require_field_match&quot;</span>: <span class="string">&quot;false&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高亮请求的构建 API 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.source().highlighter(<span class="keyword">new</span> HighlightBuilder().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="keyword">false</span>));</span><br></pre></td></tr></table></figure><p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, <span class="string">&quot;如家&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> HighlightBuilder().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="keyword">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高亮结果解析"><a class="header-anchor" href="#高亮结果解析"></a>高亮结果解析</h4><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;hotel&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;339952837&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_score&quot;</span> : <span class="number">2.8947515</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span> : <span class="number">339952837</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;如家酒店(北京良乡西路店)&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;price&quot;</span> : <span class="number">159</span>,</span><br><span class="line">    <span class="attr">&quot;score&quot;</span> : <span class="number">46</span>,</span><br><span class="line">    <span class="attr">&quot;brand&quot;</span> : <span class="string">&quot;如家&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;city&quot;</span> : <span class="string">&quot;北京&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;location&quot;</span> : <span class="string">&quot;39.73167, 116.132482&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;pic&quot;</span> : <span class="string">&quot;t0.jpg&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : [</span><br><span class="line">      <span class="string">&quot;&lt;em&gt;如家&lt;/em&gt;酒店(北京良乡西路店)&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此解析高亮的代码需要额外处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取source</span></span><br><span class="line">HotelDoc hotelDoc = JSON.parseObject(hit.getSourceAsString(), HotelDoc.class);</span><br><span class="line"><span class="comment">// 处理高亮</span></span><br><span class="line">Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line"><span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) &#123;</span><br><span class="line">    <span class="comment">// 获取高亮字段结果</span></span><br><span class="line">    HighlightField highlightField = highlightFields.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (highlightField != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出高亮结果数组中的第一个，就是酒店名称</span></span><br><span class="line">        String name = highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">        hotelDoc.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码解读：</p><ul><li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，JSON 字符串。还需要反序列为 HotelDoc 对象</li><li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是 HighlightField 对象，代表高亮值</li><li>第三步：从 Map 中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField 中获取 Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li></ul><h2 id="酒店搜索案例"><a class="header-anchor" href="#酒店搜索案例"></a>酒店搜索案例</h2><p>下面，我们通过酒店搜索案例来实战演练下之前学习的知识。</p><p>我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动 hotel-demo 项目，其默认端口是 8089，访问 <a href="http://localhost:8090">http://localhost:8090</a>，就能看到项目页面了。</p><h3 id="酒店搜索和分页"><a class="header-anchor" href="#酒店搜索和分页"></a>酒店搜索和分页</h3><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p><h4 id="需求分析"><a class="header-anchor" href="#需求分析"></a>需求分析</h4><ul><li>请求方式：POST</li><li>请求路径：/hotel/list</li><li>请求参数：JSON 对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果 PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li>步骤一：定义实体类，接收请求参数的 JSON 对象</li><li>步骤二：编写 controller，接收页面的请求</li><li>步骤三：编写业务实现，利用 RestHighLevelClient 实现搜索、分页</li></ul><h4 id="定义实体类"><a class="header-anchor" href="#定义实体类"></a>定义实体类</h4><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p><p>① 请求参数，前端请求的 JSON 结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;搜索关键字&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;size&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;sortBy&quot;</span>: <span class="string">&quot;default&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们在 <code>cn.itcast.hotel.pojo</code> 包下定义一个实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 返回值，分页查询，需要返回分页结果 PageResult，包含两个属性：</p><ul><li><code>total</code> ：总条数</li><li><code>List&lt;HotelDoc&gt;</code> ：当前页的数据</li></ul><p>因此，我们在 <code>cn.itcast.hotel.pojo</code> 中定义返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.hotels = hotels;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义-controller"><a class="header-anchor" href="#定义-controller"></a>定义 controller</h4><p>定义一个 HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：/hotel/list</li><li>请求参数：对象，类型为 RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在 <code>cn.itcast.hotel.web</code> 中定义 HotelController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现搜索业务"><a class="header-anchor" href="#实现搜索业务"></a>实现搜索业务</h4><p>我们在 controller 调用了 IHotelService，并没有实现该方法，因此下面我们就在 IHotelService 中定义方法，并且去实现业务逻辑。</p><p>① 在 <code>cn.itcast.hotel.service</code> 中的 <code>IHotelService</code> 接口中定义一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PageResult <span class="title">search</span><span class="params">(RequestParams params)</span></span>;</span><br></pre></td></tr></table></figure><p>② 实现搜索业务，肯定离不开 RestHighLevelClient，我们需要把它注册到 Spring 中作为一个 Bean。在 <code>cn.itcast.hotel</code> 中的 <code>HotelDemoApplication</code> 中声明这个 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class="string">&quot;http://halo:9200&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 在 <code>cn.itcast.hotel.service.impl</code> 中的 <code>HotelService</code> 中实现 search 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        String key = params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PageResult <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageResult(total, hotels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="酒店结果过滤"><a class="header-anchor" href="#酒店结果过滤"></a>酒店结果过滤</h3><p>需求：添加品牌、城市、星级、价格等过滤功能</p><h4 id="需求分析-v2"><a class="header-anchor" href="#需求分析-v2"></a>需求分析</h4><p>包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li>修改请求参数的对象 RequestParams，接收上述参数</li><li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li></ul><h4 id="修改实体类"><a class="header-anchor" href="#修改实体类"></a>修改实体类</h4><p>修改在 <code>cn.itcast.hotel.pojo</code> 包下的实体类 RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改搜索业务"><a class="header-anchor" href="#修改搜索业务"></a>修改搜索业务</h4><p>在 HotelService 的 search 方法中，只有一个地方需要修改：<code>requet.source().query( ... )</code> 其中的查询条件。</p><p>在之前的业务中，只有 match 查询，根据关键字搜索，现在要添加条件过滤，包括：</p><ul><li>品牌过滤：是 keyword 类型，用 term 查询</li><li>星级过滤：是 keyword 类型，用 term 查询</li><li>价格过滤：是数值类型，用 range 查询</li><li>城市过滤：是 keyword 类型，用 term 查询</li></ul><p>多个查询条件组合，肯定是 boolean 查询来组合：</p><ul><li>关键字搜索放到 must 中，参与算分</li><li>其它过滤条件放到 filter 中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里封装为一个函数，getBoolQueryBuilder 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BoolQueryBuilder <span class="title">getBoolQueryBuilder</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件过滤</span></span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 星级</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> boolQuery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我周边的酒店"><a class="header-anchor" href="#我周边的酒店"></a>我周边的酒店</h3><p>需求：我附近的酒店</p><h4 id="需求分析-v3"><a class="header-anchor" href="#需求分析-v3"></a>需求分析</h4><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置，并且，在前端会发起查询请求，将你的坐标发送到服务端。</p><p>我们要做的事情就是基于这个 location 坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li>修改 RequestParams 参数，接收 location 字段</li><li>修改 search 方法业务逻辑，如果 location 有值，添加根据 geo_distance 排序的功能</li></ul><h4 id="修改实体类-v2"><a class="header-anchor" href="#修改实体类-v2"></a>修改实体类</h4><p>修改在 <code>cn.itcast.hotel.pojo</code> 包下的实体类 RequestParams：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestParams</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="距离排序-API"><a class="header-anchor" href="#距离排序-API"></a>距离排序 API</h4><p>我们以前学习过排序功能，包括两种：</p><ul><li>普通字段排序</li><li>地理坐标排序</li></ul><p>我们只讲了普通字段排序对应的 Java 写法。地理坐标排序只学过 DSL 语法，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;sort&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;asc&quot;</span>  </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;_geo_distance&quot;</span> : &#123;</span><br><span class="line">          <span class="attr">&quot;FIELD&quot;</span> : <span class="string">&quot;纬度，经度&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;order&quot;</span> : <span class="string">&quot;asc&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;unit&quot;</span> : <span class="string">&quot;km&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应 Java 代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价格排序</span></span><br><span class="line">request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line"><span class="comment">// 距离排序</span></span><br><span class="line">request.source().sort(SortBuilders.geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> GeoPoint(<span class="string">&quot;31.21, 121.5&quot;</span>))</span><br><span class="line">                      .order(SortOrder.ASC).unit(DistanceUnit.KILOMETERS));</span><br></pre></td></tr></table></figure><h4 id="添加距离排序"><a class="header-anchor" href="#添加距离排序"></a>添加距离排序</h4><p>在 <code>cn.itcast.hotel.service.impl</code> 的 <code>HotelService</code> 的 <code>search</code> 方法中，添加一个排序功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PageResult <span class="title">search</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        <span class="comment">// 构建 boolQuery</span></span><br><span class="line">        BoolQueryBuilder boolQuery = getBoolQueryBuilder(params);</span><br><span class="line">        request.source().query(boolQuery);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="keyword">int</span> page = params.getPage();</span><br><span class="line">        <span class="keyword">int</span> size = params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        String location = params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="keyword">null</span> &amp;&amp; !location.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">&quot;location&quot;</span>, <span class="keyword">new</span> GeoPoint(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="排序距离显示"><a class="header-anchor" href="#排序距离显示"></a>排序距离显示</h4><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p><p>因此，我们在结果解析阶段，除了解析 source 部分以外，还要得到 sort 部分，也就是排序的距离，然后放到响应结果中。</p><p>我们要做两件事：</p><ul><li>修改 HotelDoc，添加排序距离字段，用于页面显示</li><li>修改 HotelService 类中的 handleResponse 方法，添加对 sort 值的获取</li></ul><p>① 修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 修改 HotelService 中的 handleResponse 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> PageResult <span class="title">handleResponse</span><span class="params">(SearchResponse response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    SearchHits searchHits = response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="keyword">long</span> total = searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        String json = hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取排序值 - location</span></span><br><span class="line">        Object[] sortValues = hit.getSortValues();</span><br><span class="line">        <span class="keyword">if</span> (sortValues.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Object sortValue = sortValues[<span class="number">0</span>];</span><br><span class="line">            hotelDoc.setDistance(sortValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PageResult(total, hotels);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="酒店竞价排名"><a class="header-anchor" href="#酒店竞价排名"></a>酒店竞价排名</h3><p>需求：让指定的酒店在搜索结果中排名置顶</p><h4 id="需求分析-v4"><a class="header-anchor" href="#需求分析-v4"></a>需求分析</h4><p>要让指定酒店在搜索结果中排名置顶，页面会给指定的酒店添加<strong>广告</strong>标记。</p><p>我们之前学习过的 function_score 查询可以影响算分，算分高了，自然排名也就高了。而 function_score 包含 3 个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算 function score</li><li>加权方式：function score 与 query score 如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。</p><p>比如，我们给酒店添加一个字段：isAD，Boolean 类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样 function_score 包含 3 个要素就很好确定了：</p><ul><li>过滤条件：判断 isAD 是否为 true</li><li>算分函数：我们可以用最简单暴力的 weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li><p>给 HotelDoc 类添加 isAD 字段，Boolean 类型</p></li><li><p>挑选几个你喜欢的酒店，给它的文档数据添加 isAD 字段，值为 true</p></li><li><p>修改 search方法，添加 function score 功能，给 isAD 值为 true 的酒店增加权重</p></li></ol><h4 id="修改-HotelDoc-实体"><a class="header-anchor" href="#修改-HotelDoc-实体"></a>修改 HotelDoc 实体</h4><p>给 <code>cn.itcast.hotel.pojo</code> 包下的 HotelDoc 类添加 isAD 字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加广告标记"><a class="header-anchor" href="#添加广告标记"></a>添加广告标记</h4><p>用 DSL 添加酒店广告标记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">36934</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;isAD&quot;</span>: <span class="keyword">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加算分函数查询"><a class="header-anchor" href="#添加算分函数查询"></a>添加算分函数查询</h4><p>接下来我们就要修改查询条件了。之前是用的 boolean 查询，现在要改成 function_socre 查询。</p><p>function_score 查询结构如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;function_score&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;match&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;外滩&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;functions&quot;</span>: [ </span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;brand&quot;</span>: <span class="string">&quot;如家&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">&quot;weight&quot;</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 JavaAPI 如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FunctionScoreQueryBuilder functionScoreQueryBuilder = </span><br><span class="line">    QueryBuilders.functionScoreQuery(</span><br><span class="line">        QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;外滩&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123;</span><br><span class="line">            <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder(</span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;如家&quot;</span>), </span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">5</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">);</span><br><span class="line">sourceBuilder.query(functionScoreQueryBuilder);</span><br></pre></td></tr></table></figure><p>我们可以将之前写的 boolean 查询作为<strong>原始查询</strong>条件放到 query 中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。</p><p>修改 <code>cn.itcast.hotel.service.impl</code> 包下的 <code>HotelService</code> 类中的 <code>getQueryBuilder</code> 方法，添加算分函数查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FunctionScoreQueryBuilder <span class="title">getQueryBuilder</span><span class="params">(RequestParams params)</span> </span>&#123;</span><br><span class="line">    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();</span><br><span class="line">    String key = params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || <span class="string">&quot;&quot;</span>.equals(key)) &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">&quot;all&quot;</span>, key));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件过滤</span></span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="keyword">null</span> &amp;&amp; !params.getCity().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;city&quot;</span>, params.getCity()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="keyword">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, params.getBrand()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 星级</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="keyword">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">&quot;starName&quot;</span>, params.getStarName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="keyword">null</span> &amp;&amp; params.getMaxPrice() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算分控制</span></span><br><span class="line">    FunctionScoreQueryBuilder functionScoreQueryBuilder =</span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score</span></span><br><span class="line">        <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder[]&#123;</span><br><span class="line">            <span class="comment">// 一个 function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">&quot;isAD&quot;</span>, <span class="keyword">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> functionScoreQueryBuilder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据聚合"><a class="header-anchor" href="#数据聚合"></a>数据聚合</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合</a>（aggregation） 可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的 SQL 要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h3 id="聚合的种类"><a class="header-anchor" href="#聚合的种类"></a>聚合的种类</h3><p>聚合常见的有三类：</p><ul><li><p>桶（Bucket）聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求 max、min、avg、sum 等</li></ul></li><li><p>管道（pipeline）聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p>**注意：**参加聚合的字段必须是 keyword、日期、数值、布尔类型</p></blockquote><h3 id="DSL-实现聚合"><a class="header-anchor" href="#DSL-实现聚合"></a>DSL 实现聚合</h3><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。</p><p>此时可以根据酒店品牌的名称做聚合，也就是 Bucket 聚合。</p><h4 id="Bucket-聚合语法"><a class="header-anchor" href="#Bucket-聚合语法"></a>Bucket 聚合语法</h4><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,  <span class="comment">// 设置 size 为 0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123; <span class="comment">// 定义聚合</span></span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123; <span class="comment">//给聚合起个名字</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123; <span class="comment">// 聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>, <span class="comment">// 参与聚合的字段</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5</span> <span class="comment">// 希望获取的聚合结果数量</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;took&quot;</span> : <span class="number">36</span>,</span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;skipped&quot;</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;value&quot;</span> : <span class="number">201</span>,</span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> : <span class="string">&quot;eq&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> : [ ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span> : &#123;</span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span> : <span class="number">96</span>,</span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;7天酒店&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">30</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;如家&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">30</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;皇冠假日&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">17</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;速8&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">15</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;key&quot;</span> : <span class="string">&quot;万怡&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> : <span class="number">13</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合结果排序"><a class="header-anchor" href="#聚合结果排序"></a>聚合结果排序</h4><p>默认情况下，Bucket 聚合会统计 Bucket 内的文档数量，记为 <code>_count</code>，并且按照 <code>_count</code> 降序排序。</p><p>我们可以指定 order 属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;_count&quot;</span>: <span class="string">&quot;asc&quot;</span> <span class="comment">// 按照 _count 升序排列</span></span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="限定聚合范围"><a class="header-anchor" href="#限定聚合范围"></a>限定聚合范围</h4><p>默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加 query 条件即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;range&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;lte&quot;</span>: <span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Metric-聚合语法"><a class="header-anchor" href="#Metric-聚合语法"></a>Metric 聚合语法</h4><p>现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的 min、max、avg 等值。</p><p>这就要用到 Metric 聚合了，例如 stats 聚合：就可以获取 min、max、avg 等结果。</p><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>, </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123; </span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123; </span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123; <span class="comment">// 是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">        <span class="attr">&quot;score_stats&quot;</span>: &#123; <span class="comment">// 聚合名称</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span>: &#123; <span class="comment">// 聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;score&quot;</span> <span class="comment">// 聚合字段，这里是score</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的 score_stats 聚合是在 brandAgg 的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;size&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;brandAgg&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;terms&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">&quot;order&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;scoreAgg.avg&quot;</span>: <span class="string">&quot;desc&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;scoreAgg&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;stats&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;score&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DSL-实现聚合小结"><a class="header-anchor" href="#DSL-实现聚合小结"></a>DSL 实现聚合小结</h4><p>aggs 代表聚合，与 query 同级，此时 query 的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h3 id="Rest-Client-实现聚合"><a class="header-anchor" href="#Rest-Client-实现聚合"></a>Rest Client 实现聚合</h3><h4 id="API-语法"><a class="header-anchor" href="#API-语法"></a>API 语法</h4><p>聚合条件与 query 条件同级别，因此需要使用 <code>request.source()</code> 来指定聚合条件。</p><p>聚合条件的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.source().size(<span class="number">0</span>);</span><br><span class="line">request.source().aggregation(</span><br><span class="line">    AggregationBuilders</span><br><span class="line">    .terms(<span class="string">&quot;brand_agg&quot;</span>)</span><br><span class="line">    .field(<span class="string">&quot;brand&quot;</span>)</span><br><span class="line">    .size(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>聚合的结果也与查询结果不同，API 也比较特殊。不过同样是 JSON 逐层解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 解析结果</span></span><br><span class="line"><span class="comment">// 4.1 获取 aggregations</span></span><br><span class="line">Aggregations aggregations = response.getAggregations();</span><br><span class="line"><span class="comment">// 4.2 根据名称获取聚合结果</span></span><br><span class="line">Terms brandTerms = aggregations.get(<span class="string">&quot;brandAgg&quot;</span>);</span><br><span class="line"><span class="comment">// 4.3 获取 buckets 并遍历</span></span><br><span class="line"><span class="keyword">for</span> (Terms.Bucket bucket : brandTerms.getBuckets()) &#123;</span><br><span class="line">    <span class="comment">// 获取 key</span></span><br><span class="line">    String key = bucket.getKeyAsString();</span><br><span class="line">    System.out.println(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务需求"><a class="header-anchor" href="#业务需求"></a>业务需求</h4><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的</p><p>分析：目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用 Bucket 聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>返回结果是一个 Map 结构：</p><ul><li>key 是字符串，城市、星级、品牌、价格</li><li>value 是集合，例如多个城市的名称</li></ul><h4 id="业务实现"><a class="header-anchor" href="#业务实现"></a>业务实现</h4><p>在 <code>cn.itcast.hotel.web</code> 包的 <code>HotelController</code> 中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;filters&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getFilters(<span class="meta">@RequestBody</span> RequestParams params)&#123;</span><br><span class="line">    <span class="keyword">return</span> hotelService.getFilters(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 IHotelService 中的 getFilters 方法，尚未实现。</p><p>在 <code>cn.itcast.hotel.service.IHotelService</code> 中定义新方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params);</span><br></pre></td></tr></table></figure><p>在 <code>cn.itcast.hotel.service.impl.HotelService</code> 中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; getFilters(RequestParams params) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 准备 request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 准备 DSL</span></span><br><span class="line">        <span class="comment">// query</span></span><br><span class="line">        FunctionScoreQueryBuilder query = getQueryBuilder(params);</span><br><span class="line">        request.source().highlighter(<span class="keyword">new</span> HighlightBuilder().field(<span class="string">&quot;name&quot;</span>).requireFieldMatch(<span class="keyword">false</span>));</span><br><span class="line">        request.source().query(query);</span><br><span class="line">        <span class="comment">// 2.1 设置 size = 0</span></span><br><span class="line">        request.source().size(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2.2 聚合</span></span><br><span class="line">        HashMap&lt;String, String&gt; items = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        items.put(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;品牌&quot;</span>);</span><br><span class="line">        items.put(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;城市&quot;</span>);</span><br><span class="line">        items.put(<span class="string">&quot;starName&quot;</span>, <span class="string">&quot;星级&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String item : items.keySet()) &#123;</span><br><span class="line">            request.source().aggregation(AggregationBuilders</span><br><span class="line">                                         .terms(item + <span class="string">&quot;Agg&quot;</span>)</span><br><span class="line">                                         .field(item)</span><br><span class="line">                                         .size(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 发出请求</span></span><br><span class="line">        SearchResponse response = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 解析结果</span></span><br><span class="line">        <span class="comment">// 4.1 获取 aggregations</span></span><br><span class="line">        Aggregations aggregations = response.getAggregations();</span><br><span class="line"></span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; itemListHashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String item : items.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 4.2 根据名称获取聚合结果</span></span><br><span class="line">            Terms brandTerms = aggregations.get(item + <span class="string">&quot;Agg&quot;</span>);</span><br><span class="line">            <span class="comment">// 4.3 获取 buckets 并遍历</span></span><br><span class="line">            ArrayList&lt;String&gt; itemList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Terms.Bucket bucket : brandTerms.getBuckets()) &#123;</span><br><span class="line">                <span class="comment">// 获取 key</span></span><br><span class="line">                itemList.add(bucket.getKeyAsString());</span><br><span class="line">            &#125;</span><br><span class="line">            itemListHashMap.put(item, itemList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> itemListHashMap;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动补全"><a class="header-anchor" href="#自动补全"></a>自动补全</h2><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h3 id="拼音分词器"><a class="header-anchor" href="#拼音分词器"></a>拼音分词器</h3><p>要实现根据字母做补全，就必须对文档按照拼音分词。在 GitHub 上有 ElasticSearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p>安装方式与 IK 分词器一样，分三步：</p><ol><li>解压</li><li>上传到虚拟机中，ElasticSearch 的 plugin 目录</li><li>重启 ElasticSearch</li><li>测试</li></ol><p>详细安装步骤可以参考 IK 分词器的安装过程。</p><p>测试用法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;如家酒店还不错&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;pinyin&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;ru&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;rjjdhbc&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;jia&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;jiu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;dian&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;hai&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;bu&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;cuo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;word&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义分词器"><a class="header-anchor" href="#自定义分词器"></a>自定义分词器</h3><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>ElasticSearch 中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如 keyword，就是不分词；还有 ik_smart</li><li>tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p>声明自定义分词器的语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: <span class="string">&quot;py&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;py&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pinyin&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;my_analyzer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>如何使用拼音分词器？</p><ul><li><p>下载 pinyin 分词器</p></li><li><p>解压并放到 ElasticSearch 的 plugin 目录</p></li><li><p>重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li>创建索引库时，在 settings 中配置，可以包含三部分：character filter、tokenizer、filter</li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h3 id="自动补全查询"><a class="header-anchor" href="#自动补全查询"></a>自动补全查询</h3><p>ElasticSearch 提供了 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a> 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是 completion 类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /test2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;title&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;completion&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后插入下面的数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST /test2/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;Sony&quot;</span>, <span class="string">&quot;WH-1000XM3&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">POST /test2/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;SK-II&quot;</span>, <span class="string">&quot;PITERA&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">POST /test2/_doc</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;title&quot;</span>: [<span class="string">&quot;Nintendo&quot;</span>, <span class="string">&quot;switch&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询的 DSL 语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /test2/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;title_suggest&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;s&quot;</span>, </span><br><span class="line">      <span class="attr">&quot;completion&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;title&quot;</span>, </span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现酒店搜索框自动补全"><a class="header-anchor" href="#实现酒店搜索框自动补全"></a>实现酒店搜索框自动补全</h3><p>现在，我们的 hotel 索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将 brand、suggestion、city 等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改 hotel 索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的 name、all 字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段 suggestion，类型为 completion 类型，使用自定义的分词器</p></li><li><p>给 HotelDoc 类添加 suggestion 字段，内容包含 brand、business</p></li><li><p>重新导入数据到 hotel 库</p></li></ol><h4 id="修改酒店映射结构"><a class="header-anchor" href="#修改酒店映射结构"></a>修改酒店映射结构</h4><p>代码如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;text_anlyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;ik_max_word&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: <span class="string">&quot;py&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;completion_analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: <span class="string">&quot;py&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;py&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;pinyin&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;keep_full_pinyin&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">&quot;keep_joined_full_pinyin&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;keep_original&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;limit_first_letter_length&quot;</span>: <span class="number">16</span>,</span><br><span class="line">          <span class="attr">&quot;remove_duplicated_term&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">&quot;none_chinese_pinyin_tokenize&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;id&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;text_anlyzer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;address&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;price&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;score&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;brand&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;city&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;starName&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;business&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;copy_to&quot;</span>: <span class="string">&quot;all&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;location&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;geo_point&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;pic&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;index&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;all&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;text_anlyzer&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;search_analyzer&quot;</span>: <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;suggestion&quot;</span>:&#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;completion&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;completion_analyzer&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改-HotelDoc-实体-v2"><a class="header-anchor" href="#修改-HotelDoc-实体-v2"></a>修改 HotelDoc 实体</h4><p>HotelDoc 中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在 HotelDoc 中添加一个 suggestion 字段，类型为 <code>List&lt;String&gt;</code>，然后将 brand、city、business 等信息放到里面。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelDoc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HotelDoc</span><span class="params">(Hotel hotel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="keyword">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="keyword">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="keyword">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="keyword">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="keyword">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="keyword">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="keyword">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="keyword">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="keyword">this</span>.location = hotel.getLatitude() + <span class="string">&quot;, &quot;</span> + hotel.getLongitude();</span><br><span class="line">        <span class="keyword">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.business.contains(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="keyword">this</span>.business.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="keyword">this</span>.suggestion = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.suggestion.add(<span class="keyword">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="keyword">this</span>.suggestion, arr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.suggestion = Arrays.asList(<span class="keyword">this</span>.brand, <span class="keyword">this</span>.business);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重新导入并测试"><a class="header-anchor" href="#重新导入并测试"></a>重新导入并测试</h4><p>重新执行之前编写的导入数据功能 <code>testBulkRequest()</code>，并搜索测试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到新的酒店数据中包含了 suggestion，接下来测试自动补全功能</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;suggest&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;suggestions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;sd&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;completion&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;field&quot;</span>: <span class="string">&quot;suggestion&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;skip_duplicates&quot;</span>: <span class="literal">true</span>, </span><br><span class="line">        <span class="attr">&quot;size&quot;</span>: <span class="number">10</span> </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动补全查询的-Java-API"><a class="header-anchor" href="#自动补全查询的-Java-API"></a>自动补全查询的 Java API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.准备请求</span></span><br><span class="line">SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line"><span class="comment">// 2.请求参数</span></span><br><span class="line">request.source().suggest(<span class="keyword">new</span> SuggestBuilder().addSuggestion(</span><br><span class="line">    <span class="string">&quot;mySuggestion&quot;</span>,</span><br><span class="line">    SuggestBuilders</span><br><span class="line">    .completionSuggestion(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">    .prefix(<span class="string">&quot;h&quot;</span>)</span><br><span class="line">    .skipDuplicates(<span class="keyword">true</span>)</span><br><span class="line">    .size(<span class="number">10</span>)</span><br><span class="line">));</span><br><span class="line"><span class="comment">// 3.发送请求</span></span><br><span class="line">client.search(request, RequestOptions.DEFAULT);</span><br></pre></td></tr></table></figure><p>而自动补全的结果也比较特殊，解析的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.处理结果</span></span><br><span class="line">Suggest suggest = response.getSuggest();</span><br><span class="line"><span class="comment">// 4.1.根据名称获取补全结果</span></span><br><span class="line">CompletionSuggestion suggestion = suggest.getSuggestion(<span class="string">&quot;mySuggestion&quot;</span>);</span><br><span class="line"><span class="comment">// 4.2.获取options并遍历</span></span><br><span class="line"><span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) &#123;</span><br><span class="line">    <span class="comment">// 4.3.获取一个option中的text，也就是补全的词条</span></span><br><span class="line">    String text = option.getText().string();</span><br><span class="line">    System.out.println(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现搜索框自动补全"><a class="header-anchor" href="#实现搜索框自动补全"></a>实现搜索框自动补全</h4><p>在 <code>cn.itcast.hotel.web</code> 包下的 <code>HotelController</code> 中添加新接口，接收新的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;suggestion&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSuggestions</span><span class="params">(<span class="meta">@RequestParam(&quot;key&quot;)</span> String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hotelService.getSuggestions(prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>cn.itcast.hotel.service</code> 包下的 <code>IhotelService</code> 中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;String&gt; <span class="title">getSuggestions</span><span class="params">(String prefix)</span></span>;</span><br></pre></td></tr></table></figure><p>在 <code>cn.itcast.hotel.service.impl.HotelService</code> 中实现该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSuggestions</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备请求</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;hotel&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.请求参数</span></span><br><span class="line">        request.source().suggest(<span class="keyword">new</span> SuggestBuilder().addSuggestion(</span><br><span class="line">            <span class="string">&quot;suggestions&quot;</span>,</span><br><span class="line">            SuggestBuilders</span><br><span class="line">            .completionSuggestion(<span class="string">&quot;suggestion&quot;</span>)</span><br><span class="line">            .prefix(prefix)</span><br><span class="line">            .skipDuplicates(<span class="keyword">true</span>)</span><br><span class="line">            .size(<span class="number">10</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.处理结果</span></span><br><span class="line">        Suggest suggest = response.getSuggest();</span><br><span class="line">        <span class="comment">// 4.1.根据名称获取补全结果</span></span><br><span class="line">        CompletionSuggestion suggestion = suggest.getSuggestion(<span class="string">&quot;suggestions&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.2.获取options并遍历</span></span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) &#123;</span><br><span class="line">            <span class="comment">// 4.3.获取一个option中的text，也就是补全的词条</span></span><br><span class="line">            String text = option.getText().string();</span><br><span class="line">            result.add(text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据同步"><a class="header-anchor" href="#数据同步"></a>数据同步</h2><p>ElasticSearch 中的酒店数据来自于 MySQL 数据库，因此 MySQL 数据发生改变时，ElasticSearch 也必须跟着改变，这个就是 ElasticSearch 与 MySQL 之间的数据同步。</p><h3 id="思路分析"><a class="header-anchor" href="#思路分析"></a>思路分析</h3><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听 binlog</li></ul><h4 id="同步调用"><a class="header-anchor" href="#同步调用"></a>同步调用</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8.i2rj0d3cpwg.svg" alt="同步调用"></p><p>基本步骤如下：</p><ul><li>hotel-demo 对外提供接口，用来修改 ElasticSearch 中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用 hotel-demo 提供的接口</li></ul><h4 id="异步通知"><a class="header-anchor" href="#异步通知"></a>异步通知</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5.1p2ptlc5nrs0.svg" alt="异步通知"></p><p>流程如下：</p><ul><li>hotel-admin 对 MySQL 数据库数据完成增、删、改后，发送 MQ 消息</li><li>hotel-demo 监听 MQ，接收到消息后完成 ElasticSearch 数据修改</li></ul><h4 id="监听-binlog"><a class="header-anchor" href="#监听-binlog"></a>监听 binlog</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%9B%91%E5%90%ACbinlog.1n6hcbad4pb4.svg" alt="监听binlog"></p><p>流程如下：</p><ul><li>给 MySQL 开启 binlog 功能</li><li>MySQL 完成增、删、改操作都会记录在 binlog 中</li><li>hotel-demo 基于 canal 监听 binlog 变化，实时更新 ElasticSearch 中的内容</li></ul><h4 id="不同数据同步方案优缺点"><a class="header-anchor" href="#不同数据同步方案优缺点"></a>不同数据同步方案优缺点</h4><p>方式一：同步调用</p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务耦合度高</li></ul><p>方式二：异步通知</p><ul><li>优点：低耦合，实现难度一般</li><li>缺点：依赖 MQ 的可靠性</li></ul><p>方式三：监听 binlog</p><ul><li>优点：完全解除服务间耦合</li><li>缺点：开启 binlog 增加数据库负担、实现复杂度高</li></ul><h3 id="实现数据同步"><a class="header-anchor" href="#实现数据同步"></a>实现数据同步</h3><h4 id="基于-MQ-的实现思路"><a class="header-anchor" href="#基于-MQ-的实现思路"></a>基于 MQ 的实现思路</h4><p>利用提供的 hotel-admin 项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对 ElasticSearch 中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入 hotel-admin 项目，启动并测试酒店数据的 CRUD</p></li><li><p>声明 exchange、queue、RoutingKey</p></li><li><p>在 hotel-admin 中的增、删、改业务中完成消息发送</p></li><li><p>在 hotel-demo 中完成消息监听，并更新 ElasticSearch 中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h3 id="导入-demo"><a class="header-anchor" href="#导入-demo"></a>导入 demo</h3><p>代码链接：<a href="https://github.com/Lanqilu/HaloElasticSearch/commit/b9d7c724b44d6ea8e307ac5d54778bba635bd314">GitHub</a></p><p>运行后，访问 <a href="http://localhost:8099">http://localhost:8099</a></p><h3 id="声明交换机、队列"><a class="header-anchor" href="#声明交换机、队列"></a>声明交换机、队列</h3><p>MQ 结构如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/MQ%E7%BB%93%E6%9E%84.lv1ecla6gvk.svg" alt="MQ结构"></p><h4 id="引入依赖并修改配置文件"><a class="header-anchor" href="#引入依赖并修改配置文件"></a>引入依赖并修改配置文件</h4><p>在 hotel-admin、hotel-demo 中引入 rabbitmq 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">rabbitmq</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">halo</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">halo</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br></pre></td></tr></table></figure><h4 id="声明交换机、队列-v2"><a class="header-anchor" href="#声明交换机、队列-v2"></a>声明交换机、队列</h4><p>在 hotel-admin 和 hotel-demo 中的 <code>cn.itcast.hotel.constatnts</code> 包下新建一个类 <code>MqConstants</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConstants</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_EXCHANGE = <span class="string">&quot;hotel.topic&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_INSERT_QUEUE = <span class="string">&quot;hotel.insert.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_DELETE_QUEUE = <span class="string">&quot;hotel.delete.queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_INSERT_KEY = <span class="string">&quot;hotel.insert&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_DELETE_KEY = <span class="string">&quot;hotel.delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 hotel-demo 中，定义配置类，声明队列、交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MqConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TopicExchange <span class="title">topicExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(MqConstants.HOTEL_EXCHANGE, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">insertQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(MqConstants.HOTEL_INSERT_QUEUE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">deleteQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(MqConstants.HOTEL_DELETE_QUEUE, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">insertQueueBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">deleteQueueBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送-MQ-消息"><a class="header-anchor" href="#发送-MQ-消息"></a>发送 MQ 消息</h3><p>在 hotel-admin 中的增、删、改业务中分别发送 MQ 消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveHotel</span><span class="params">(<span class="meta">@RequestBody</span> Hotel hotel)</span></span>&#123;</span><br><span class="line">    hotelService.save(hotel);</span><br><span class="line">    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PutMapping()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateById</span><span class="params">(<span class="meta">@RequestBody</span> Hotel hotel)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hotel.getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidParameterException(<span class="string">&quot;id不能为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    hotelService.updateById(hotel);</span><br><span class="line">    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    hotelService.removeById(id);</span><br><span class="line">    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_DELETE_KEY,id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收-MQ-消息"><a class="header-anchor" href="#接收-MQ-消息"></a>接收 MQ 消息</h3><p>hotel-demo 接收到 MQ 消息要做的事情包括：</p><ul><li>新增消息：根据传递的 hotel 的 id 查询 hotel 信息，然后新增一条数据到索引库</li><li>删除消息：根据传递的 hotel 的 id 删除索引库中的一条数据</li></ul><p>首先在 hotel-demo 的 <code>cn.itcast.hotel.service</code> 包下的 <code>IHotelService</code> 中新增新增、删除业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertById</span><span class="params">(Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>给 hotel-demo 中的 <code>cn.itcast.hotel.service.impl</code> 包下的 HotelService 中实现业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        DeleteRequest request = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;hotel&quot;</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        Hotel hotel = getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        HotelDoc hotelDoc = <span class="keyword">new</span> HotelDoc(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;hotel&quot;</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写监听器，在 hotel-demo 中的 <code>cn.itcast.hotel.mq</code> 包新增一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotelListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenHotelDelete</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ElasticSearch-集群"><a class="header-anchor" href="#ElasticSearch-集群"></a>ElasticSearch 集群</h2><p>单机的 ElasticSearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为 N 个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica）</li></ul><p>ES 集群相关概念:</p><ul><li>集群（cluster）：一组拥有共同的 cluster name 的 节点。</li><li>节点（node)   ：集群中的一个 Elasticearch 实例</li><li>分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</li></ul><p>解决问题：数据量太大，单点存储量有限的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4pwzs1lq4540.png" alt="image"></p><p>此处，我们把数据分成 3 片：shard0、shard1、shard2</p><ul><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p></li></ul><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以 3 分片，每个分片备份一份为例：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3jlk46u66q60.png" alt="image"></p><p>现在，每个分片都有 1 个备份，存储在 3 个节点：</p><ul><li>node0：保存了分片 0 和 1</li><li>node1：保存了分片 0 和 2</li><li>node2：保存了分片 1 和 2</li></ul><h3 id="部署-ElasticSearch-集群"><a class="header-anchor" href="#部署-ElasticSearch-集群"></a>部署 ElasticSearch 集群</h3><p>我们会在单机上利用 docker 容器运行多个 ElasticSearch 实例来模拟 ElasticSearch 集群。不过生产环境推荐大家每一台服务节点仅部署一个 ElasticSearch 的实例。</p><p>部署 ElasticSearch 集群可以直接使用 docker-compose 来完成，但这要求你的 Linux 虚拟机至少有 4G 的内存空间</p><h4 id="创建-ElasticSearch-集群"><a class="header-anchor" href="#创建-ElasticSearch-集群"></a>创建 ElasticSearch 集群</h4><p>首先编写一个 docker-compose 文件，内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  es01:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es01</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es01</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es02,es03</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data01:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es02:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es02</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es02</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es03</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data02:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9201:9200</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">  es03:</span><br><span class="line">    image: elasticsearch:7.12.1</span><br><span class="line">    container_name: es03</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es03</span><br><span class="line">      - cluster.name=es-docker-cluster</span><br><span class="line">      - discovery.seed_hosts=es01,es02</span><br><span class="line">      - cluster.initial_master_nodes=es01,es02,es03</span><br><span class="line">      - <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - data03:/usr/share/elasticsearch/data</span><br><span class="line">    networks:</span><br><span class="line">      - elastic</span><br><span class="line">    ports:</span><br><span class="line">      - 9202:9200</span><br><span class="line">volumes:</span><br><span class="line">  data01:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  data02:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line">  data03:</span><br><span class="line">    driver: <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  elastic:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><p>ElasticSearch  运行需要修改一些 Linux 系统权限，修改 <code>/etc/sysctl.conf</code> 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>添加下面的内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>然后执行命令，让配置生效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>通过 docker-compose 启动集群：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h4 id="集群状态监控"><a class="header-anchor" href="#集群状态监控"></a>集群状态监控</h4><p>kibana 可以监控 ElasticSearch  集群，不过新版本需要依赖 ElasticSearch  的 x-pack 功能，配置比较复杂。</p><p>这里推荐使用 cerebro 来监控 ElasticSearch  集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a></p><p>双击其中的 cerebro.bat 文件即可启动服务。访问 <a href="http://localhost:9000">http://localhost:9000</a> 即可进入管理界面：</p><p>输入你的 ElasticSearch 的任意节点的地址和端口，点击 connect 即可</p><h4 id="创建索引库-v2"><a class="header-anchor" href="#创建索引库-v2"></a>创建索引库</h4><p>利用 kibana 的 DevTools 创建索引库，在 DevTools 中输入指令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PUT /test</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;number_of_shards&quot;</span>: <span class="number">3</span>, <span class="comment">// 分片数量</span></span><br><span class="line">    <span class="attr">&quot;number_of_replicas&quot;</span>: <span class="number">1</span> <span class="comment">// 副本数量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// mapping映射定义 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或利用 cerebro 创建索引库</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.29xen9tqfmvw.png" alt="image"></p><p>查看分片效果，回到首页，即可查看索引库分片效果：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jn8zaht2280.png" alt="image"></p><h3 id="集群脑裂问题"><a class="header-anchor" href="#集群脑裂问题"></a>集群脑裂问题</h3><h4 id="集群职责划分"><a class="header-anchor" href="#集群职责划分"></a>集群职责划分</h4><p>ElasticSearch 中集群节点有不同的职责划分：</p><table><thead><tr><th>节点类型</th><th>配置参数</th><th>默认值</th><th>节点职责</th></tr></thead><tbody><tr><td>master  eligible</td><td>node.master</td><td>true</td><td>备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求</td></tr><tr><td>data</td><td>node.data</td><td>true</td><td>数据节点：存储数据、搜索、聚合、CRUD</td></tr><tr><td>ingest</td><td>node.ingest</td><td>true</td><td>数据存储之前的预处理</td></tr><tr><td>coordinating</td><td>上面 3 个参数都为 false 则为 coordinating 节点</td><td>无</td><td>路由请求到其它节点  合并其它节点处理的结果，返回给用户</td></tr></tbody></table><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master 节点：对 CPU 要求高，但是内存要求低</li><li>data 节点：对 CPU 和内存要求都高</li><li>coordinating 节点：对网络带宽、CPU 要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的 ElasticSearch 集群职责划分如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES%E9%9B%86%E7%BE%A4.2rrl7g78cxs0.svg" alt="ES集群"></p><h4 id="脑裂问题"><a class="header-anchor" href="#脑裂问题"></a>脑裂问题</h4><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联，</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6ry0qp2sxiw0.png" alt="image"></p><p>此时 node2 和 node3 认为 node1 宕机，就会重新选主：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5qon8j1rbak0.png" alt="image"></p><p>当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.wmlcqz00rls.png" alt="image"></p><p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此 eligible 节点数量最好是奇数。对应配置项是 discovery.zen.minimum_master_nodes，在 ElasticSearch 7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3 个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为主。node1 只有自己 1 票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂。</p><h3 id="集群分布式存储"><a class="header-anchor" href="#集群分布式存储"></a>集群分布式存储</h3><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？</p><h4 id="分片存储测试"><a class="header-anchor" href="#分片存储测试"></a>分片存储测试</h4><p>在一个节点中加入数据，后可以通过 explain 命令查询</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /test/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;explain&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现数据在不同的节点中，形成分片存储</p><h4 id="分片存储原理"><a class="header-anchor" href="#分片存储原理"></a>分片存储原理</h4><p>ElasticSearch 会通过 hash 算法来计算文档应该存储到哪个分片：<code>shard = hash(_routing) % number_of_shards</code></p><p>说明：</p><ul><li><code>_routing</code> 默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES%E9%9B%86%E7%BE%A4.akvhs79fwq0.svg" alt="ES集群"></p><p>解读：</p><ul><li>新增一个 id=1 的文档</li><li>对 id 做 hash 运算，假如得到的是 2，则应该存储到 P-2</li><li>P-2 的主分片在 node3 节点，将数据路由到 node3</li><li>保存文档</li><li>同步给 P-2 的副本 R-2，在 node2 节点</li><li>返回结果给 coordinating-node 节点</li></ul><h4 id="集群分布式查询"><a class="header-anchor" href="#集群分布式查询"></a>集群分布式查询</h4><p>ElasticSearch 的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户</p></li></ul><h4 id="集群故障转移"><a class="header-anchor" href="#集群故障转移"></a>集群故障转移</h4><p>集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><ul><li>假如，node1 发生了故障</li><li>宕机后的第一件事，需要重新选主，例如选中了 node2，</li><li>node2 成为主节点后，会检测集群监控状态，发现：shard-1、shard-0 没有副本节点。因此需要将 node1 上的数据迁移到 node2、node3</li><li>但 node1 恢复，此时 node1 不在是主节点，但数据会重新平衡</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识-ElasticSearch&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#初识-ElasticSearch&quot;&gt;&lt;/a&gt;初识 ElasticSearch&lt;/h2&gt;
&lt;h3 id=&quot;了解-ElasticSearch&quot;&gt;&lt;a class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/B_Docker%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/B_Docker%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.806Z</published>
    <updated>2021-09-20T05:58:11.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识-Docker"><a class="header-anchor" href="#初识-Docker"></a>初识 Docker</h2><h3 id="什么是-Docker"><a class="header-anchor" href="#什么是-Docker"></a>什么是 Docker</h3><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li></ul><h4 id="应用部署的环境问题"><a class="header-anchor" href="#应用部署的环境问题"></a>应用部署的环境问题</h4><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p>例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p><h4 id="Docker-解决依赖兼容问题"><a class="header-anchor" href="#Docker-解决依赖兼容问题"></a>Docker 解决依赖兼容问题</h4><p>而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？</p><p>Docker 为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p><h4 id="Docker-解决操作系统环境差异"><a class="header-anchor" href="#Docker-解决操作系统环境差异"></a>Docker 解决操作系统环境差异</h4><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。计算机系统结构如下：</p><ul><li>计算机硬件：例如 CPU、内存、磁盘等</li><li>系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><ul><li>应用调用操作系统应用（函数库），实现各种功能</li><li>系统函数库是对内核指令集的封装，会调用内核指令</li><li>内核指令操作计算机硬件</li></ul><p>Ubuntu 和 CentOS 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异。此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了。</p><p>Docker 如何解决不同系统环境的问题？</p><ul><li>Docker 将用户程序与所需要调用的系统（比如 Ubuntu）函数库一起打包</li><li>Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li></ul><h4 id="什么是-Docker-小结"><a class="header-anchor" href="#什么是-Docker-小结"></a>什么是 Docker 小结</h4><p>Docker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker 允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker 应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行</li></ul><p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷</li></ul><h3 id="Docker-和虚拟机的区别"><a class="header-anchor" href="#Docker-和虚拟机的区别"></a>Docker 和虚拟机的区别</h3><p>Docker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。</p><p>Docker 仅仅是封装函数库，并没有模拟完整的操作系统</p><p>两者有什么差异呢？</p><ul><li><p>Docker 是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>Docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p></li></ul><h3 id="Docker-基本知识"><a class="header-anchor" href="#Docker-基本知识"></a>Docker 基本知识</h3><h4 id="镜像和容器"><a class="header-anchor" href="#镜像和容器"></a>镜像和容器</h4><p>Docker 中有几个重要的概念：</p><ul><li>镜像（Image）：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</li><li>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是 Docker 会给容器进程做隔离，对外不可见。</li></ul><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><ul><li>镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</li><li>容器，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。</li></ul><p>因此一个镜像可以启动多次，形成多个容器进程。</p><h4 id="DockerHub"><a class="header-anchor" href="#DockerHub"></a>DockerHub</h4><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。</p><ul><li><p>DockerHub ：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。</p></li><li><p>国内也有类似于 DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a> 等。</p></li></ul><h4 id="Docker-架构"><a class="header-anchor" href="#Docker-架构"></a>Docker 架构</h4><p>我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。</p><p>Docker 是一个 CS 架构的程序，由两部分组成：</p><ul><li><p>服务端（server）：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</p></li><li><p>客户端（client）：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E6%9E%B6%E6%9E%84.4alzm4dto2g0.svg" alt="Docker架构"></p><h2 id="配置-Docker"><a class="header-anchor" href="#配置-Docker"></a>配置 Docker</h2><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p><p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p><h3 id="CentOS-安装-Docker"><a class="header-anchor" href="#CentOS-安装-Docker"></a>CentOS 安装 Docker</h3><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在 CentOS 7 安装 Docker。</p><h4 id="卸载-Docker（可选）"><a class="header-anchor" href="#卸载-Docker（可选）"></a>卸载 Docker（可选）</h4><p>如果之前安装过旧版本的 Docker，可以使用下面命令卸载：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure><h4 id="安装-Docker"><a class="header-anchor" href="#安装-Docker"></a>安装 Docker</h4><p>安装 yum 工具</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure><p>然后更新本地镜像源：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i <span class="string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>然后输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><p>docker-ce 为社区免费版本。稍等片刻，docker 即可安装成功。</p><h3 id="启动-Docker"><a class="header-anchor" href="#启动-Docker"></a>启动 Docker</h3><p>Docker 应用需要用到各种端口，逐一去修改防火墙设置。学习时可以直接关闭防火墙。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><p>通过命令启动 Docker：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure><p>然后输入命令，可以查看 Docker 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速"><a class="header-anchor" href="#配置镜像加速"></a>配置镜像加速</h3><p>Docker 官方镜像仓库网速较差，我们需要设置国内镜像服务：</p><p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p><p>通过修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://578xeysa.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker-的基本操作"><a class="header-anchor" href="#Docker-的基本操作"></a>Docker 的基本操作</h2><h3 id="镜像操作"><a class="header-anchor" href="#镜像操作"></a>镜像操作</h3><h4 id="镜像名称"><a class="header-anchor" href="#镜像名称"></a>镜像名称</h4><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li></ul><h4 id="镜像命令"><a class="header-anchor" href="#镜像命令"></a>镜像命令</h4><p>常见的镜像操作命令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.71pfsgm3nn00.svg" alt="Docker镜像操作命令"></p><h4 id="拉取、查看镜像"><a class="header-anchor" href="#拉取、查看镜像"></a>拉取、查看镜像</h4><p>需求：从 DockerHub 中拉取一个 Nginx 镜像并查看</p><ol><li>首先去镜像仓库搜索 Nginx 镜像，比如 <a href="https://hub.docker.com/">DockerHub</a>:</li><li>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<code>docker pull nginx</code></li><li>通过命令：<code>docker images</code> 查看拉取到的镜像</li></ol><h4 id="保存镜像"><a class="header-anchor" href="#保存镜像"></a>保存镜像</h4><p>需求：利用 docker save 将 Nginx 镜像导出磁盘，然后再通过 load 加载回来</p><p>利用 <code>docker xx --help</code> 命令查看 <code>docker save</code> 和 <code>docker load</code> 的语法。例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure><p>使用 <code>docker save</code> 导出镜像到磁盘，运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><h4 id="导入镜像"><a class="header-anchor" href="#导入镜像"></a>导入镜像</h4><p>先删除本地的 Nginx 镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a class="header-anchor" href="#容器操作"></a>容器操作</h3><h4 id="容器相关命令"><a class="header-anchor" href="#容器相关命令"></a>容器相关命令</h4><p>容器操作的命令如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.54kd7pt4p2w0.svg" alt="Docker容器相关命令"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU 不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU 等资源</li></ul><p>其中：</p><ul><li><code>docker run</code>：创建并运行一个容器，处于运行状态</li><li><code>docker pause</code>：让一个运行的容器暂停</li><li><code>docker unpause</code>：让一个容器从暂停状态恢复运行</li><li><code>docker stop</code>：停止一个运行的容器</li><li><code>docker start</code>：让一个停止的容器再次运行</li><li><code>docker rm</code>：删除一个容器</li><li><code>docker logs</code> ：查看容器日志的命令，添加 <code>-f</code> 参数可以持续查看日志</li><li><code>docker ps</code> ：查看容器状态，<code>-a</code> 查看所有容器，包括已经停止的</li></ul><h4 id="创建并运行一个容器"><a class="header-anchor" href="#创建并运行一个容器"></a>创建并运行一个容器</h4><p>创建并运行 Nginx 容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name haloNginx -p 81:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>docker run</code> ：创建并运行一个容器</li><li><code>--name</code> : 给容器起一个名字，比如叫做 haloNginx</li><li><code>-p</code> ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li><code>-d</code>：后台运行容器</li><li><code>nginx</code>：镜像名称，例如 nginx</li></ul><p>这里的 <code>-p</code> 参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的 81 端口，肯定访问不到容器中的 Nginx。</p><p>现在，将容器的 80 与宿主机的 81 关联起来，当我们访问宿主机的 81 端口时，就会被映射到容器的80，这样就能访问到 Nginx 了</p><h4 id="进入容器并修改文件"><a class="header-anchor" href="#进入容器并修改文件"></a>进入容器并修改文件</h4><p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加“Halo World!”</p><blockquote><p>提示：进入容器要用到 <code>docker exec</code> 命令。</p></blockquote><p>① 进入容器。进入我们刚刚创建的 Nginx 容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it haloNginx bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p><code>docker exec</code> ：进入容器内部，执行一个命令</p></li><li><p><code>-it</code> : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p><code>haloNginx</code>：要进入的容器的名称</p></li><li><p><code>bash</code>：进入容器后执行的命令，bash 是一个 Linux 终端交互命令</p></li></ul><p>② 进入 Nginx 的 HTML 所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 Linux 服务器一样</p><p>Nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p><p>查看 DockerHub 网站中的 Nginx 页面，可以知道 Nginx 的 html 目录位置在 <code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p>③ 修改 index.html 的内容</p><p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#Halo World!#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><h3 id="数据卷（容器数据管理）"><a class="header-anchor" href="#数据卷（容器数据管理）"></a>数据卷（容器数据管理）</h3><p>在之前的 Nginx 案例中，修改 Nginx 的 html 页面时，需要进入 Nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。容器与数据耦合的问题：</p><ul><li>不便于修改：当我们要修改 Nginx 的 html 内容时，需要进入容器内部修改，很不方便。</li><li>数据不可复用：在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li><li>升级维护困难：数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li></ul><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h4 id="什么是数据卷"><a class="header-anchor" href="#什么是数据卷"></a>什么是数据卷</h4><p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了</p><h4 id="数据集操作命令"><a class="header-anchor" href="#数据集操作命令"></a>数据集操作命令</h4><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p><code>docker volume</code> 命令是数据卷操作，根据命令后跟随的 <code>command</code> 来确定下一步的操作：</p><ul><li><code>create</code> ：创建一个 volume</li><li><code>inspect</code> ：显示一个或多个 volume 的信息</li><li><code>ls</code> ：列出所有的 volume</li><li><code>prune</code> ：删除未使用的 volume</li><li><code>rm</code> ：删除一个或多个指定的 volume</li></ul><h4 id="创建和查看数据卷"><a class="header-anchor" href="#创建和查看数据卷"></a>创建和查看数据卷</h4><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create nginx-html</span><br></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect nginx-html</span><br></pre></td></tr></table></figure><p>可以看到，我们创建的 nginx-html 这个数据卷关联的宿主机目录为 <code>/var/lib/docker/volumes/nginx-html/_data</code> 目录。</p><h4 id="挂载数据卷"><a class="header-anchor" href="#挂载数据卷"></a>挂载数据卷</h4><p>我们在创建容器时，可以通过 <code>-v</code> 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name halo-nginx \</span><br><span class="line">  -v nginx-html:/usr/share/nginx/html \</span><br><span class="line">  -p 81:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><p>这里的 <code>-v</code> 就是挂载数据卷的命令。<code>-v nginx-html:/root/htm</code> ：把 nginx-html 数据卷挂载到容器内的 /root/html 这个目录中</p><p>需求：创建一个 Nginx 容器，修改容器内的 html 目录内的 index.html 内容</p><p>分析：上个案例中，我们进入 Nginx 容器内部，已经知道 Nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p><p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name halo-nginx -v nginx-html:/usr/share/nginx/html -p 81:80 -d nginx</span><br></pre></td></tr></table></figure><p>② 进入 nginx-html 数据卷所在位置，并修改 HTML 内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect nginx-html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/nginx-html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><blockquote><p>数据卷不存在会自动创建</p></blockquote><h4 id="挂载本地目录"><a class="header-anchor" href="#挂载本地目录"></a>挂载本地目录</h4><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 → 数据卷 → 容器内目录</li><li>直接挂载模式：宿主机目录 → 容器内目录</li></ul><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li><code>-v [宿主机目录]:[容器内目录]</code></li><li><code>-v [宿主机文件]:[容器内文件]</code></li></ul><p>需求：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p><ol><li><p>拉取 MySQL 镜像</p></li><li><p>创建目录 /develop/docker-volumes/halo-mysql/data</p></li><li><p>创建目录 /develop/docker-volumes/halo-mysql/conf ，并在其中创建 halo.conf，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">character_set_server&#x3D;utf8</span><br><span class="line">datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">server-id&#x3D;1000</span><br></pre></td></tr></table></figure></li><li><p>进行挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name halo-mysql \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD&#x3D;halo \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -v &#x2F;develop&#x2F;docker-volumes&#x2F;halo-mysql&#x2F;conf&#x2F;halo.conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;halo.conf \</span><br><span class="line">  -v &#x2F;develop&#x2F;docker-volumes&#x2F;halo-mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">  -d \</span><br><span class="line">  mysql:latest</span><br></pre></td></tr></table></figure></li></ol><h2 id="Dockerfile-自定义镜像"><a class="header-anchor" href="#Dockerfile-自定义镜像"></a>Dockerfile 自定义镜像</h2><h3 id="镜像结构"><a class="header-anchor" href="#镜像结构"></a>镜像结构</h3><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><ul><li>基础镜像（Base Image）：应用依赖的系统函数库、环境、配置、文件等</li><li>层（ Layer ）：在 Base Image 基础上添加安装包、依赖、配置等，每次操作都形成新的一层。</li><li>入口（Entry Point）：镜像运行入口，一般是程序启动的脚本和参数</li></ul><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。</p><h3 id="Dockerfile-语法"><a class="header-anchor" href="#Dockerfile-语法"></a>Dockerfile 语法</h3><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些 Base Image、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。</p><p>而描述上述信息的文件就是 Dockerfile 文件。</p><p>Dockerfile 就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p><table><thead><tr><th>指令</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>FROM</td><td>指定基础镜像</td><td><code>FROM centos:6</code></td></tr><tr><td>ENV</td><td>设置环境变量，可在后面指令使用</td><td><code>ENV key value</code></td></tr><tr><td>COPY</td><td>拷贝本地文件到镜像的指定目录</td><td><code>COPY ./mysql-5.7.rpm /tmp</code></td></tr><tr><td>RUN</td><td>执行 Linux 的 shell 命令，一般是安装过程的命令</td><td><code>RUN yum install gcc</code></td></tr><tr><td>EXPOSE</td><td>指定容器运行时监听的端口，是给镜像使用者看的</td><td><code>EXPOSE 8080</code></td></tr><tr><td>ENTRYPOINT</td><td>镜像中应用的启动命令，容器运行时调用</td><td><code>ENTRYPOINT java -jar xx.jar</code></td></tr></tbody></table><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p><h3 id="直接构建-Java-项目"><a class="header-anchor" href="#直接构建-Java-项目"></a>直接构建 Java 项目</h3><p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 Java 项目</p><ol><li><p>Linux 下新建一个空文件夹 docker-demo</p></li><li><p>拷贝 docker-demo.jar 文件到 docker-demo 这个目录</p></li><li><p>拷贝 jdk8.tar.gz 文件到 docker-demo 这个目录</p></li><li><p>拷贝 Dockerfile 到 docker-demo 这个目录，其中的内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="bash"> &amp;&amp; mv ./jdk1.8.0_144 ./java8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li><li><p>进入 docker-demo ，运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 .</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p></li></ol><h3 id="基于-java8-alpine-构建-Java-项目"><a class="header-anchor" href="#基于-java8-alpine-构建-Java-项目"></a>基于 java8-alpine  构建 Java 项目</h3><p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p><p>例如，构建 Java 项目的镜像，可以在已经准备了JDK 的基础镜像基础上构建。</p><p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p><p>实现思路如下：</p><ul><li><p>新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</p></li><li><p>拷贝 docker-demo.jar 到这个目录中</p></li><li><p>编写 Dockerfile 文件，内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./app.jar /tmp/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8090</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /tmp/app.jar</span></span><br></pre></td></tr></table></figure></li><li><p>进入 docker-demo ，运行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:2.0 .</span><br></pre></td></tr></table></figure></li></ul><h3 id="Dockerfile-小结"><a class="header-anchor" href="#Dockerfile-小结"></a>Dockerfile 小结</h3><ol><li><p>Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程</p></li><li><p>Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建</p></li><li><p>基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p></li></ol><h2 id="Docker-Compose"><a class="header-anchor" href="#Docker-Compose"></a>Docker Compose</h2><p>Docker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器。</p><h3 id="初识-Docker-Compose"><a class="header-anchor" href="#初识-Docker-Compose"></a>初识 Docker Compose</h3><p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"> services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql:5.7.25</span><br><span class="line">    environment:</span><br><span class="line">     MYSQL_ROOT_PASSWORD: 123 </span><br><span class="line">    volumes:</span><br><span class="line">     - &quot;/tmp/mysql/data:/var/lib/mysql&quot;</span><br><span class="line">     - &quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - &quot;8090:8090&quot;</span><br></pre></td></tr></table></figure><p>上面的 Compose 文件就描述一个项目，其中包含两个容器：</p><ul><li>mysql：一个基于 <code>mysql:5.7.25</code> 镜像构建的容器，并且挂载了两个目录</li><li>web：一个基于 <code>docker build</code> 临时构建的镜像容器，映射端口时 8090</li></ul><p>Docker Compose 的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p><p>其实 Docker Compose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p><h3 id="安装-Docker-Compose"><a class="header-anchor" href="#安装-Docker-Compose"></a>安装 Docker Compose</h3><ol><li><p>下载 docker-compose，Linux 下需要通过命令下载（速度较慢）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></li><li><p>修改文件权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></li></ol><p>配置 Base 自动补全命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>如果这里出现错误，需要修改自己的 hosts 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h3 id="部署微服务集群"><a class="header-anchor" href="#部署微服务集群"></a>部署微服务集群</h3><p>需求：将之前学习的 spring-cloud-demo 微服务集群利用 Docker Compose 部署</p><p>实现思路：</p><ol><li>编写 docker-compose 文件</li><li>修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</li><li>使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</li><li>将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中</li><li>到 cloud-demo 目录，利用 <code>docker-compose up -d</code> 来部署</li></ol><h2 id="Docker-镜像仓库"><a class="header-anchor" href="#Docker-镜像仓库"></a>Docker 镜像仓库</h2><h3 id="搭建私有镜像仓库"><a class="header-anchor" href="#搭建私有镜像仓库"></a>搭建私有镜像仓库</h3><p>搭建镜像仓库可以基于 Docker 官方提供的 Docker Registry 来实现。</p><p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p><h4 id="简化版镜像仓库"><a class="header-anchor" href="#简化版镜像仓库"></a>简化版镜像仓库</h4><p>Docker 官方的 Docker Registry 是一个基础版本的 Docker 镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p><p>搭建方式比较简单，命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure><p>命令中挂载了一个数据卷 registry-data 到容器内的 /var/lib/registry 目录，这是私有镜像库存放数据的目录。</p><p>访问 <a href="http://halo:5000/v2/_catalog">http://halo:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p><h4 id="带有图形化界面版本"><a class="header-anchor" href="#带有图形化界面版本"></a>带有图形化界面版本</h4><p>使用 Docker Compose 部署带有图象界面的 Docker Registry，命令如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8181</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=Halo-Docker-Registry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure><p>配置 Docker 信任地址，私服采用的是 http 协议，默认不被 Docker 信任，所以需要做一个配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://halo:8181&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="推送、拉取镜像"><a class="header-anchor" href="#推送、拉取镜像"></a>推送、拉取镜像</h3><p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p><p>① 重新 tag 本地镜像，名称前缀为私有仓库的地址：halo:8181/</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest halo:8181/nginx:1.0 </span><br></pre></td></tr></table></figure><p>② 推送镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push halo:8181/nginx:1.0 </span><br></pre></td></tr></table></figure><p>③ 拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull halo:8181&#x2F;nginx:1.0 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识-Docker&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#初识-Docker&quot;&gt;&lt;/a&gt;初识 Docker&lt;/h2&gt;
&lt;h3 id=&quot;什么是-Docker&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#什么是-Doc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ 入门</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/C_RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/C_RabbitMQ%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.806Z</published>
    <updated>2021-09-20T06:01:06.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识-RabbitMQ"><a class="header-anchor" href="#初识-RabbitMQ"></a>初识 RabbitMQ</h2><h3 id="同步和异步通讯"><a class="header-anchor" href="#同步和异步通讯"></a>同步和异步通讯</h3><p>微服务间通讯有同步和异步两种方式：</p><ul><li>同步通讯：就像打电话，需要实时响应。</li><li>异步通讯：就像发邮件，不需要马上回复。</li></ul><h4 id="同步通讯"><a class="header-anchor" href="#同步通讯"></a>同步通讯</h4><p>我们之前学习的 Feign 调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p><ul><li>耦合度高：每次加入新的需求，都要修改原来的代码</li><li>性能下降：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li><li>资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li><li>级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li></ul><h4 id="异步通讯"><a class="header-anchor" href="#异步通讯"></a>异步通讯</h4><p>异步调用则可以避免上述问题：</p><p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p><ul><li>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单 id。</li><li>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</li><li>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到 Broker，不关心谁来订阅事件。订阅者从 Broker 订阅事件，不关心谁发来的消息。</li></ul><p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p><p>异步通讯的优点：</p><ul><li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p></li><li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p></li><li><p>调用间没有阻塞，不会造成无效的资源占用</p></li><li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p></li><li><p>流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件</p></li></ul><p>异步通讯的缺点：</p><ul><li>架构复杂了，业务没有明显的流程线，不好管理</li><li>需要依赖于 Broker 的可靠、安全、性能</li></ul><h3 id="技术对比"><a class="header-anchor" href="#技术对比"></a>技术对比</h3><p>MQ，中文是消息队列（Message Queue），字面来看就是存放消息的队列。也就是事件驱动架构中的 Broker。</p><p>比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见 MQ 的对比：</p><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala &amp; Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire，STOMP，REST，XMPP，AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><h2 id="RabbitMQ-快速入门"><a class="header-anchor" href="#RabbitMQ-快速入门"></a>RabbitMQ 快速入门</h2><p>RabbitMQ 是基于 Erlang 语言开发的开源消息通信中间件，官网地址：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><h3 id="安装-RabbitMQ"><a class="header-anchor" href="#安装-RabbitMQ"></a>安装 RabbitMQ</h3><p>在 Centos 7 虚拟机中使用 Docker 来安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>执行下面的命令来运行 MQ 容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER&#x3D;halo \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS&#x3D;halo \</span><br><span class="line"> --name halo-rabbitmq-1 \</span><br><span class="line"> --hostname halo-rabbitmq-1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h3 id="RabbitMQ-的基本结构"><a class="header-anchor" href="#RabbitMQ-的基本结构"></a>RabbitMQ 的基本结构</h3><p>RabbitMQ 的基本结构：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%A6%82%E5%BF%B5.5365ey5rjww0.svg" alt="RabbitMQ的结构和概念"></p><p>RabbitMQ 中的一些角色：</p><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的 exchange、queue、消息的隔离</li></ul><h3 id="RabbitMQ-消息模型"><a class="header-anchor" href="#RabbitMQ-消息模型"></a>RabbitMQ 消息模型</h3><p><a href="https://www.rabbitmq.com/getstarted.html">RabbitMQ 官方</a> 提供了 5 个不同的 Demo 示例，对应了不同的消息模型：</p><ul><li>基本消息队列（Basic Queue）</li><li>工作消息队列（Work Queue）</li><li>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：<ul><li>Fanout Exchange：广播</li><li>Direct Exchange：路由</li><li>Topic Exchange：主题</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.1fiomitimbsw.png" alt="RabbitMQ消息模型"></p><h3 id="Hello-World-案例"><a class="header-anchor" href="#Hello-World-案例"></a>Hello World 案例</h3><p>官方的 HelloWorld 是基于最基础的消息队列模型来实现的，只包括三个角色：</p><p>•publisher：消息发布者，将消息发送到队列 queue</p><p>•queue：消息队列，负责接受并缓存消息</p><p>•consumer：订阅队列，处理队列中的消息</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld%E6%A1%88%E4%BE%8B.zb6pinalxzk.svg" alt="HelloWorld案例"></p><p>publisher 实现思路：</p><ul><li>建立连接</li><li>创建 Channel</li><li>声明队列</li><li>发送消息</li><li>关闭连接和 Channel</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PublisherTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.发送消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, rabbitmq!&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">&quot;发送消息成功：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consumer 实现思路：</p><ul><li>建立连接</li><li>创建 Channel</li><li>声明队列</li><li>订阅消息</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.建立连接</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span></span><br><span class="line">        factory.setHost(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        factory.setUsername(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        factory.setPassword(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2.建立连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建通道Channel</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建队列</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.订阅消息</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// 5.处理消息</span></span><br><span class="line">                String message = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">&quot;接收到消息：【&quot;</span> + message + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收消息。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本消息队列的消息发送流程：</p><ol><li><p>建立 connection</p></li><li><p>创建 channel</p></li><li><p>利用 channel 声明队列</p></li><li><p>利用 channel 向队列发送消息</p></li></ol><p>基本消息队列的消息接收流程：</p><ol><li><p>建立 connection</p></li><li><p>创建 channel</p></li><li><p>利用 channel 声明队列</p></li><li><p>定义 consumer 的消费行为 <code>handleDelivery()</code></p></li><li><p>利用 channel 将消费者与队列绑定</p></li></ol><h2 id="Spring-AMQP"><a class="header-anchor" href="#Spring-AMQP"></a>Spring AMQP</h2><p>Spring AMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 Spring Boot 对其实现了自动装配，使用起来非常方便。</p><p>Spring AMQP 的官方地址：<a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a></p><p>AMQP ：Advanced Message Queuing Protocol，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p><p>Spring AMQP ：Spring AMQP 是基于 AMQP 协议定义的一套 API 规范，提供了模板来发送和接收消息。包含两部分，其中 spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现。</p><p>Spring AMQP 提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了 RabbitTemplate 工具，用于发送消息</li></ul><h3 id="Basic-Queue-基本消息队列"><a class="header-anchor" href="#Basic-Queue-基本消息队列"></a>Basic Queue 基本消息队列</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld%E6%A1%88%E4%BE%8B.zb6pinalxzk.svg" alt="HelloWorld案例"></p><p>流程如下：</p><ul><li>在父工程中引入 spring-amqp 的依赖</li><li>在 publisher 服务中利用 RabbitTemplate 发送消息到 simple.queue 这个队列</li><li>在 consumer 服务中编写消费逻辑，绑定 simple.queue 这个队列</li></ul><h4 id="引入依赖"><a class="header-anchor" href="#引入依赖"></a>引入依赖</h4><p>在父工程 mq-demo 中引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="消息发送"><a class="header-anchor" href="#消息发送"></a>消息发送</h4><p>首先配置 RabbitMQ 地址，在 publisher 服务的 application.yml 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">halo</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">halo</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">halo</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在 publisher 服务中编写测试类 <code>SpringAmqpTest</code>，并利用 RabbitTemplate 实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.spring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAmqpTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimpleQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        String message = <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收"><a class="header-anchor" href="#消息接收"></a>消息接收</h4><p>首先配置 RabbitMQ 地址，在 consumer 服务的 application.yml 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">halo</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">halo</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">halo</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在 consumer 服务的 <code>cn.itcast.mq.listener</code> 包中新建一个类 <code>SpringRabbitListener</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringRabbitListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：消息一旦消费就会从队列删除，RabbitMQ 没有消息回溯功能</p><h3 id="Work-Queue-工作队列"><a class="header-anchor" href="#Work-Queue-工作队列"></a>Work Queue 工作队列</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/WorkQueue%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.3xixqzsmydc0.svg" alt="WorkQueue工作队列"></p><p>Work Queue，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。</p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p><p>基本思路如下：</p><ol><li>在 publisher 服务中定义测试方法，每秒产生 50 条消息，发送到 simple.queue</li><li>在 consumer 服务中定义两个消息监听者，都监听 simple.queue 队列</li><li>消费者 1 每秒处理 50 条消息，消费者 2 每秒处理 10 条消息</li></ol><h4 id="消息发送-v2"><a class="header-anchor" href="#消息发送-v2"></a>消息发送</h4><p>这次我们循环发送，模拟大量消息堆积现象。</p><p>在 publisher 服务中的 SpringAmqpTest 类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收-v2"><a class="header-anchor" href="#消息接收-v2"></a>消息接收</h4><p>要模拟多个消费者绑定同一个队列，我们在 consumer 服务的 <code>SpringRabbitListener</code> 中添加 2 个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者-[1]-接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者-[2]-接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试分析"><a class="header-anchor" href="#测试分析"></a>测试分析</h4><p>启动 <code>ConsumerApplication</code> 后，在执行 publisher 服务中刚刚编写的发送测试方法 <code>testWorkQueue</code>。</p><p>可以看到消费者 1 很快完成了自己的 25 条消息。消费者 2 却在缓慢的处理自己的 25 条消息。</p><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p><h4 id="能者多劳"><a class="header-anchor" href="#能者多劳"></a>能者多劳</h4><p>在 spring 中有一个简单的配置，可以解决这个问题。我们修改 consumer 服务的 application.yml 文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>设置 <code>preFetch</code> 这个值，可以控制预取消息的上限：</p><h3 id="发布与订阅"><a class="header-anchor" href="#发布与订阅"></a>发布与订阅</h3><p>发布订阅的模型如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.g64vagn8am0.svg" alt="发布订阅模式"></p><p>可以看到，在订阅模型中，多了一个 exchange 角色，而且过程略有变化：</p><ul><li>Publisher（生产者）：也就是要发送消息的程序，但是不再发送到队列中，而是发给 exchange</li><li>Exchange（交换机）：一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange 的类型。Exchange 有以下 3 种类型：<ul><li>Fanout：广播，将消息交给所有绑定到交换机的队列</li><li>Direct：定向，把消息交给符合指定 routing key 的队列</li><li>Topic：通配符，把消息交给符合 routing pattern（路由模式） 的队列</li></ul></li><li>Consumer：消费者，与以前一样，订阅队列，没有变化</li><li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li></ul><p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><h3 id="Fanout-Exchange"><a class="header-anchor" href="#Fanout-Exchange"></a>Fanout Exchange</h3><p>Fanout，英文翻译是扇出，在 MQ 中叫广播更合适。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Fanout.5ru00gaykjs0.svg" alt="Fanout"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>可以有多个队列</li><li>每个队列都要绑定到 Exchange</li><li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li><li>交换机把消息发送给绑定过的所有队列</li><li>订阅队列的消费者都能拿到消息</li></ul><p>利用 Spring AMQP 演示 Fanout Exchange 的使用，实现思路如下：</p><ol><li>在 consumer 服务中，利用代码声明队列、交换机（halo.fanout），并将两者绑定</li><li>在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2</li><li>在 publisher 中编写测试方法，向 halo.fanout 发送消息</li></ol><h4 id="声明队列和交换机"><a class="header-anchor" href="#声明队列和交换机"></a>声明队列和交换机</h4><p>Spring 提供了一个接口 Exchange，来表示所有不同类型的交换机：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1jmh85mmwahs.png" alt="image"></p><p>在 consumer 中创建一个类，声明 Exchange、Queue、Binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanoutConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">fanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">&quot;halo.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">fanoutQueue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息发送-v3"><a class="header-anchor" href="#消息发送-v3"></a>消息发送</h4><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFanoutExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;halo.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收-v3"><a class="header-anchor" href="#消息接收-v3"></a>消息接收</h4><p>在 consumer 服务的 <code>SpringRabbitListener</code> 中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者-[1]-接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenFanoutQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者-[2]-接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fanout-Exchange-小结"><a class="header-anchor" href="#Fanout-Exchange-小结"></a>Fanout Exchange 小结</h4><p>交换机的作用是什么？</p><ul><li>接收 publisher 发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>Fanout Exchange 的会将消息路由到每个绑定的队列</li></ul><p>声明队列、交换机、绑定关系的 Bean 是什么？</p><ul><li>Queue</li><li>Fanout Exchange</li><li>Binding</li></ul><h3 id="Direct-Exchange"><a class="header-anchor" href="#Direct-Exchange"></a>Direct Exchange</h3><p>在 Fanout 模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 Direct 类型的 Exchange。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/DirectExchange.1xsf8z6diw00.svg" alt="DirectExchange"></p><p>Direct Exchange 会将接收到的消息根据规则路由到指定的 Queue，因此称为路由模式（routes）。</p><ul><li>每一个 Queue 都与 Exchange 设置一个 BindingKey</li><li>发布者发送消息时，指定消息的 RoutingKey</li><li>Exchange 将消息路由到 BindingKey 与消息 RoutingKey 一致的队列</li></ul><p>案例需求如下：</p><ul><li>利用 <code>@RabbitListener</code> 声明 Exchange、Queue、RoutingKey</li><li>在 consumer 服务中，编写两个消费者方法，分别监听 direct.queue1 和 direct.queue2</li><li>在 publisher 中编写测试方法，向 halo.direct发送消息</li></ul><h4 id="消息发送-v4"><a class="header-anchor" href="#消息发送-v4"></a>消息发送</h4><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendDirectExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;halo.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;halo-direct-red&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;halo-direct-yellow&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;halo-direct-blue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于注解声明队列和交换机"><a class="header-anchor" href="#基于注解声明队列和交换机"></a>基于注解声明队列和交换机</h4><p>基于 <code>@Bean</code> 的方式声明队列和交换机比较麻烦，Spring 还提供了基于注解方式来声明。</p><p>在 consumer 的 SpringRabbitListener 中添加两个消费者，同时基于注解来声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;halo.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue1</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;halo.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenDirectQueue2</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct-Exchange-小结"><a class="header-anchor" href="#Direct-Exchange-小结"></a>Direct Exchange 小结</h4><p>描述下 Direct 交换机与 Fanout 交换机的差异？</p><ul><li>Fanout 交换机将消息路由给每一个与之绑定的队列</li><li>Direct 交换机根据 Routing Key 判断路由给哪个队列</li><li>如果多个队列具有相同的 Routing Key，则与 Fanout 功能类似</li></ul><p>基于 <code>@RabbitListener</code> 注解声明队列和交换机有哪些常见注解？</p><ul><li><code>@Queue</code></li><li><code>@Exchange</code></li></ul><h3 id="Topic-Exchange"><a class="header-anchor" href="#Topic-Exchange"></a>Topic Exchange</h3><p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 Routing Key 把消息路由到不同的队列。</p><p>只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符！</p><p>Routing Key 一般都是有一个或多个单词组成，多个单词之间以 <code>.</code> 分割，例如：item.insert</p><p>通配符规则：</p><p><code>#</code>：匹配一个或多个词</p><p><code>*</code>：匹配不多不少恰好 1 个词</p><p>举例：</p><p><code>item.#</code>：能够匹配 <code>item.spu.insert</code> 或者 <code>item.spu</code></p><p><code>item.*</code>：只能匹配 <code>item.spu</code></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Topic.60w0j0blgsw0.svg" alt="Topic"></p><ul><li>Queue1：绑定的是 <code>china.#</code> ，因此凡是以 <code>china.</code> 开头的 Routing Key 都会被匹配到。包括<code>china.news</code> 和 <code>china.weather</code></li><li>Queue2：绑定的是 <code>#.news</code> ，因此凡是以 <code>.news</code> 结尾的 Routing Key 都会被匹配。包括 <code>china.news</code> 和 <code>japan.news</code></li><li>其他队列同理</li></ul><p>实现思路如下：</p><ol><li><p>利用 <code>@RabbitListener</code> 声明 Exchange、Queue、RoutingKey</p></li><li><p>在 consumer 服务中，编写两个消费者方法，分别监听 topic.queue1 和 topic.queue2</p></li><li><p>在 publisher 中编写测试方法，向 halo. topic发送消息</p></li></ol><h4 id="消息发送-v5"><a class="header-anchor" href="#消息发送-v5"></a>消息发送</h4><p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendTopicExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    String exchangeName = <span class="string">&quot;itcast.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    String message = <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收-v4"><a class="header-anchor" href="#消息接收-v4"></a>消息接收</h4><p>在 consumer 服务的 SpringRabbitListener 中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;halo.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue1</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;halo.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenTopicQueue2</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a class="header-anchor" href="#消息转换器"></a>消息转换器</h3><p>之前说过，Spring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。</p><p>只不过，默认情况下 Spring 采用的序列化方式是 JDK 序列化。众所周知，JDK 序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><h4 id="测试默认转换器"><a class="header-anchor" href="#测试默认转换器"></a>测试默认转换器</h4><p>我们修改消息发送的代码，发送一个 Map 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSendMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    String queueName = <span class="string">&quot;object.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String, Object&gt; msg = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(queueName, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jjb6wxbs120.png" alt="image"></p><p>Spring 的对消息对象的处理是由 <code>org.springframework.amqp.support.converter.MessageConverter</code> 来处理的。而默认实现是 <code>SimpleMessageConverter</code>，基于 JDK 的 <code>ObjectOutputStream</code> 完成序列化。</p><h4 id="配置-JSON-转换器"><a class="header-anchor" href="#配置-JSON-转换器"></a>配置 JSON 转换器</h4><p>显然，JDK 序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用 JSON 方式来做序列化和反序列化。如果要修改只需要定义一个 <code>MessageConverter</code> 类型的Bean即可，步骤如下：</p><p>在 publisher 和 consumer 两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器。</p><p>在启动类中添加一个 Bean 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初识-RabbitMQ&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#初识-RabbitMQ&quot;&gt;&lt;/a&gt;初识 RabbitMQ&lt;/h2&gt;
&lt;h3 id=&quot;同步和异步通讯&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#同步和异</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>微服务入门</title>
    <link href="https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/A_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/"/>
    <id>https://whl123456.top/2021/09/20/WebBackEnd/%E5%BE%AE%E6%9C%8D%E5%8A%A1/A_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-20T05:57:08.790Z</published>
    <updated>2021-09-20T05:58:01.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="认识微服务"><a class="header-anchor" href="#认识微服务"></a>认识微服务</h2><h3 id="单体架构与分布式架构"><a class="header-anchor" href="#单体架构与分布式架构"></a>单体架构与分布式架构</h3><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点是架构简单、部署成本低，但耦合度高（维护困难、升级困难）</p><p>分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。降低了服务耦合，有利于服务升级和拓展，但服务调用关系错综复杂</p><p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p><ul><li>服务拆分的粒度如何界定？</li><li>服务之间如何调用？</li><li>服务的调用关系如何管理？</li></ul><p>人们需要制定一套行之有效的标准来约束分布式架构。</p><h3 id="微服务"><a class="header-anchor" href="#微服务"></a>微服务</h3><p>微服务的架构特征：</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li><li>自治：团队独立、技术独立、数据独立，独立部署和交付</li><li>面向服务：服务提供统一标准的接口，与语言和技术无关</li><li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li></ul><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</p><p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p><p>其中在 Java 领域最引人注目的就是 Spring Cloud 提供的方案了。</p><h3 id="Spring-Cloud"><a class="header-anchor" href="#Spring-Cloud"></a>Spring Cloud</h3><p>Spring Cloud 是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>Spring Cloud 集成了各种微服务功能组件，并基于 Spring Boot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/SpringCloud%E7%BB%84%E4%BB%B6.1y5f5er0mdkw.svg" alt="SpringCloud组件"></p><p>另外，Spring Cloud 底层是依赖于 Spring Boot 的，并且有版本的兼容关系，如下：</p><p><img src="https://pic.imgdb.cn/item/6133818144eaada739d722b1.jpg" alt="SpringBoot与SpringCloud"></p><h3 id="认识微服务小结"><a class="header-anchor" href="#认识微服务小结"></a>认识微服务小结</h3><ul><li>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</li><li>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</li><li>微服务：一种良好的分布式架构方案<ul><li>优点：拆分粒度更小、服务更独立、耦合度更低</li><li>缺点：架构非常复杂，运维、监控、部署难度提高</li></ul></li><li>Spring Cloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</li></ul><h2 id="服务拆分和远程调用"><a class="header-anchor" href="#服务拆分和远程调用"></a>服务拆分和远程调用</h2><h3 id="服务拆分原则"><a class="header-anchor" href="#服务拆分原则"></a>服务拆分原则</h3><p>微服务拆分时的几个原则：</p><ul><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ul><h3 id="服务拆分示例"><a class="header-anchor" href="#服务拆分示例"></a>服务拆分示例</h3><p>以 spring-cloud-demo 为例，其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring-cloud-demo</span><br><span class="line"> ├── order-service</span><br><span class="line"> └── user-service</span><br></pre></td></tr></table></figure><p>spring-cloud-demo：父工程，管理依赖</p><ul><li>order-service：订单微服务，负责订单相关业务</li><li>user-service：用户微服务，负责用户相关业务</li></ul><p>要求：</p><ul><li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li><li>订单服务和用户服务都对外暴露 Restful 的接口</li><li>订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库</li></ul><p>初始项目代码：<a href="https://github.com/Lanqilu/HaloSpringCloud/releases/tag/v0.1">链接</a></p><h3 id="实现远程调用案例"><a class="header-anchor" href="#实现远程调用案例"></a>实现远程调用案例</h3><h4 id="案例需求"><a class="header-anchor" href="#案例需求"></a>案例需求</h4><p>修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。</p><p>因此，我们需要在 order-service 中向 user-service 发起一个 http 的请求，调用 <code>http://localhost:8081/user/&#123;userId&#125;</code> 这个接口。</p><p>大概的步骤是这样的：</p><ul><li>注册一个 RestTemplate 的实例到 Spring 容器</li><li>修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User</li><li>将查询的 User 填充到 Order 对象，一起返回</li></ul><h4 id="注册-RestTemplate"><a class="header-anchor" href="#注册-RestTemplate"></a>注册 RestTemplate</h4><p>首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现远程调用"><a class="header-anchor" href="#实现远程调用"></a>实现远程调用</h4><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">queryOrderById</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    Order order = orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 利用 RestTemplate 发起 http 请求，查询用户</span></span><br><span class="line">    String url = <span class="string">&quot;http://localhost:8081/user/&quot;</span> + order.getUserId();</span><br><span class="line">    User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 3. 封装 user 到 Order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：<a href="https://github.com/Lanqilu/HaloSpringCloud/tree/44482f1ec6618da6ee5805fbbdc5c0c2464725bb">链接</a></p><h3 id="提供者与消费者"><a class="header-anchor" href="#提供者与消费者"></a>提供者与消费者</h3><p>在服务调用关系中，会有两个不同的角色：</p><ul><li>服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</li><li>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</li></ul><p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。如果服务 A 调用了服务 B，而服务B又调用了服务 C，服务 B 的角色是什么？</p><ul><li>对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者</li><li>对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者</li></ul><p>因此，服务 B 既可以是服务提供者，也可以是服务消费者。</p><h2 id="Eureka-注册中心"><a class="header-anchor" href="#Eureka-注册中心"></a>Eureka 注册中心</h2><p>以上实例存在的问题：</p><ul><li>order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？</li><li>有多个 user-service 实例地址，order-service 调用时该如何选择？</li><li>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</li></ul><h3 id="Eureka-的结构和作用"><a class="header-anchor" href="#Eureka-的结构和作用"></a>Eureka 的结构和作用</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Eureka%E7%9A%84%E4%BD%9C%E7%94%A8.mzzzu1u538w.svg" alt="Eureka的作用"></p><p>问题1：order-service 如何得知 user-service 实例地址？获取地址信息的流程如下：</p><ul><li>user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册</li><li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li><li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li></ul><p>问题2：order-service 如何从多个 user-service 实例中选择具体的实例？</p><ul><li>order-service 从实例列表中利用负载均衡算法选中一个实例地址</li><li>向该实例地址发起远程调用</li></ul><p>问题3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</p><ul><li>user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳</li><li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li><li>order-service 拉取服务时，就能将故障实例排除了</li></ul><p>在 Eureka 架构中，微服务角色有两类：</p><ul><li>EurekaServer：服务端，注册中心。记录服务信息、心跳监控</li><li>EurekaClient：客户端<ul><li>Provider：服务提供者，例如案例中的 user-service。注册自己的信息到 EurekaServer、每隔 30 秒向 EurekaServer 发送心跳</li><li>Consumer：服务消费者，例如案例中的 order-service 根据服务名称从 EurekaServer 拉取服务列表基于服务列表做负载均衡，选中一个微服务后发起远程调用</li></ul></li></ul><blockquote><p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了eureka-client 端</p></blockquote><p>eureka 服务注册分为以下步骤：</p><ul><li>搭建注册中心：搭建 EurekaServer</li><li>服务注册：将 user-service、order-service 都注册到 eureka</li><li>服务发现：在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</li></ul><h3 id="搭建-eureka-server"><a class="header-anchor" href="#搭建-eureka-server"></a>搭建 eureka-server</h3><p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p><p>创建 eureka-server 服务，在 spring-cloud-demo 父工程下，创建 eureka-server Maven 子模块</p><p>引入 eureka 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写启动类"><a class="header-anchor" href="#编写启动类"></a>编写启动类</h4><p>给 eureka-server 服务编写一个启动类，一定要添加一个 <code>@EnableEurekaServer</code> 注解，开启 eureka 的注册中心功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写配置文件"><a class="header-anchor" href="#编写配置文件"></a>编写配置文件</h4><p>编写一个 application.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10086</span> <span class="comment"># 服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span> <span class="comment"># 服务名称 必须</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># eureka 的地址信息</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><h4 id="启动服务"><a class="header-anchor" href="#启动服务"></a>启动服务</h4><p>启动微服务，然后在浏览器访问：<a href="http://127.0.0.1:10086">http://127.0.0.1:10086</a></p><p>看到下面结果应该是成功了：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3fxbktup2b40.png" alt="image"></p><p>代码：<a href="https://github.com/Lanqilu/HaloSpringCloud/tree/6485893c857e8407573b163f91fd7b6b7cfd4cfe">链接</a></p><h3 id="Eureka-服务注册"><a class="header-anchor" href="#Eureka-服务注册"></a>Eureka 服务注册</h3><p>下面，我们将 user-service 注册到 eureka-server 中去</p><h4 id="引入依赖"><a class="header-anchor" href="#引入依赖"></a>引入依赖</h4><p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="修改配置文件"><a class="header-anchor" href="#修改配置文件"></a>修改配置文件</h4><p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>用同样的方法可以注册 order-service</p><h4 id="启动多个-user-service-实例"><a class="header-anchor" href="#启动多个-user-service-实例"></a>启动多个 user-service 实例</h4><p>为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。</p><p>首先，复制原来的 user-service 启动配置：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1oxav2o4lv7k.png" alt="image"></p><p>然后，在弹出的窗口中，填写信息：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.acb3rk5x180.png" alt="image"></p><p>启动两个 user-service 实例后，查看 eureka-server 管理页面：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4tnhuetb1yc0.png" alt="image"></p><h3 id="Eureka-服务发现"><a class="header-anchor" href="#Eureka-服务发现"></a>Eureka 服务发现</h3><p>下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。</p><h4 id="引入依赖和修改配置文件"><a class="header-anchor" href="#引入依赖和修改配置文件"></a>引入依赖和修改配置文件</h4><p>之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。</p><h4 id="服务拉取和负载均衡"><a class="header-anchor" href="#服务拉取和负载均衡"></a>服务拉取和负载均衡</h4><p>去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。</p><p>在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个 <code>@LoadBalanced</code> 注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 RestTemplate 并注入容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">queryOrderById</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    Order order = orderMapper.findById(orderId);</span><br><span class="line">    <span class="comment">// 2. 利用 RestTemplate 发起 http 请求，查询用户</span></span><br><span class="line">    String url = <span class="string">&quot;http://user-service/user/&quot;</span> + order.getUserId();</span><br><span class="line">    User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="comment">// 3. 封装 user 到 Order</span></span><br><span class="line">    order.setUser(user);</span><br><span class="line">    <span class="comment">// 4.返回</span></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡（默认轮询）。</p><h3 id="Eureka-注册中心小结"><a class="header-anchor" href="#Eureka-注册中心小结"></a>Eureka 注册中心小结</h3><ol><li>搭建 EurekaServer<ul><li>引入 eureka-server 依赖</li><li>添加 <code>@EnableEurekaServer</code> 注解</li><li>在 application.yml 中配置 eureka 地址</li></ul></li><li>服务注册<ul><li>引入 eureka-client 依赖</li><li>在 application.yml 中配置 eureka 地址</li></ul></li><li>服务发现<ul><li>引入 eureka-client 依赖</li><li>在 application.yml 中配置 eureka 地址</li><li>给 RestTemplate 添加 <code>@LoadBalanced</code> 注解</li><li>用服务提供者的服务名称远程调用</li></ul></li></ol><h2 id="Ribbon-负载均衡"><a class="header-anchor" href="#Ribbon-负载均衡"></a>Ribbon 负载均衡</h2><p>上一节中，我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h3 id="负载均衡原理"><a class="header-anchor" href="#负载均衡原理"></a>负载均衡原理</h3><p>Spring Cloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B.2mk0jmuwdoq0.svg" alt="Ribbon负载均衡流程"></p><h3 id="源码跟踪"><a class="header-anchor" href="#源码跟踪"></a>源码跟踪</h3><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是 <code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h4 id="LoadBalancerIntercepor"><a class="header-anchor" href="#LoadBalancerIntercepor"></a>LoadBalancerIntercepor</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5mxujbposco0.png" alt="image"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p><ul><li><code>request.getURI()</code>：获取请求 url，本例中就是 <a href="http://user-service/user/8">http://user-service/user/8</a></li><li><code>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code>user-service</code></li><li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li></ul><p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型，我们继续跟入。</p><h4 id="LoadBalancerClient"><a class="header-anchor" href="#LoadBalancerClient"></a>LoadBalancerClient</h4><p>继续跟入 execute 方法：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.66vjvvg0xn40.png" alt="image"></p><p>代码是这样的：</p><ul><li><code>getLoadBalancer(serviceId)</code>：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li><li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8081端口的服务</li></ul><h4 id="负载均衡策略-IRule"><a class="header-anchor" href="#负载均衡策略-IRule"></a>负载均衡策略 IRule</h4><p>在刚才的代码中，可以看到获取服务使通过一个 <code>getServer</code> 方法来做负载均衡:</p><p>我们继续跟入：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3vkjab3blgm0.png" alt="image"></p><p>继续跟踪源码 chooseServer 方法，发现调用父类中 BaseLoadBalancer 一段代码：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4ks2tojsyxe0.png" alt="image"></p><p>我们看看这个 rule 是谁：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jcbindlmai0.png" alt="image"></p><p>默认是使用轮询，到这里，整个负载均衡的流程我们就清楚了。</p><h4 id="负载均衡原理源码分析小结"><a class="header-anchor" href="#负载均衡原理源码分析小结"></a>负载均衡原理源码分析小结</h4><p>Spring Cloud Ribbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。基本流程如下：</p><ul><li>拦截我们的 RestTemplate 请求 <a href="http://userservice/user/1">http://userservice/user/1</a></li><li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li><li>DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表</li><li>eureka 返回列表，localhost:8081、localhost:8082</li><li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li><li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li></ul><h3 id="负载均衡策略"><a class="header-anchor" href="#负载均衡策略"></a>负载均衡策略</h3><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.61x1c4fc6pg0.png" alt="image"></p><p>常见的不同规则的含义如下：</p><ol><li>RoundRobinRule：  简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</li><li>AvailabilityFilteringRule：对以下两种服务器进行忽略<ul><li>在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。</li><li>并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit </code>属性进行配置。</li></ul></li><li>WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</li><li>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</li><li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器。</li><li>RandomRule：随机选择一个可用的服务器。</li><li>RetryRule：  重试机制的选择逻辑</li></ol><p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p><h4 id="自定义负载均衡策略"><a class="header-anchor" href="#自定义负载均衡策略"></a>自定义负载均衡策略</h4><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><p>代码方式：在 order-service 中的 OrderApplication 类（或配置类）中，定义一个新的 IRule：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">randomRule</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span> <span class="comment"># 给某个微服务配置负载均衡规则，这里是user-service服务</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><p>代码方式针对全局，配置文件方式可以对某个服务进行配置</p><p>一般用默认的负载均衡规则，不做修改。</p><h4 id="饥饿加载"><a class="header-anchor" href="#饥饿加载"></a>饥饿加载</h4><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span> </span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启饥饿加载</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">user-service</span> <span class="comment"># 指定对 user-service 这个服务进行加载</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon-负载均衡小结"><a class="header-anchor" href="#Ribbon-负载均衡小结"></a>Ribbon 负载均衡小结</h3><ol><li>Ribbon 负载均衡规则：<ul><li>规则接口是 IRule</li><li>默认实现是 ZoneAvoidanceRule，根据 zone 选择服务列表，然后轮询</li></ul></li><li>负载均衡自定义方式：<ul><li>代码方式：配置灵活，但修改时需要重新打包发布</li><li>配置方式：直观，方便，无需重新打包发布，但是无法做全局配置</li></ul></li><li>饥饿加载<ul><li>开启饥饿加载，配置文件</li><li>指定饥饿加载的微服务名称，多个 clients 使用 yaml 列表</li></ul></li></ol><h2 id="Nacos-注册中心"><a class="header-anchor" href="#Nacos-注册中心"></a>Nacos 注册中心</h2><h3 id="认识和安装-Nacos"><a class="header-anchor" href="#认识和安装-Nacos"></a>认识和安装 Nacos</h3><p><a href="https://nacos.io/">Nacos</a> 是阿里巴巴的产品，现在是 <a href="https://spring.io/projects/spring-cloud">SpringCloud</a> 中的一个组件。相比 <a href="https://github.com/Netflix/eureka">Eureka</a> 功能更加丰富，在国内受欢迎程度较高。</p><p>Docker 安装：<a href="https://nacos.io/zh-cn/docs/quick-start-docker.html">官网</a></p><h3 id="服务注册到-Nacos"><a class="header-anchor" href="#服务注册到-Nacos"></a>服务注册到 Nacos</h3><p>Nacos 是 Spring Cloud Alibaba 的组件，而 Spring Cloud Alibaba 也遵循 Spring Cloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。其主要差异在于：依赖不同、服务地址不同。</p><h4 id="引入-Nacos-依赖"><a class="header-anchor" href="#引入-Nacos-依赖"></a>引入 Nacos 依赖</h4><p>在 spring-cloud-demo 父工程的 pom 文件中的 <code>&lt;dependencyManagement&gt;</code> 中引入 Spring Cloud Alibaba 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：不要忘了注释掉 eureka 的依赖。</p></blockquote><h4 id="配置-Nacos-地址"><a class="header-anchor" href="#配置-Nacos-地址"></a>配置 Nacos 地址</h4><p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">n:8848</span></span><br></pre></td></tr></table></figure><blockquote><p>这里使用的是远程服务器的地址</p></blockquote><h4 id="启动项目"><a class="header-anchor" href="#启动项目"></a>启动项目</h4><p>启动 user-service 和 order-service 浏览器输入 <a href="http://halo:8848/nacos/">http://halo:8848/nacos/</a> 账号密码默认都为 nacos，项目成功可以看到服务列表中的服务。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6jgz8xeif3g0.png" alt="image"></p><h3 id="服务分级存储模型"><a class="header-anchor" href="#服务分级存储模型"></a>服务分级存储模型</h3><p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p><ul><li>127.0.0.1:8081</li><li>127.0.0.1:8082</li><li>127.0.0.1:8083</li></ul><p>假如这些实例分布于全国各地的不同机房，例如：</p><ul><li>127.0.0.1:8081，在上海机房</li><li>127.0.0.1:8082，在上海机房</li><li>127.0.0.1:8083，在杭州机房</li></ul><p>Nacos 就将同一机房内的实例划分为一个<strong>集群</strong>。</p><p>也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2mxp9c1ugiw0.png" alt="image"></p><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p><h4 id="给-user-service-配置集群"><a class="header-anchor" href="#给-user-service-配置集群"></a>给 user-service 配置集群</h4><p>修改 user-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">halo:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>重启两个 user-service 实例后，我们再次复制一个 user-service 启动配置，添加属性：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1piv5isgkpb4.png" alt="image"></p><p>我们可以在 Nacos 控制台看到下面结果：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3pz2tkuveru0.png" alt="image"></p><h4 id="同集群优先的负载均衡"><a class="header-anchor" href="#同集群优先的负载均衡"></a>同集群优先的负载均衡</h4><p>默认的 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡。</p><p>因此 Nacos 中提供了一个 <code>NacosRule</code> 的实现，可以优先从同集群中挑选实例。</p><p>首先给 order-service 配置集群信息，方法同上一节</p><p>修改 order-service 的 application.yml 文件，添加集群配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">halo:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><p>修改负载均衡规则。修改 order-service 的 application.yml 文件，修改负载均衡规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则</span></span><br></pre></td></tr></table></figure><p>本地集群中采用随机</p><p>Nacos Rule 负载均衡策略</p><ol><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ol><h3 id="权重配置"><a class="header-anchor" href="#权重配置"></a>权重配置</h3><p>实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p><p>但默认情况下 Nacos Rule 是同集群内随机挑选，不会考虑机器的性能问题。</p><p>因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。</p><p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5bywq83lkh00.png" alt="image"></p><blockquote><p>注意：如果权重修改为 0，则该实例永远不会被访问</p></blockquote><h3 id="环境隔离"><a class="header-anchor" href="#环境隔离"></a>环境隔离</h3><p>Nacos 提供了 namespace 来实现环境隔离功能。</p><ul><li>Nacos 中可以有多个 namespace</li><li>namespace 下可以有 group、service 等</li><li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.33r23m595e00.png" alt="image"></p><h4 id="创建-namespace"><a class="header-anchor" href="#创建-namespace"></a>创建 namespace</h4><p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3ebpxcypny00.png" alt="image"></p><p>我们可以点击页面新增按钮，添加一个 namespace</p><h4 id="给微服务配置-namespace"><a class="header-anchor" href="#给微服务配置-namespace"></a>给微服务配置 namespace</h4><p>给微服务配置 namespace 只能通过修改配置来实现。</p><p>例如，修改 order-service 的 application.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">halo:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="number">45e30304</span><span class="string">-1b64-4c21-8c83-22309949af10</span> <span class="comment"># 命名空间，填ID</span></span><br></pre></td></tr></table></figure><p>重启 order-service 后，访问控制台，可以看到下面的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7fljcch1djg0.png" alt="image"></p><p>此时访问 order-service，因为 namespace 不同，会导致找不到 user-service，控制台会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">09-09 22:11:49:886 ERROR 4100 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[&#x2F;].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalStateException: No instances available for user-service] with root cause</span><br></pre></td></tr></table></figure><h2 id="Nacos-与-Eureka-的异同"><a class="header-anchor" href="#Nacos-与-Eureka-的异同"></a>Nacos 与 Eureka 的异同</h2><h3 id="Nacos-服务实例类型"><a class="header-anchor" href="#Nacos-服务实例类型"></a>Nacos 服务实例类型</h3><p>Nacos 的服务实例分为两种类型：</p><ul><li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li><li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li></ul><p>配置一个服务实例为永久实例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 设置为非临时实例</span></span><br></pre></td></tr></table></figure><h3 id="Nacos-注册中心原理"><a class="header-anchor" href="#Nacos-注册中心原理"></a>Nacos 注册中心原理</h3><p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86.vsk7w614iqo.svg" alt="Nacos注册中心原理"></p><h3 id="Nacos-与-Eureka-的共同点"><a class="header-anchor" href="#Nacos-与-Eureka-的共同点"></a>Nacos 与 Eureka 的共同点</h3><ul><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测</li></ul><h3 id="Nacos-与-Eureka-的区别"><a class="header-anchor" href="#Nacos-与-Eureka-的区别"></a>Nacos 与 Eureka 的区别</h3><ul><li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li><li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka采用 AP 方式</li></ul><h2 id="Nacos-配置管理"><a class="header-anchor" href="#Nacos-配置管理"></a>Nacos 配置管理</h2><p>Nacos 除了可以做注册中心，也可以做配置管理来使用。</p><h3 id="统一配置管理"><a class="header-anchor" href="#统一配置管理"></a>统一配置管理</h3><p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p><p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p><h4 id="在-Nacos-中添加配置文件"><a class="header-anchor" href="#在-Nacos-中添加配置文件"></a>在 Nacos 中添加配置文件</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1k2q3p4hypa8.png" alt="image"></p><p>然后在弹出的表单中，填写配置信息：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.26dw95t2zibk.png" alt="image"></p><blockquote><p>注意：项目的核心配置，需要热更新的配置才有放到 Nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h4 id="从微服务拉取配置"><a class="header-anchor" href="#从微服务拉取配置"></a>从微服务拉取配置</h4><p>微服务要拉取 Nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。</p><p>但如果尚未读取 application.yml，又如何得知 Nacos 地址呢？</p><p>因此 Spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.50gh2h1avrw0.png" alt="image"></p><p>① 引入 nacos-config 依赖</p><p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 添加 bootstrap.yaml</p><p>然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境，这里是 dev </span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">halo:8848</span> <span class="comment"># Nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>这里会根据 <code>spring.cloud.nacos.server-addr</code> 获取 Nacos 地址，再根据 <code>$&#123;spring.application.name&#125;-$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</code> 作为文件 id，来读取配置。</p><p>本例中，就是去读取 <code>user-service-dev.yaml</code>：</p><p>③ 读取 Nacos 配置</p><p>在 user-service 中的 <code>UserController</code> 中添加业务逻辑，读取 <code>pattern.dateformat</code> 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String dateformat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置热更新"><a class="header-anchor" href="#配置热更新"></a>配置热更新</h3><p>我们最终的目的，是修改 Nacos 中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。</p><p>要实现配置热更新，可以使用两种方式：</p><h4 id="方式一"><a class="header-anchor" href="#方式一"></a>方式一</h4><p>在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pattern.dateformat&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二"><a class="header-anchor" href="#方式二"></a>方式二</h4><p>使用 <code>@ConfigurationProperties</code> 注解代替 <code>@Value</code> 注解。</p><p>在 user-service 服务中，添加一个类，读取 <code>patterrn.dateformat</code> 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.user.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>UserController</code> 中使用这个类代替 <code>@Value</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PatternProperties properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;now&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置共享"><a class="header-anchor" href="#配置共享"></a>配置共享</h3><p>其实微服务启动时，会去 Nacos 读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：user-service-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：user-service.yaml</p></li></ul><p>而 <code>[spring.application.name].yaml</code> 不包含环境，因此可以被多个环境共享。</p><p>下面我们通过案例来测试配置共享</p><h4 id="添加一个环境共享配置"><a class="header-anchor" href="#添加一个环境共享配置"></a>添加一个环境共享配置</h4><p>在 Nacos 中添加一个 user-service.yaml 文件：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4j1r0ype41k0.png" alt="image"></p><h4 id="在-user-service-中读取共享配置"><a class="header-anchor" href="#在-user-service-中读取共享配置"></a>在 user-service 中读取共享配置</h4><p>在 user-service 服务中，修改 <code>PatternProperties</code> 类，读取新添加的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;pattern&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">    <span class="keyword">private</span> String envShareValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 user-service 服务中，修改 <code>UserController</code>，添加一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PatternProperties properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;prop&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PatternProperties <span class="title">prop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> properties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不同的-profile-下测试"><a class="header-anchor" href="#不同的-profile-下测试"></a>不同的 profile 下测试</h4><p>运行两个 UserApplication，使用不同的 profile。修改 UserApplication2 这个启动项，改变其 profile 值：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5fmr356kyr80.png" alt="image"></p><p>这样，UserApplication（8081） 使用的 profile 是 dev，UserApplication2（8082） 使用的 profile 是 test。</p><p>启动 UserApplication 和 UserApplication2</p><p>可以看出来，不管是 dev，还是 test 环境，都读取到了envSharedValue 这个属性的值。</p><h4 id="配置共享的优先级"><a class="header-anchor" href="#配置共享的优先级"></a>配置共享的优先级</h4><p>当 Nacos、服务本地同时出现相同属性时，优先级有高低之分，优先级从高到低依次是：</p><ul><li>服务名-[profile].yaml</li><li>服务名.yaml</li><li>本地配置</li></ul><h2 id="搭建-Nacos-集群"><a class="header-anchor" href="#搭建-Nacos-集群"></a>搭建 Nacos 集群</h2><p>计划的集群结构：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3v4vof6qfki0.png" alt="image"></p><p>三个 nacos 节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>halo</td><td>8845</td></tr><tr><td>nacos2</td><td>halo</td><td>8846</td></tr><tr><td>nacos3</td><td>halo</td><td>8847</td></tr></tbody></table><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载 Nacos 安装包</li><li>配置 Nacos</li><li>启动 Nacos 集群</li><li>Nginx 反向代理</li></ul><h3 id="初始化数据库"><a class="header-anchor" href="#初始化数据库"></a>初始化数据库</h3><p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="下载-Nacos"><a class="header-anchor" href="#下载-Nacos"></a>下载 Nacos</h3><p>Nacos 在 GitHub 上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用 1.4.1 版本</p><h3 id="配置-Nacos"><a class="header-anchor" href="#配置-Nacos"></a>配置 Nacos</h3><p>将这个包解压到任意非中文目录下</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入 Nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5nlh9ki5w2s0.png" alt="image"></p><p>然后添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure><p>然后修改 application.properties 文件，添加数据库配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.platform&#x3D;mysql</span><br><span class="line"></span><br><span class="line">db.num&#x3D;1</span><br><span class="line"></span><br><span class="line">db.url.0&#x3D;jdbc:mysql:&#x2F;&#x2F;halo:3306&#x2F;nacos?characterEncoding&#x3D;utf8&amp;connectTimeout&#x3D;1000&amp;socketTimeout&#x3D;3000&amp;autoReconnect&#x3D;true&amp;useUnicode&#x3D;true&amp;useSSL&#x3D;false&amp;serverTimezone&#x3D;UTC</span><br><span class="line">db.user.0&#x3D;root</span><br><span class="line">db.password.0&#x3D;mogu2018</span><br></pre></td></tr></table></figure><h3 id="启动-Nacos"><a class="header-anchor" href="#启动-Nacos"></a>启动 Nacos</h3><p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p>然后分别修改三个文件夹中的 application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure><p>然后分别启动三个 nacos 节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure><h3 id="Nginx-反向代理"><a class="header-anchor" href="#Nginx-反向代理"></a>Nginx 反向代理</h3><p>修改 conf/nginx.conf 文件，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">upstream nacos-cluster &#123;</span><br><span class="line">    server 127.0.0.1:8845;</span><br><span class="line">server 127.0.0.1:8846;</span><br><span class="line">server 127.0.0.1:8847;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location &#x2F;nacos &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos">http://localhost/nacos</a> 即可。</p><p>代码中 application.yml 文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure><ul><li><p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。</p></li><li><p>Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul><h2 id="Feign-远程调用"><a class="header-anchor" href="#Feign-远程调用"></a>Feign 远程调用</h2><p>先来看我们以前利用 RestTemplate 发起远程调用的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 利用 RestTemplate 发起 http 请求，查询用户</span></span><br><span class="line">String url = <span class="string">&quot;http://user-service/user/&quot;</span> + order.getUserId();</span><br><span class="line">User user = restTemplate.getForObject(url, User.class);</span><br></pre></td></tr></table></figure><p>存在下面的问题：</p><ul><li>代码可读性差，编程体验不统一</li><li>参数复杂 URL 难以维护</li></ul><p>Feign 是一个声明式的 http 客户端，官方地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。</p><h3 id="Feign-替代-RestTemplate"><a class="header-anchor" href="#Feign-替代-RestTemplate"></a>Feign 替代 RestTemplate</h3><p>Feign 的使用步骤如下：</p><h4 id="引入依赖-v2"><a class="header-anchor" href="#引入依赖-v2"></a>引入依赖</h4><p>我们在 order-service 服务的 pom 文件中引入 feign 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加注解"><a class="header-anchor" href="#添加注解"></a>添加注解</h4><p>在 order-service 的启动类添加 <code>@EnableFeignClients</code> 注解开启 Feign 的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;cn.itcast.order.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写-Feign-的客户端"><a class="header-anchor" href="#编写-Feign-的客户端"></a>编写 Feign 的客户端</h4><p>在 order-service 中新建一个接口，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.order.clients;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.order.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(&quot;user-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：user-service</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p><h4 id="测试"><a class="header-anchor" href="#测试"></a>测试</h4><p>修改 order-service 中的 <code>OrderService</code> 类中的 <code>queryOrderById</code> 方法，使用 Feign 客户端代替 RestTemplate：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Order <span class="title">queryOrderById</span><span class="params">(Long orderId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        Order order = orderMapper.findById(orderId);</span><br><span class="line">        <span class="comment">// 2. 使用 Feign 进行远程调用</span></span><br><span class="line">        User user = userClient.findById(order.getUserId());</span><br><span class="line">        <span class="comment">// 3. 封装 user 到 Order</span></span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Feign-替代-RestTemplate-小结"><a class="header-anchor" href="#Feign-替代-RestTemplate-小结"></a>Feign 替代 RestTemplate 小结</h4><p>使用 Feign 的步骤：</p><ol><li>引入依赖</li><li>添加 <code>@EnableFeignClients</code> 注解</li><li>编写 FeignClient 接口</li><li>使用 FeignClient 中定义的方法代替 RestTemplate</li></ol><h3 id="Feign-的自定义配置"><a class="header-anchor" href="#Feign-的自定义配置"></a>Feign 的自定义配置</h3><p>Feign 可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><code>feign.Logger.Level</code></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td><code>feign.codec.Decoder</code></td><td>响应结果的解析器</td><td>http 远程调用的结果做解析，例如解析 JSON 字符串为 Java 对象</td></tr><tr><td><code>feign.codec.Encoder</code></td><td>请求参数编码</td><td>将请求参数编码，便于通过 http 请求发送</td></tr><tr><td><code>feign.Contract</code></td><td>支持的注解格式</td><td>默认是 SpringMVC 的注解</td></tr><tr><td><code>feign.Retryer</code></td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon 的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 <code>@Bean</code> 覆盖默认Bean 即可。</p><p>下面以日志为例来演示如何自定义配置。</p><h4 id="配置文件方式"><a class="header-anchor" href="#配置文件方式"></a>配置文件方式</h4><p>基于配置文件修改 Feign 的日志级别可以针对单个服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">userservice:</span> <span class="comment"># 针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment"># 日志级别 </span></span><br></pre></td></tr></table></figure><p>也可以针对所有服务：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span>  </span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span> </span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># 这里用 default 就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span> <span class="comment"># 日志级别 </span></span><br></pre></td></tr></table></figure><p>而日志的级别分为四种：</p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间</li><li>HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><h4 id="Java-代码方式"><a class="header-anchor" href="#Java-代码方式"></a>Java 代码方式</h4><p>也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 <code>Logger.Level</code> 的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFeignConfiguration</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLogLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC; <span class="comment">// 日志级别为BASIC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要全局生效，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class)</span> </span><br></pre></td></tr></table></figure><p>如果是局部生效，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;user-service&quot;, configuration = DefaultFeignConfiguration .class)</span></span><br></pre></td></tr></table></figure><h3 id="Feign-使用优化"><a class="header-anchor" href="#Feign-使用优化"></a>Feign 使用优化</h3><p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：</p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此提高 Feign 的性能主要手段就是使用连接池代替默认的 URLConnection。</p><p>这里我们用 Apache 的 HttpClient 来演示。</p><h4 id="引入依赖-v3"><a class="header-anchor" href="#引入依赖-v3"></a>引入依赖</h4><p>在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--httpClient的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置连接池"><a class="header-anchor" href="#配置连接池"></a>配置连接池</h4><p>在 order-service 的 application.yml 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default 全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC 就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启 feign 对 HttpClient 的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h4 id="Feign-的优化小结"><a class="header-anchor" href="#Feign-的优化小结"></a>Feign 的优化小结</h4><ol><li>日志级别尽量用 basic</li><li>使用 HttpClient（或 OKHttp ）代替 URLConnection<ul><li>引入 feign-httpclient 依赖</li><li>配置文件开启 httpclient 功能，设置连接池参数</li></ul></li></ol><h2 id="Feign-的最佳实践"><a class="header-anchor" href="#Feign-的最佳实践"></a>Feign 的最佳实践</h2><p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p><p>仔细观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似</p><p>Feign客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function">User <span class="title">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br></pre></td></tr></table></figure><p>UserController：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有一种办法简化这种重复的代码编写呢？</p><h3 id="继承方式"><a class="header-anchor" href="#继承方式"></a>继承方式</h3><p>一样的代码可以通过继承来共享：</p><ol><li>定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。</li><li>Feign 客户端和 Controller 都集成改接口</li></ol><p>优点：简单、实现了代码共享</p><p>缺点：</p><ul><li>服务提供方、服务消费方紧耦合</li><li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li></ul><h3 id="抽取方式"><a class="header-anchor" href="#抽取方式"></a>抽取方式</h3><p>将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p><h3 id="基于抽取的最佳实践实现"><a class="header-anchor" href="#基于抽取的最佳实践实现"></a>基于抽取的最佳实践实现</h3><h4 id="抽取"><a class="header-anchor" href="#抽取"></a>抽取</h4><p>首先创建一个 module，命名为 feign-api</p><p>在 feign-api 中然后引入 feign 的 starter 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都剪切到 feign-api项目中</p><h4 id="使用-feign-api"><a class="header-anchor" href="#使用-feign-api"></a>使用 feign-api</h4><p>在 order-service 的 pom 文件中中引入 feign-api 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包</p><h4 id="解决扫描包问题"><a class="header-anchor" href="#解决扫描包问题"></a>解决扫描包问题</h4><p>order-service 的 <code>@EnableFeignClients</code> 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。</p><p>方式一，指定 Feign 应该扫描的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二，指定需要加载的 Client 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Gateway-服务网关"><a class="header-anchor" href="#Gateway-服务网关"></a>Gateway 服务网关</h2><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h3 id="为什么需要网关"><a class="header-anchor" href="#为什么需要网关"></a>为什么需要网关</h3><p>Gateway 网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的核心功能特性：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p>路由和负载均衡：一切请求都必须先经过 Gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p>限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在 Spring Cloud 中网关的实现包括两种：Gateway、Zuul</p><p>Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring 5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</p><h3 id="Gateway-快速入门"><a class="header-anchor" href="#Gateway-快速入门"></a>Gateway 快速入门</h3><p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p><ol><li>创建 Maven 工程 gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h4 id="创建-Gateway-服务并引入依赖"><a class="header-anchor" href="#创建-Gateway-服务并引入依赖"></a>创建 Gateway 服务并引入依赖</h4><p>创建 gateway 服务，引入一下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写启动类-v2"><a class="header-anchor" href="#编写启动类-v2"></a>编写启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写基础配置和路由规则"><a class="header-anchor" href="#编写基础配置和路由规则"></a>编写基础配置和路由规则</h4><p>创建 application.yml 文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">halo:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service-gateway</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><p>我们将符合 <code>Path</code> 规则的一切请求，都代理到 <code>uri</code> 参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到 <code>lb://user-service</code>，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><h4 id="启动测试"><a class="header-anchor" href="#启动测试"></a>启动测试</h4><p>启动网关，访问 <a href="http://localhost:10010/user/1">http://localhost:10010/user/1</a> 时，符合<code>/user/**</code>规则，请求转发到 uri：<a href="http://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C">http://userservice/user/1，得到了结果</a></p><h4 id="网关路由的流程图"><a class="header-anchor" href="#网关路由的流程图"></a>网关路由的流程图</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Gateway%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.6onddfdjlr00.svg" alt="Gateway网关路由的流程图"></p><h4 id="Gateway-快速入门小结"><a class="header-anchor" href="#Gateway-快速入门小结"></a>Gateway 快速入门小结</h4><p>网关搭建步骤：</p><ol><li><p>创建项目，引入 nacos 服务发现和 gateway 依赖</p></li><li><p>配置 application.yml，包括服务基本信息、nacos 地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由 id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h3 id="断言工厂"><a class="header-anchor" href="#断言工厂"></a>断言工厂</h3><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件</p><p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个：</p><table><thead><tr><th>名称</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td><code>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</code></td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td><code>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</code></td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td><code>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</code></td></tr><tr><td>Cookie</td><td>请求必须包含某些 cookie</td><td><code>- Cookie=chocolate, ch.p</code></td></tr><tr><td>Header</td><td>请求必须包含某些 header</td><td><code>- Header=X-Request-Id, \d+</code></td></tr><tr><td>Host</td><td>请求必须是访问某个 host（域名）</td><td><code>-  Host=**.somehost.org,**.anotherhost.org</code></td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td><code>- Method=GET,POST</code></td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td><code>- Path=/red/&#123;segment&#125;,/blue/**</code></td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td><code>- Query=name, Jack</code> 或者 <code>-  Query=name</code></td></tr><tr><td>RemoteAddr</td><td>请求者的 ip 必须是指定范围</td><td><code>- RemoteAddr=192.168.1.1/24</code></td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><p>详情查阅：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">官方文档</a></p><h3 id="过滤器工厂"><a class="header-anchor" href="#过滤器工厂"></a>过滤器工厂</h3><p>Gateway Filter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82.2sw963vwfry0.svg" alt="过滤器工厂"></p><h4 id="路由过滤器的种类"><a class="header-anchor" href="#路由过滤器的种类"></a>路由过滤器的种类</h4><p>Spring 提供了 31 种不同的路由过滤器工厂。例如：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td><code>AddRequestHeader</code></td><td>给当前请求添加一个请求头</td></tr><tr><td><code>RemoveRequestHeader</code></td><td>移除请求中的一个请求头</td></tr><tr><td><code>AddResponseHeader</code></td><td>给响应结果中添加一个响应头</td></tr><tr><td><code>RemoveResponseHeader</code></td><td>从响应结果中移除有一个响应头</td></tr><tr><td><code>RequestRateLimiter</code></td><td>限制请求的流量</td></tr></tbody></table><p>详情查阅：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">官方文档</a></p><h4 id="请求头过滤器"><a class="header-anchor" href="#请求头过滤器"></a>请求头过滤器</h4><p>下面我们以 <code>AddRequestHeader</code> 为例来讲解。</p><p>需求：给所有进入 user-service 的请求添加一个请求头：Truth=Halo</p><p>只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span> </span><br><span class="line">        <span class="attr">filters:</span> <span class="comment"># 过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Halo</span> <span class="comment"># 添加请求头</span></span><br></pre></td></tr></table></figure><p>当前过滤器写在 user-service 路由下，因此仅仅对访问 user-service 的请求有效。</p><h4 id="默认过滤器"><a class="header-anchor" href="#默认过滤器"></a>默认过滤器</h4><p>如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> </span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://userservice</span> </span><br><span class="line">        <span class="attr">predicates:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认过滤项</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">AddRequestHeader=Truth,</span> <span class="string">Halo</span></span><br></pre></td></tr></table></figure><h4 id="过滤器工厂总结"><a class="header-anchor" href="#过滤器工厂总结"></a>过滤器工厂总结</h4><p>过滤器的作用是什么？</p><ul><li>对路由的请求或响应做加工处理，比如添加请求头</li><li>配置在路由下的过滤器只对当前路由的请求生效</li></ul><p>defaultFilters 的作用是什么？</p><ul><li>对所有路由都生效的过滤器</li></ul><h3 id="全局过滤器"><a class="header-anchor" href="#全局过滤器"></a>全局过滤器</h3><p>上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p><h4 id="全局过滤器作用"><a class="header-anchor" href="#全局过滤器作用"></a>全局过滤器作用</h4><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。</p><p>两者的区别在于：</p><ul><li>GatewayFilter 通过配置定义，处理逻辑是固定的；</li><li>GlobalFilter 的逻辑需要自己写代码实现。</li></ul><p>定义方式是实现 GlobalFilter 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  处理当前请求，有必要的话通过&#123;<span class="doctag">@link</span> GatewayFilterChain&#125;将请求交给下一个过滤器处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;Void&gt;&#125; 返回标示当前过滤器业务结束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 filter 中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h4 id="自定义全局过滤器"><a class="header-anchor" href="#自定义全局过滤器"></a>自定义全局过滤器</h4><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有 authorization，</p></li><li><p>authorization 参数值是否为 admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现，在 gateway 中定义一个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求参数</span></span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">// 2. 获取参数中的 authorization</span></span><br><span class="line">        String auth = queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 判断参数值是否等于 admin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(auth)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="comment">// 设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Order(-1)</code> 用于指定过滤器顺序，值越小优先级越高</p><p>重启网关，访问 <a href="http://localhost:10010/user/1?authorization=admin">http://localhost:10010/user/1?authorization=admin</a></p><h4 id="过滤器执行顺序"><a class="header-anchor" href="#过滤器执行顺序"></a>过滤器执行顺序</h4><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.4mfcqien0h60.svg" alt="过滤器执行顺序"></p><p>排序的规则是什么呢？</p><ul><li>首先，每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。</li><li>GlobalFilter 通过实现 Ordered 接口，或者添加 <code>@Order</code> 注解来指定 order 值，由我们自己指定。路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。</li><li>当过滤器的 order 值一样时，会按照 defaultFilter、路由过滤器、GlobalFilter 的顺序执行。</li></ul><p>详细内容，可以查看源码：</p><ul><li><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code> 方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。</li><li><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code> 方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</li></ul><h3 id="跨域问题"><a class="header-anchor" href="#跨域问题"></a>跨域问题</h3><h4 id="什么是跨域问题"><a class="header-anchor" href="#什么是跨域问题"></a>什么是跨域问题</h4><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com">www.taobao.com</a> 和 <a href="http://www.taobao.org">www.taobao.org</a> 和 <a href="http://www.jd.com">www.jd.com</a> 和 <a href="http://miaosha.jd.com">miaosha.jd.com</a></p></li><li><p>域名相同，端口不同：localhost:8080 和 localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 Ajax 请求，请求被浏览器拦截的问题</p><p>CORS 解决方案，参考资料：<a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h4 id="解决跨域问题"><a class="header-anchor" href="#解决跨域问题"></a>解决跨域问题</h4><p>在 gateway 服务的 application.yml 文件中，添加下面的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># .</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;认识微服务&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h2&gt;
&lt;h3 id=&quot;单体架构与分布式架构&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#单体架构与分布式架构&quot;&gt;&lt;/a&gt;单体架</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VSCode 插件整理</title>
    <link href="https://whl123456.top/2021/08/18/Tools/VSCode/"/>
    <id>https://whl123456.top/2021/08/18/Tools/VSCode/</id>
    <published>2021-08-18T06:19:12.213Z</published>
    <updated>2021-09-20T06:03:43.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础插件"><a class="header-anchor" href="#基础插件"></a>基础插件</h3><ol><li>【Chinese (Simplified) Language Pack for Visual Studio Code】适用于 VS Code 的中文（简体）语言包</li><li>【Visual Studio IntelliCode】智能提示插件</li><li>【vscode-icons】文件夹图标</li><li>【Code Runner】支持运行多种语言代码片段</li></ol><h3 id="前端开发"><a class="header-anchor" href="#前端开发"></a>前端开发</h3><ol><li>【Auto Close Tag】自动关闭标签</li><li>【Auto Rename Tag】自动重命名标签</li><li>【<a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer-2">Bracket Pair Colorizer 2</a>】匹配括号并用不同颜色区别</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基础插件&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#基础插件&quot;&gt;&lt;/a&gt;基础插件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;【Chinese (Simplified) Language Pack for Visual Studio Code】适用于 VS</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>npm 和 yarn 安装及配置</title>
    <link href="https://whl123456.top/2021/08/18/WebFrontEnd/NodeJS/"/>
    <id>https://whl123456.top/2021/08/18/WebFrontEnd/NodeJS/</id>
    <published>2021-08-18T05:42:20.672Z</published>
    <updated>2021-09-20T06:02:07.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="npm"><a class="header-anchor" href="#npm"></a>npm</h2><h3 id="npm-换源成淘宝镜像"><a class="header-anchor" href="#npm-换源成淘宝镜像"></a>npm 换源成淘宝镜像</h3><p>由于 node 下载第三方依赖包是从国外服务器下载，虽然没有被墙，但是下载的速度是非常的缓慢且有可能会出现异常。所以为了提高效率，我们还是把 npm 的镜像源替换成淘宝的镜像源。有几种方式供我们选择</p><p>方法一：使用阿里定制的 cnpm 命令行工具代替默认的 npm，输入以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>检测是否安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cnpm -v</span><br></pre></td></tr></table></figure><p>安装成功之后，以后安装依赖包的方式和 npm 的是一样的，只是 npm 的命令换成是 cnpm 就可以了</p><p>假如你已经习惯了使用 npm 的安装方式的，不想去下载阿里的 cnpm 命令工具的话，很简单，我们直接将 node的仓库地址换成淘宝仓库地址即可</p><p>方法二：替换仓库地址（单次使用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>方法三（推荐）：替换仓库地址（永久使用）</p><p>在开发 react-native 的时候，不要使用 cnpm！cnpm 安装的模块路径比较奇怪，packager 不能正常识别。所以，为了方便开发，我们最好是直接永久使用淘宝的镜像源</p><p>直接命令行的设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>检测是否修改成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure><p>注：如果想还原 npm 仓库地址的话，只需要在把地址配置成 npm 镜像就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/cythia/p/10985080.html">参考链接</a></p><h2 id="yarn"><a class="header-anchor" href="#yarn"></a>yarn</h2><p><a href="https://www.yarnpkg.cn/getting-started/install">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;npm&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#npm&quot;&gt;&lt;/a&gt;npm&lt;/h2&gt;
&lt;h3 id=&quot;npm-换源成淘宝镜像&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#npm-换源成淘宝镜像&quot;&gt;&lt;/a&gt;npm 换源成</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>存储系统</title>
    <link href="https://whl123456.top/2021/07/12/ComputerComposition/C_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"/>
    <id>https://whl123456.top/2021/07/12/ComputerComposition/C_%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-07-12T15:00:05.000Z</published>
    <updated>2021-07-13T04:38:58.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器概述"><a class="header-anchor" href="#存储器概述"></a>存储器概述</h2><h3 id="存储器的分类"><a class="header-anchor" href="#存储器的分类"></a>存储器的分类</h3><p>存储器种类繁多，可从不同角度对存储器进行分类。</p><h4 id="按在计算机中的作用（层次）分类"><a class="header-anchor" href="#按在计算机中的作用（层次）分类"></a>按在计算机中的作用（层次）分类</h4><ol><li>主存储器。简称主存，又称内存储器（内存），用来存放计算机运行期间所需的大量程序和数据，CPU 可以直接随机地对其进行访问，也可以和高速缓冲存储器（Cache）及辅助存储器交换数据。其特点是容量较小、存取速度较快、每位价格较高。</li><li>辅助存储器。简称辅存，又称外存储器（外存），是主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与 CPU 直接交换信息。其特点是容量极大、存取速度较慢、单位成本低。</li><li>高速缓冲存储器。简称 Cache，位于主存和 CPU 之间，用来存放正在执行的程序段和数据，以便 CPU 能高速地使用它们。Cache 的存取速度可与 CPU 的速度相匹配，但存储容量小、价格高。目前的高档计算机通常将它们制作在 CPU 中。</li></ol><h4 id="按存储介质分类"><a class="header-anchor" href="#按存储介质分类"></a>按存储介质分类</h4><p>按存储介质，存储器可分为：</p><ul><li>磁表面存储器（磁盘、磁带）</li><li>磁心存储器半导体存储器（MOS 型存储器、双极型存储器）</li><li>光存储器（光盘）</li></ul><h4 id="按存取方式分类"><a class="header-anchor" href="#按存取方式分类"></a>按存取方式分类</h4><ol><li>随机存储器（Random Access Memory，RAM）。存储器的任何一个存储单元的内容都可以随机存取，而且<font color="#33a3dc">存取时间与存储单元的物理位置无关</font>。其优点是读写方便、使用灵活，主要用作主存或高速缓冲存储器。RAM 又分为静态 RAM（以触发器原理寄存信息）和动态 RAM（以电容充电原理寄存信息）。</li><li>只读存储器（ROM）。存储器的内容只能随机读出而不能写入。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。它与随机存储器可共同作为主存的一部分，统一构成主存的地址域。由 ROM 派生出的存储器也包含可反复重写的类型，ROM 和 RAM 的存取方式均为随机存取。注意广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍然保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。</li><li>串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）。<ul><li>顺序存取存储器（Sequential Access Memory，SAM）：读写一个存储单元所需时间取决于存储单元所在的物理地址。</li><li>直接存取存储器（Direct Access Memory，DAM）：既有随机存取特性，也有顺序存取特性。先直接选取信息所在区域，然后按顺序方式存取</li></ul></li><li>相联存储器（Associative Memory），即可以按内容访问的存储器（Content Addressed Memory，CAM）也可以按照内容检索到存储位置进行读写，“快表”就是一种相联存储器。</li></ol><p>顺序存取存储器的内容只能按某种顺序存取，存取时间的长短与信息在存储体上的物理位置有关，其特点是存取速度慢。直接存取存储器既不像 RAM 那样随机地访问任何一个存 储单元，又不像顺序存取存储器那样完全按顺序存取，而是介于两者之间。存取信息时通常先寻找整个存储器中的某个小区域（如磁盘上的磁道），再在小区域内顺序查找。</p><h4 id="按信息的可更改性"><a class="header-anchor" href="#按信息的可更改性"></a>按信息的可更改性</h4><ul><li>读写存储器（Read/Write Memory）——既可读又可写（如：磁盘、内存、Cache）</li><li>只读存储器（Read Only Memory）——只能读，不能写（如：实体音乐专辑通常采用 CD-ROM，实体电影采用蓝光光碟，BIOS 通常写在 ROM 中）</li></ul><h4 id="按信息的可保存性分类"><a class="header-anchor" href="#按信息的可保存性分类"></a>按信息的可保存性分类</h4><ul><li><p>断电后，存储信息即消失的存储器，称为易失性存储器，如 RAM。</p></li><li><p>断电后信息仍然保持的存储器，称为非易失性存储器，如 ROM、磁表面存储器和光存储器。</p></li><li><p>若某个存储单元所存储的信息被读出时，原存储信息被破坏，则称为破坏性读出；（如 DRAM 芯片）</p></li><li><p>若读出时，被读单元原存储信息不被破坏，则称为非破坏性读出。（如 SRAM 芯片、磁盘、光盘）</p></li></ul><p>具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个再生的操作，以便恢复被破坏的信息。</p><h3 id="存储器的性能指标"><a class="header-anchor" href="#存储器的性能指标"></a>存储器的性能指标</h3><p>存储器有 3 个主要性能指标，即存储容量、单位成本和存储速度。这 3 个指标相互制约，设计存储器系统所追求的目标就是大容量、低成本和高速度。</p><ol><li>存储容量 = 存储字数 × 字长（如 1M × 8位）。单位换算：1B（Byte, 字节）= 8b（bit，位）。存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量。</li><li>单位成本：每位价格 = 总成本 / 总容量。</li><li>存储速度：数据传输率 = 数据的宽度 / 存储周期。<ul><li>存取时间（$T_g$）：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。</li><li>存取周期（$T_m$）：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔。</li><li>主存带宽（$B_m$）：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字/秒、字节/秒（B/s）或位/秒（b/s）。</li></ul></li></ol><p>存取时间不等于存储周期，通常存储周期大于存取时间。这是因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器，存取周期往往比存取时间大得多，甚至可达 $T_{m} = 2T_{a}$ ，因为存储器中的信息读出后需要马上进行再生。</p><h3 id="存储器的性能指标-v2"><a class="header-anchor" href="#存储器的性能指标-v2"></a>存储器的性能指标</h3><h2 id="存储器的层次化结构"><a class="header-anchor" href="#存储器的层次化结构"></a>存储器的层次化结构</h2><h3 id="多级存储系统"><a class="header-anchor" href="#多级存储系统"></a>多级存储系统</h3><p>为了解决存储系统大容量、高速度和低成本 3 个相互制约的矛盾，在计算机系统中，通常采用多级存储器结构，如下图所示。在图中由上至下，位价越来越低，速度越来越慢，容量越来大，CPU 访问的频度也越来越低。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1dl9lv5htwps.png" alt="image"></p><p>实际上，存储系统层次结构主要体现在“Cache——主存”层次和“主存——辅存”层次。前者主要解决 CPU 和主存速度不匹配的问题，后者主要解决存储系统的容量问题。在存储体系中，Cache、主存能与 CPU 直接交换信息，辅存则要通过主存与 CPU 交换信息；主存与 CPU、Cache、 辅存都能交换信息。</p><p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。从 CPU 的角度看，“Cache——主存”层次速度接近于 Cache，容量和位价却接近于主存。从“主存——辅存”层次分析，其速度接近于主存，容量和位价却接近于辅存。这就解决了速度、容量、成本这三者之间的矛盾，现代计算机系统几乎都采用这种三级存储系统。需要注意的是，主存和 Cache 之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动则是由硬<br>件和操作系统共同完成的，对应用程序员是透明的。</p><p>在“主存——辅存”这一层次的不断发展中，逐渐形成了虚拟存储系统，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远大于主存空间。</p><p>注意：在“Cache——主存”和“主存——辅存”层次中，上一层中的内容都只是下一层中内容的副本，也即 Cache（或主存）中的内容只是主存（或辅存）中内容的一部分。</p><h2 id="半导体随机存储器"><a class="header-anchor" href="#半导体随机存储器"></a>半导体随机存储器</h2><h3 id="主存储器的基本组成"><a class="header-anchor" href="#主存储器的基本组成"></a>主存储器的基本组成</h3><h2 id="主存储器与CPU的连接"><a class="header-anchor" href="#主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h2 id="双端口RAM和多模块存储器"><a class="header-anchor" href="#双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><h2 id="高速缓冲存储器"><a class="header-anchor" href="#高速缓冲存储器"></a>高速缓冲存储器</h2><h2 id="虚拟存储器"><a class="header-anchor" href="#虚拟存储器"></a>虚拟存储器</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;存储器概述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#存储器概述&quot;&gt;&lt;/a&gt;存储器概述&lt;/h2&gt;
&lt;h3 id=&quot;存储器的分类&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#存储器的分类&quot;&gt;&lt;/a&gt;存储器的分类&lt;/h3&gt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://whl123456.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://whl123456.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://whl123456.top/2021/07/09/ComputerNetworks/C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://whl123456.top/2021/07/09/ComputerNetworks/C_%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-07-09T04:34:00.000Z</published>
    <updated>2021-07-26T03:05:08.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据链路层基本概念"><a class="header-anchor" href="#数据链路层基本概念"></a>数据链路层基本概念</h2><p><font color="#ea66a6">结点</font>：主机、路由器</p><p><font color="#ea66a6">链路</font>：网络中两个结点之间的<font color="#33a3dc">物理通道</font>，链路的传输介质主要有双绞线、光纤和微波。分为有线链路、无线链路。</p><p><font color="#ea66a6">数据链路</font>：网络中两个结点之间的<font color="#33a3dc">逻辑通道</font>，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。</p><p><font color="#ea66a6">帧</font>：链路层的协议数据单元，封装网络层数据报。</p><p>数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p><h2 id="数据链路层的功能"><a class="header-anchor" href="#数据链路层的功能"></a>数据链路层的功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。</p><ul><li>功能一：为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务。（有连接一定有确认，不存在有连接没有确认的服务）</li><li>功能二：链路管理，即连接的建立、维持、释放（用于面向连接的服务）。</li><li>功能三：组帧。</li><li>功能四：流量控制。</li><li>功能五：差错控制（帧错/位错）</li></ul><h3 id="为网络层提供服务"><a class="header-anchor" href="#为网络层提供服务"></a>为网络层提供服务</h3><h3 id="链路管理"><a class="header-anchor" href="#链路管理"></a>链路管理</h3><h3 id="帧定界、帧同步与透明传输"><a class="header-anchor" href="#帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h3><h3 id="流量管理"><a class="header-anchor" href="#流量管理"></a>流量管理</h3><h3 id="差错控制"><a class="header-anchor" href="#差错控制"></a>差错控制</h3><h2 id="组帧"><a class="header-anchor" href="#组帧"></a>组帧</h2><h3 id="封装成帧"><a class="header-anchor" href="#封装成帧"></a>封装成帧</h3><p><font color="#faa755">封装成帧</font>就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</p><p>首部和尾部包含许多的控制信息，他们的一个重要作用：<font color="#33a3dc">帧定界</font>（确定帧的界限）。</p><p><font color="#faa755">帧同步</font>：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p>组帧的四种方法：</p><ol><li>字符计数法</li><li>字符（节）填充法</li><li>零比特填充法</li><li>违规编码法</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2znurkhe6tw0.png" alt="image"></p><h3 id="透明传输"><a class="header-anchor" href="#透明传输"></a>透明传输</h3><p><font color="#faa755">透明传输</font>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。</p><p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><h3 id="字符计数法"><a class="header-anchor" href="#字符计数法"></a>字符计数法</h3><p>帧首部使用一个计数字段（第一个字节，八位）来标明帧内字符数。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3ydd27olhj00.png" alt="image"></p><p>痛点：鸡蛋装在一个篮子里了。</p><h3 id="字符填充的首尾定界符法"><a class="header-anchor" href="#字符填充的首尾定界符法"></a>字符填充的首尾定界符法</h3><ul><li>当传送的帧是由文本文件组成时（文本文件的字符都是从键盘上输入的，都是 ASCII 码）。 不管从键盘上输入什么字符都可以放在帧里传过去，即透明传输。</li><li>当传送的帧是由非 ASCII 码的文本文件组成时（二进制代码的程序或图像等）。 就要采用字符填充方法实现透明传输。</li></ul><h3 id="零比特填充的为首标志法"><a class="header-anchor" href="#零比特填充的为首标志法"></a>零比特填充的为首标志法</h3><p>操作：</p><ol><li>在发送端，扫描整个信息字段，只要连续 5 个 1，就立即填入 1 个 0。</li><li>在接收端收到一个帧时，先找到标志字段确定边界，再用硬件对比特流进行扫描。发现连续 5 个 1 时，就把后面的 0 删除。</li></ol><p>保证了透明传输：在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判断错误。</p><h3 id="违规编码法"><a class="header-anchor" href="#违规编码法"></a>违规编码法</h3><p>可以用“高-高”，“低-低”来定界帧的起始和终止。</p><p>由于字节计数法中 Count 字段的脆弱性（其值若有差错将导致灾难性后果）及字符填充实现上的复杂性和不兼容性，目前较普遍使用的帧同步法是比特填充和违规编码法。</p><h2 id="差错控制-v2"><a class="header-anchor" href="#差错控制-v2"></a>差错控制</h2><p>概括来说，传输中的差错都是由于噪声引起的。<br>全局性，由于线路本身电气特性所产生的随机噪声（热噪声），是信道固有的，随机存在的。解决办法：提高信噪比来减少或避免干扰。（对传感器下手）</p><p>局部性，外界特定的短暂原因所造成的冲击噪声，是产生差错的主要原因。解决办法：通常利用编码技术来解决。</p><h3 id="检错编码"><a class="header-anchor" href="#检错编码"></a>检错编码</h3><p>奇偶校验码</p><p>CRC 循环冗余码</p><h3 id="纠错编码"><a class="header-anchor" href="#纠错编码"></a>纠错编码</h3><p>海明码</p><h2 id="流量控制与可靠传输机制"><a class="header-anchor" href="#流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><h3 id="流量控制、可靠传输与滑动窗口机制"><a class="header-anchor" href="#流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h3><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的。</p><p>数据链路层流量控制手段：接收方收不下就不回复确认。</p><p>传输层流量控制手段：接收端给发送端一个窗口公告。</p><p>可靠传输：发送端发啥，接收端收啥。</p><p>流量控制：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧。</p><p>滑动窗口解决：流量控制（收不下就不给确认，想发也发不了），可靠传输（发送方自动重传）</p><h3 id="单帧滑动窗与停止等待协议"><a class="header-anchor" href="#单帧滑动窗与停止等待协议"></a>单帧滑动窗与停止等待协议</h3><p>每发送完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧。</p><h3 id="多帧滑动窗口与后退-N-帧协议（GBN）"><a class="header-anchor" href="#多帧滑动窗口与后退-N-帧协议（GBN）"></a>多帧滑动窗口与后退 N 帧协议（GBN）</h3><h3 id="多帧滑动窗与选择重传协议（SR）"><a class="header-anchor" href="#多帧滑动窗与选择重传协议（SR）"></a>多帧滑动窗与选择重传协议（SR）</h3><h2 id="介质访问控制"><a class="header-anchor" href="#介质访问控制"></a>介质访问控制</h2><h3 id="信道划分介质访问控制"><a class="header-anchor" href="#信道划分介质访问控制"></a>信道划分介质访问控制</h3><h3 id="随机访问介质访问控制"><a class="header-anchor" href="#随机访问介质访问控制"></a>随机访问介质访问控制</h3><h3 id="轮询访问介质访问控制：令牌传递协议"><a class="header-anchor" href="#轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h3><h2 id="局域网"><a class="header-anchor" href="#局域网"></a>局域网</h2><h3 id="局域网的基本概念和体系结构"><a class="header-anchor" href="#局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h3><h3 id="以太网与-IEE-802-3"><a class="header-anchor" href="#以太网与-IEE-802-3"></a>以太网与 IEE 802.3</h3><h3 id="IEEE-802-11"><a class="header-anchor" href="#IEEE-802-11"></a>IEEE 802.11</h3><h3 id="令牌环网的基本原理"><a class="header-anchor" href="#令牌环网的基本原理"></a>令牌环网的基本原理</h3><h2 id="广域网"><a class="header-anchor" href="#广域网"></a>广域网</h2><h3 id="广域网的基本概念"><a class="header-anchor" href="#广域网的基本概念"></a>广域网的基本概念</h3><h3 id="PPP-协议"><a class="header-anchor" href="#PPP-协议"></a>PPP 协议</h3><h3 id="HDLC-协议"><a class="header-anchor" href="#HDLC-协议"></a>HDLC 协议</h3><h2 id="数据链路层设备"><a class="header-anchor" href="#数据链路层设备"></a>数据链路层设备</h2><h3 id="网桥的概念及其基本原理"><a class="header-anchor" href="#网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h3><h3 id="局域网交换机及其工作原理"><a class="header-anchor" href="#局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据链路层基本概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#数据链路层基本概念&quot;&gt;&lt;/a&gt;数据链路层基本概念&lt;/h2&gt;
&lt;p&gt;&lt;font color=&quot;#ea66a6&quot;&gt;结点&lt;/font&gt;：主机、路由器&lt;/p&gt;
&lt;p&gt;&lt;font colo</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://whl123456.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://whl123456.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>高等数学规划</title>
    <link href="https://whl123456.top/2021/07/09/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    <id>https://whl123456.top/2021/07/09/%E6%95%B0%E5%AD%A6/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</id>
    <published>2021-07-09T02:59:33.000Z</published>
    <updated>2021-07-09T04:17:22.145Z</updated>
    
    <content type="html"><![CDATA[<p>7 月 基础</p><p>8 月 强化</p><p>9 月 刷题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;7 月 基础&lt;/p&gt;
&lt;p&gt;8 月 强化&lt;/p&gt;
&lt;p&gt;9 月 刷题&lt;/p&gt;
</summary>
      
    
    
    
    <category term="考研数学" scheme="https://whl123456.top/categories/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>马克思主义基本原理概论（24%）</title>
    <link href="https://whl123456.top/2021/07/08/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA/"/>
    <id>https://whl123456.top/2021/07/08/%E6%94%BF%E6%B2%BB/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%A6%82%E8%AE%BA/</id>
    <published>2021-07-08T14:27:33.000Z</published>
    <updated>2021-07-26T03:04:58.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>⭐ 表示选择题考点，理解</li><li>🌙 表示论述题考点</li><li>没有标记表示一般考点</li></ul></blockquote><h2 id="导论"><a class="header-anchor" href="#导论"></a>导论</h2><h3 id="第一节-马克思主义的创立和发展"><a class="header-anchor" href="#第一节-马克思主义的创立和发展"></a>第一节 马克思主义的创立和发展</h3><h4 id="考点-1-马克思主义的内涵和构成"><a class="header-anchor" href="#考点-1-马克思主义的内涵和构成"></a>考点 1 马克思主义的内涵和构成</h4><p><font color="#faa755">马克思主义的内涵</font>：</p><ul><li>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系，（创立者，谁创立的）</li><li>是关于自然、社会和人类思维发展一般规律的学说，（内容观点，创立了什么）</li><li>是关于社会主义必然代替资本主义、最终实现共产主义的学说，（目标，为什么而创立的）</li><li>是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，（立场，为谁而创立）</li><li>是指引人民创造美好生活的行动指南。（作用，有什么用）</li></ul><p><font color="#faa755">马克思主义的构成</font>：马克思主义是一个博大精深的理论体系。马克思主义哲学、马克思主义政治经济学和科学社会主义是其三个基本组成部分，它们有机统一并共同构成了马克思主义理论的主体内容。</p><p>三个基本组成部分之间的划分：恩格斯在《反杜林论》全面阐述马克思主义理论体系</p><p>三个基本组成部分之间的关系：哲学是基础，政治经济学是主体内容，科学社会主义是目的和归属。用哲学的方法写出政治经济学的内容得出科学社会主义的结论</p><h4 id="考点-2-⭐-马克思主义的基本立场、基本观点和基本方法"><a class="header-anchor" href="#考点-2-⭐-马克思主义的基本立场、基本观点和基本方法"></a>考点 2 ⭐ 马克思主义的基本立场、基本观点和基本方法</h4><p><font color="#faa755">马克思主义的基本立场</font>：马克思主义观察、分析和解决问题的根本立足点和出发点。马克思主义以无产阶级的解放和全人类的解放为己任，以人的自由全面发展为美好目标，以人民为中心，一切为了人民，一切依靠人民。（为谁说话）</p><p><font color="#faa755">马克思主义的基本观点</font>：是关于自然、社会和人类思维发展一般规律的科学认识，是对人类思想成果和社会实践经验的科学总结。</p><p><font color="#faa755">马克思主义的基本方法</font>：是建立在辩证唯物主义和历史唯物主义世界观和方法论基础上，指导我们正确认识世界和改造世界的思想方法和工作方法，主要包括实事求是的方法、辩证分析的方法、社会基本矛盾和主要矛盾分析的方法、历史分析的方法、阶级分析的方法、群众路线的方法等。</p><h4 id="考点-3-⭐-马克思主义的来源"><a class="header-anchor" href="#考点-3-⭐-马克思主义的来源"></a>考点 3 ⭐ 马克思主义的来源</h4><p><font color="#faa755">世界上第一个无产阶级政党</font>：共产主义者同盟</p><p><font color="#faa755">马克思主义公开问世的标志</font>：《共产党宣言》的发表</p><p><font color="#faa755">马克思主义产生的条件</font>：</p><ul><li>社会根源（经济社会基础）：马克思、恩格斯生活的时代，资本主义生产方式在欧洲已经有了相当的发展。</li><li>阶级基础（实践基础）：无产阶级在反抗资产阶级剥削和压迫的斗争中，逐步走向自觉，并迫切渴望科学的理论指导。</li><li>思想渊源：德国古典哲学、英国古典政治经济学、英法两国的空想社会主义（马克思主义的三个基本组成部分的渊源）</li></ul><p>总结扩展 <font color="#faa755">“马恩列”经典著作总结</font></p><p>马克思：</p><ul><li>《德意志意识形态》，首次系统阐述历史唯物主义的基本观点（世界上第一个）</li><li>《共产党宣言》（马、恩共同起草），无产阶级政党的第一个党纲</li><li>《法兰西内战》，科学总结巴黎公社的历史经验和教训</li><li>《资本论》，系统阐述剩余价值学说</li><li>《哥达纲领批判》，进一步丰富了科学社会主义学说</li></ul><p>恩格斯：</p><ul><li>《反杜林论》，全面阐述马克思主义理论体系</li><li>《家庭、私有制和国家的起源》，关于古代社会发展规律和国家起源的著作，马克思主义国家学说的代表之一</li></ul><p>列宁：</p><ul><li>《论欧洲联邦口号》，明确指出:“经济和政治发展的不平衡是资本主义的绝对规律。由此就应得出结论：社会主义可能首先在少数甚至单独一个资本主义国家内获得胜利”</li><li>《无产阶级革命的军事纲领》，资本主义的发展在各个国家是极不平衡的。而且在商品生产下也只能是这样。由此可得出一个必然的结论：社会主义不能在所有国家内同时获得胜利。它将首先在一个或者几个国家内获得胜利，而其余的国家在一段时间内将仍然是资产阶级的或资产阶级以前的国家</li></ul><hr><p>马克思、恩格斯接受国际性工人组织“正义者同盟”的邀请，将其改组为“共产主义者同盟”，并为其起草了世界上第一个无产阶级政党的党纲——《 共产党宣言》。1848 年 2 月，《共产党宣言》的发表，标志着马克思主义的公开问世。</p><p>马克思主义的产生具有深刻的社会根源、阶级基础和思想渊源。</p><ul><li>社会根源：马克思、恩格斯生活的时代，资本主义生产方式在欧洲已经有了相当的发展。工业革命和科技进步极大地提高了劳动生产率，促进了生产力的发展。资本主义生产方式一方面带来了社会化大生产的迅猛发展，另一方面又造成了深重的社会灾难。</li><li>阶级基础：无产阶级在反抗资产阶级剥削和压迫的斗争中，逐步走向自觉，并迫切渴望科学的理论指导。</li><li>思想渊源：19 世纪欧洲三大先进思潮为马克思主义的创立提供了直接的理论来源。德国古典哲学、英国古典政治经济学、英法两国的空想社会主义，这三大思潮都是资本主义发展初期的先进思想家求索时代课题的尝试，他们提出了许多具有启发性的思想。</li></ul><h3 id="第二节-马克思主义的鲜明特征和当代价值"><a class="header-anchor" href="#第二节-马克思主义的鲜明特征和当代价值"></a>第二节 马克思主义的鲜明特征和当代价值</h3><h4 id="考点-4-⭐-马克思主义的鲜明特征"><a class="header-anchor" href="#考点-4-⭐-马克思主义的鲜明特征"></a>考点 4 ⭐ 马克思主义的鲜明特征</h4><p>马克思主义具有鲜明的科学性、革命性、实践性、人民性和发展开放性，这些鲜明特征体现了马克思主义的本质和使命，也展现出马克思主义的理论形象。</p><ol><li><font color="#faa755">科学性</font>，马克思主义是对自然、社会和人类思维发展本质和规律的<font color="#e03e3e">正确</font>反映。（不仅是鲜明特征而且还是独有特征）</li><li><font color="#faa755">革命性</font>，马克思主义的革命性，集中表现为它的<font color="#e03e3e">彻底的批判精神</font>和鲜明的无产阶级立场。（马克思对以往的理论都批判，但不是对其全盘否定）</li><li><font color="#faa755">实践性</font>，马克思主义是从实践中来，到实践中去，在实践中接受检验，并随实践而不断发展的学说。实践性是马克思主义理论区别于其他理论的显著特征。（不仅是显著特征而且还是独有特征）</li><li><font color="#faa755">人民性</font>，人民至上是马克思主义的政治立场。马克思主义政党把人民放在心中最高位置，一切奋斗都致力于实现最广大人民的根本利益。之所以如此，是因为人民群众是历史的创造者，是社会主义事业的依靠力量。需要指出的是，马克思主义的<font color="#e03e3e">人民性是以阶级性为深刻基础</font>的，是无产阶级先进性的体现。（为无产阶级服务就是为人民服务为全人类服务，利益一致，无产阶级的先进性在于没有自己的私利，无产阶级只有解放全人类才能解放它自己）</li><li><font color="#faa755">发展开放性</font>，发展性是指马克思主义是不断发展的学说，具有与时俱进的理论品质。开放性是指马克思主义不断吸收人类历史上一切优秀思想文化成果而不断丰富自己。</li></ol><h4 id="考点-5-马克思主义的当代价值"><a class="header-anchor" href="#考点-5-马克思主义的当代价值"></a>考点 5 马克思主义的当代价值</h4><ul><li>观察当代世界变化的认识工具</li><li>指引当代中国发展的行动指南</li><li>引领人类社会进步的科学真理</li></ul><p>（1）观察当代世界变化的认识工具</p><p>马克思主义给予我们观察当代世界的宏大视野。马克思主义是科学的世界观和方法论，是无产阶级和全人类解放的科学指南，它能够站在科学和时代的制高点上观察事物和现象，从而具有极为广大的视野。</p><p>马克思主义给予我们透视时代风云的锐利目光。当今世界风云变幻，世界格局正处在加速演变的进程之中，产生了大量深刻复杂的现实问题，提出了大量亟待回答的理论课题。要把握和澄清这些问题，就必须学会马克思主义观察和分析问题的方法原则。</p><p>马克思主义给予我们展望未来世界的长远眼光和战略定力。观察当今世界局势和社会发展，不仅要看到现状，更要看到未来;不仅要把握变化脉络，更要观察演化趋势。只有眼光超前、先行一步，才能在世界变化中掌握主动，立于不败之地。</p><p>（2）指引当代中国发展的行动指南</p><p>马克思主义是指引当代中国发展的精神旗帜，是推动当代中国发展的精神动力，是引领当代中国实践的行动指南。</p><p>（3）引领人类社会进步的科学真理</p><p>人类历史发展到今天，与马克思所处的时代相比已经发生了巨大而深刻的变化，但从人类历史发展的大视野来看，世界仍然处于马克思主义所指明的从资本主义走向社会主义的大时代。人类的未来仍然需要马克思主义的启迪和指引。社会是在矛盾中进步的，每一个时代的社会进步总是伴随着相应的社会问题，人类社会怎样面对和处理这些问题，怎样才能走向更加美好的明天?回答和解决这样的根本性问题，还是需要到马克思主义中汲取智慧。</p><p>大学生在学习马克思主义的过程中，要有正确的态度和科学的方法：</p><ul><li>第一，努力学习和掌握马克思主义的基本立场、观点、方法；</li><li>第二，坚持理论联系实际的马克思主义学风；</li><li>第三，自觉将马克思主义内化于心、外化于行。</li></ul><h2 id="第一章-辩证唯物论"><a class="header-anchor" href="#第一章-辩证唯物论"></a>第一章 辩证唯物论</h2><h3 id="第一节-哲学的基本问题"><a class="header-anchor" href="#第一节-哲学的基本问题"></a>第一节 哲学的基本问题</h3><h4 id="考点-6-⭐-哲学基本问题及不同哲学流派"><a class="header-anchor" href="#考点-6-⭐-哲学基本问题及不同哲学流派"></a>考点 6 ⭐ 哲学基本问题及不同哲学流派</h4><p>哲学基本问题：思维（意识）和存在（物质）的关系问题，包括物质和意识第一性问题和有无同一性问题。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.ne2vwhtt5yo.png" alt="image"></p><p>恩格斯总结和概括了哲学发展特别是近代哲学发展的历史事实，第一次明确提出:“全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题。”哲学基本问题包括两个方面的内容。</p><p><font color="#faa755">基本问题一：物质和精神何者是第一性、何者是第二性，即“物质和精神何者是世界的本原”?</font></p><p>根据对上述基本问题的不同回答，哲学可划分为唯物主义和唯心主义两个对立的基本派别。</p><ul><li>唯物主义把世界的本原归结为物质，主张物质第一性、意识第二性，意识是物质的产物；</li><li>唯心主义把世界的本原归结为精神，主张意识第一性、物质第二性，物质是意识的产物。</li></ul><p>凡唯物主义者，都承认世界的本原是物质，但根据对物质理解的广度和深度，唯物主义可划分为三种基本形态。</p><ul><li>古代朴素唯物主义（古典唯物主义）从具体的物质形态出发说明世界，把物质等同于物质的具体形态，对世界物质性的理解和把握具有直观性和朴素性。</li><li>近代形而上学唯物主义根据当时自然科学关于原子是物质最小单位的认识，把物质归结为原子，认为原子的属性就是一切物质形态的共同属性。这种概括虽然有了一定的科学依据，但混淆了自然科学物质结构概念同哲学物质范畴的区别，经不起自然科学发展的检验，也经不起唯心主义的进攻，尤其是不能说明社会生活的物质性。</li><li>现代辩证唯物主义从无限多样的物质现象中抽象出共同的本质，从哲学上作了最高概括，指出客观实在性是物质的本质规定。（现代辩证唯物主义包含前两派，但现代辩证唯物主义认为是物质的东西前两派不一定支持，如人类历史，把历史当做物质去看到得出唯物史观）</li></ul><blockquote><p>马克思在<font color="#e03e3e">哲学史</font>上两大历史贡献：创立了历史唯物主义和辩证唯物主义。</p><p>马克思在理论上的两大伟大贡献：唯物史观、剩余价值学说。</p></blockquote><p>凡唯心主义者，都承认世界的本原是意识。唯心主义归结起来有两种基本形态。</p><ul><li>主观唯心主义认为作为本原的意识是本我的意识；（笛卡尔、王阳明）</li><li>客观唯心主义认为作为本原的意识是独立于“我”之外的客观精神。（上帝，道生说，理说）</li></ul><p><font color="#faa755">基本问题二：思维和存在有无同一性，即“思维能否正确认识存在”?</font></p><p>根据对上述基本问题的不同回答，哲学又可以划分为可知论和不可知论。</p><ul><li>可知论认为世界是可以被认识的，思维和存在具有同一性；（唯物主义和唯心主义都是可知论，但认识产生的顺序不同）</li><li>不可知论认为世界是不能被人所认识或不能被完全认识的，否认思维和存在的同一性。（二元论：不彻底的唯心主义者）</li></ul><p><font color="#faa755">重要问题：世界是怎样存在的？</font></p><p>哲学除了对基本问题进行回答，还回答世界是怎样存在的问题，即“世界上的事物是联系的还是孤立的，是发展的还是静止的&quot;。根据对这个问题的不同回答，形成了辩证法和形而上学两种不同的观点。</p><ul><li>辩证法坚持用联系的、发展的观点看世界，认为发展的根本原因在于事物的内部矛盾；</li><li>形而上学则坚持用孤立的、静止的观点看问题，否认事物内部矛盾的存在和作用。（机械一定是形而上学，形而上学不一定是机械）</li></ul><h3 id="第二节-世界的多样性与物质统一性"><a class="header-anchor" href="#第二节-世界的多样性与物质统一性"></a>第二节 世界的多样性与物质统一性</h3><h4 id="考点-7-⭐-物质范畴及其理论意义"><a class="header-anchor" href="#考点-7-⭐-物质范畴及其理论意义"></a>考点 7 ⭐ 物质范畴及其理论意义</h4><p>马克思批判了旧唯物主义对物质世界直观、消极的理解，强调要从能动的实践出发去把握客观世界的意义。</p><p><font color="#faa755">恩格斯关于物质概念的提法</font>：“物、物质无非是各种物的总和，而这个概念就是从这一总和中<font color="#e03e3e">抽象</font>出来的。”这就是说，物质这个名词是一种简称， “我们就用这种简称把感官可感知的许多不同的事物依照其共同的属性概括起来”。这样就明确指出了哲学物质概念与自然科学关于具体的物质形态和物质结构的概念之间共性与个性的关系。</p><p><font color="#faa755">列宁关于物质概念的提法</font>：“物质是标志客观实在的哲学范畴，</p><ul><li>这种客观实在是人通过感觉感知的，</li><li><font color="#e03e3e">它不依赖于我们的感觉而存在</font>，</li><li>为我们的感觉所复写、摄影、反映。”</li></ul><p>列宁是从物质与意识的关系上来把握物质的。物质范畴是对物质世界多样性和统一性所作的最高的哲学概括。物质的唯一特性是客观实在性，它存在于人的意识之外，为人的意识所反映。</p><p>定义方式：通过物质和意识的关系</p><p>物质的唯一特性：客观实在</p><blockquote><p>物质的根本属性：运动</p></blockquote><p><font color="#faa755">马克思主义物质观的理论意义</font>：</p><ul><li>第一，坚持了物质的客观实在性原则，坚持了唯物主义一元论，同唯心主义一元论和二元论划清了界限。</li><li>第二，坚持了能动的反映论和可知论，有力地批判了不可知论。</li><li>第三，体现了唯物论和辩证法的统一， 克服了形而上学唯物主义的缺陷。</li><li>第四，体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了理论基础。</li></ul><h4 id="考点-8-⭐-物质和运动"><a class="header-anchor" href="#考点-8-⭐-物质和运动"></a>考点 8 ⭐ 物质和运动</h4><p><font color="#faa755">运动的概念</font>：**运动是标志一切事物和现象的变化及其过程的哲学范畴。**运动是物质的<font color="#e03e3e">存在方式</font>和<font color="#e03e3e">根本属性</font>。恩格斯说:“运动，就它被理解为存在方式，被理解为物质的固有属性这一最一般的意义来说，囊括宇宙中发生的一切变化和过程，从单纯的位置变动起直到思维。”</p><p><font color="#faa755">物质和运动的关系</font>：不可分割。运动是物质的运动，物质是运动着的物质。（X 是 Y 的 X，Y 是 X 的 Y）</p><p><font color="#faa755">两种错误的观点</font>：脱离物质谈运动，将导致唯心主义；脱离运动谈物质，将导致形而上学。</p><h4 id="考点-9-⭐-运动和静止"><a class="header-anchor" href="#考点-9-⭐-运动和静止"></a>考点 9 ⭐ 运动和静止</h4><p>物质世界的运动是绝对的，而物质在运动过程中又有某种暂时的静止，静止是相对的。</p><p><font color="#faa755">静止的概念</font>：静止是物质运动在一定条件下的稳定状态，包括空间位置和根本性质暂时未变这样两种运动的特殊状态。</p><p><font color="#faa755">运动和静止的关系</font>：对立统一 。（相互区别、相互联系）</p><p><font color="#faa755">运动和静止相互区别</font>：</p><ul><li>运动的绝对性体现了物质运动的变动性、无条件性；</li><li>静止的相对性体现了物质运动的稳定性、有条件性。</li></ul><p><font color="#faa755">运动和静止相互联系</font>：运动和静止相互依赖、相互渗透、相互包含，“动中有静，静中有动”。无条件的绝对运动和有条件的相对静止构成了事物的矛盾运动。只有把握了运动和静止的辩证关系，才能正确理解物质世界及其运动形式的多样性，才能理解认识和改造世界的可能性。</p><blockquote><p>概念之间的关系：不可分割（词性不同）、对立统一（词性相同）</p></blockquote><p><font color="#faa755">两种错误的观点</font>：夸大静止，否定运动将导致形而上学；夸大运动，否定静止将导致诡辩论。</p><h4 id="考点-10-⭐-物质运动和时空"><a class="header-anchor" href="#考点-10-⭐-物质运动和时空"></a>考点 10 ⭐ 物质运动和时空</h4><p><font color="#faa755">时空的概念</font>：</p><ul><li>时间是指物质运动的持续性、顺序性，特点是<font color="#e03e3e">一维性</font>，即一去不复返。</li><li>空间是指物质运动的广延性、伸张性，特点是<font color="#e03e3e">三维性</font>。</li></ul><p><font color="#faa755">物质运动和时空的关系</font>：不可分割。时空是物质运动的时空，物质运动是时空中的物质运动。时间和空间是物质运动的<font color="#e03e3e">存在形式</font>（存在方式）。</p><blockquote><p>运动是物质的<font color="#e03e3e">存在方式</font>和<font color="#e03e3e">根本属性</font>。</p></blockquote><p><font color="#faa755">时空的特点</font>：</p><ul><li>物质运动与时间和空间的不可分割证明了时间和空间的客观性。（不以人的意志为转移）</li><li>具体物质形态的时空是有限的，（具体事物的时间是有限的）</li><li>而整个物质世界的时空是无限的；（所有事物的时间是无限的）</li><li>物质运动时间和空间的客观实在性是绝对的，（绝对存在）</li><li>物质运动时间和空间的具体特性是相对的。（物质速度超过一定极限，时空发生变化）</li></ul><p>物质、运动、时间、空间具有内在的统一性。从根本上说，世界上除了运动的物质，什么也没有。</p><h4 id="考点-11-⭐-实践是自然存在与社会存在区分和统一的基础"><a class="header-anchor" href="#考点-11-⭐-实践是自然存在与社会存在区分和统一的基础"></a>考点 11 ⭐ 实践是自然存在与社会存在区分和统一的基础</h4><p>物质世界在漫长的历史演进中，按其自身的规律不断地自发演化，展现出发展的多样性。而人类的产生使自然界的演化发生了新的飞跃，世界从此有了自然与社会的区别。这种飞跃和区别归根到底是人通过实践完成的。</p><p><font color="#33a3dc">社会生活的本质是实践</font></p><p><font color="#faa755">从实践出发理解社会生活的本质，要把握以下两个大的方面</font>：</p><ul><li><font color="#33a3dc">一方面，实践是使物质世界分化为自然界与人类社会的历史前提，又是使自然界与人类社会统一起来的现实基础</font>。在实践活动中，物质世界被区分为自然界和人类社会两大领域，二者都具有客观实在性，它们相互联系、相互作用。自从人类产生以后，自然界在人的实践活动中以新的形式延续自己的存在和发展。通过劳动，人类具有了自己实践的存在方式。人类社会既是自然界的一部分，又有着自身特殊的发展规律。如果离开了社会实践，抽去社会性这一环节，人与自然的关系就变成了动物与自然的关系。</li><li><font color="#33a3dc">另一方面，实践是人类社会的基础，是理解和解释一切社会现象的钥匙</font>。马克思主义确认社会生活在本质上是实践的，也就是把社会生活“当作实践去理解”。社会生活是对人们各种社会活动的总称。<font color="#faa755">社会生活的实践性主要表现在</font>：<ul><li>第一，实践是社会关系形成的基础。（生产劳动）</li><li>第二，实践形成了社会生活的基本领域。</li><li>第三，实践<font color="#e03e3e">构成了</font>社会发展的动力。（<font color="#e03e3e">社会发展的动力是社会基本矛盾</font>）</li></ul></li></ul><h4 id="考点-12-⭐-意识的来源、本质和作用"><a class="header-anchor" href="#考点-12-⭐-意识的来源、本质和作用"></a>考点 12 ⭐ 意识的来源、本质和作用</h4><p><font color="#faa755">意识的概念</font>：意识</p><ul><li>是自然界长期发展的产物，（是物质世界长期发展的产物，因为在还没有人的时候物质世界与自然界是等同的）</li><li>是人脑的机能和属性，</li><li>是客观世界的主观映象。（意识的本质）</li></ul><p><font color="#faa755">意识的来源</font>：意识从其起源来看是自然界长期发展的产物。意识作为一种反映形式，它的形成经历了三个发展阶段，</p><ul><li>即由一切物质所具有的反应特性到低等生物的刺激感应性，</li><li>再到高等动物的感觉和心理，</li><li>最终发展为人类的意识。（意识是人独有的）</li></ul><p><font color="#faa755">意识形成过程中的影响因素</font>：意识不仅是自然界长期发展的产物，而且是社会历史发展的产物。<font color="#33a3dc">社会实践特别是劳动，在意识的产生和发展中起着决定性的作用</font>。（决定）</p><ul><li>一方面，劳动为意识的产生和发展提供了客观需要和可能；</li><li>另一方面，在人们的劳动和交往中形成的语言促进了意识的发展，<font color="#33a3dc">语言是意识的物质外壳</font>。（重要影响）</li></ul><p><font color="#faa755">意识的本质</font>：<font color="#33a3dc">意识从其本质来看是客观世界的主观映象，是客观内容和主观形式的统一</font>。意识是物质的产物，但又不是物质本身，意识是特殊的物质一人脑的机能和属性，意识在内容上是客观的，在形式上是主观的。马克思指出:“观念的东西不外是移人人的头脑并在人的头脑中改造过的物质的东西而已。”这表明，物质决定意识，意识依赖于物质并反作用于物质。</p><p>🌙 <font color="#e03e3e">意识的作用</font>：辩证唯物主义在坚持物质决定意识、意识依赖于物质的同时，又承认意识对物质具有<font color="#33a3dc">能动作用</font>。意识的能动作用是人的意识所特有的积极认识世界与改造世界的能力和活动。主要表现在：</p><p><font color="#33a3dc">第一，意识活动具有目的性和计划性</font>。人在认识客观世界、尊重客观规律的同时，还总是根据一定的目的和要求去确定反映什么、不反映什么，以及怎样反映，从而表现出主体的选择性。马克思说，人在“劳动过程结束时得到的结果，在这个过程开始时就已经在劳动者的表象中存在着，即已经观念地存在着”。人的整个实践过程，就是围绕意识活动所构建的目标和蓝图来进行的。</p><p><font color="#33a3dc">第二，意识活动具有创造性</font>。人的意识不仅采取感觉、知觉、表象等形式，反映事物的外部现象，而且运用概念、判断、推理等形式，对感性材料进行加工制作和选择建构，在思维中构造一个现实中所没有的理想世界。</p><p><font color="#33a3dc">第三，意识具有指导实践改造客观世界的作用</font>。意识的能动作用不限于从实践中形成一定的思想，形成活动的目的、计划、方法等观念的东西，更重要的在于以这些观念的东西为指导，通过实践使之一步步变为客观现实。正如列宁所说：“世界不会满足人，人决心以自己的行动来改变世界。”改变世界或创造世界不仅意味着强化客观世界的变化过程，而且意味着创造出世界上原来所没有的东西，即没有人的参与永远也不可能出现的东西。</p><p><font color="#33a3dc">第四，意识具有调控人的行为和生理活动的作用</font>。现代科学和医学实验证明：意识、心理因素能够对人的行为选择和健康状况产生重要影响。俗话说的“笑一笑十年少， 愁一愁白了头”多少反映了这个道理。</p><h4 id="考点-13-⭐-物质与意识的辩证关系"><a class="header-anchor" href="#考点-13-⭐-物质与意识的辩证关系"></a>考点 13 ⭐ 物质与意识的辩证关系</h4><p><font color="#faa755">物质和意识相互区别</font>：</p><ol><li>物质是本原，意识是派生；</li><li>物质不是意识，意识不是物质；（庸俗唯物主义观点：意识是人脑的分泌物）</li><li>物质不能代替意识，意识不能代替物质。</li></ol><p><font color="#faa755">物质和意识相互联系</font>：</p><ol><li>物质可以转化为（变成）意识，意识可以转化为（变成）物质；（实践是两者相互转换的桥梁）</li><li>意识对物质既有依赖性，又有相对独立性；（物质与意识是“一强一弱”的关系，但意识又不是那么的弱可以反作用于物质）</li><li>物质决定意识，意识反作用于物质。</li></ol><hr><p>实践活动不但形成了社会存在，而且还创造了地球上“最美丽的花朵”——意识， 使世界二重化为客观世界和主观世界。物质和意识的辩证关系，指的是二者之间既相互区别又相互联系，具体表述如下表所示。</p><p>正确认识和把握物质与意识的辩证关系，还需要处理好<font color="#faa755">主观能动性和客观规律性的关系</font>。</p><p><font color="#33a3dc">一方面，尊重客观规律是正确发挥主观能动性的前提</font>。人们只有在认识和掌握客观规律的基础上，才能正确地认识世界，有效地改造世界。人创造历史，但不是随心所欲地创造。只有遵循历史的规律和进程，把握时代的脉搏和契机，人才能真正成为历史的主人。</p><p><font color="#33a3dc">另一方面，只有充分发挥主观能动性，才能正确认识和利用客观规律</font>。承认规律的客观性，并不是说人在规律面前无能为力、无所作为。人能够通过自觉活动去认识规律，并按照客观规律去改造世界，以满足自身的需要。因此，尊重事物发展的客观规律性与发挥人的主观能动性是辩证统一的， 实践是客观规律性与主观能动性统一的基础。</p><p><font color="#faa755">正确发挥人的主观能动性，有以下三个方面的前提和条件</font>：</p><ul><li><font color="#33a3dc">第一，从实际出发是正确发挥人的主观能动性的前提</font>。只有从实际出发、充分反映客观规律的认识，才是正确的认识；只有以正确的认识为指导，才能形成正确的行动。</li><li><font color="#33a3dc">第二，实践是正确发挥人的主观能动性的基本途径</font>。正确的认识要变为现实的物质力量，只能通过物质的活动——实践才能达到。</li><li><font color="#33a3dc">第三，正确发挥人的主观能动性，还需要依赖于一定的物质条件和物质手段</font>。“巧妇难为无米之炊”，没有现实的原材料，人的意识再“巧”也创造不出任何物质的东西来。</li></ul><p><font color="#33a3dc">在社会历史领域，主观能动性与客观规律性的辩证关系具体表现为社会历史趋向与主体选择的关系</font>。社会历史趋向指的是社会历史规律的客观性和必然性，主体选择指的是历史主体在社会发展中的能动性和选择性。社会历史规律的客观性和必然性规定了人的活动要受规律性的制约，但与此同时，又不能否定人作为历史主体的能动性和选择性。在社会发展的每一个具体<br>阶段上，都存在着各种不同的客观趋势和可能性，而人则需要确定自己对待它们的态度并作出选择。选择的方向、目标和方式是否正确，只能由实践来检验。</p><p>坚持和发展中国特色社会主义道路，体现了社会历史趋向与主体选择的辩证统一。发展道路要与社会生产力水平相适应，不能脱离基本国情，这是社会历史趋向；发展道路不能违背人民群众的利益和愿望，不能脱离各国的政治条件和历史文化传统，这是主体选择。实践证明：中国特色社会主义道路是我国实现社会主义现代化、创造人民美好生活、实现中华民族伟大复兴的必由之路。中国特色社会主义道路是符合社会历史趋向的正确的主体选择。</p><h4 id="考点-14-⭐-世界的物质统一性原理"><a class="header-anchor" href="#考点-14-⭐-世界的物质统一性原理"></a>考点 14 ⭐ 世界的物质统一性原理</h4><p>世界的物质统一性原理是马克思主义关于世界本质问题的一个基本原理。这一原理的内容包括：</p><ul><li><font color="#33a3dc">其一，世界是统一的，即世界的本原是一个</font>；（可以批判二元论）</li><li><font color="#33a3dc">其二，世界的统一性在于它的物质性，即世界统一的基础是物质，而不是某种“始基”的物体</font>；（可以批判唯心主义）</li><li><font color="#33a3dc">其三，物质世界的统一性是多样性的统一，而不是单一的无差别的统一</font>。（可以批判旧唯物主义）</li></ul><p>马克思主义与其他哲学派别的联系和区别</p><div class=demo><p>马克思主义哲学与唯心主义哲学（唯心主义一元论）</p><p>联系：都是可知论（一元论）</p><p>区别：</p><ol><li>马克思主义哲学认为物质是世界的本原，唯心主义认为意识是世界的本原；</li><li>马克思主义哲学在认识问题上坚持能动的反映论，唯心主义坚持先验论；</li><li>马克思主义哲学彻底坚持辩证法，唯心主义部分坚持；</li><li>马克思主义哲学在历史观上是唯物的，唯心主义在历史观上是唯心的</li></ol></div><div class=demo><p>马克思主义哲学与旧唯物主义哲学</p><p>联系：都是唯物主义，都认为物质是世界的本原</p><p>区别：</p><ol><li>马克思主义哲学在认识论上坚持能动的反映论，旧唯物主义坚持机械反映论；</li><li>马克思主义哲学彻底坚持辩证法，旧唯物主义完全不认同辩证法，坚持形而上学；</li><li>马克思主义哲学在历史观上是唯物的，旧唯物主义在历史观上是唯心的；</li><li>马克思主义哲学坚持实践的观点，旧唯物主义没有</li></ol></div><p><font color="#33a3dc">世界的物质统一性首先体现在，意识统一于物质</font>。从意识的起源上看，意识是物质世界长期发展的产物，是物质世界中的一种特殊存在；从意识的本质上看，意识是人脑这种特殊的物质器官的机能，是客观存在的主观映象；从意识的作用上看，意识能动性的发挥必须以尊重物质世界的客观规律为前提。因此，意识统一于物质， 在统一的物质世界之外，没有任何非物质<br>的存在或非物质的活动。</p><p><font color="#33a3dc">世界的物质统一性还体现在，人类社会也统一于物质</font>。人类社会是否具有物质性，是在马克思主义产生之前长期没有得到正确解决的问题。马克思主义以前的旧唯物主义在自然观上是唯物主义的，但在社会历史领域，旧唯物主义不理解人的实践活动本身是一种客观存在，不理解物质生产实践在社会生活中的地位和作用，而是把历史过程看成人的主观意志的产物，因而得出社会意识决定社会存在的错误结论，成了不彻底的“半截子”唯物主义。马克思主义将唯物主义真正贯彻到社会历史领域，认为物质资料生产方式是人类社会存在和发展的基础，实践性是社会生活的本质，人类社会统一于物质。<font color="#faa755">人类社会的物质性主要表现在</font>：</p><ul><li>第一，人类社会是物质世界的组成部分。</li><li>第二，人类获取生活资料的活动是物质性的活动。（实践属于物质）</li><li>第三，人类社会存在和发展的基础是物质资料的生产方式。</li></ul><p>🌙 <font color="#faa755">世界的物质统一性原理是马克思主义的基石</font>。在认识世界和改造世界的过程中，坚持实事求是，一切从实际出发。一切从实际出发，是世界的物质统一性原理在现实生活中和实际工作中的生动体现。</p><h2 id="第二章-唯物辩证法"><a class="header-anchor" href="#第二章-唯物辩证法"></a>第二章 唯物辩证法</h2><h3 id="第一节-事物的联系和发展"><a class="header-anchor" href="#第一节-事物的联系和发展"></a>第一节 事物的联系和发展</h3><h4 id="考点-15-⭐-唯物辩证法两大总特征"><a class="header-anchor" href="#考点-15-⭐-唯物辩证法两大总特征"></a>考点 15 ⭐ 唯物辩证法两大总特征</h4><p>唯物辩证法是关于世界普遍联系和永恒发展的科学，联系和发展的观点是唯物辩证法的总观点和总特征。</p><p>（1）事物的普遍联系</p><p><font color="#faa755">联系的概念</font>：联系是指<font color="#33a3dc">事物内部</font>各要素之间和<font color="#33a3dc">事物之间</font>相互影响、相互制约和相互作用的关系。（联系是以区别为前提）</p><p><font color="#faa755">联系的特点</font>：</p><ol><li>联系具有<font color="#33a3dc">客观性</font>。事物的联系是事物本身所固有的，不是主观臆想的。</li><li>联系具有<font color="#33a3dc">普遍性</font>。事物联系的普遍性有三层含义：<ul><li>其一，任何事物内部的不同部分和要素是相互联系的，即任何事物都具有内在的结构性。</li><li>其二，任何事物都不能孤立存在，都同其他事物处于一定的相互联系之中。</li><li>其三，整个世界是相互联系的统一整体， 每一事物都是世界普遍联系中的一个成分或环节，并通过它表现出联系的普遍性。世界的普遍联系是通过“中介”来实现的。</li></ul></li><li>联系具有<font color="#33a3dc">多样性</font>。世界上的事物是多样的，因而事物的联系也是多样的。事物联系的主要方式：内部联系和外部联系、直接联系和间接联系、必然联系和偶然联系、本质联系和非本质联系等。</li><li>联系具有<font color="#33a3dc">条件性</font>。条件是对事物存在和发展发生作用的诸要素的总和。<ul><li>其一，条件对事物发展和人的活动具有支持或制约作用；</li><li>其二，条件是可以改变的，人们经过努力可以创造出事物发展所需要的条件；</li><li>其三，改变和创造条件不是任意的，必须尊重事物发展的客观规律。</li></ul></li></ol><p>事物普遍联系原理的方法论意义：马克思主义关于事物普遍联系的原理，要求人们要善于分析事物的具体联系，确立整体性、开放性的观念，从动态中考察事物的普遍联系。</p><p>（2）事物的永恒发展</p><p><font color="#faa755">发展的内涵（概念）</font>：概括一切形式的变化就是运动，运动变化的基本趋势是发展。（运动 = 变化 &gt; 发展）</p><p><font color="#faa755">发展的实质</font>：发展是前进上升的运动，发展的实质是新事物的产生和旧事物的灭亡。</p><p><font color="#faa755">新事物和旧事物的概念</font>：新事物是指合乎历史前进方向、具有远大前途的东西；旧事物是指丧失历史必然性、日趋灭亡的东西。（与时间没有关系，新事物一定产生于旧事物之后的说法是错误）</p><p><font color="#faa755">新事物必然战胜旧事物的原因</font>：</p><ul><li>第一，就新事物与环境的关系而言，新事物有新的结构和功能，它适应已经变化了的环境和条件；旧事物的各种要素和功能已不适应环境和客观条件的变化。</li><li>第二，就新事物与旧事物的关系而言，新事物是在旧事物的“母体”中孕育成熟的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、仍然适合新的条件的因素，并添加了旧事物所不能容纳的新内容。</li><li>这两方面也就是新事物在本质上优越于旧事物，具有强大生命力的原因所在。在社会历史领域内，新事物是社会上先进的、富有创造力的人们创造性活动的产物，它从根本上符合人民群众的利益和要求，能够得到人民群众的拥护，因而必然战胜旧事物。</li></ul><p><font color="#faa755">事物发展的过程性</font>：事物的发展是一个过程。一切事物只有经过一定的过程才能实现自身的发展。所谓过程是指一切事物都有其产生、发展和转化为其他事物的历史，都有它的过去、现在和未来。恩格斯指出:“<font color="#33a3dc">世界不是既成事物的集合体，而是过程的集合体。</font>”</p><p><font color="#faa755">事物永恒发展的方法论意义</font>：坚持事物发展是过程的思想，就要用历史的眼光看问题，把一切事物如实地看作变化、发展的过程，既要了解它们的过去、观察它们的现在，又要预见它们的未来。</p><h4 id="考点-16-⭐-原因和结果（唯物辩证法第一对基本范畴）"><a class="header-anchor" href="#考点-16-⭐-原因和结果（唯物辩证法第一对基本范畴）"></a>考点 16 ⭐ 原因和结果（唯物辩证法第一对基本范畴）</h4><p>原因和结果是揭示事物的<font color="#33a3dc">前后相继</font>、<font color="#33a3dc">彼此制约</font>的关系范畴。（前后相继即为因果关系的说法是错误的）</p><p><font color="#faa755">概念</font>：客观世界到处都存在着引起与被引起的普遍联系，辩证法把这种引起与被引起的关系称为因果关系。</p><ul><li>其中，引起某种现象的现象叫原因，</li><li>而被某种现象所引起的现象叫结果。</li></ul><p><font color="#faa755">关系</font>：原因和结果的关系是辩证的。（对立统一）</p><ul><li>第一， 原因和结果的区分<font color="#33a3dc">既是确定的，又是不确定的</font>。（在既定的条件之下因果的关系是确定的）</li><li>第二，原因和结果<font color="#33a3dc">相互作用</font>，原因产生结果，结果反过来影响原因，互为因果。</li><li>第三，原因和结果<font color="#33a3dc">互相渗透</font>，结果存在于原因之中，原因表现在结果之中。</li><li>第四，原因和结果的关系是<font color="#33a3dc">复杂多样</font>的，有一因多果、同因异果、一果多因、异因同果、多因多果、复合因果。（有其因必有其果的说法是错误的违背了原因与结果复杂多样的关系，有因必有果的说法是正确的）</li></ul><p><font color="#faa755">方法论意义</font>：正确把握事物的因果联系是自觉的实践活动的必要条件。“<font color="#33a3dc">凡事预则立，不预则废</font>。”辩证地分析事物的因果关系，分析存在和发展的不同原因及其不同结果，可以增强人们活动的自觉性、预测性和调控性。</p><h4 id="考点-17-⭐-必然和偶然（唯物辩证法第二对基本范畴）"><a class="header-anchor" href="#考点-17-⭐-必然和偶然（唯物辩证法第二对基本范畴）"></a>考点 17 ⭐ 必然和偶然（唯物辩证法第二对基本范畴）</h4><p>必然和偶然是揭示客观事物发生、发展和灭亡的不同趋势的范畴。</p><p><font color="#faa755">概念</font>：</p><ul><li>必然是指事物联系和发展过程中一定要发生、确定不移的趋势；</li><li>偶然是指事物联系和发展过程中并非确定发生的，可以出现，也可以不出现，可以这样出现，也可以那样出现的不确定的趋势。</li></ul><p><font color="#faa755">关系</font>：必然和偶然是对立统一的关系。</p><ol><li>一方面， 必然和偶然是有区别的（相互区别）：<ul><li><font color="#33a3dc">它们产生和形成的原因不同</font>。必然产生于事物内部的根本矛盾；偶然产生于非根本矛盾和外部条件。</li><li><font color="#33a3dc">它们的表现形式不同</font>。必然在事物发展过程中比较稳定、时空上比较确定，是同类事物普遍具有的发展趋势；偶然则是不稳定的、暂时的、不确定的，是事物发展中的个别表现。</li><li><font color="#33a3dc">它们在事物发展中的地位和作用不同</font>。必然在事物发展中居于支配地位，决定着事物发展的方向；偶然居于从属地位，对发展的必然过程起促进或延缓作用，使发展的确定趋势带有一定的特点和偏差。</li></ul></li><li>另一方面，必然和偶然又是统一的（相互联系）：<ul><li>必然存在于偶然之中，通过大量的偶然表现出来，并为自己开辟道路；</li><li>偶然背后隐藏着必然，受必然的支配，偶然是必然的表现形式和补充；</li><li>必然和偶然在一定条件下可以互相转化。</li></ul></li></ol><p><font color="#faa755">方法论意义</font>：唯物辩证法关于必然和偶然辩证关系的原理要求我们既要重视事物发展的必然，把握事物发展的总趋势，又要善于从偶然中发现必然，把握有利于事物发展的机遇。</p><h4 id="考点-18-⭐-可能和实现（唯物辩证法第三对基本范畴）"><a class="header-anchor" href="#考点-18-⭐-可能和实现（唯物辩证法第三对基本范畴）"></a>考点 18 ⭐ 可能和实现（唯物辩证法第三对基本范畴）</h4><p>可能和现实是揭示事物的过去、现在和将来的相互关系的范畴。</p><p><font color="#faa755">概念</font>：</p><ul><li>可能是指事物发展过程中潜在的东西，是指包含在事物中并预示事物发展前途的种种趋势；</li><li>现实是指相互联系着的实际存在的事物的综合。</li></ul><p><font color="#faa755">关系</font>：（对立统一）</p><ol><li>一方面，现实蕴藏着未来的发展方向，会不断产生出新的可能；（相互包含）</li><li>另一方面，可能包含着发展成为现实的因素和根据，一旦主客观条件成熟，可能就会转化为现实。（相互转换）</li></ol><p>根据现实中是否有依据，区分可能与不可能；</p><p>根据在现实中是否有充分依据，可以区分现实的可能和抽象的可能（潜在的可能）</p><p><font color="#faa755">方法论意义</font>：要求人们立足现实，展望未来，注意分析事物发展的各种可能，发挥主观能动性，做好应对不利情况的准备，争取实现好的可能。</p><h4 id="考点-19-⭐-现象和本质（唯物辩证法第四对基本范畴）"><a class="header-anchor" href="#考点-19-⭐-现象和本质（唯物辩证法第四对基本范畴）"></a>考点 19 ⭐ 现象和本质（唯物辩证法第四对基本范畴）</h4><p>现象和本质是揭示客观事物的外部表现和内在联系相互关系的范畴。</p><p><font color="#faa755">概念</font>：</p><ul><li>现象是事物的外部联系和表面特征，人们可通过感官感知；</li><li>本质则是事物的内在联系和根本性质，只有通过理性思维才能把握。</li></ul><p><font color="#faa755">关系</font>：（对立统一）</p><ol><li>一方面，现象和本质是有区别的。<ul><li>现象是个别的、具体的，而本质是一般的、普遍的；</li><li>现象是多变易逝的，本质则是相对稳定的；</li><li>现象是生动、丰富的，本质是比较深刻、单纯的。</li><li>现象有真象和假象之分，假象与错觉不是一回事。（错觉一定是假象迷惑导致的说法是错误的）</li></ul></li><li>另一方面，现象和本质又是统一的，它们相互联系、相互依存。<ul><li>任何本质都是通过现象表现出来的，没有不表现为现象的本质；</li><li>任何现象都从一定的方面表现着本质，现象是本质的外部表现，即使是假象也是本质的表现。</li></ul></li></ol><div calss=demo><p>真象是正确的现象（×）客观存在不能使用对错来形容</p><p>错觉是错误的感觉（√）</p></div><div calss=demo><p>真象往往隐藏在内部（×）</p><p>假象往往外露在外部（√）</p><p>无论真象还是假象都是现象，现象都是外露在外部</p></div><p><font color="#faa755">方法论意义</font>：现象和本质的辩证关系表明，</p><ul><li>正是因为现象和本质是统一的， 所以我们能够通过现象认识事物的本质；</li><li>同时由于现象和本质是对立的，又要求人们不能停留于现象而必须透过现象揭示本质。</li></ul><p>人们正是通过对事物现象的去粗取精、去伪存真、由此及彼、由表及里的认识过程，才能不断深化对事物本质的认识。透过现象发现本质是科学研究的任务，因为“如果事物的表现形式和事物的本质会直接合而为一，一切科学都成为多余的了”。</p><h4 id="考点-20-⭐-内容和形式（唯物辩证法第五对基本范畴）"><a class="header-anchor" href="#考点-20-⭐-内容和形式（唯物辩证法第五对基本范畴）"></a>考点 20 ⭐ 内容和形式（唯物辩证法第五对基本范畴）</h4><p>内容和形式是揭示事物内在要素同这些要素的结构和表现方式的关系范畴。</p><p><font color="#faa755">概念</font>：</p><ul><li>内容是构成事物一切要素的总和，是事物存在的基础；</li><li>形式是内容诸要素相互结合的结构和表现方式。</li></ul><p><font color="#faa755">关系</font>：内容和形式是相互依赖、不可分割的。</p><ul><li>任何事物的内容都有一定的形式，任何形式也都有一定的内容，没有无内容的空洞的形式，也没有无形式的纯粹的内容。</li><li>事物的内容是无限丰富的，事物的形式也是多种多样的。内容和形式相互作用、相互影响。</li><li>内容决定形式，形式反作用于内容。当形式适合内容时，对内容的发展起着积极的推动作用；当形式不适合内容<br>时，对内容的发展起着消极的阻碍作用。</li></ul><blockquote><p>生产力和生产关系就是内容和形式</p></blockquote><p><font color="#faa755">方法论意义</font>：</p><ul><li>在把握内容和形式这对范畴时，既要重视内容，根据内容的需要决定形式的取舍、改造和创新；</li><li>又要善于运用形式，发挥其积极作用，利用和创造必要的形式，适时地抛弃与内容不相适应的形式。</li></ul><h4 id="辩证法五对基本范畴方法论总结"><a class="header-anchor" href="#辩证法五对基本范畴方法论总结"></a>辩证法五对基本范畴方法论总结</h4><ul><li>原因和结果：凡事预则立，不预则废</li><li>必然和偶然：我们既要重视事物发展的必然，把握事物发展的总趋势，又要善于从偶然中发现必然，把握有利于事物发展的机遇</li><li>可能和现实：要求人们立足现实，展望未来，注意分析事物发展的各种可能，发挥主观能动性，做好应对不利情况的准备，争取实现好的可能</li><li>现象和本质：人们正是通过对事物现象的去粗取精、去伪存真、由此及彼、由表及里的认识过程，才能不断深化对事物本质的认识。透过现象发现本质是科学研究的任务</li><li>内容和形式：既要重视内容，根据内容的需要决定形式的取舍、改造和创新；又要善于运用形式，发挥其积极作用，利用和创造必要的形式，适时地抛弃与内容不相适应的形式</li></ul><h4 id="考点-21-🌙-对立统一规律（唯物辩证法第一规律）"><a class="header-anchor" href="#考点-21-🌙-对立统一规律（唯物辩证法第一规律）"></a>考点 21 🌙 对立统一规律（唯物辩证法第一规律）</h4><p><font color="#faa755">对立统一规律是唯物辩证法的实质和核心</font>。这是因为：</p><ul><li>对立统一规律揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题；</li><li>对立统一规律是贯穿量变质变规律、否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解这些规律和范畴的“钥匙”；</li><li>对立统一规律提供了人们认识世界和改造世界的根本方法——矛盾分析法，它是对事物辩证认识的实质；</li><li>是否承认对立统一学说是唯物辩证法和形而上学对立的实质。</li></ul><p>（1）<strong>矛盾同一性和斗争性的辩证关系</strong></p><p>对立统一规律又称矛盾规律，矛盾是辩证法的核心概念。矛盾是反映事物内部和事物之间对立统一关系的哲学范畴。 简言之，矛盾即对立统一。要区分逻辑矛盾与辩证矛盾。逻辑矛是指人们思维过程中由于违反形式逻辑规则所造成的自相矛盾；辩证矛盾则是事物本身所固有的对立统一关系。列宁说:“辩证法就是研究对象的本质自身中的矛盾。”</p><p>对立和统一分别体现了矛盾的两种基本属性。矛盾的对立属性又称斗争性，矛盾的统一属性又称同一性。（同一和斗争是既同一又斗争，不是时而同一时而斗争）</p><p><font color="#faa755">矛盾的同一性</font>是指矛盾双方相互依存、相互贯通的性质和趋势。它有两个方面的含义：</p><ul><li>一是矛盾着的对立面<font color="#33a3dc">相互依存</font>，互为存在的前提，并共处于一个统一体中；</li><li>二是矛盾着的对立面之间<font color="#33a3dc">相互贯通</font>，在一定条件下相互转化。</li></ul><p><font color="#faa755">矛盾的斗争性</font>是指矛盾着的对立面之间相互排斥、相互分离的性质和趋势。由于矛盾的性质不同，矛盾的斗争形式也不同，对于多种多样的斗争形式，（根据激烈程度）可以区分为对抗性和非对抗性两种基本形式。</p><p><font color="#faa755">同一性和斗争性的关系</font>（对立统一）</p><ul><li><p>相互联系。矛盾的同一性和矛盾的斗争性是相互联结、相辅相成的。同一性不能脱离斗争性而存在，没有斗争性就没有同一性， 斗争性寓于同一性之中，没有同一性也就没有斗争性。</p></li><li><p>相互区别。在事物的矛盾中，矛盾的斗争性是无条件的、绝对的，矛盾的同一性是有条件的、相对的。矛盾斗争性的绝对性体现了物质运动的绝对性，矛盾同一性的相对性体现了物质静止的相对性。无条件的、绝对的斗争性与有条件的、相对的同一性相结合，构成事物的矛盾运动，推动事物的发展。</p></li></ul><p><font color="#faa755">方法论意义</font>：矛盾的同一性和斗争性是同时存在的，因此事物总是具有两面性，这要求我们看待事物时要做到“一分为二”。例如，对待传统文化要“批判地继承”，对待外来文化应该“批判地吸收”。“求同存异”；“事物之间会相互转化”。</p><p>（2）<strong>矛盾的同一性和矛盾的斗争性在事物发展中的作用</strong></p><p><font color="#faa755">矛盾的同一性在事物发展中的作用主要表现在</font>：</p><ul><li>第一，由于矛盾双方相互依存，互为存在的条件，矛盾双方可以利用对方的发展使自己得到发展；</li><li>第二，由于矛盾双方相互包含，矛盾双方可以相互吸取有利于自身的因素而得到发展；</li><li>第三，由于矛盾双方彼此相通，矛盾双方可以向着彼此的对立面转化而得到发展，并规定着事物发展的方向。</li></ul><p><font color="#faa755">矛盾的斗争性在事物发展中的作用主要表现在</font>：</p><ul><li>第一，矛盾双方的斗争推动矛盾双方力量的对比发生变化，此消彼长，造成事物的量变；</li><li>第二，矛盾双方的斗争促使矛盾双方的地位或性质发生转化，实现事物的质变。</li></ul><p><font color="#faa755">方法论意义</font>：</p><ul><li>事物的发展不仅表现为“相反相成”，而且表现为“相辅相成”</li><li>学会从事物的对立面把握事物的统一，逆向思考</li><li>和谐不是无差别的一致</li></ul><p>矛盾的同一性和斗争性不能孤立地起作用，它们对事物发展的作用只有在二者的结合中才能实现，矛盾推动事物发展是同一性和斗争性共同作用的结果。但在不同的条件下，二者所处的地位会有所不同，在一定条件下，矛盾的斗争性可能处于主要的方面，而在另外的条件下，矛盾的同一性又可能处于主要的方面。了解同一性和斗争性在事物发展中的作用，对于我们自觉地利用矛盾的这两种力量推动事物发展，具有重要意义。它说明事物的发展不仅表现为“相反相成”，而且表现为“相辅相成”。它还说明和谐作为矛盾的一种特殊表现形式，体现着矛盾双方的相互依存、相互促进、共同发展。但和谐并不意味着矛盾的绝对同一。和谐是相对的有条件的，只有在矛盾双方处于平衡、协调、合作的情况下，事物才展现出和谐状态。社会的和谐、人与自然的和谐，都是在不断解决矛盾的过程中实现的。事物是多样性的统一，和谐的本质就在于协调事物内部各种因素的相互关系，促进最有利于事物发展的状态，构建社会主义和谐社会就是在发展的基础上正确处理各种社会矛盾的历史过程和社会结果。</p><p>（3）<strong>矛盾的普遍性和特殊性的辩证关系</strong></p><p><font color="#faa755">矛盾的普遍性</font>简单地说可以表述为“矛盾无处不在，无时不有”。其含义是：矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生。事物始终在矛盾中运动。矛盾普遍存在，但不同事物的矛盾又是具体的、特殊的。</p><p><font color="#faa755">矛盾的特殊性</font>是指具体事物在其运动中的矛盾及每一矛盾的各个方面都有其特点。具体表现为三种情形：</p><ul><li>一是不同事物的矛盾各有其特点；</li><li>二是同一事物的矛盾在不同发展过程和发展阶段各有不同特点；</li><li>三是构成事物的诸多矛盾以及每一矛盾的不同方面各有不同的性质、地位和作用。</li></ul><p><font color="#faa755">矛盾的普遍性和特殊性的关系</font>：</p><p>矛盾的普遍性和特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。</p><ul><li>相互区别：矛盾的共性是无条件的、绝对的，矛盾的个性是有条件的、相对的。</li><li>相互联系：任何现实存在的事物都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性。</li></ul><p><font color="#faa755">方法论意义</font>：矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓，是正确理解矛盾学说的关键，不懂得它，就不能真正掌握唯物辩证法。矛盾的共性和个性相统一的关系， 既是客观事物固有的辩证法，也是科学的认识方法。人的认识的一般规律就是由认识个别上升到认识一般， 再由一般到个别的辩证发展过程。所以“<font color="#33a3dc">具体问题具体分析</font>”是马克思主义的活的灵魂。</p><p>（4）<strong>矛盾的不平衡发展原理</strong></p><p>在矛盾群中存在着根本矛盾和非根本矛盾、主要矛盾和次要矛盾。</p><ul><li>根本矛盾贯穿事物发展过程的始终，规定着事物的性质。</li><li>主要矛盾是矛盾体系中处于支配地位，对事物发展起决定作用的矛盾。</li><li>非根本矛盾、次要矛盾是处于服从地位的矛盾。</li><li>在每一对矛盾中又有矛盾的主要方面与矛盾的次要方面。</li></ul><p><font color="#faa755">原理</font>：矛盾的性质主要是由矛盾的主要方面决定的。只有如实地分析矛盾的特殊性，才能认清事物的本质和发展规律，才能采取正确的方针和办法去解决矛盾。</p><p><font color="#faa755">方法论意义</font>：在处理问题的时候，既要看到主要矛盾，强调主要矛盾，也要看到次要矛盾，不能忽略次要矛盾，做到“两点论”和“重点论”相结合。</p><p><strong>对立统一规律方法论总结（矛盾分析方法总结）</strong></p><ul><li>矛盾的同一性和斗争性的辩证关系原理：看问题一分为二、批判地继承、物极必反、否极泰来、福祸相依、中庸和谐不走极端</li><li>矛盾的同一性和斗争性在事物发展中的作用：反向思维、逆向思考</li><li>矛盾的普遍性和特殊性的辩证关系原理：具体问题具体分析、举一反三、对症下药、因材施教、量体裁衣、马克思主义中国化</li><li>矛盾的不平衡发展原理：“两点论”和“重点论”相结合，抓关键、看主流</li></ul><h4 id="考点-22-⭐-量变质变规律（唯物辩证法第二规律）"><a class="header-anchor" href="#考点-22-⭐-量变质变规律（唯物辩证法第二规律）"></a>考点 22 ⭐ 量变质变规律（唯物辩证法第二规律）</h4><p>（1）概念：质、量、度和关节点、量变、质变</p><p><font color="#faa755">质</font>是一事物成为自身并区别于其他事物的内在规定性。事物质的规定性是由事物内部矛盾的特殊性所决定的。事物的质是通过属性表现出来的，属性是一物和他物在相互联系中表现出来的质。<font color="#33a3dc">认识质是认识和实践的起点和基础</font>。<font color="#33a3dc">只有认识质，才能区别事物</font>。</p><p><font color="#faa755">量</font>是事物的规模、程度、速度等可以用数量关系表示的规定性。认识量的意义：</p><ul><li>一是<font color="#33a3dc">认识事物的量是认识的深化和精确化</font>。只有认识量，才能更深刻地把握质。马克思认为，一种科学只有在成功地运用数学时，才算达到了真正完善的地步。</li><li>二是<font color="#33a3dc">只有正确了解事物的量，才能正确估计事物在实践中的地位和作用</font>，因为同质的事物由于数量不同，在实践中的地位和作用往往不同。做任何事情，既要有质的要求，又要有量的要求，做到心中有数。</li></ul><p>事物的量和质是统一的， 量和质的统一在度中得到体现。</p><p><font color="#faa755">度</font>是保持事物质的稳定性的数量界限，即事物的限度、幅度和范围。度的两端叫关节点或临界点，超出度的范围，此物就转化为他物。度这一哲学范畴启示我们，在认识和处理问题时要掌握适度的原则。</p><p><font color="#faa755">量变</font>是事物数量的增减和组成要素排列次序的变动，是保持事物的质的相对稳定性的<font color="#33a3dc">不显著的变化</font>，体现了事物发展渐进过程的连续性。</p><p><font color="#faa755">质变</font>是事物性质的<font color="#33a3dc">根本变化</font>，是事物由一种质态向另一种质态的飞跃，体现了事物渐进过程和连续性的<font color="#33a3dc">中断</font>。</p><p>（2）<strong>量变和质变的辩证关系</strong></p><p>量变和质变是既相区别又相联系的。</p><p>相互联系：</p><ul><li>第一，量变是质变的<font color="#33a3dc">必要</font>准备。任何事物的变化都有一个量变的积累过程，没有量变的积累，质变就不会发生。（反例：激变论，夸大质变）</li><li>第二，质变是量变的<font color="#33a3dc">必然</font>结果。单纯的量变不会永远持续下去，量变达到一定程度必然引起质变。（反例：庸俗进化论，夸大量变）</li><li>第三，量变和质变是相互渗透的。<ul><li>一方面，在总的量变过程中有阶段性和局部性的部分质变；</li><li>另一方面，在质变过程中也有旧质在量上的收缩和新质在量上的扩张。</li></ul></li></ul><p>量变和质变是相互依存、相互贯通的，量变引起质变，在新质的基础上，事物又开始新的量变，如此交替循环，形成事物量变质变的规律性。量变质变规律体现了事物发展的渐进性和飞跃性的统一。</p><p>（3）<strong>方法论意义</strong></p><ul><li>首先，它揭示了事物发展过程是连续性和阶段性的统一，这是无产阶级政党制定路线、方针、政策的重要理论依据。</li><li>其次，它是我们分析社会发展形式的基本理论工具，对于我们正确处理社会主义改革、发展、稳定的关系具有指导意义。</li><li>最后，它是指导我们从事一切实践活动的重要思想原则。</li></ul><h4 id="考点-23-⭐-否定之否定规律（唯物辩证法第三规律）"><a class="header-anchor" href="#考点-23-⭐-否定之否定规律（唯物辩证法第三规律）"></a>考点 23 ⭐ 否定之否定规律（唯物辩证法第三规律）</h4><p>（1）事物发展过程中的肯定因素和否定因素</p><p><font color="#faa755">事物内部都存在着肯定因素和否定因素</font>。</p><ul><li>肯定因素是维持现存事物存在的因素，</li><li>否定因素是促使现存事物灭亡的因素。</li></ul><p><font color="#faa755">辩证否定观的基本内容</font>：</p><ul><li>第一，否定是事物的<font color="#33a3dc">自我否定</font>，是事物内部矛盾运动的结果。（形而上学：外在力量对事物进行否定和消灭）</li><li>第二，否定是事物发展的环节。它是旧事物向新事物的转变，是从旧质到新质的飞跃。只有经过否定，旧事物才能向新事物转变。</li><li>第三，否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物是通过否定环节联系起来的。</li><li>第四，辩证否定的实质是“<font color="#33a3dc">扬弃</font>”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。（形而上学：要么肯定一切，要么否定一切）</li></ul><p>与辩证否定观相对立的形而上学否定观则认为，否定是外在的否定，主观任意的否定;否定是绝对的否定，是不包含肯定的否定，这就既割断了事物的联系，又使发展中断。它的信条:“是就是，不是就不是；除此之外，都是鬼话。”</p><p>（2）否定之否定规律</p><p>事物的辩证发展过程经过第一次否定，使矛盾得到初步解决。而处于否定阶段的事物仍然具有片面性，还要经过再次否定，即否定之否定，实现对立面的统一，使矛盾得到解决。事物的辩证发展就是经过两次否定，出现三个阶段即“肯定一否定一否定之否定&quot;，形成一个周期。其中否定之否定阶段<font color="#33a3dc">仿佛</font>是向原来出发点的“回复”， 但这是在更高阶段的“回复”，“扬弃”的结果，事物的发展呈现出周期性，上一个周期和下一个周期的无限交替，使事物的发展呈现出波浪式前进或螺旋式上升的总趋势。</p><p>否定之否定规律揭示了事物发展的前进性与曲折性的统一。前进性体现在：每一次否定都是质变，都把事物推到新阶段；每一个周期都是开放的，不存在不被否定的终点。曲折性体现在回复性上，其中有暂时的停顿或倒退，但是经过曲折终将为事物的发展开辟道路。这表明事物的发展不是直线式前进而是螺旋式上升。</p><p>（3）<strong>方法论意义</strong></p><p>理论上的方法论：</p><ul><li>循环论：只看到回归，没有看到发展</li><li>直线论：只看到发展，看不到回归</li></ul><p>实践中的方法论：</p><ul><li>前途是光明的</li><li>道路是曲折的</li></ul><p>否定之否定规律对于人们正确认识事物发展的曲折性和前进性，具有重要的指导意义。由于事物发展是前进性和曲折性的统一，我们就不能奢望什么事情都是径情直遂、一帆风顺的，要善于洞察事物发展中的各种可能性，充分估计其困难和曲折,经得起困难和挫折的考验，坚定信心，知难而上，开辟前进的道路。</p><h3 id="第二节-唯物辩证法是认识世界和改造世界的根本方法"><a class="header-anchor" href="#第二节-唯物辩证法是认识世界和改造世界的根本方法"></a>第二节 唯物辩证法是认识世界和改造世界的根本方法</h3><h4 id="考点-24-⭐-客观辩证法与主观辩证法"><a class="header-anchor" href="#考点-24-⭐-客观辩证法与主观辩证法"></a>考点 24 ⭐ 客观辩证法与主观辩证法</h4><ul><li><font color="#faa755">客观辩证法是指客观事物或客观存在的辩证法</font>，即客观事物以相互作用、相互联系的形式呈现出的各种物质形态的辩证运动和发展规律。</li><li><font color="#faa755">主观辩证法是指人类认识和思维运动的辩证法</font>，即以概念作为思维细胞的辩证思维运动和发展的规律。唯物辩证法既包括客观辩证法也包括主观辩证法，体现了唯物主义、辩证法、认识论的统一。</li></ul><p>客观辩证法与主观辩证法在本质上是统一的， 但在表现形式上却是不同的。</p><ul><li><font color="#faa755">客观辩证法采取外部必然性的形式</font>，离开人的意识、思维而独立存在，不以人的意志为转移。</li><li><font color="#faa755">主观辩证法则采取观念的、逻辑的形式</font>，是同人类思维的自觉活动相联系的，是以概念为基础的辩证思维规律。因此，可以简要地把主观辩证法称为概念辩证法。</li></ul><h4 id="考点-25-辩证思维方法"><a class="header-anchor" href="#考点-25-辩证思维方法"></a>考点 25 辩证思维方法</h4><p>（1）辩证思维的主要方法</p><p>辩证思维方法是人们正确进行理性思维的方法，主要有归纳和演绎、分析和综合、从抽象上升到具体、逻辑和历史相一致等 方法。</p><p>（2）矛盾分析法是根本的认识方法</p><p>在唯物辩证法的方法论体系中，矛盾分析法居于核心的地位，是根本的认识方法。矛盾分析法的重要作用，是由对立统一规律在辩证法中的地位决定的。矛盾分析法包含广泛而深刻的内容。例如，分析矛盾特殊性的方面，“两点论”与“重点论”相结合的方法，抓关键、看主流的方法，在对立中把握统一与在统一中把握对立的方法，批判与继承相统一的方法等， 都是矛盾分析法的具体体现。马克思主义的最本质的东西，马克思主义的活的灵魂，就在于具体地分析具体情况。运用唯物辩证法的矛盾分析法研究问题和解决问题，根本的是具体问题具体分析，一切以时间、地点和条件为转移。</p><p>（3）学习唯物辩证法，不断增强思维能力</p><p>学习和掌握唯物辩证法的科学思维方法，要求我们在实践中不断增强思维能力，特别是不断增强辩证思维能力、历史思维能力、战略思维能力、底线思维能力和创新思维能力。</p><h2 id="第三章-认识论"><a class="header-anchor" href="#第三章-认识论"></a>第三章 认识论</h2><h3 id="第一节-实践与认识"><a class="header-anchor" href="#第一节-实践与认识"></a>第一节 实践与认识</h3><h4 id="考点-26-⭐-实践的本质和基本特征"><a class="header-anchor" href="#考点-26-⭐-实践的本质和基本特征"></a>考点 26 ⭐ 实践的本质和基本特征</h4><p>（1）实践的本质</p><p><font color="#faa755">错误的观点</font>：马克思、恩格斯以前的中外哲学都使用过实践的概念，并作过很多论述。</p><ol><li>在中国古代哲学中，实践被称为“践行”“实行”或“行”，与“知”相对应，但主要是指<font color="#33a3dc">道德伦理行为</font>。</li><li>康德把实践看成<font color="#33a3dc">理性自主</font>的<font color="#33a3dc">道德活动</font>；（忽略了实践的客体）</li><li>黑格尔把实践理解为主观改造客观对象的创造性的<font color="#33a3dc">精神活动</font>，尽管他触摸到了生产劳动的意义，认为劳动陶冶事物，但最终还是把实践限定在抽象的精神活动范围之内；</li><li>费尔巴哈把实践与物质性的活动联系起来，但他所理解的实践又仅限于日常生活活动，并将实践等同于<font color="#33a3dc">生物适应环境的活动</font>。</li></ol><p>总之，他们都没有科学地理解人类实践的真正本质，没有看到实践在人类认识和整个社会生活中的决定意义。</p><p><font color="#faa755">正确的观点</font>：马克思在《关于费尔巴哈的提纲》这个集中阐述科学实践观的重要文献中，阐明了<font color="#faa755">实践是感性的、对象性的物质活动</font>，提出全部社会生活在本质上是实践的，并鲜明指出哲学家们只是用不同的方式解释世界，而问题在于改变世界。</p><p>（2）实践的特征</p><p>实践是<font color="#33a3dc">人类</font>能动地改造世界的社会性的物质活动，具有直接现实性、自觉能动性（主体能动性）和社会历史性三个基本特征。</p><ol><li>实践是改造世界的客观物质活动，具有直接现实性（本质特性）。实践具有将人脑中的东西变成现实的东西的功能，这种功能称为“直接现实性”，所以说，实践是同主观认识活动相区别的客观物质活动。</li><li>实践是人类有意识的、有目的的活动，体现了自觉的能动性。人具有理性思维，所从事的是不同于动物的本能活动的有目的、有意识地改造世界的活动，只有人的自觉的、能动的活动才具有真正的实践的意义。</li><li>实践是社会的、历史的活动，具有社会历史性。实践的社会性决定了它的历史性，因为实践的内容、性质、范围、水平以及方式都是受一定的社会历史条件所制约的，都是随着一定的社会历史条件的变化而变化的，因而都是具体的、历史的。</li></ol><h4 id="考点-27-⭐-实践的基本结构和形式"><a class="header-anchor" href="#考点-27-⭐-实践的基本结构和形式"></a>考点 27 ⭐ 实践的基本结构和形式</h4><p>（1）实践的基本结构</p><p>人的实践活动是以改造客观世界为目的的客观过程，是实践的主体与客体之间的相互作用，这种相互作用必须借助于一定的手段和工具，即实践的中介。实践的主体、客体和中介是实践活动的三项基本要素，三者的有机统一构成实践的基本结构。</p><p>第一，实践主体。在实践活动中，实践主体是指<font color="#33a3dc">具有一定的主体能力</font>、<font color="#33a3dc">从事现实社会实践活动</font>的<font color="#faa755">人</font>，是实践活动中自主性和能动性的因素，担负着设定实践目的、操作实践中介、改造实践客体的任务。实践主体的能力包括自然能力和精神能力，精神能力又包括知识性因素和非知识性因素。其中，知识性因素是首要的能力，既包括对理论知识的掌握，也包括对经验知识的掌握；非知识性因素主要指情感和意志因素。实践主体有个体主体、群体主体和人类主体三种基本形态。</p><p>第二，实践客体。实践客体是指实践活动所指向的对象。实践客体与客观存在的事物不完全等同，客观事物只有在被纳人主体实践活动的范围之内，为主体实践活动所指向并与主体相互作用时才成为现实的实践客体。实践客体也有不同的类型：从是否为实践所创造的角度看，可划分为天然客体和人工客体；从自然界与人类社会两个领域相区分的角度看，可划分为自然客体和社会客体；从物质性和精神性相区分的角度看，可划分为物质性客体和精神性客体；等等。</p><p>第三，实践中介。实践中介是指各种形式的工具、手段以及运用、操作这些工具、手段的程序和方法。实践的中介系统可分为两个子系统：一是作为人的肢体延长、感官延伸、体能放大的物质性工具系统，如各种机器系统和动力能源系统。火车、电脑、雷达分别是对人的腿、脑、眼功能的延伸和放大。二是语言符号工具系统。语言符号是主体思维活动进行的现实形式，也是人们社会交往得以进行的中介。正是依靠这些中介系统，实践的主体和客体才能够相互作用。实践的主体和客体相互作用的关系，包括实践关系、认识关系和价值关系，其中实践关系是最根本的关系。实践的主体和客体与认识的主体和客体在本质上是一致的。 认识的主体和客体的关系不仅是认识和被认识的关系，而且首先是改造和被改造的关系。主体认识客体的过程，也是主体改造客体的过程。主体对客体的认识和改造，说到底是为了满足自己的需要，因而又构成了价值关系。</p><p>实践的主体和客体相互作用的关系，包括<font color="#33a3dc">实践关系、认识关系和价值关系</font>，其中<font color="#faa755">实践关系是最根本的关系</font>。实践的主体和客体与认识的主体和客体在本质上是一致的。 认识的主体和客体的关系不仅是认识和被认识的关系，而且首先是改造和被改造的关系。主体认识客体的过程，也是主体改造客体的过程。主体对客体的认识和改造，说到底是为了满足自己的需要，因而又构成了价值关系。</p><p>实践的主体、客体和中介是不断变化发展的，因而实践的基本结构也是历史地变化发展的，这种变化主要表现为主体客体化与客体主体化的双向运动。</p><ul><li><font color="#faa755">主体客体化</font>，是人通过实践使自己的本质力量作用于客体，使其按照主体的需要发生结构和功能上的变化，形成了世界上本来不存在的对象物。它是人的体力和智力的物化体现，是主体的本质力量通过实践活动积淀、凝聚和物化在客体中。实际上，人类一切实践活动的结果都是主体客体化的结果。在主体客体化的同时，还发生着客体主体化的运动。</li><li><font color="#faa755">客体主体化</font>，是客体从客观对象的存在形式转化为主体生命结构的因素或主体本质力量的因素，客体失去客体性的形式，变成主体的一部分。例如，主体把物质工具如电脑、汽车等作为自己身体器官的延长包括在主体的活动之中，把作为精神性客体的精神产品、先进理念和思想转化为主体意识的一部分，都属于客体主体化的表现。</li></ul><p>主体客体化与客体主体化的双向运动是人类实践活动两个不可分割的方面，它们互为前提、互为媒介，人类就是通过这种运动形式不断解决着现实世界的矛盾。</p><p>（2）实践的形式</p><p>人的活动分为本能活动、实践活动</p><p>人类的社会生活色彩斑斓，实践活动形式丰富多样。毛泽东指出，“人的社会实践，不限于生产活动一种形式，还有多种其他的形式，阶级斗争，政治生活，科学和艺术的活动”。随着人与世界关系的发展，特别是随着社会分工的进步，人类实践的具体形式日益多样化。从内容上看，实践可分为三种基本类型：</p><ul><li>一是物质生产实践；</li><li>二是社会政治实践；</li><li>三是科学文化实践。</li></ul><p>以上三种实践类型既各具不同的社会功能，又密切联系在一起。其中<font color="#33a3dc">物质生产实践是最基本的实践活动</font>，它构成全部社会生活的基础，社会政治实践和科学文化实践在物质生产实践基础上产生和发展起来，受物质生产实践的制约并对其产生能动的反作用。</p><p>随着社会的快速发展，当代人类实践出现了新的变化，呈现出许多新的发展特点，实践活动的范围越来越广泛而深入。一个突出的表现就是，现代信息技术的发展使得当代社会开始产生一种新的实践形式，即虚拟实践。虚拟实践是伴随信息化和网络化发展而产生的，其实质是主体和客体之间通过数字化中介系统在虚拟空间进行的双向对象化的活动，主要活跃于网络世界，具有交互性、开放性、间接性等特点。虚拟实践的出现为人的发展提供了多样的自由空间，极大地提升了人的活动的自主性、创造性，对人类社会生活产生了重大影响，同时也带来许多新的问题。必须看到，<font color="#33a3dc">虛拟实践是实践活动的派生形式，具有相对独立性</font>。</p><h4 id="考点-28-🌙-实践对认识的决定作用（实践和认识的辩证关系）"><a class="header-anchor" href="#考点-28-🌙-实践对认识的决定作用（实践和认识的辩证关系）"></a>考点 28 🌙 实践对认识的决定作用（实践和认识的辩证关系）</h4><p>辩证唯物主义认为，<font color="#e03e3e">实践决定认识，实践是认识的基础</font>。实践对认识的决定作用主要表现在以下四个方面：</p><p><font color="#faa755">第一，实践是认识的来源</font>。首先，实践产生了认识的需要，其次，实践还为认识的形成提供了可能。正如习近平所指出的:“我们党现阶段提出和实施的理论和路线方针政策，之所以正确，就是因为它们都是以我国现时代的社会存在为基础的。”离开实践的认识是不可能产生的。一切真知都是从直接经验发源的。一个人的知识，不外直接经验和间接经验两部分。就知识的本源来说，任何知识都不能离开直接经验。但是，这并不意味着事事都必须去直接经验，“ 吾生也有涯，而知也无涯”，一个人的多数知识还是来自于间接经验，是从书本和传授中得来的。然而，“在我为间接经验者，在人则仍为直接经验”。从根本上说，实践是认识的源头活水。要想成就一番事业，不仅要努力学习，而且要潜心实践。【受天赋（生理因素）的影响、间接经验的影响】</p><p><font color="#faa755">第二，实践是认识发展的动力</font>。实践的需要推动认识的产生和发展，推动人类的科学发现和技术发明，推动人类的思想进步和理论创新。恩格斯说:“社会一旦有技术上的需要，这种需要就会比十所大学更能把科学推向前进。”</p><p><font color="#faa755">第三，实践是认识的目的</font>。人们通过实践获得认识，不是“猎奇”或“雅兴”，不是为认识而认识，其最终目的是为实践服务，指导实践，以满足人们生活和生产的需要。自然科学的不断创新，目的是推动技术的更大发展，创造更丰富的物质财富，给人类带来更多的福祉。人文社会科学的不断创新，目的是认识社会，认识人类自身，改造社会,建设精神文明，创造精神财富，促进人的自由而全面的发展。</p><p><font color="#faa755">第四，实践是检验认识真理性的唯一标准</font>。真理不是自封的。“判定认识或理论之是否真理，不是依主观上觉得如何而定，而是依客观上社会实践的结果如何而定。真理的标准只能是社会的实践。”也就是说，认识是否具有真理性，既不能从认识本身得到证实，也不能从认识对象中得到回答，只有在实践中才能得到验证。</p><h4 id="考点-29-⭐-认识的本质"><a class="header-anchor" href="#考点-29-⭐-认识的本质"></a>考点 29 ⭐ 认识的本质</h4><p>深刻把握认识的本质，需要弄清各种哲学派别在这个问题上的不同观点。</p><p>（1）唯心主义先验论</p><p><font color="#faa755">主要观点</font>：坚持认识过程是“<font color="#33a3dc">从思想和感觉到物</font>”。</p><p>举例：主观唯心主义认为人的认识是主观自生的，是生而知之的；客观唯心主义认为人的认识是上帝的启示或某种客观精神的产物。古希腊哲学家柏拉图认为存在一个独立于现实世界之外的“理念世界”，人的知识就来源于对其中“理念”的认识和回忆，故而提出了“认识即回忆”的观点。</p><p>缺陷：否认认识是人脑对客观世界的反映，认为认识先于物质，先于人的实践经验。</p><p>（2）唯物主义反映论</p><p><font color="#faa755">主要观点</font>：坚持认识过程是“<font color="#33a3dc">从物到感觉和思想</font>&quot;。唯物主义认识路线坚持反映论的立场，认为认识是主体对客体的反映，人的一切知识都是从后天接触实际中得来的。</p><p>举例：我国古代唯物主义哲学家荀况就明确指出，没有什么“生而知之”，而是“求之而后得”，认为人的知识和才能都是后天学习积累而成的，而“非天性也”。</p><p>分类：直观反映论（旧唯物主义）和能动反映论（辩证唯物主义）。</p><p>第一，直观反映论（机械反映论）。</p><p>主要观点：旧唯物主义认识论的基本特点是以感性直观为基础，把人的认识看成消极地、被动地反映和接受外界对象，类似于照镜子那样的反射活动，所以又称为直观的、消极被动的反映论。</p><p>缺陷：一是离开实践考察认识问题，因而不了解实践对认识的决定作用。二是不了解认识的辩证本性，离开辩证法来考察认识问题，最根本的是它看不到主观和客观之间的矛盾及其相互作用，没有把认识看作一个不断发展的过程，认为认识是一次性完成的。</p><p>第二，能动反映论。</p><p><font color="#faa755">主要观点</font>：辩证唯物主义认识论认为，<font color="#33a3dc">认识的本质是主体在实践基础上对客体的能动反映</font>。这种能动反映不但具有反映客体内容的反映性特征，而且具有实践所要求的主体能动的、创造性的特征。</p><ul><li>一方面，认识的反映特性是人类认识的基本规定性。认识的反映特性是指人的认识必然要以客观事物为原型和摹本，在思维中再现或摹写客观事物的状态、属性和本质。</li><li>另一方面，认识的能动反映具有创造性。认识是一种在思维中的能动的、创造性的活动，而不是主观对客观对象简单、直接的描摹或照镜子式的原物映现。</li></ul><p><font color="#faa755">认识的反映特性和创造特性之间的关系</font>：不可分割。反映和创造不是人类认识的两种不同的本质，而是同一本质的两种不同的功能，是一枚硬币的两面。</p><ul><li>只坚持认识的反映性，看不到认识能动的创造性，就重复走上了旧唯物主义直观反映论的错误之路；</li><li>相反，只坚持认识能动的创造性，使创造性脱离反映论的前提，就会把创造变成主观随意，从而滑向唯心主义和不可知论。</li><li>这两种倾向都不符合实际的认识活动，而且也会给实践带来危害。</li></ul><p><font color="#faa755">“能动反映论”的两个突出特点（优点）</font>：</p><ul><li>一是把实践的观点引入认识论。</li><li>二是把辩证法应用于反映论考察认识的发展过程，把认识看成一个由不知到知、由浅入深的充满矛盾的能动的认识过程，全面地揭示了认识过程的辩证性质。</li></ul><h4 id="形而上学错误观点的汇总"><a class="header-anchor" href="#形而上学错误观点的汇总"></a>形而上学错误观点的汇总</h4><ul><li>在运动和静止的问题上：夸大静止，否定运动</li><li>在意识观的问题上：认为意识是人脑的分泌物，是某种特殊的物质，混淆了物质和意识的界限，夸大了物质和意识的联系，忽视了二者的区别</li><li>在“世界是怎样的”的问题上：与辩证法相对，观点片面:只讲联系，不讲区别；或者只讲区别，不讲联系</li><li>在否定观的问题上：主张外在力量对事物进行否定；主张全盘否定</li><li>在认识论的问题上：虽然看到了认识是对客观事物的反映，但错误地认为这种反映是“机械的”“直观的”，否定了主体的创造性和能动性</li></ul><h4 id="考点-30-🌙-认识的过程（两次飞跃）"><a class="header-anchor" href="#考点-30-🌙-认识的过程（两次飞跃）"></a>考点 30 🌙 认识的过程（两次飞跃）</h4><p>（1）🌙 从实践到认识（感性认识到理性认识的飞跃）</p><p>认识的过程首先是从实践到认识的过程。这个过程主要表现为在实践基础上认识活动由感性认识能动地飞跃到理性认识。这是认识运动的第一次飞跃。</p><p><font color="#faa755">概念</font>：</p><p><font color="#faa755">感性认识</font><font color="#33a3dc">是人们在实践基础上，由感觉器官直接感受到的关于事物的现象、事物的外部联系、事物的各个方面的认识，包括感觉、知觉和表象三种形式。感性认识是认识的初级阶段，直接性是感性认识的突出特点</font>。因为感性认识还没有深入到对事物本质的认识，具有不深刻的局限性，必须进一步上升到理性认识。</p><ul><li>感性认识的对象：事物的现象、事物的外部联系、事物的各个方面</li><li>感性认识的形式：感觉、知觉和表象</li><li>感性认识的特点：直接性和具体性</li></ul><p><font color="#faa755">理性认识</font><font color="#33a3dc">是认识的高级阶段，是指人们借助抽象思维，在概括整理大量感性材料的基础上，达到关于事物的本质、全体、内部联系和事物自身规律性的认识。理性认识包括概念、判断、推理三种形式。理性认识的特点是它的间接性和抽象性</font>。理性认识在形式上超越了客观事物，而在内容上则更深刻、更正确、更完整地反映了客观事物。</p><ul><li>理性认识的对象：事物的本质、全体、内部联系和事物自身规律性</li><li>理想认识的形式：概念、判断、推理</li><li>理想认识的特点：间接性和抽象性</li></ul><p><font color="#faa755">关系</font>：辩证统一。</p><ul><li>第一，感性认识有待于发展和深化为理性认识。</li><li>第二，理性认识依赖于感性认识。</li><li>第三，感性认识和理性认识相互渗透、相互包含。感性认识和理性认识的辩证统一关系是在实践的基础上形成的，也需要在实践中发展。如果割裂二者的辩证统一关系，就会走向唯理论或经验论，在实际工作中就会犯教条主义错误或经验主义错误。</li></ul><p>实现飞跃的基本条件：</p><ul><li>一是勇于实践，深入调查，获取十分丰富和合乎实际的感性材料。这是正确实现由感性认识上升到理性认识的基础。</li><li>二是必须经过理性思考的作用，将丰富的感性材料加工制作，去粗取精、去伪存真、由此及彼、由表及里，才能将感性认识上升为理性认识。</li></ul><p>（2）从认识到实践（理性认识到实践的飞跃）</p><p><font color="#faa755">重要性</font>：从认识到实践，是“认识过程的第二个阶段，即由精神到物质的阶段，由思想到存在的阶段”。这是认识过程的第二次能动的飞跃，是认识过程中更为重要的一次飞跃。 其必要性和重要性在于，</p><ul><li>一方面， 认识世界的目的是改造世界，此外再无别的目的；</li><li>另一方面，认识的真理性只有在实践中才能得到检验和发展。</li></ul><p><font color="#faa755">实现飞跃的条件</font>：需要经过一定的中介环节，包括确定实践目的、形成实践理念、制定实践方案、进行中间实验、运用科学实践方法等。因此必须从实际出发，坚持理论和实际相结合，让理论为群众所掌握，转化为改造社会、改造自然的物质力量。只有这样，理论才能发挥指导作用，并随着实践的发展而发展。</p><h4 id="考点-31-🌙-认识过程中的影响因素（理性因素和非理性因素）"><a class="header-anchor" href="#考点-31-🌙-认识过程中的影响因素（理性因素和非理性因素）"></a>考点 31 🌙 认识过程中的影响因素（理性因素和非理性因素）</h4><p>（1）理性因素</p><p><font color="#faa755">概念</font>：理性因素是指人的理性直观、理性思维等能力。</p><p><font color="#faa755">作用</font>：它在认识活动中的作用主要有<font color="#33a3dc">指导作用、解释作用和预见作用</font>等。</p><p>（2）非理性因素（感性因素）</p><p><font color="#faa755">概念</font>：非理性因素主要是指认识主体的情感和意志。从广义上看，人们还常把认识能力中具有不自觉、非逻辑性等特点的认识形式，如联想、 想象、猜测、顿悟、灵感等，也包括在人的非理性因素中。</p><p><font color="#faa755">作用</font>：非理性因素对于人的认识能力和认识活动具有<font color="#33a3dc">激活、驱动和控制</font>作用。</p><h4 id="考点-32-🌙-认识的两大规律（反复性和无限性）"><a class="header-anchor" href="#考点-32-🌙-认识的两大规律（反复性和无限性）"></a>考点 32 🌙 认识的两大规律（反复性和无限性）</h4><p>（1）认识的反复性</p><p>认识过程的反复性是指，人们对于一个复杂事物的认识往往要经过由感性认识到理性认识、再由理性认识到实践的多次反复才能完成。这是因为在认识过程中始终存在着主观和客观的矛盾。</p><ul><li>从客观方面看，事物的各个侧面及其本质的暴露有一个过程；</li><li>从主观方面看，人的认识能力有一个提高的过程。人的认识受实践范围、立场、观点、方法、思维能力、工作经验和知识水平等因素的制约。</li></ul><p>（2）认识的无限性</p><p>认识发展的无限性是指，对于事物发展过程的推移来说，人类的认识是永无止境、无限发展的，它表现为“实践——认识——再实践——再认识” 的无限循环，由初级阶段向高级阶段不断推移的永无止境的前进运动。这种认识的无限发展过程，在形式上是循环往复的，在实质上是前进上升的。（否定之否）</p><h4 id="考点-33-实践和认识是具体的历史的统一"><a class="header-anchor" href="#考点-33-实践和认识是具体的历史的统一"></a>考点 33 实践和认识是具体的历史的统一</h4><ul><li>实践超前于认识：冒进主义（左）</li><li>实践落后于认识：保守主义（右）</li></ul><p>从实践到认识、从认识到实践，实践——认识——再实践——再认识， 认识运动不断反复和无限发展，这是人类认识运动的辩证发展过程，也是人类认识运动的基本规律。这一认识运动过程和基本规律决定了主观和客观、认识和实践的统一是具体的和历史的。当事物的具体过程已经向前推移，转变到另一个具体过程的时候，主观认识就应当随之而转变。如果主观认识仍然停留在原来的阶段上，思想落后于实际，就容易犯保守的错误。当事物的具体过程尚未结束，原有的矛盾尚未得到充分地暴露和展开，向另一个具体过程推移、转变的条件还不具备时，如果人们硬要把将来可能做的事情勉强拿到现在来做,企图超越阶段，就容易犯冒进的错误。所以，“我们的结论是主观和客观、理论和实践、知和行的具体的历史的统一， 反对一切离开具体历史的‘左’的或右的错误思想”。马克思主义认识论是党的群众路线工作方法的哲学基础。党的“从群众中来，到群众中去”的工作方法，正是辩证唯物主义和历史唯物主义认识论在实际工作中的创造性运用。群众是实践的主体，也是认识的主体。认识从群众中来，主要是从群众的实践中来；认识回到实践中去，也主要是回到群众的实践中去。</p><h3 id="第二节-真理与价值"><a class="header-anchor" href="#第二节-真理与价值"></a>第二节 真理与价值</h3><h4 id="考点-34-🌙-真理及其特性"><a class="header-anchor" href="#考点-34-🌙-真理及其特性"></a>考点 34 🌙 真理及其特性</h4><p>（1）<strong>错误的真理观</strong></p><p><font color="#faa755">主观唯心主义</font>：</p><ul><li>休谟认为真理是“观念与主体感觉相符合”；</li><li>贝克莱断言“真理存在于观念之中”；</li><li>康德认为“真理是思维与它的先验形式相一致”。</li></ul><p>这些是主观唯心主义的真理观。</p><p><font color="#faa755">客观唯心主义</font>：</p><ul><li>柏拉图认为“真理是某种超验的、永恒的‘理念’”；</li><li>黑格尔说“真理是‘绝对理念’的自我显现”。</li></ul><p>这些是客观唯心主义的真理观。</p><p><font color="#faa755">马赫主义</font>认为真理是“思想形式”，是“社会地组织起来的经验”，凡是多数人承认的就是真理。</p><p><font color="#faa755">实用主义</font>认为“有用即真理”，把真理的有用性与真理本身等同起来。（真理一定是有用的说法是正确的）</p><p>（2）<strong>正确的真理观</strong></p><p>马克思主义认为，真理是标志主观与客观相符合的哲学范畴，是对客观事物及其规律的<font color="#33a3dc">正确反映</font>。所谓正确反映，是指真理是在实践基础上主体认识对客体本质和规律的符合、一致和接近。</p><p>（3）真理的客观性</p><p>真理的<font color="#faa755">客观性</font>是指真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖于人和人的意识的客观内容。（内容是客观的、检验标准是客观的，真理的形式是主观的）</p><p>客观性是真理的本质属性，但是真理的形式又是主观的，真理通过感觉、知觉、表象、概念、判断、推理等主观形式表达出来。</p><p>真理的客观性决定了真理的<font color="#33a3dc">一元性</font>。真理的一元性是指在同一条件下对于特定的认识客体的真理性认识只有一个，而不可能有多个。真理的客观内容就是客观事物的实际状况，而特定条件下客观事物存在和运动的实际状况也是特定的唯一。认识是多元的，但真理是一元的。</p><p>（4）真理的绝对性</p><p>真理的绝对性是指真理的内容表明了主客观统一的确定性和发展的无限性。它有两个方面的含义：</p><ul><li>一是任何真理都必然包含同客观对象相符合的客观内容，都同谬误有原则的界限。否则就不称其为真理，这一点是无条件的、 绝对的。</li><li>二是人类认识按其本性来说，能够正确认识无限发展着的物质世界，认识每前进一步，都是对无限发展着的物质世界的接近，这一点也是无条件的、绝对的。</li></ul><p>因此，承认世界的可知性，承认人能够获得关于无限发展着的物质世界的正确认识，也就是承认了真理的绝对性。</p><p>（5）真理的相对性</p><p>真理的相对性是指人们在一定条件下对事物的客观过程及其发展规律的正确认识总是有限度的。真理的相对性也有两个方面的含义：</p><ul><li>一是真理所反映的对象是有条件的、有限的；</li><li>二是真理反映客观对象的正确程度也是有条件的、有限的。</li></ul><p>任何特定的真理不仅所反映的对象在范围上是有限的，而且其正确程度也是有限的。任何真理都只能是主观对客观事物近似正确即相对正确的反映。</p><hr><ul><li>客观性：真理的内容是客观的；真理的检验标准是客观的。但是，真理的形式是主观的</li><li>绝对性：真理是正确的，这是绝对的；人类有能力认识这个无限发展着的世界，所以，我们获得的真理肯定是正确的</li><li>相对性：真理虽然现在是正确的，但是被认识的对象会发生变化，所以，现在对的以后可能会变错；虽然人类的认知能力是无限的，但是目前来说，还是有限的，所以，所谓的正确认知，未来还要深化</li></ul><hr><p>（6）真理的绝对性和相对性之间的关系：辩证统一</p><p>其一，二者相互依存。所谓相互依存，是说人们对于客观事物及其本质和规律的每一个正确认识，都是在一定范围内、一定程度上、一定条件下的认识，因而必然是相对的和有局限性的；但是在这一定范围内、一定程度上、一定条件下，它又是对客观对象的正确反映，因而它又是无条件的、绝对的。</p><p>其二，二者相互包含。所谓相互包含，</p><ul><li>一是说真理的绝对性寓于真理的相对性之中；</li><li>二是说真理的相对性必然包含并表现着真理的绝对性。</li><li>所以，绝对真理和相对真理是不可分的，没有离开绝对真理的相对真理，也没有离开相对真理的绝对真理。</li><li>毛泽东把真理的绝对性与相对性的关系比喻为长河与水滴的关系，“马克思主义者承认，在绝对的总的宇宙发展过程中，各个具体过程的发展都是相对的，因而在绝对真理的长河中，人们对于在各个一定发展阶段上的具体过程的认识只具有相对的真理性。<font color="#33a3dc">无数相对的真理之总和，就是绝对的真理</font>”。</li></ul><p>在二者的辩证关系中，还要明确，真理永远处在由相对向绝对的转化和发展中，是从真理的相对性走向绝对性、接近绝对性的过程。任何真理性的认识都是由真理的相对性向绝对性转化过程中的一个环节，这是真理发展的规律。</p><p>真理的绝对性与相对性，根源于人的认识能力、思维能力的矛盾本性，是人的思维的<font color="#33a3dc">至上性和非至上性</font>或人的认识能力的<font color="#33a3dc">无限性和有限性</font>的矛盾。人的认识能力、思维能力的这种至上和非至上、无限和有限的对立统一，决定了作为认识、思维成果的真理，也是绝对和相对的对立统一。</p><p>（7）批判两种错误的观点</p><ul><li>只看到绝对的真理：教条主义</li><li>只看到相对的真理：诡辩论（怀疑主义）</li></ul><p>承认真理是绝对性和相对性的辩证统一， 就必须以科学的态度对待一切真理，既要反对绝对主义，又要反对相对主义。</p><p>绝对主义片面夸大真理的绝对性，否认真理的相对性，认为人们可以一下子穷尽绝对真理，把已有的理论看成永恒不变的教条。这种绝对主义在实际生活中表现为教条主义和思想僵化。</p><p>相对主义片面夸大真理的相对性，否认真理的绝对性、客观性，怀疑科学理论的可靠性，把真理看成主观随意的东西。这种相对主义在实际生活中表现为怀疑主义和诡辩论。</p><p>（8）方法论意义</p><p>马克思主义作为科学真理，也是绝对性和相对性的统一。 以科学的态度对待马克思主义，就要正确处理好坚持和发展的辩证关系，对马克思主义既要坚持、又要发展，在坚持中发展、在发展中坚持，反对把马克思主义当作僵死的教条或认为马克思主义已经“过时”这两种错误倾向。</p><h4 id="考点-35-🌙-真理和谬误"><a class="header-anchor" href="#考点-35-🌙-真理和谬误"></a>考点 35 🌙 真理和谬误</h4><p>真理发展的过程，不仅是相对不断趋近绝对的过程，而且还是不断同谬误作斗争并战胜谬误的过程。真理和谬误是相伴而生的，人类在探索真理的过程中，难免产生谬误。</p><p><font color="#faa755">相互区别</font>：由于真理和谬误决定于认识的内容是否如实地反映了客观事物，因此真理和谬误是性质不同的两种认识，它们是对立的。</p><p><font color="#faa755">相互联系</font>：真理和谬误是统一的， 它们相互依存、相互转化。</p><ul><li>真理和谬误相比较而存在，没有真理也无所谓谬误，没有谬误也无所谓真理；</li><li>真理中包含着某种以后会暴露出来的错误的方面或因素，谬误中也隐藏着以后会显露出来的真理的成分或萌芽。</li></ul><p>在一定条件下，真理和谬误可以相互转化。真理和谬误在一定范围内的对立是绝对的，但超出一定范围，它们就会互相转化，真理变成谬误，谬误变成真理。真理和谬误之间相互依存、相互斗争和相互转化，是促进真理发展的重要动力，也是真理的无限发展过程的一个重要方面。坚持真理，修正错误，是马克思主义的一条基本原则。我们要善于坚持和发展真理，敢于和善于同谬误作斗争。</p><h4 id="考点-36-真理的检验标准"><a class="header-anchor" href="#考点-36-真理的检验标准"></a>考点 36 真理的检验标准</h4><p>（1）错误的检验标准</p><ul><li>以圣人或权威的意见为标准，如“以孔子的是非为是非”；</li><li>以自己的观念、意见为标准，如王阳明把所谓“良知”作为“自家标准”；</li><li>以多数人的意见和感觉为标准，如贝克莱的“集体的知觉”就是“实在性的证据&quot; ；</li><li>以概念是否清楚明白为标准，如笛卡儿、斯宾诺莎等；</li><li>以“有用”或“效果”为标准，如实用主义的“有用即真理”。</li></ul><p>以上观点都属于主观真理标准论，它们的共同点就是在主观范围内绕圈子，把主观的东西当作真理的标准，用认识检验认识，从而无法划清真理与谬误的根本界限。旧唯物主义哲学承认真理的客观性，在什么是检验真理标准的问题上作过一些有益的探讨，例如，旧唯物主义哲学的代表费尔巴哈主张，理论所不能解决的那些疑难，实践会解决。但是，由于旧唯物主义的反映论是消极的、直观的反映论，不能对实践作出科学的解释，也没有给实践以应有的地位，因而也没有科学地解决检验真理标准的问题。</p><p>（2）正确的检验标准：实践</p><p>实践是检验真理的唯一标准， 这是由<font color="#33a3dc">真理的本性和实践的特点</font>决定的。</p><p><font color="#faa755">真理的本性</font>是主观和客观的一致、符合。所谓检验认识的真理性，就是检验人的主观认识同客观对象是否相符合以及符合的程度。这种情况决定了检验标准既不能在纯粹主观范围内去寻找，也不能在纯粹客观范围内去解决，而只能是把主观同客观联系起来加以比较对照，从而确定认识是否符合客观实在。</p><p>实践是主观见之于客观的物质活动，是沟通主观和客观的“桥梁”，它不仅具有普遍性的特点和优点，而且具有<font color="#33a3dc">直接现实性的特点和优点</font>。只有实践才能把主观认识同客观实在联系起来加以对照，从而判明主观与客观是否一致， 判明认识是否具有真理性。</p><p>实践是检验真理的唯一标准，并不排斥逻辑证明的作用。逻辑证明是根据前提条件推断出某种结论的思维过程，它是探索真理、论证真理和扩大真理范围的重要手段，是对实践标准的一个重要补充，但不是检验真理的标准。这是因为逻辑证明只能证明前提条件与结论的一致性（或自洽性），而不是证明它的真理性，即不能证明它们与客观事物及其规律是否一致。同时，逻辑证明中使用的逻辑法则，也是在实践中产生的，必须经过实践的检验才能获得真理性。</p><p>（3）实践标准的确定性与不确定性</p><p>实践作为检验认识真理性的标准，既是确定的，又是不确定的，是确定性和不确定性的统一。</p><p><font color="#faa755">实践标准的确定性即绝对性是指</font>：</p><ul><li>实践是检验真理的唯一标准，此外再无别的标准；</li><li>凡经过实践证明了的一切认识都是客观真理，都具有不可推翻的性质；</li><li>实践能够检验一切认识，即使当前的实践还不能加以判定，最终也会被以后的实践作出裁决。</li></ul><p><font color="#faa755">实践标准的不确定性是指</font>：</p><ul><li>一定历史阶段上的具体实践具有局限性，它往往不能充分证明或驳倒某一认识的真理性；</li><li>实践检验真理是一个过程，不是一次完成的；</li><li>已被实践检验过的真理还要继续经受实践的检验。</li></ul><p>因此，我们必须把实践对真理的检验，看作全部人类实践即无数个别的、历史发展着的、整个社会的实践对真理的检验。实践检验和证明真理是一个过程， 这个过程永远不会完结。坚持实践标准的确定性和不确定性的统一，既可防止唯心主义的随意性，又可避免形而上学的绝对化。</p><h4 id="考点-37-⭐-真理与价值的辩证统一"><a class="header-anchor" href="#考点-37-⭐-真理与价值的辩证统一"></a>考点 37 ⭐ 真理与价值的辩证统一</h4><p>（1）价值的概念</p><p>作为哲学范畴，价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</p><p>（2）价值的基本特性</p><p>第一，<font color="#faa755">主体性</font>。（主体不同价值不同）这是指价值直接同主体相联系，始终以主体为中心。其一，价值关系的形成依赖于主体的存在。其二，价值关系的形成依赖于主体的创造，使客体潜在的价值转化为现实的存在。因此，主客体之间的价值关系不是一种自然的现成关系，而是主体在实践基础上确立的同客体之间的一种创造性的关系。</p><p>第二，<font color="#faa755">客观性</font>。（不以人的意志为转移）这是指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在。价值是一种客观存在，独立于人们对它的认识和评价。其一，主体的存在和需要是客观的，而不是抽象的。其二，客体的存在、属性及作用是客观的。</p><p>第三，<font color="#faa755">多维性</font>。（维度不同价值不同）这是指每个主体的价值关系都具有多样性，同一客体相对于主体的不同需要会产生不同的价值。</p><p>第四，<font color="#faa755">社会历史性</font>。（历史时期不同价值不同）价值关系中的主体是在一定社会关系中从事实践的具体的人，随着实践和历史的发展，主体和客体以及主客体之间的关系发生变化，导致人们对客体价值的判断也会发生改变。</p><p>（3）价值评价的特点及其标准</p><blockquote><p>认识分为知识性认识和评价性认识，知识性认识对客体，评价性认识对主客体的关系。</p></blockquote><p><font color="#faa755">价值评价</font>是一种关于价值现象的评价性的认识活动，是主体对客体价值以及价值大小所作的评判或判断，因而也被称作价值判断。其基本特点主要有：</p><p>第一，<font color="#33a3dc">评价以主客体的价值关系为认识对象</font>。评价性的认识与知识性的认识不同，知识性认识以客体本身的属性、关系和发展过程为反映内容，以获得关于客体的“真”的认识为目的；评价性认识则以客体和主体之间的价值关系为反映内容，以获得关于客体对于主体的意义即“善”“美”的认识为目的。</p><p>第二，<font color="#33a3dc">评价结果与评价主体直接相关</font>。知识性认识是人的主观反映客观的过程，主体的状态、需要不应当影响认识的客观结果，一个正确的认识是不应以不同主体的具体特点为转移的；评价性认识所认识的是客体与主体之间的价值关系，因而主体的存在状态作为价值关系的构成要素必然会对评价结果产生直接的影响，使评价结果依主体的具体特点而转移。</p><p>第三，<font color="#33a3dc">评价结果的正确与否依赖于对客体状况和主体需要的认识</font>。评价是关于主客体之间价值关系的认识，是对客体对于主体需要的意义的判断。人们是否正确地作出正确判断，取决于人对客体和主体的双重认识，这种认识不仅包括对客体属性和规律的认识，也包括对主体的规定性和需要的认识。只有对主体和客体都有了正确认识，才能对主客体间的价值关系作出正确的价值评判。</p><p>价值评价的特点表明，<font color="#33a3dc">评价并不是一种主观随意性的认识活动，而是具有客观性的认识活动</font>。在现实生活中，不同主体对同一事物的价值评价存在着差异或矛盾，并不说明价值评价没有客观标准。由于人民群众的要求和利益从根本上代表着人类整体的要求和利益，是与历史发展的基本要求或趋势相一致的，因此对于任何价值评价的主体而言，其<font color="#33a3dc">价值评价只有与人类整体的要求或利益相一致，才是正确的价值评价</font>。</p><p>（4）真理与价值的辩证统一关系</p><p>在实践中，真理既是制约实践的客观尺度，又是实践追求的价值目标之一，即通过实践获取外部世界的科学认识；而价值则是实践追求的根本目标，同时又是制约实践的主体尺度，真理和价值在实践基础上是辩证统一的。</p><p>真理和价值在实践中的辩证统一关系，主要体现在：</p><ul><li>首先，成功的实践必然是以真理和价值的辩证统一为前提的。任何成功的实践都必然是既遵循真理尺度，又符合价值尺度，并将二者有机地统一起来的结果。</li><li>其次，价值的形成和实现必须以坚持真理为前提，而<font color="#33a3dc">真理又必然是具有价值的</font>。人们对价值实现的追求，构成了实践的动因，但价值的实现必须以对相关真理的正确把握为前提才能成功。</li><li>最后，真理和价值在实践和认识活动中是相互制约、相互引导、相互促进的。</li></ul><p>坚持真理尺度和价值尺度的辩证统一， 要求我们在实践中必须坚持和弘扬科学精神和人文精神。科学精神要求我们必须坚持以实事求是精神去认识世界和改造世界，要求我们必须崇尚理性思维，以清醒的、严谨的、合乎逻辑的思想从事科学认识和理论创造，以进一步指导实践。人文精神要求把人民的利益和人的发展看作一切认识和实践活动的出发点，贯彻“以人为本”的原则，要求人们时刻以符合人民的利益和发展要求的价值标准审视一切思想和行动的合理性。</p><h3 id="第三节-认识世界和改造世界"><a class="header-anchor" href="#第三节-认识世界和改造世界"></a>第三节 认识世界和改造世界</h3><h4 id="考点-38-认识世界和改造世界必须勇于创新"><a class="header-anchor" href="#考点-38-认识世界和改造世界必须勇于创新"></a>考点 38 认识世界和改造世界必须勇于创新</h4><p>马克思主义批判的革命的本质，就是创新。创新是一个民族进步的灵魂，是一个国家兴旺发达的不竭动力，也是一个政党永葆生机的源泉。实践基础上的理论创新是社会发展和变革的先导。通过理论创新推动制度创新、科技创新、文化创新以及各方面的创新，不断在实践中探索前进，是我们的治党治国之道，是坚持和发展马克思主义之道，也是我们每个人学习和工作的成功之道。理论创新是在继承的基础上，不断吸取新的实践经验、新的思想形成新认识的过程。它源于实践又指导实践。在实践基础上的理论创新，能够在更高层次上引领和推动实践活动的开展，重视理论创新，是我们党的一个根本特点，也是我们党的一条重要政治经验，注重理论创新，是党的事业前进的重要保证。重视理论创新，必须坚决反对对待马克思主义的教条主义态度。对待马克思主义，我们必须做到坚持与创新的统一。马克思主义的生命力在于创新。只有进行创新，才能不断发展。创新又是以坚持和继承为前提的。把继承和创新统一起来，理论才能真正顺应时代和实践的呼唤，体现与时俱进的要求。</p><h4 id="考点-39-⭐-从必然走向自由"><a class="header-anchor" href="#考点-39-⭐-从必然走向自由"></a>考点 39 ⭐ 从必然走向自由</h4><p>认识世界和改造世界、改造客观世界和改造主观世界的过程，也就是从必然走向自由的过程。</p><p><font color="#faa755">自由的概念</font>：哲学上的自由是标示人的活动状态的范畴，是指人在活动中通过认识和利用必然所表现出的一种自觉自主的状态。</p><p><font color="#faa755">必然的概念</font>：必然性即规律性，是指不依赖于人的意识而存在的自然和社会发展所固有的客观规律。自由是对必然的认识和对客观世界的改造。</p><p>认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个历史性的过程。由必然到自由表现为人类不断地从必然王国走向自由王国的过程。</p><p><font color="#faa755">自由是历史发展的产物，自由是有条件的</font>：一是认识条件；二是实践条件。意志自由只是借助于对事物的认识作出决定的能力，而犹豫不决是以不知为基础的，它看来好像是在许多不同的和相互矛盾的可能的决定中任意进行选择，但恰好由此证明它的不自由，证明它正好被应该由它支配的对象所支配。恩格斯指出:“自由不在于幻想中摆脱自然规律而独立，而在于认识这些规律，从而能够有计划地使自然规律为一定的目的服务……自由就在于根据对自然界的必然性的认识来支配我们自己和外部自然。”</p><h2 id="第四章-唯物史观"><a class="header-anchor" href="#第四章-唯物史观"></a>第四章 唯物史观</h2><h3 id="第一节-社会基本矛盾及其运动规律"><a class="header-anchor" href="#第一节-社会基本矛盾及其运动规律"></a>第一节 社会基本矛盾及其运动规律</h3><h4 id="考点-40-⭐-唯物史观和唯心史观的对立"><a class="header-anchor" href="#考点-40-⭐-唯物史观和唯心史观的对立"></a>考点 40 ⭐ 唯物史观和唯心史观的对立</h4><p><font color="#faa755">社会历史观的基本问题</font>：社会存在和社会意识的关系问题。</p><p><font color="#faa755">唯心史观的缺陷</font>：</p><ul><li><font color="#33a3dc">一是至多考察人们活动的思想动机，而没有进一步追究思想动机背后的物质动因</font>；</li><li><font color="#33a3dc">二是只看到个人在历史上的作用，而忽视人民群众创造历史的决定作用</font>。</li></ul><p>马克思正确地解决了社会存在与社会意识的关系问题，发现了人类社会发展的客观规律，创立了唯物史观。唯物史观是唯一科学的历史观，它把人们对社会历史的认识，从唯心史观的统治下彻底解放出来，它给社会历史的研究提供了科学的理论和方法，把对社会主义的研究奠定在实践的基础之上，从而使社会主义成为科学。</p><h4 id="考点-41-⭐-社会存在和社会意识及其辩证关系"><a class="header-anchor" href="#考点-41-⭐-社会存在和社会意识及其辩证关系"></a>考点 41 ⭐ 社会存在和社会意识及其辩证关系</h4><p>（1）社会存在及其在社会发展过程中的作用</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1nrctff99xq8.png" alt="image"></p><p><font color="#faa755">社会存在</font>是社会生活的物质方面，是社会实践和物质生活条件的总和，主要包括物质生产方式、自然地理环境和人口因素。</p><p>自然地理环境和人口因素是社会存在和发展的必要条件，它们对社会发展起着加速或延缓的作用，但不能脱离社会生产发生作用，不能决定社会的性质和社会形态的更替。</p><p><font color="#33a3dc">物质生产方式就是劳动者和劳动资料结合的特殊方式，是生产力和生产关系的统一</font>，它集中体现了人类社会的物质性。生产方式中的生产力体现着人们改造自然的现实的物质力量，生产关系是人们在物质生产中发生的“物质的社会关系”，生产力和生产关系的统一所构成的生产方式使自然界的一部分转化为社会物质生活条件，使生物的人上升为社会的人。（生产方式 = 生产力 + 生产关系）</p><p>生产方式是社会历史发展的决定力量。首先，物质生产活动及生产方式是人类社会赖以存在和发展的基础，是人类其他一切活动的首要前提。其次，物质生产活动及生产方式决定着社会的结构、性质和面貌，制约着人们的经济生活、政治生活和精神生活等全部社会生活。最后，物质生产活动及生产方式的变化发展决定着整个社会历史的变化发展，决定着社会形态从低级向高级的更替和发展。</p><p>（2）社会意识及其构成</p><p>社会意识是社会生活的精神方面，是社会存在的反映。它既包括<font color="#33a3dc">社会意识的各种形式</font>，也包括<font color="#33a3dc">社会心理与自发形成的风俗、习惯</font>。社会意识具有复杂的结构，可以从不同角度对其进行划分。根据不同的主体，可分为个体意识和群体意识；根据不同的层次，可分为社会心理和社会意识形式。</p><p>社会意识的各种形式：</p><ul><li>社会意识形态（社会意识形式中与经济、阶级、利益有关的内容）：政治法律思想、道德、艺术、宗教、哲学等</li><li>非社会意识形态（社会意识形式中与经济、阶级、利益无关的内容）：语言学、心理学及自然科学等</li></ul><p>属于上层建筑的社会意识形式称为社会意识形态，主要包括政治法律思想、道德、艺术、宗教、哲学等。它们各自从不同方面发挥独特的作用。在阶级社会中，占统治地位的思想文化，本质上是经济上占统治地位的阶级意识形态，因而具有鲜明的阶级性。</p><p>（3）社会存在与社会意识的辩证关系原理的内容及其意义</p><p>社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。</p><ul><li>首先，<font color="#33a3dc">社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映</font>。社会意识根源于社会存在，是对以实践为基础的不断变化发展的现实世界的反映。</li><li>其次，<font color="#33a3dc">社会意识是人们进行社会物质交往的产物</font>。交往活动是在生产活动中形成的一种人类活动的重要方式，社会意识同语言一样，是在生产中由于交往活动的需要而产生的，随着生活和交往的发展，人们的社会意识也同时改变。所以，马克思说:“不是意识决定生活，而是生活决定意识。”</li><li>最后，<font color="#33a3dc">随着社会存在的发展，社会意识也相应地或迟或早地发生变化和发展</font>。社会意识是具体的、历史的。每一时代的社会意识都有其独特的内容和特点，具有不断进步的历史趋势，但其变化、发展的根源深深地埋藏于经济的事实之中。</li><li>总之，社会意识以理论、观念、心理等形式反映社会存在，这是社会意识对社会存在的依赖性，也是社会意识和社会存在辩证关系的一个方面。</li></ul><p>社会意识和社会存在辩证关系的另一个方面，是社会意识具有相对独立性，它在反映社会存在的同时具有自己特有的发展形式和规律。</p><ul><li>首先，<font color="#33a3dc">社会意识与社会存在发展的不完全同步性和不平衡性</font>。进步的社会意识可以在一定程度上预见、推断未来，指导人们的实践活动；落后于社会存在的社会意识则阻碍社会的发展。社会经济发展水平较高的国家或地区，其社会意识的发展水平未必是最高的；某些经济水平相对落后的国家或地区，其社会意识的某些方面却可以领先于经济发达的国家或地区。</li><li>其次，<font color="#33a3dc">社会意识内部各种形式之间的相互影响及各自具有的历史继承性</font>。一定历史发展阶段上的社会意识，在内容上主要是反映现实的社会存在，但同时也会吸收、保留以往形成的某些思想材料，即“古为今用”;在形式上继承以往既有的方式和方法，同时又根据新的内容和条件加以改造、补充和发展，并增添一些新的形式， 即“推陈出新”。正是由于这种继承性，才有社会意识发展的独特的历史，才能形成各具特色的民族传统。</li><li>最后，<font color="#33a3dc">社会意识对社会存在的能动的反作用</font>。这是社会意识相对独立性的突出表现。这种反作用就在于，它把不同集团、阶级，尤其是统治阶级的利益要求内化为人的思想、情感、意志，以支配人们的行动，从而影响社会的经济和政治。先进的社会意识对社会发展起积极的促进作用；落后的社会意识对社会发展起消极的阻碍作用。</li></ul><p>（4）方法论意义</p><p>社会存在与社会意识辩证关系的原理具有重要的理论意义和现实意义。它在人类思想史上第一次正确解决了社会历史观的基本问题，是社会历史观革命性变革的基础：第一，它宣告了唯心史观的彻底破产;第二，它使对社会历史的研究真正成为科学。这一原理对于社会发展包括社会文化建设具有重要的指导意义。</p><p>文化是社会意识的重要组成部分。文化是一个国家、一个民族的灵魂。文化兴则国运兴，文化强则民族强。文化蕴含着人类的智慧、价值追求和审美情趣，文化的核心是价值观。文化对社会发展的重要作用主要表现在：</p><ul><li>其一，文化为社会发展提供思想保证；</li><li>其二，文化为社会发展提供精神动力；</li><li>其三，文化为社会发展提供凝聚力量；</li><li>其四，文化为社会发展提供智力支持。</li></ul><h4 id="考点-42-⭐-生产力和生产关系矛盾运动的规律（第一对社会基本矛盾）"><a class="header-anchor" href="#考点-42-⭐-生产力和生产关系矛盾运动的规律（第一对社会基本矛盾）"></a>考点 42 ⭐ 生产力和生产关系矛盾运动的规律（第一对社会基本矛盾）</h4><p>（1）生产力的含义和基本要素</p><p><font color="#faa755">生产力</font>是人类在生产实践中形成的改造和影响自然以使其适应社会需要的<font color="#33a3dc">物质力量</font>。在哲学上，生产力是标志人类改造自然的实际程度和实际能力的范畴，它表示<font color="#33a3dc">人与自然</font>的关系。</p><p>生产力的基本要素：</p><ul><li>一是劳动资料， 即劳动手段。它是人们在劳动过程中用以改变或影响劳动对象的物质资料或物质条件，是人和劳动对象之间的媒介。其中，<font color="#33a3dc">最重要的是生产工具</font>，它<font color="#33a3dc">是生产力发展水平的客观尺度</font>，<font color="#33a3dc">是区分社会经济时代的客观依据</font>。</li><li>二是劳动对象。它是指人们通过自身劳动对之进行加工，使之变为使用价值用以满足社会需要的那一部分物质资料，包括未经加工的自然物和已经加工的物体。一方面，劳动对象是进行物质资料生产的前提，劳动只有同劳动对象相结合，才构成现实生产力；另一方面，劳动对象又是人们改造自然的程度和生产力发展状况的一-种标志，不同的劳动对象直接制约着生产力的发展水平。<font color="#33a3dc">劳动资料和劳动对象合称为生产资料</font>。（生产资料 = 劳动资料 + 劳动对象 ）</li><li>三是劳动者。它是指具有一定生产经验、劳动技能和知识，能够运用一定劳动资料作用于劳动对象，并从事生产实践活动的人。<font color="#33a3dc">劳动者是生产力中最活跃的因素</font>。生产资料和劳动者相结合，才能变为现实生产力。</li><li>生产力中还包含着科学技术。科学技术是知识形态的生产力，即一般生产力，它能够应用于生产过程，与生产力中的劳动资料、劳动对象和劳动者等因素相结合而转化为实际生产能力。科学技术上的发明创造，会引起劳动资料、劳动对象和劳动者素质的深刻变革和巨大进步；科学技术应用于生产的组织管理，能够大幅度提高管理效率；科学技术为劳动者所掌握，可以极大地提高劳动生产率。在现代，<font color="#33a3dc">科学技术日益成为生产发展的决定性因素</font>。科学技术是先进生产力的集中体现和主要标志，是第一生产力。（科技不是生产力中的独立要素，科技在生产劳动中起到决定性因素，不是社会历史）</li></ul><p>（2）生产关系的含义和内容</p><p><font color="#faa755">生产关系</font>是人们在物质生产过程中形成的<font color="#33a3dc">不以人的意志为转移</font>的经济关系。生产关系是社会关系中最基本的关系。生产关系有狭义和广义之分。狭义的生产关系是指在直接生产过程中结成的相互关系，包括<font color="#33a3dc">生产资料所有制关系</font>、<font color="#33a3dc">生产中人与人的关系</font>和<font color="#33a3dc">产品分配关系</font>。广义的生产关系是指人们在再生产的过程中结成的相互关系，包括生产、分配、交换和消费等诸多关系在内的生产关系体系。在生产关系中，<font color="#33a3dc">生产资料所有制关系是最基本的、决定性的，它构成全部生产关系的基础，是区分不同生产方式、判定社会经济结构性质的客观依据</font>。</p><blockquote><ul><li>生产工具是生产力发展水平的客观尺度，是区分社会经济时代的客观依据</li><li>生产资料所有制关系是最基本的、决定性的，它构成全部生产关系的基础，是区分不同生产方式、判定社会经济结构性质的客观依据</li></ul></blockquote><p>生产关系是一种客观的物质的社会关系。生产关系虽然是一种<font color="#33a3dc">人与人的关系</font>，但它是在物质生产过程中结成的关系，是不以人的意志为转移的。第一，生产关系具有客观性，本质上是生产力的社会存在形式，人们不能离开生产力的发展状况自由地选择生产关系，也不能任意改变生产关系。第二，生产关系是一种物 质利益关系，它体现着人们之间的物质经济利益，不是人们的主观愿望和要求。</p><p>（3）生产力与生产关系的辩证关系</p><p>生产力和生产关系是社会生产不可分割的两个方面。在社会生产中，生产力是生产的物质内容，生产关系是生产的社会形式，二者的有机结合和统一，构成社会的生产方式。生产力与生产关系的相互关系：生产力决定生产关系，生产关系反作用于生产力。</p><p><font color="#faa755">生产力决定生产关系</font>。</p><ul><li>第一，生产力状况决定生产关系的性质。有什么样的生产力，就会产生什么样的生产关系。马克思说:“手推磨产生的是封建主的社会，蒸汽磨产生的是工业资本家的社会。”</li><li>第二，生产力的发展决定生产关系的变革。当一种生产关系还能适合生产力发展时，它是不会灭亡的；当生产力发展到一定阶段，生产关系不适合生产力发展时，必然引起生产关系的变革。</li></ul><p><font color="#faa755">生产关系反作用于生产力</font>。当生产关系适合生产力发展的客观要求时，它对生产力的发展起推动作用；当生产关系不适合生产力发展的客观要求时，它就会阻碍生产力的发展；当不变更生产关系，生产力就不能继续发展时，生产关系对生产力的反作用表现得尤为突出。生产关系对生产力反作用的实际过程和情形是十分复杂的。新的生产关系总体上基本适合生产力发展，但并不排除它的某些环节或方面不适合生产力状况而阻碍其发展；旧的生产关系总体上基本不适合生产力发展，但也不排除它的某些环节或方面的调整和改变，能够暂时地、局部地对生产力发展有一定的促进作用。生产关系落后于生产力固然会阻碍其发展，而由于人为的原因使某种生产关系“超越”生产力水平，这种“拔高”了的生产关系也会阻碍生产力的发展。但是，不管哪种情况，生产关系对生产力的反作用归根到底还是由生产力决定的，生产关系对生产力反作用的性质也是取决于它是否适合生产力的状况。因此，判断一种生产关系是否优越的标准，在于这种生产关系对生产力是适合的还是不适合的，是促进还是阻碍生产力发展。不能离开生产力的状况和要求，孤立地、抽象地看待生产关系。</p><p>（4）生产力与生产关系的矛盾运动规律（人类社会发展第一规律）</p><p>生产力与生产关系的矛盾运动中的内在的、本质的、必然的联系，就是生产关系一定要适合生产力状况的规律，亦称生产力与生产关系的矛盾运动规律。这是人类社会发展的基本规律。</p><p>这一规律就内容看，概括了生产力和生产关系相互作用的两个方面：一方面，生产力的状况决定一定的生产关系的产生及其变化发展的方向和形式；另一方面，生产关系反作用于生产力，当生产关系适合生产力的状况时对生产力发展起促进作用，反之将起阻碍作用。从过程上看，这一规律表现为生产关 系对生产力总是从基本相适合到基本不相适合,再到基本相适合；与此相适应，生产关系也总是从相对稳定到新旧更替，再到相对稳定。生产力和生产关系的这种矛盾运动循环往复，不断推动社会生产发展，进而推动整个社会逐步走向更高阶段。</p><p>（5）方法论意义</p><p>生产力与生产关系矛盾运动规律的原理具有极为重要的理论意义和现实意义。首先，这一原理在人类思想史上彻底否定了以“道德说教”作为评判历史功过是非的思想体系，第一次科学地确立了生产力发展是“社会进步的最高标准”。其次，这一规律揭示了社会主义代替资本主义的历史必然性，是我们坚定社会主义信念的科学依据。最后，这一规律是马克思主义政党始终保持自己先进性质和制定路线、方针、政策的客观依据。</p><h4 id="考点-43-⭐-经济基础和上层建筑矛盾运动的规律（第二对社会基本矛盾）"><a class="header-anchor" href="#考点-43-⭐-经济基础和上层建筑矛盾运动的规律（第二对社会基本矛盾）"></a>考点 43 ⭐ 经济基础和上层建筑矛盾运动的规律（第二对社会基本矛盾）</h4><p>（1）经济基础的内涵</p><p><font color="#faa755">经济基础</font>是指由社会一定发展阶段的生产力所决定的生产关系的总和。理解经济基础的内涵，要把握两点：</p><ul><li>其一，经济基础的实质是社会一定发展阶段上的基本经济制度，是制度化的物质社会关系。在一定社会内部往往存在着多种而不是单一的经济关系，但决定一个社会性质的是其占支配地位的经济关系。</li><li>其二，经济基础与经济体制具有内在联系。经济体制是社会基本经济制度所采取的组织形式和管理形式，是生产关系的具体实现形式。经济体制与生产力发展的关系更为直接、更为具体，在实践中它是与社会的基本经济制度结合在一起的。 经济体制的选择是否恰当，对基本经济制度即生产关系的自我完善和生产力的发展起重大作用。</li></ul><p>（2）上层建筑的内涵</p><p><font color="#faa755">上层建筑</font>是指建立在一定经济基础之上的意识形态以及相应的制度、组织和设施。自原始社会解体以来，上层建筑由意识形态和政治法律制度及设施、政治组织两部分构成。</p><ul><li>意识形态又称观念上层建筑，包括政治法律思想、道德、艺术、宗教、哲学等思想观点。（属于上层建筑的社会意识就是社会意识形态）</li><li>政治法律制度及设施和政治组织又称政治上层建筑，包括国家政治制度、立法司法制度和行政制度，以及国家政权机构、政党、军队、警察、法庭、监狱等政治组织形态和设施。</li></ul><p>观念上层建筑和政治上层建筑的关系：政治上层建筑是在一定意识形态指导下建立起来的，是统治阶级意志的体现；政治上层建筑一旦形成， 就成为一种现实的力量，影响并制约着人们的思想理论观点。</p><p>在整个上层建筑中，政治上层建筑居主导地位，国家政权是核心。国家是阶级矛盾不可调和的产物。在阶级已经产生且矛盾冲突愈演愈烈的形势下，为了把阶级斗争限制在一定“秩序”之内，国家作为强制性的力量应运而生。国家的实质是一个阶级统治另一个阶级的工具。</p><p>（3）经济基础与上层建筑的辩证关系</p><p>经济基础决定上层建筑。具体表现在：</p><ul><li>第一，<font color="#33a3dc">经济基础的需要决定上层建筑的产生</font>。上层建筑是适应经济基础而建立起来的。经济基础是根源，上层建筑是派生物，是经济基础的政治和思想表现形态。</li><li>第二，经济基础的性质决定上层建筑的性质。有什么样的经济基础，就有什么样的上层建筑；不同性质的经济基础一定会产生不同性质的上层建筑。由于占统治地位的生产关系决定经济基础的性质，因而它必然对上层建筑起主导作用，并决定上层建筑的性质。</li><li>第三，经济基础的变化发展决定上层建筑的变化发展及其方向。经济基础变化了，上层建筑也要随之改变；经济基础不仅推动上层建筑的变化发展，而且决定上层建筑变化发展的方向。上层建筑的各个部分，由于具有不同程度的相对独立性，其改变有早有晚、有快有慢，虽不是同时的立即的改变，但变化是必然的。在阶级社会里，上层建筑的变革， 首先是从国家政权和政法制度开始，旧的上层建筑的其他部分，特别是道德、哲学等意识形态的变化就更缓慢一些。这种情况决定了，上层建筑中思想文化领域里新旧斗争的长期性。</li></ul><p><font color="#33a3dc">上层建筑对经济基础具有反作用</font>。这种反作用集中表现在为自己的经济基础服务。上层建筑反作用的性质，取决于它所服务的经济基础的性质，归根到底取决于它是否有利于生产力的发展。当它为适合生产力发展的经济基础服务时，它就成为推动社会发展的进步力量；当它为束缚生产力发展的经济基础服务时，它就成为阻碍社会发展的消极力量。社会主义国家的无产阶级政党是上层建筑中的核心政治力量，其先进性的发挥，就集中表现在它能代表先进生产力的发展要求，为社会主义经济基础服务。上层建筑的反作用是巨大的，但不是无限的。它可以影响社会性质和历史进程，但不能决定历史发展的总趋势。</p><p>（4）经济基础与上层建筑的矛盾运动及其规律</p><p>上层建筑是适应经济基础的要求而产生的，它根源于经济基础，但作为一种超经济的力量，它又超越于经济基础。上层建筑与经济基础的矛盾表现在：</p><ul><li>新建立起来的上层建筑总有某些不完善的地方，不能完全适应经济基础的要求。</li><li>上层建筑一旦形成，就成为一种相对独立的力量，它有脱离经济基础的倾向。</li><li>经济基础总会变化，这种变化不会立即在上层建筑中得到反映，这就造成上层建筑落后于经济基础的情况。</li><li>当生产力的发展要求变革已经陈旧的经济基础时，仍然维护这种经济基础的上层建筑就成为经济基础和生产力发展的严重阻碍，它们之间的矛盾就趋于尖锐化。</li></ul><p>经济基础和上层建筑相互作用构成的二者矛盾运动规律，就是上层建筑一定要适合经济基础状况的规律。这一规律的主要内容：经济基础决定上层建筑的产生、性质和发展变化的方向；上层建筑的反作用取决于和服务于经济基础的性质和要求。这一规律表明，上层建筑的性质和变化发展，上层建筑是否需要改革以及改革的形式和方向，都取决于经济基础的状况。</p><p>（5）方法论意义</p><p>上层建筑一定要适合经济基础状况的规律是人类社会发展的又一基本规律。这一规律也是我们观察和研究社会历史的一把钥匙，对于每一历史时期的政治法律制度和设施以及宗教的、哲学的和其他的观念形式，都可以从社会的经济基础中得到科学的说明。这一规律 是我们党制定路线、方针、政策的重要依据，是我们进行社会主义政治体制改革和建设社会主义精神文明的客观依据，对于我们深刻理解和自觉实行依法治国和以德治国的方针、构建社会主义和谐社会都具有重要的指导意义。</p><h4 id="考点-44-⭐-社会形态更替的一般规律及特殊形式"><a class="header-anchor" href="#考点-44-⭐-社会形态更替的一般规律及特殊形式"></a>考点 44 ⭐ 社会形态更替的一般规律及特殊形式</h4><p>（1）社会形态的内涵</p><p><font color="#faa755">社会形态</font>是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。社会形态包括社会的经济形态、政治形态和意识形态，是三者的历史的、具体的统一。一定的社会形态总要以一定 的社会制度形式呈现出来，社会制度也被视为社会形态的同义语。人类社会是不断发展的，社会的根本性变革和进步就是通过社会形态的更替实现的。（社会形态 = 经济基础 + 上层建筑）</p><p>（2）社会形态的特点</p><p>首先，社会形态的内容是全面的，既包括经济基础，又包括上层建筑，二者缺一不可，犹如“骨骼”和“血肉”。经济基础是社会的“骨骼系统”，上层建筑是社会的“血肉系统”，上层建筑不过是经济基础的政治和思想的表现形态。这就同那些把社会基础归结为人类天性、心理素质等的唯心史观区别开来，也同那些单纯用某些科学技术特征作为划分社会历史阶段标准的做法有所不同。</p><p>其次，社会形态是具体的，不是抽象的。现实存在的社会形态是复杂的，同一种社会形态在不同国家、民族中，由于历史条件和具体环境不同，又表现出不同的特点；每一种社会形态内部既有这个社会自已的经济基础和上层建筑，又有旧社会的残余和新社会的萌芽。“纯粹的社会”是不存在的。因此，社会形态的发展既有统一性， 又有多样性，要做具体的分析。</p><p>最后，社会形态是历史的，有其产生、发展和灭亡的过程。</p><p>（3）社会形态更替的特点</p><p>第一，<font color="#33a3dc">社会形态更替的统一性和多样性</font>。社会发展的决定性和主体的选择性使社会发展过程呈现出统一性和多样性。它表现在两个方面：</p><p>从纵向看，表现为社会形态更替的统一性和多样性。 统一性是社会形态运动由低级到高级、由简单到复杂的过程，人类的总体历史过程表现为五种社会形态的依次更替。多样性是指不同的民族可以超越一种或几种社会形态而跳跃式地向前发展。社会形态更替的多样性并不能否定人类总体历史过程。某些民族可以实现跨越，但其跨越的方向、跨越的限度受总体历史进程的制约。</p><p>从横向看，社会发展过程的统一性和多样性表现为同类社会形态既有共同的本质，又有各自的特点。在现实社会中，每一种社会形态在不同的民族那里都有自己特殊的表现形式。正如列宁所深刻指出的:“世界历史发展的一般规律，不仅丝毫不排斥个别发展阶段在发展的形式或顺序上表现出特殊性，反而是以此为前提的。”</p><p>第二，<font color="#33a3dc">社会形态更替的必然性与人们的历史选择性</font>。社会形态更替的客观必然性，主要是指社会发展过程中的决定性，指社会形态依次更替的过程和规律是客观的，其发展的基本趋势是确定不移的，也就是说社会发展是一种自然历史过程。人们的历史选择性即社会发展过程中的选择性，是指社会主体以一定的方式在可能性空间中有意识、有目的地指向确定对象的创造性活动。</p><p>一个民族之所以作出这种或那种选择，有其特定的原因：一是取决于民族利益；二是取决于交往；三是取决于对历史必然性以及本民族特点的把握程度。</p><p>第三，<font color="#33a3dc">社会形态更替的前进性与曲折性</font>。社会发展过程中的决定性、统一性表明社会发展的总趋势是前进的；社会发展过程中的选择性、多样性表明社会发展的具体道路不是直线的，而是曲折的。社会发展过程的曲折性是指社会前进过程中所出现的反复、停滞和倒退现象。曲折前进是历史的普遍规律。我们要用历史的、辩证的眼光来看待社会主义发展过程中的曲折现象，坚信“前途是光明的，道路是曲折的”伟大真理。</p><h3 id="第二节-社会历史发展的动力"><a class="header-anchor" href="#第二节-社会历史发展的动力"></a>第二节 社会历史发展的动力</h3><h4 id="考点-45-⭐-社会基本矛盾是社会发展的根本动力（第一动力）"><a class="header-anchor" href="#考点-45-⭐-社会基本矛盾是社会发展的根本动力（第一动力）"></a>考点 45 ⭐ 社会基本矛盾是社会发展的根本动力（第一动力）</h4><p>（1）社会基本矛盾的内容</p><p><font color="#faa755">生产力和生产关系、经济基础和上层建筑的矛盾是社会基本矛盾</font>。这是因为：</p><ul><li>第一，这两对矛盾所涉及的三个方面，即生产力、生产关系（经济基础）和上层建筑，囊括了社会生活的基本领域，形成了社会有机体的基本结构即经济结构、政治结构和观念结构；</li><li>第二，这两对矛盾存在于每个社会形态之中，贯穿于人类社会发展过程的始终；</li><li>第三，这两对矛盾规定了社会发展过程中各种社会形态、社会制度的基本性质；</li><li>第四，这两对矛盾是其他一切社会矛盾的根源，决定并制约其他社会矛盾的存在和解决；</li><li>第五，这两对矛盾运动所体现的生产力、生产关系（经济基础）上层建筑之间的本质的必然的联系，形成了社会发展的基本规律，即两个“一定要适合”的规律。</li></ul><p>这两对基本矛盾是相互联系、相互制约的，但地位和作用并不相同。生产力和生产关系的矛盾是更为根本的矛盾，它决定经济基础和上层建筑矛盾的产生和发展；生产力和生产关系的矛盾又受到经济基础和上层建筑矛盾的制约，它的解决有赖于经济基础和上层建筑矛盾的解决。在社会基本矛盾运动中，以至在整个社会发展中，生产方式或经济因素起决定作用，但也不能忽视上层建筑即政治和社会意识因素的巨大的能动作用。</p><p>（2）社会基本矛盾在历史发展中的作用</p><p>社会基本矛盾作为历史发展的根本动力，它在历史发展中的作用<font color="#faa755">主要表现在</font>：</p><ul><li>首先，生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。</li><li>其次，社会基本矛盾特别是生产力和生产关系的矛盾，是“一切历史冲突的根源”，决定着社会中其他矛盾的存在和发展。</li><li>最后，社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。</li></ul><p>（3）社会基本矛盾分析方法及其重要意义</p><p>社会基本矛盾分析方法要求我们全面认识和分析生产力和生产关系、经济基础和上层建筑的矛盾运动。只有把生产力和生产关系的矛盾运动同经济基础和上层建筑的矛盾运动结合起来观察，把社会基本矛盾作为一个整体来观察，才能全面把握整个社会的基本面貌和发展方向。坚持和发展中国特色社会主义，必须不断调整生产关系以适应社会生产力发展，不断完善上层建筑以适应经济基础发展。当前我国正在全面深化改革，这是由我国社会基本矛盾运动决定的。</p><h4 id="考点-46-阶级斗争在阶级社会发展中的作用（第二动力）"><a class="header-anchor" href="#考点-46-阶级斗争在阶级社会发展中的作用（第二动力）"></a>考点 46 阶级斗争在阶级社会发展中的作用（第二动力）</h4><p>阶级的本质在于它是与特定的生产关系相联系的、在经济上处于不同地位的社会集团或人群共同体。生产资料占有关系不同，是划分阶级的基础。阶级对立的实质是社会上一部分人拥有生产资料因而占有另一部分人的劳动。</p><p>阶级斗争是社会基本矛盾在阶级社会中的直接表现，是阶级社会发展的<font color="#33a3dc">直接动力</font>。无产阶级反对资产阶级的斗争，是以消灭私有制和剥削制度、解放全人类为最终目的的斗争，其历史进步作用是其他阶级斗争不可比拟的。</p><h4 id="考点-47-社会革命在阶级社会发展中的作用（第三动力）"><a class="header-anchor" href="#考点-47-社会革命在阶级社会发展中的作用（第三动力）"></a>考点 47 社会革命在阶级社会发展中的作用（第三动力）</h4><p>阶级斗争发展到一定程度，必然导致社会革命。社会革命是阶级斗争的最高形式，是社会形态的质变。社会革命的实质是革命阶级推翻反动阶级的统治，用新的社会制度代替旧的社会制度，解放生产力，推动社会发展。社会革命的根本问题是国家政权问题，国家政权从反动阶级手里转到革命阶级手里，是实现社会形态变革的首要的基本的标志。</p><p>革命在社会发展中的重要作用表现在：社会革命是实现社会形态更替的重要手段和决定性环节；社会革命能充分发挥人民群众创造历史的积极性和伟大作用;无产阶级革命将为消除阶级对抗、充分利用全人类的文明成果促进社会全面进步创造条件。马克思说，“革命是历史的火车头”。马克思主义重视革命的伟大作用，同时也不否认改良作为革命的一种补充手段、 为争取劳动者境况的改善所起的作用。马克思主义不拒绝改良，但反对改良主义。</p><h4 id="考点-48-改革的性质及其在社会发展中的作用（第四动力）"><a class="header-anchor" href="#考点-48-改革的性质及其在社会发展中的作用（第四动力）"></a>考点 48 改革的性质及其在社会发展中的作用（第四动力）</h4><p>改革是推动社会发展的又一重要动力。改革是在同一社会形态内，通过调整、变革不适合生产力发展要求的生产关系和上层建筑的某些部分及环节，实现该社会形态的自我发展和自我完善。社会主义社会的发展同样离不开改革。恩格斯指出:“我认为，所谓‘社会主义社会’不是一种一成不变的东西 ，而应当和任何其他社会制度一样，把它看成是经常变化和改革的社会。”</p><h4 id="考点-49-⭐-科学技术在社会发展中的作用（第五动力）"><a class="header-anchor" href="#考点-49-⭐-科学技术在社会发展中的作用（第五动力）"></a>考点 49 ⭐ 科学技术在社会发展中的作用（第五动力）</h4><p>（1）科学技术的含义</p><p><font color="#faa755">科学技术</font>是一个复合概念。科学和技术既相互区别，又有着十分密切的联系。科学是对客观世界的认识，是反映客观事实和客观规律的知识体系及其相关的活动。科学主要分为自然科学、社会科学和思维科学。技术有广义和狭义之分。广义的技术包括生产技术和非生产技术；狭义的技术是指生产技术，即人类改造自然，进行生产的方法与手段。科学活动主要是一种认识活动或精神性活动;技术活动主要是一种生产性、实践性活动。科学和技术是辩证统一的整体。在今天，科学活动与技术活动的联系越来越紧密，日益融为一-体。</p><p>（2）科学技术革命的作用</p><p>科学技术革命是社会动力体系中的一种<font color="#33a3dc">重要动力</font>。马克思对科学技术的伟大历史作用作过精辟而形象的概括，认为科学是“历史的有力的杠杆”，是“最高意义上的革命力量”。科学技术革命主要是通过促进人们的生产方式、生活方式和思维方式的深刻变化来推动社会发展的。</p><p>现代科学技术革命对人类社会发展的影响更加深远、更加强烈。主要表现在：</p><p>首先，现代科学技术革命对生产方式产生了深刻影响。其一，改变了社会生产力的构成要素；其二，改变了人们的劳动形式；其三，改变了社会经济结构，特别是导致了产业结构发生变革。</p><p>其次，现代科学技术革命对生活方式产生了巨大影响。现代科学技术革命直接或间接地作用于人们生活方式的四个基本要素，即生活主体、生活资料、生活时间和生活空间，从而引起生活方式发生新的变革。</p><p>最后，现代科学技术革命促进了思维方式的变革。现代科学技术革命对人的思维方式产生了重要影响，主要表现在新的科学理论和技术手段通过影响思维主体、思维客体和思维工具，引起了思维方式的变革。现代科学技术革命使思维方式具有系统性、整体性、开放性、动态性、创造性等特征，并使认识活动出现数学化、模型化、形式化的趋势。我国制定并实施的“科教兴国”战略，鼓励自主创新，推进国家创新体系建设，促进科学技术事业和社会主义事业蓬勃发展，是正确的战略决策。</p><p>（3）正确把握科学技术的社会作用</p><p>科学技术能够通过促进经济发展造福于人类，科学技术的作用既受到一定客观条件， 如社会制度、利益关系等因素的影响，也受到一定的主观条件，如人们的观念和认识水平的影响。科学技术的发展标志着人类改造自然能力的增强，意味着能够更多地创造出人们所需的物质财富，对社会发展有巨大的推动作用。但是，科学技术在运用于社会时所遇到的问题也越来越突出。一种情形是由于对自然规律和人与自然关系的认识不够，或缺乏对科学技术消极后果的强有力的控制手段。还有一种情形是与一定的社 会制度有关。正确认识和运用科学技术，首要的就是有合理的社会制度保障科学技术的正确运用，始终坚持使科学技术为人类的健康发展服务，让科学技术为人类造福。</p><h3 id="第三节-人民群众在历史发展中的作用"><a class="header-anchor" href="#第三节-人民群众在历史发展中的作用"></a>第三节 人民群众在历史发展中的作用</h3><h4 id="考点-50-关于历史创造者问题"><a class="header-anchor" href="#考点-50-关于历史创造者问题"></a>考点 50 关于历史创造者问题</h4><p>（1）两种历史观在历史创造者问题上的对立</p><p>究竟谁是历史的创造者？是人民群众创造历史还是英雄创造历史？这是唯物史观与唯心史观的分水岭。</p><p>唯心史观从社会意识决定社会存在的基本前提出发，否认物质资料生产方式是社会发展的决定力量，抹杀人民群众的历史作用，宣扬少数英雄人物创造历史,因而这样的观点被称为英雄史观。英雄史观的产生有其深刻的根源：它停留于历史现象的表面，把活动在历史舞台前面的少数英雄人物的作用加以夸大并绝对化，是其认识根源；社会生产力水平较低，社会的政治统治和精神生活被少数人所垄断，是其社会历史根源；剥削阶级的偏见是其阶级根源。</p><p>与唯心史观相反，唯物史观认为，“全部历史本来是由个人活动所构成，而社会科学的任务在于解释这些活动”。人是现实社会中的人，要说明历史创造者问题，必须全面、具体、历史地考察和分析人们在社会历史发展中的作用。</p><p>（2）唯物史观考察历史创造者问题的原则</p><p>首先，<font color="#33a3dc">唯物史观立足于现实的人及其本质来把握历史的创造者</font>。唯物史观认为，人不是抽象的而是现实的，现实的人及其活动是社会历史存在和发展的前提。马克思指出:“人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。”这就告诉我们，人的本质属性是社会属性，而不是自然属性;人的本质属性表现在各种社会关系中；人的本质是变化<br>发展的，而不是永恒不变的。</p><p>其次，<font color="#33a3dc">唯物史观立足于整体的社会历史过程来探究谁是历史的创造者</font>。社会历史发展过程虽然离不开个体的人的活动，但整体的社会历史并非个体的历史的简单堆砌。历史是无数个追求着自己目的的人的活动的合力，就其中的每个人而言，可以说，他“创造”了自己个人的“历史”，但不能说创造了整个社会历史。社会历史就其整体而言，是一定的群体（集体、阶级、民族乃至全人类）的认识活动和实践活动及其产物的演进过程，是以一定的物质生产方式为基础的社会形成和演进过程。</p><p>再次，<font color="#33a3dc">唯物史观从社会历史发展的必然性入手来考察和说明谁是历史的创造者</font>。历史发展的必然性体现在一定的历史主体的活动之中，在其中，既存在着符合社会历史必然性、推动和促进社会历史向前发展的力量，也存在着违反社会历史必然性、阻碍历史前进的力量。只有代表前一种力量的人才属于历史的创造者。</p><p>最后，<font color="#33a3dc">唯物史观从人与历史关系的不同层次上考察谁是历史的创造者</font>。人与历史的关系具有类与历史、群体与历史、个体与历史三层关系，唯物史观更深人地考察群体与历史、个体与历史的关系，考察群体与个体的关系，区分了创造历史过程中的决定力量与非决定力量、主导力量与非主导力量，从而科学地解决了谁是历史创造者的问题。</p><h4 id="考点-51-⭐-现实的人及其本质"><a class="header-anchor" href="#考点-51-⭐-现实的人及其本质"></a>考点 51 ⭐ 现实的人及其本质</h4><p>（1）现实的人及其活动与社会历史</p><p>社会和人是不可分的，社会是人的社会，人是社会中的人。社会历史是由现实的人及其活动构成的。所谓现实的人，“不是处在某种虚幻的离群索居和固定不变状态中的人，而是处在现实的、可以通过经验观察到的、在一定条件下进行的发展过程中的人”。这种现实的人，是基于自身需要和社会需要而从事一定实践活动、处于一定社会关系中、具有能动性的人。只有把，人看作现实的人，才能正确把握人及其活动的本质，把握人与社会历史的关系。唯物史观就是“关于现实的人及其历史发展的科学”。</p><p>（2）人的本质</p><p>人的本质是现实的人之所以存在的内在根据。人的本质问题包括两个方面：一是人与动物的区别；二是人与人的区别。</p><p>从人与动物相区别的层次上看，<font color="#33a3dc">人的本质在于劳动</font>。劳动是人类的本质活动。劳动不仅创造了人本身，而且通过一-定的创造物使人的本质力量得到确证。劳动是最基本的实践活动，也是人类最基本的存在方式。劳动发展史是理解社会历史奥秘的钥匙，同样也是理解社会历史创造过程和历史创造者的关键。人们创造历史的第一个或最基本的活动是生产劳动。</p><p>从人与人相区别的层次上看，<font color="#33a3dc">人的本质是一切社会关系的总和</font>。马克思指出:“人的本质不是单个人所固有的抽象物，在其现实性上，它是一切社会关系的总和。”这就是说，人的本质不是单个人天生就具有的东西，也不是从所有个体的人身上抽象出来的共同性。现实的人总是处在特定的社会关系和特定历史条件下的人。因此，人的本质是具体的而不是抽象的，是历史的而不是永恒不变的。</p><h4 id="考点-52-⭐-人民群众创造历史"><a class="header-anchor" href="#考点-52-⭐-人民群众创造历史"></a>考点 52 ⭐ 人民群众创造历史</h4><p>（1）人民群众在创造历史过程中的决定作用</p><p>人民群众是一个历史范畴。</p><ul><li>从质上说，人民群众是指一切对社会历史发展起推动作用的人；</li><li>从量上说，是指社会人口中的绝大多数。</li></ul><p>在不同的历史时代，人民群众有着不同的内容，包含着不同的阶级、阶层和集团。人民群众中最稳定的主体部分始终是从事物质资料生产的劳动群众及知识分子。</p><p>在社会历史发展过程中,人民群众起着决定性的作用。人民群众是社会历史实践的主体，是历史的创造者。</p><ul><li>首先，人民群众是社会物质财富的创造者；</li><li>其次，人民群众是社会精神财富的创造者；</li><li>再次，人民群众是社会变革的决定力量；</li><li>最后，人民群众既是先进生产力和先进文化的创造主体，也是实现自身利益的根本力量。</li></ul><p>人民群众创造历史的作用是同社会基本矛盾运动推动社会前进的过程相一致的。人民群众的总体意愿和行动代表了历史发展的方向，人民群众的社会实践最终决定历史发展的结局。</p><p>历史是人民群众创造的，但人民群众创造历史的活动及作用又受到社会历史条件的制约。这些条件包括经济条件（根本制约因素）、政治条件和精神文化条件。</p><p>（2）无产阶级政党的群众路线</p><p>唯物史观关于人民群众是历史创造者的原理，是无产阶级政党的群众观点和群众路线的理论基础。</p><p><font color="#faa755">群众观点</font>的基本内容：坚信人民群众自己解放自己的观点，全心全意为人民服务的观点，一切向人民群众负责的观点，虚心向群众学习的观点。</p><p><font color="#faa755">群众路线</font>是群众观点在实际工作中的贯彻运用。其基本内容：一切为了群众，一切依靠群众，从群众中来，到群众中去。群众路线是无产阶级政党的根本路线，也是党的根本领导方法和工作方法。</p><p>在新的历史时期，坚持和贯彻党的群众观点和群众路线，就要把“人民拥护不拥护”“人民赞成不赞成”“人民高兴不高兴”“人民答应不答应”作为制定各项方针、政策的出发点和归宿；把代表最广大人民的根本利益，作为保持党的先进性的重要内容；把以人为本作为科学发展观的核心，做到发展为了人民、发展依靠人民、发展成果由人民共享。</p><h4 id="考点-53-个人在社会历史中的作用"><a class="header-anchor" href="#考点-53-个人在社会历史中的作用"></a>考点 53 个人在社会历史中的作用</h4><p>历史人物，特别是杰出人物在社会发展过程中起着特殊的作用，主要表现在：历史人物是历史事件的发起者、当事者；历史人物是实现一定历史任务的组织者、领导者;历史人物是历史进程的影响者，它可以加速或延缓历史任务的解决。因此，历史人物对历史发展的具体过程始终起着一定的作用，有时甚至对历史事件的进程和结局产生决定性的影响，但不能决定历史发展的基本趋势。</p><p>无产阶级领袖不同于以往历史上的杰出人物，因为他们所代表的是历史上最革命、最先进的阶级，在革命和建设中发挥了重大作用。但无产阶级领袖是人而不是神，必然受到一定历史条件的限制，有时也会有这样或那样的失误。无产阶级领袖在历史上的作用，取决于他们对历史发展规律的认识程度以及同人民群众的结合程度。在新的历史条件下，仍然需要尊敬领袖、发挥领袖的作用，但不能夸大个人的作用、搞个人崇拜。</p><h2 id="第五章-资本主义的本质及规律"><a class="header-anchor" href="#第五章-资本主义的本质及规律"></a>第五章 资本主义的本质及规律</h2><h3 id="第一节-商品经济和价值规律"><a class="header-anchor" href="#第一节-商品经济和价值规律"></a>第一节 商品经济和价值规律</h3><h4 id="考点-54-资本主义生产关系的产生和资本主义生产方式的形成"><a class="header-anchor" href="#考点-54-资本主义生产关系的产生和资本主义生产方式的形成"></a>考点 54 资本主义生产关系的产生和资本主义生产方式的形成</h4><p>（1）前资本主义社会形态的演进和更替</p><p>原始社会是人类社会发展中的第一个社会形态。奴隶社会是人类历史上第个阶级剥削社会。封建社会的生产关系以封建主占有土地等生产资料和不完全占有农民（农奴）为基本特征。</p><p>（2）资本主义生产关系的产生</p><p>资本主义生产关系产生的途径有两个：</p><ul><li>一是从小商品经济分化出来；</li><li>二是从商人和高利贷者转化而成。</li></ul><p>（3）资本的原始积累</p><p>资本原始积累的概念：生产者与生产资料相分离，货币资本迅速集中于少数人手中的历史过程。</p><p>资本原始积累的途径：</p><ul><li>一是用暴力手段剥夺农民土地；</li><li>二是用暴力手段掠夺货币财富。</li></ul><p>资本原始积累的事实表明，资产阶级的发家史就是一部罪恶的掠夺史，正如马克思所说：“资本来到世间，从头到脚，每个毛孔都滴着血和肮脏的东西。”“这种剥夺的历史，是用血和火的文字，写在人类的编年史中的。”</p><p>（4）资本主义生产方式的确立</p><p>资本主义生产力和生产关系的进一步发展， 对上层建筑的彻底变革提出了强烈要求。从 17 世纪中期到 18 世纪后半期，英、法等国先后进行了资产阶级革命，建立了资产阶级的政治统治，实现了产业革命，机器大工业代替了工场手工业，促进了社会生产力和资本主义生产关系的空前大发展，最终建立起资本主义生产方式。</p><h4 id="考点-55-⭐-价值是什么"><a class="header-anchor" href="#考点-55-⭐-价值是什么"></a>考点 55 ⭐ 价值是什么</h4><p>（1）商品经济产生的历史条件</p><p><font color="#faa755">商品经济</font>是作为自然经济的对立物而产生和发展起来的。自然经济是一种以自给自足为特征的经济形式。自然经济以分散的、自给自足的家庭生产为基础，生产规模狭小，社会分工低下，以使用价值为生产目的。</p><p>商品经济是以交换为目的而进行生产的经济形式。商品经济产生的历史条件有两个：</p><ul><li>一是社会分工的存在；</li><li>二是生产资料和劳动产品属于不同的所有者。</li></ul><p>（2）商品的二因素</p><p>商品的概念及其二因素：商品是用来交换的能满足人们某种需要的劳动产品，具有<font color="#33a3dc">使用价值</font>和<font color="#33a3dc">价值</font>两个因素或两种属性，是使用价值和价值的矛盾统一体。</p><p><font color="#faa755">使用价值的概念及其特点</font>：使用价值是指商品能满足人们某种需要的属性，即商品的有用性，反映人与自然之间的物质关系，是商品的<font color="#33a3dc">自然属性</font>，是一切劳动产品共有的属性。使用价值构成社会财富的物质内容。</p><p>交换价值是如何被决定的：使用价值是交换价值的物质承担者。交换价值首先<font color="#33a3dc">表现</font>为一种使用价值同另一种使用价值交换的量的关系或比例。<font color="#33a3dc">决定</font>商品交换比例的，不是商品的使用价值，而是价值。</p><p><font color="#faa755">价值的概念及其特点</font>：价值是凝结在商品中的无差别的一般人类<font color="#33a3dc">劳动</font>，即人类脑力和体力的耗费。价值是商品特有的<font color="#33a3dc">社会属性</font>。使用价值不同的商品之所以能按一定比例相交换，就是因为它们都有价值。商品价值在质的规定性上是相同的，因而彼此可以比较。商品的价值实体是凝结在商品中的无差别的人类劳动，在本质上体现了生产者之间的一定社会关系。</p><p>价值是交换价值的基础，交换价值是价值的表现形式。</p><p>使用价值和价值之间的关系：对立统一的关系。</p><ul><li>其对立性表现在：商品的使用价值和价值是相互排斥的，二者<font color="#33a3dc">不可兼得</font>。</li><li>其统一性表现在：作为商品，使用价值和价值二者<font color="#33a3dc">缺一不可</font>。一种物品如果没有使用价值，即使人们为它付出了劳动，也没有价值；一种物品尽管具有使用价值，但如果不是劳动产品，也没有价值。</li></ul><p>（3）生产商品的劳动二重性</p><p>商品是劳动产品，生产商品的劳动可区分为具体劳动和抽象劳动。</p><ul><li>具体劳动的概念：具体劳动是指生产一定使用价值的具体形式的劳动，即有用劳动。</li><li>抽象劳动的概念：抽象劳动是指撇开一切具体形式的、无差别的一般人类劳动，即人的体力和脑力的消耗。</li></ul><p>劳动二重性决定了商品的二因素：具体劳动形成商品的使用价值，抽象劳动形成商品的价值实体。</p><p>具体劳动和抽象劳动的关系：具体劳动和抽象劳动是同一劳动的两种规定。任何一种劳动，一方面是特殊的具体劳动，另一方面又是一般的抽象劳动，这就是劳动的二重性，它决定了商品的二因素。具体劳动和抽象劳动也是对立统一的关系。</p><ul><li>一方面，具体劳动和抽象劳动在时间上和空间上是统一的，是商品生产者同一劳动过程的两个方面；</li><li>另一方面，具体劳动所反映的是人与自然的关系，它是劳动的<font color="#33a3dc">自然属性</font>，而抽象劳动所反映的是商品生产者之间的社会关系，它是劳动的<font color="#33a3dc">社会属性</font>。</li></ul><h4 id="考点-56-⭐-价值如何衡量"><a class="header-anchor" href="#考点-56-⭐-价值如何衡量"></a>考点 56 ⭐ 价值如何衡量</h4><p>（1）商品价值量的决定</p><p>商品的价值不仅有质的规定性，而且还有量的规定性。商品价值的质即实体是凝结在商品中的劳动。商品价值的量是由生产商品所耗费的劳动量决定的，而劳动量则是按劳动时间来计量的。</p><p>决定商品价值量的，不是生产商品的个别劳动时间，而是社会必要劳动时间。</p><p><font color="#faa755">社会必要劳动时间</font>是指在现有的社会正常生产条件下，在社会<font color="#33a3dc">平均</font>的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。</p><p>（2）商品价值量与劳动生产率的关系</p><p>生产商品所需要的社会必要劳动时间随着劳动生产率的变化而变化。商品的价值量与生产商品所耗费的劳动时间成正比，与劳动生产率成反比。<font color="#faa755">劳动生产率</font>指的是劳动者生产使用价值的能力，它的高低可以用单位劳动时间内生产的产品数量来测量，也可以用单位产品中所耗费的劳动时间来测量。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.dj7rtefzqug.png" alt="image"></p><p>影响劳动生产率的因素主要包括：劳动者的平均熟练程度，科学技术的发展程度及其在生产中的应用，生产过程的社会结合，生产资料的规模和效能以及自然条件。</p><p>（3）简单劳动与复杂劳动</p><p>商品的价值量同简单劳动和复杂劳动密切相关。</p><ul><li>简单劳动是指不需要经过专门训练和培养的一般劳动者都能从事的劳动；</li><li>复杂劳动是指需要经过专门训练和培养，具有一定文化知识和技术专长的劳动者所从事的劳动。</li></ul><p>商品价值量是以简单劳动为尺度计量的，复杂劳动等于自乘（市场自发形成）的或多倍的简单劳动。复杂劳动转化为简单劳动，是在商品交换过程中自发实现的。</p><h4 id="考点-57-⭐-价值如何表现"><a class="header-anchor" href="#考点-57-⭐-价值如何表现"></a>考点 57 ⭐ 价值如何表现</h4><p>商品的价值形式的发展经历了四个阶段：简单的或偶然的价值形式、总和的或扩大的价值形式、一般的价值形式以及货币形式。</p><p>货币的概念：商品的交换是以货币为媒介的，货币是在长期交换过程中形成的固定地充当一般等价物的<font color="#33a3dc">商品</font>。（金银天然不是货币，货币天然是金银）</p><p>货币的五种基本职能：价值尺度、流通手段、贮藏手段、支付手段和世界货币。其中，价值尺度和流通手段是货币的两个最基本的职能。</p><p>货币产生后整个商品世界的变化：分化为两极。一极是各种各样的具体商品，它们分别代表不同的使用价值；另一极是货币，它们只代表商品的价值。这样，商品内在的使用价值和价值的矛盾就发展成为外在的商品和货币的矛盾。货币的出现，有利于解决商品交换的困难，促进了商品经济的发展。但是，货币的出现并没有也不可能解决商品经济的基本矛盾，反而使矛盾更加扩大和加深了。所以，马克思把商品转换成货币，称为“商品的惊险的跳跃”，“这 个跳跃如果不成功，摔坏的不是商品，但一定是商品占有者”。</p><h4 id="考点-58-⭐-价值有何规律"><a class="header-anchor" href="#考点-58-⭐-价值有何规律"></a>考点 58 ⭐ 价值有何规律</h4><p>价值规律是商品经济的基本经济规律，其<font color="#faa755">基本内容</font>和客观要求：商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行。</p><p>价值规律的<font color="#faa755">表现形式</font>：商品的价格围绕价值自发波动。价格是商品价值的货币表现。由于供求关系变动的影响，商品的价格总是时而高于价值，时而低于价值，不停地围绕价值这个中心上下波动。从较长时间来看，价格高于价值的部分和价格低于价值的部分能够相抵，商品的平均价格和价值是一致的。</p><p>价值规律的积极作用：</p><ul><li>第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例；</li><li>第二，自发地刺激社会生产力的发展；</li><li>第三，自发地调节社会收入分配。</li></ul><p>价值规律的消极作用：</p><ul><li>第一，导致社会资源浪费；</li><li>第二，导致收入两极分化；</li><li>第三，阻碍技术的进步。</li></ul><h4 id="考点-59-⭐-私有制基础上商品经济的基本矛盾"><a class="header-anchor" href="#考点-59-⭐-私有制基础上商品经济的基本矛盾"></a>考点 59 ⭐ 私有制基础上商品经济的基本矛盾</h4><p>商品生产者的劳动的社会性质是由社会分工决定的，在社会分工的条件下，每个商品生产者在社会分工体系中从事的是某一一种商品生产，他们的劳动都是社会总劳动的一部分，是具有社会性质的社会劳动。由于生产资料私有制的存在，每个商品生产者的劳动又是按照自己的利益和要求进行的，是具有私人性质的私人劳动。</p><p><font color="#faa755">私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾</font>。</p><ul><li>首先，私人劳动和社会劳动的矛盾决定着商品经济的本质及其发展过程；</li><li>其次，私人劳动和社会劳动的矛盾是商品经济其他一切矛盾的基础；</li><li>最后，私人劳动和社会劳动的矛盾决定着商品生产者的命运。</li></ul><p>私有制商品经济条件下私人劳动与社会劳动之间的矛盾及其运动，使商品生产者认为商品、价值乃至货币似乎具有一种超自然的神秘性，商品生产者听凭商品、价值、货币运动的摆布，人们之间一定的社会关系在人们面前采取了物与物的关系的虚幻形式，马克思称之为商品拜物教。私有制商品经济条件下商品世界的拜物教性质的产生具有必然性。其一，私有制商品经济条件下劳动产品只有采取商品的形式才能进行交换，人类劳动的等同性只有采取了同质的价值形式才能在交换中体现出来。其二，劳动量只有采取价值量这一物的形式才能进行计算和比较。其三，生产者的劳动关系的社会性质只有采取了商品之间即物与物之间相交换的形式才能间接地表现出来，这就使人们之间一定的社会关系被物与物的关系所掩盖，具有了拜物教性质。商品世界的拜物教性质掩盖了商品经济关系的本质，妨碍人们透过物的外表认识商品、价值以及货币的实质。</p><p>私人劳动和社会劳动之间的矛盾在资本主义制度下，进一步发展成资本主义的基本矛盾，即生产资料的资本主义私人占有和生产社会化之间的矛盾，正是这一矛盾的不断运动，才使资本主义制度最终被社会主义制度所代替具有了客观必然性。</p><h4 id="考点-60-⭐-马克思劳动价值论的意义"><a class="header-anchor" href="#考点-60-⭐-马克思劳动价值论的意义"></a>考点 60 ⭐ 马克思劳动价值论的意义</h4><p>（1）马克思劳动价值论的理论和实践意义</p><p>第一，马克思劳动价值论扬弃了英国古典政治经济学的观点，为剩余价值理论的创立奠定了基础。马克思在<font color="#33a3dc">继承</font>古典政治经济学劳动创造价值理论的同时，<font color="#33a3dc">创立</font>了劳动二重性理论，第一次确定了什么劳动形成价值、为什么形成价值以及怎样形成价值，阐明了具体劳动和抽象劳动在商品价值形成中的不同作用，从而为揭示剩余价值的真正来源、创立剩余价值理论奠定了基础。此外，马克思的资本有机构成理论、资本积累理论、社会资本再生产理论等政治经济学的一系列重 要理论的创立，也同劳动二重性学说有关。因此，劳动二重性理论成为理解政治经济学的枢纽。第二，马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。这对我们科学认识商品经济的本质，正确理解商品经济的运动规律及影响，清除商品拜物教和货币拜物教观念，具有十分重要的理论意义和现实意义。第三，马克思劳动价值论揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义。在发展社会主义市场经济的过程中，马克思在劳动价值论中所揭示的关于商品生产和商品交换的- -般理论， 对于我国深化经济体制改革、完善社会主义市场经济体制，实现社会主义现代化建设的宏伟目标，具有重要的现实指导意义。</p><p>（2）深化对马克思劳动价值论的认识</p><p>人类进入了 21 世纪，与马克思所处的时代相比，社会经济条件发生了很大的变化，因此，必须深化对马克思劳动价值论的认识：</p><ul><li>第一，深化对创造价值的劳动的认识，对生产性劳动作出新的界定。</li><li>第二，深化对科技人员、经营管理人员在社会生产和价值创造中所起的作用的认识。</li><li>第三，深化对科技、知识、信息等新的生产要素在财富和价值创造中的作用的认识。</li><li>第四，深化对价值创造与价值分配关系的认识。</li></ul><h3 id="第二节-资本主义经济制度的本质"><a class="header-anchor" href="#第二节-资本主义经济制度的本质"></a>第二节 资本主义经济制度的本质</h3><h4 id="考点-61-⭐-劳动力成为商品与货币转化为资本"><a class="header-anchor" href="#考点-61-⭐-劳动力成为商品与货币转化为资本"></a>考点 61 ⭐ 劳动力成为商品与货币转化为资本</h4><p>（1）劳动力成为商品的基本条件</p><p><font color="#faa755">劳动力</font>的概念：劳动力是指人的劳动能力，是人的体力和脑力的总和。劳动力的使用即劳动。</p><p>劳动力成为商品，要具备两个基本条件：</p><ul><li>第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；</li><li>第二，劳动者没有别的商品可以出卖，“自由”得一无所有，没有任何实现自己的劳动力价值所必需的物质条件。</li></ul><p>劳动力成为商品，标志着简单商品生产发展到资本主义商品生产的新阶段。在这一阶段，资本家与工人的关系，形式上是“自由”“平等”的关系，而实质上是资本主义雇佣劳动关系。</p><p>（2）劳动力商品的特点与货币转化为资本</p><p>像其他任何商品一样，劳动力商品也具有使用价值和价值。</p><p><font color="#faa755">劳动力商品的价值</font>：是由生产、发展、维持和延续劳动力所必需的生活必需品的价值决定的。它包括三个部分：</p><ul><li>维持劳动者本人生存所必需的生活资料的价值；</li><li>维持劳动者家属的生存所必需的生活资料的价值；</li><li>劳动者接受教育和训练所支出的费用。</li></ul><p>劳动力价值的构成包含一个历史的和道德的因素，在不同的国家或同一国家的不同历史时期，劳动者所必需的生活资料的数量和构成也是有区别的。</p><p><font color="#faa755">劳动力商品的使用价值</font>：劳动力商品在使用价值上有一个很大的特点，就是它的使用价值是价值的源泉，它在消费过程中能够创造新价值，而且这个新的价值比劳动力本身的价值更大。货币所有者购买到这种特殊商品，能够获得剩余价值，货币也就转化为资本。在资本主义条件下，资本家购买的是雇佣工人的劳动力而不是劳动。</p><h4 id="考点-62-资本主义所有制"><a class="header-anchor" href="#考点-62-资本主义所有制"></a>考点 62 资本主义所有制</h4><p>（1）所有制和所有权</p><p>经济意义上的所有制，是指事实上生产资料归谁所有、归谁支配，并凭借这种所有和支配实现生产和获得剩余产品（利润或超额利润）。法律意义上的所有制，是由占有生产资料的法律原则决定的。所有制关系上升到法的关系的高度，所有制的现实经济形态就具有了法律形态，即所有权范畴。所有权是一-种排他性的权利，它强制地规定了人们在经济生活中对占有物行使权利的界限，直接影响到现实经济生活中生产资料的实际利用及其与劳动者的关系。所有制与所有权既有区别也有联系。所有制是所有权的基础，所有权是所有制的法律形态，它反映着经济关系的意志关系，这种意志关系的性质在根本上是由经济关系本身决定的。</p><p>（2）资本主义所有制的本质</p><p>在资本主义社会，生产资料和货币采取了资本的形式，生产资料的所有者成为资本人格化的资本家，资本家与劳动者之间的关系是资本雇佣劳动的关系。资本家凭借对生产资料的占有，在等价交换原则的掩盖下，雇佣工人从事劳动，占有雇佣工人的剩余价值，这就是资本主义所有制的实质。</p><h4 id="考点-63-⭐-剩余价值的生产"><a class="header-anchor" href="#考点-63-⭐-剩余价值的生产"></a>考点 63 ⭐ 剩余价值的生产</h4><p>（1）资本主义生产过程的两重性及其特点</p><p>资本主义生产过程具有两重性：</p><ul><li>一方面是物质资料的生产过程；</li><li>另一方面是剩余价值的生产过程，即价值增殖过程。</li></ul><p>资本主义生产过程是<font color="#33a3dc">劳动过程</font>和<font color="#33a3dc">价值增殖</font>过程的统一。</p><p>资本主义劳动过程是生产使用价值的过程。由于资本主义劳动过程的要素都被资本家所占有，由此决定了资本主义劳动过程的两个特点：</p><ul><li>其一，工人在资本家的监督下劳动，他们的劳动隶属于资本家；</li><li>其二，劳动成果或劳动产品全部归资本家所有。</li></ul><p>价值增殖过程是剩余价值的生产过程，这是资本主义生产过程的主要方面。所谓价值增殖过程，是超过劳动力价值的补偿这个-定点而延长了的价值形成过程。资本家购买的劳动力，在生产过程中创造了超过补偿劳动力的价值，从而形成了剩余价值，这是价值形成过程转变为价值增殖过程的关键。</p><p>（2）剩余价值的实质</p><p>在价值增殖过程中，雇佣工人的劳动分为两部分：</p><ul><li>一部分是必要劳动，用于再生产劳动力的价值；</li><li>另一部分是剩余劳动，用于无偿地为资本家生产剩余价值。</li></ul><p>因此，剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值，它是雇佣工人剩余劳动的凝结，体现了资本家与雇佣工人之间剥削与被剥削的关系。</p><p>（3）资本的本质</p><p>资本是可以带来剩余价值的价值。剩余价值是由雇佣工人的剩余劳动创造的。在资本主义社会里，资本总是通过各种物品表现出来，但资本的本质不是物，而是一定的历史社会形态下的生产关系。</p><p>（4）不变资本和可变资本的区分及其意义、剩余价值率</p><p>根据资本在剩余价值生产过程中的作用不同，资本可以区分为不变资本和可变资本。</p><p>不变资本是以生产资料形态存在的资本，它通过工人的具体劳动转移到新产品中去，其价值量不会大于它原有的价值量。以生产资料形式存在的资本，在生产过程中只转移自己的物质形态而不改变自己的价值量，不发生增殖，所以马克思把这一部分资本叫作不变资本（c）。</p><p>可变资本是用来购买劳动力的那部分资本，在生产过程中不是被转移到新产品中去，而是由工人的劳动再生产出来。在再生产过程中，工人 所创造的新价值，不仅包括相当于劳动力价值的价值，而且还包括一定量的剩余价值。 由于这部分资本价值不是不变的，而是一个可变的量，所以马克思把这部分资本叫作可变资本（v）。</p><p>把资本区分为不变资本和可变资本，进一步揭示了剩余价值产生的源泉。它表明，雇佣劳动者的剩余劳动是剩余价值产生的唯一源泉。 剩余价值既不是由全部资本创造的，也不是由不变资本创造的，而是由可变资本创造的。这种划分为确定资本家对雇佣劳动者的剥削程度提供了科学依据。资本家对工人的剥削程度，可以用剩余价值率表示：m’ = m / v。 剩余价值率还可以表示为：m’ = 剩余劳动 / 必要劳动 = 剩余劳动时间 / 必要劳动时间。</p><p>（5）绝对剩余价值、相对剩余价值和超额剩余价值</p><p>资本家提高对工人的剥削程度的方法是多种多样的，最基本的方法有两种，即绝对剩余价值的生产和相对剩余价值的生产。</p><p><font color="#faa755">绝对剩余价值</font>是指在必要劳动时间不变的条件下，由于延长工作日的长度而生产的剩余价值。在必要劳动时间既定的条件下，工作日越长，剩余劳动时间越长，剩余价值率越高。除了延长劳动时间外，资本家还用提高工人劳动强度的方法来增加剩余价值。提高劳动强度，是让工人在同样的时间内消耗更多的体力和脑力,这与延长工作日并没有本质区别。</p><p>在资本主义发展初期，由于生产技术以手工劳动为基础，资本主义增加生产主要靠增加劳动量来实现，因此延长工作日就成为资本家提高剥削程度的基本方法。</p><p><font color="#faa755">相对剩余价值</font>是指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。缩短必要劳动时间是通过提高全社会的劳动生产率实现的。由于社会劳动生产率的提高，降低了劳动力的价值，从而缩短了必要劳动时间，相对延长了剩余劳动时间。全社会劳动生产率的提高是资本家追逐超额剩余价值的结果。</p><p><font color="#faa755">超额剩余价值</font>是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额。在资本主义商品生产的条件下，每个资本家总是力图不断改进技术，改善经营管理，提高劳动生产率，使其生产的商品个别价值低于社会价值，从而获得超额剩余价值。这个过程的客观后果则是整个社会各个生产部门的劳动生产率普遍提高，导致生活资料的价值下降和补偿劳动力价值的必要劳动时间缩短，剩余劳动时间延长，整个资本家阶级普遍获得相对剩余价值。随着生产技术条件的不断改善和工人阶级反抗资本家延长工作日的斗争力量的增强，<font color="#33a3dc">相对剩余价值生产的作用日益突出了</font>。（超额是原因，相对是结果）</p><p>（6）生产自动化条件下剩余价值的源泉</p><p>资本主义条件下的生产自动化是资本家获取超额剩余价值的手段，而雇佣工人的剩余劳动仍然是这种剩余价值的唯一源泉。</p><h4 id="考点-64-⭐-资本的积累"><a class="header-anchor" href="#考点-64-⭐-资本的积累"></a>考点 64 ⭐ 资本的积累</h4><p>把剩余价值转化为资本，或者说剩余价值的资本化，就是资本积累。马克思关于资本积累的学说是剩余价值理论的重要组成部分，它揭露了资本主义制度下贫富两极分化的原因，揭示了资本主义失业现象的本质，深刻地阐明了资本主义制度必然灭亡的历史命运。</p><p>（1）资本主义简单再生产和扩大再生产</p><p>资本家获得剩余价值后，如果将其全部用于消费，则生产就在原有规模的基础上重复进行，这叫资本主义简单再生产。它不仅生产商品，生产剩余价值，而且还生产和再生产资本关系本身：一方面是资本家；另一方面是雇佣工人。因此，资本主义简单再生产是物质资料再生产和资本主义生产关系再生产的统一。</p><p>资本主义再生产的特点是扩大再生产。资本家将获得剩余价值的一部分转化为资本，使生产在扩大规模上重复进行，这就是资本主义的扩大再生产。在这里，<font color="#33a3dc">资本积累是资本主义扩大再生产的源泉</font>。</p><p>（2）资本积累的本质、源泉和后果</p><p>资本积累的本质，就是资本家不断利用无偿占有的工人创造的剩余价值，来扩大自己的资本规模，进一步扩大和加强对工人的剥削和统治。</p><p><font color="#33a3dc">资本积累的源泉是剩余价值</font>，资本积累规模的大小取决于对工人的剥削程度、劳动生产率的高低、所用资本和所费资本之间的差额，以及资本家垫付资本的大小。</p><p>随着资本积累和生产规模的扩大，必然加剧社会的两极分化，即一极是财富越来越集中于少数人手中，另一极是多数人只拥有社会财富的较小部分。资本积累不但是社会财富占有两极分化的重要原因，而且是资本主义社会失业现象产生的根源。</p><p>（3）资本有机构成</p><p>随着资本积累而产生的失业是由资本主义追逐剩余价值引起资本有机构成的提高所导致的。资本家投人到生产过程中的资本，从自然形式上看，总是由一定数量的生产资料和劳动力构成的。</p><ul><li>生产资料和劳动力之间，存在一定的比例，这种由生产的技术水平所决定的生产资料和劳动力之间的比例，叫作资本的技术构成。</li><li>从价值形式上看，资本可分为不变资本和可变资本，这两部分资本价值之间的比例，叫作资本的价值构成。</li></ul><p>一般说来，资本的技术构成决定资本的价值构成，技术构成的变化往往会引起价值构成的相应变化，而价值构成的变化通常反映技术构成的变化。这种由资本技术构成决定并反映技术构成变化的资本价值构成，叫作资本的有机构成，通常用 c:v 来表示。</p><p>（4）相对过剩人口</p><p>在资本主义生产过程中，资本有机构成呈现不断提高的趋势，这是由资本无限追逐剩余价值的本性决定的。资本家通过资本积聚和资本集中扩大生产规模，使资本有机构成不断提高。资本有机构成提高，可变资本相对量减少，资本对劳动力的需求日益相对地减少，结果就不可避免地造成大批工人失业，形成相对过剩人口。相对过剩人口就是劳动力供给超过了资本对它的需求形成的过剩人口。相对过剩人口有三种形式：流动的过剩人口、潜在的过剩人口、停滞的过剩人口。经常性的庞大失业人口的存在，是资本主义的痼疾。</p><p>（5）资本积累的历史趋势</p><p>资本积累的历史趋势是资本主义制度的必然灭亡和社会主义制度的必然胜利。随着资本积累的增长，一方面，资本主义生产愈来愈具有社会性；另一方面， 资本愈来愈集中于少数资本家手中，生产完全服从于资本家追逐剩余价值的目的。这就使生产的社会性和资本主义的私人占有形式之间产生了深刻的矛盾。随着资本积累的不断增长，这一矛盾日益加剧，这是资本主义被新的、更能够适应社会化大生产要求的社会形态所取代的根本原因。</p><h4 id="考点-65-⭐-资本的循环周转与再生产"><a class="header-anchor" href="#考点-65-⭐-资本的循环周转与再生产"></a>考点 65 ⭐ 资本的循环周转与再生产</h4><p>（1）资本循环及其职能形式</p><p>资本作为一种自行增殖的价值，不仅在生产过程内运动，而且也在流通过程内运动。马克思在分析资本主义流通过程时，首先详尽地分析了个别资本的运动，即资本的循环和周转过程，揭示了资本循环周转的规律。</p><p>资本循环是资本从一种形式出发，经过一系列形式的变化，又回到原来出发点的运动。产业资本在循环过程中要经历三个不同阶段，与此相联系的是资本依次执行三种不同职能：</p><ul><li>第一个阶段是购买阶段，产业资本执行的是<font color="#33a3dc">货币资本</font>的职能；</li><li>第二个阶段是生产阶段，产业资本执行的是<font color="#33a3dc">生产资本</font>的职能；</li><li>第三个阶段是售卖阶段，产业资本执行的是<font color="#33a3dc">商品资本</font>的职能。</li></ul><p>产业资本运动的两个基本前提条件：</p><ul><li>一是产业资本的三种职能形式必须在空间上并存，也就是说，产业资本必须按照一定比例并存于货币资本、生产资本和商品资本三种形式中。</li><li>二是产业资本的三种职能形式必须在时间上继起，也就是说，产业资本循环的三种职能必须保持时间上的依次连续性。</li></ul><p>产业资本的连续循环是流通过程和生产过程的统一，也是它的三种循环形式的统一。</p><p>（2）资本周转及其速度</p><p>资本是在运动中增殖的，资本周而复始、不断反复的循环，就叫资本的周转。如果每次资本周转带来的剩余价值一定， 则资本周转越快，在一定时期内带来的剩余价值就越多。影响资本周转快慢的因素有很多，其中关键的因素有两个：</p><ul><li>一是资本周转时间；</li><li>二是生产资本中固定资本和流动资本的构成。</li></ul><p>要加快资本周转速度，获得更多剩余价值，就要缩短资本周转时间，加快流动资本的周转速度。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.ma06wov9m00.png" alt="image"></p><p>（3）社会再生产的核心问题及实现条件</p><p>在对个别资本的再生产和流通的规律进行分析的基础上，马克思对社会总资本的再生产和流通也进行了深入分析，进一步揭示了资本主义经济所包含的对抗性矛盾。</p><p>社会生产是连续进行的，这种连续不断重复的生产就是再生产。<font color="#faa755">社会再生产的核心问题</font>是社会总产品的实现问题，即社会总产品的<font color="#33a3dc">价值补偿</font>和<font color="#33a3dc">实物补偿</font>问题。</p><p>马克思分析社会再生产问题的两个理论前提条件：</p><ul><li>第一，社会总产品在价值形态上又叫社会总价值，包括在产品中的生产资料的转移价值（c）、凝结在产品中的工人必要劳动创造的价值（v）和凝结在产品中的由工人在剩余劳动时间里创造的价值（m）。</li><li>第二，社会总产品在物质形态上划分为两大部类即第 Ⅰ 部类和第 Ⅱ 部类，第 Ⅰ 部类由生产生产资料的部门构成，第 Ⅱ 部类由生产消费资料的部门构成。</li></ul><p>社会再生产顺利进行的条件：社会再生产的顺利进行，要求生产中所耗费的资本在价值上得到补偿，同时要求实际生产过程中所耗费的生产资料和消费资料得到实物的替换，这在客观上就要求两大部类内部各个产业部门之间和两大部类之间保持一定的比例关系。生产资料的生产，既要满足两大部类对消耗掉的生产资料的补偿，也要保证两大部类扩大生产规模后对追加生产资料的需求。消费资料的生产则既要满足两大部类劳动者的个人消费和社会消费，也要满足扩大生产规模后对追加消费资料的需求。只有两大部类的生产不仅在规模上，而且在结构，上保持一定比例， 社会总产品的价值补偿和实物替换才能正常实现，社会再生产才能顺利进行。</p><p>在资本主义发展的相当长时期内，由生产资料的私有制和雇佣劳动制度所决定，两大部类的生产都是在价值规律和剩余价值规律作用下自发进行的，具有严重的盲目性，这就导致了两大部类生产在规模上和结构上经常处于失衡状态，最严重的就是引发经济危机。经济危机的发生，实际上是资本主义条件下以强制的方式解决社会再生产的实现问题的途径。这种强制性地恢复平衡，是以社会经济生活的严重混乱以及社会资源和财富的极大浪费为代价的。</p><h4 id="考点-66-⭐-工资与剩余价值的分配"><a class="header-anchor" href="#考点-66-⭐-工资与剩余价值的分配"></a>考点 66 ⭐ 工资与剩余价值的分配</h4><p>（1）资本主义工资的本质和形式</p><p>在资本主义制度下，工人工资是劳动力的价值或价格，这是资本主义工资的本质。资本家购买工人的劳动力是以货币工资形式支付的，工资表现为“劳动的价格”或工人全部劳动的报酬，这就模糊了工人必要劳动和剩余劳动的界限，掩盖了资本主义剥削关系。</p><p>工资的形式主要有两种：计时工资和计件工资。此外还有各种形式的血汗工资制度，如 19 世纪末 20 世纪初流行的“泰罗制”和“福特制”。</p><p>（2）利润和平均利润</p><p>利润的本质：在现实的资本主义经济生活中，资本家并不把剩余价值看作可变资本的产物，而是把它看作全部垫付资本的产物或增加额，剩余价值便取得了利润的形态。剩余价值是利润的本质，利润是剩余价值的转化形式。当剩余价值转化为利润时,剩余价值和可变资本的关系便被掩盖了。</p><p>平均利润与生产价格的形成：资本主义生产是为了获得利润，因此，不同部门之间如果利润率不同，资本家之间就会展开激烈的竞争，使资本从利润率低的部门转向利润率高的部门，从而导致利润率趋于平均化，不同部门的资本家按照等量资本获得等量利润的原则来瓜分剩余价值。按照平均利润率来计算和获得的利润，叫作平均利润。随着利润转化为平均利润，商品价值就转化为生产价格，即商品的成本价格加平均利润。</p><p>生产价格的计算方法：生产价格是商品价值的转化形式，是生产成本（即 c + v ）与平均利润之和。生产成本是由生产中实际耗费的不变资本和可变资本构成的。</p><p>生产价格形成以后，价值规律表现形式的变化：在价值转化为生产价格的条件下，价值规律作用的形式发生了变化。商品不再以价值而是以生产价格为基础进行交换，市场价格的变动不再以价值为中心，而是以生产价格为中心。生产价格是价值的转化形式，商品按照生产价格而不是价值进行出售并不违背价值规律，而是价值规律实现形式发生了变化。</p><p>在利润率平均化过程中，产业资本家获得产业利润，商业资本家获得商业利润，银行资本家获得银行利润，农业资本家获得农业利润。利润平均化规律，反映了在瓜分剩余价值上，资本家之间存在竞争和矛盾，但在加强对工人阶级的剥削以榨取更大量的剩余价值这一点上，资本家之间有着共同的阶级利益。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.qbxfype6140.png" alt="image"></p><h4 id="考点-67-马克思剩余价值理论的意义"><a class="header-anchor" href="#考点-67-马克思剩余价值理论的意义"></a>考点 67 马克思剩余价值理论的意义</h4><p>马克思通过分析剩余价值的生产、积累、流通以及分配，揭示了剩余价值的运动规律，<font color="#33a3dc">创立了剩余价值理论</font>。剩余价值理论深刻<font color="#33a3dc">揭露了</font>资本主义生产关系的剥削本质，<font color="#33a3dc">阐明了</font>资产阶级与无产阶级之间阶级斗争的经济根源，指出了无产阶级革命的历史必然性。剩余价值理论是马克思主义经济理论的基石，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的锐利武器。由于唯物史观和剩余价值的发现，社会主义由空想变为科学。</p><p>马克思在分析剩余价值的生产、积累、流通以及分配过程，揭示资本主义经济特殊规律的同时，也揭示了商品经济和社会化生产的一般规律。例如，资本循环周转规律、社会再生产规律、积累规律等。如果撇开资本主义制度因素，这些规律对发展社会主义市场经济也具有指导意义。</p><h4 id="考点-68-⭐-资本主义的基本矛盾与经济危机"><a class="header-anchor" href="#考点-68-⭐-资本主义的基本矛盾与经济危机"></a>考点 68 ⭐ 资本主义的基本矛盾与经济危机</h4><p>（1）资本主义基本矛盾及其尖锐化</p><p>生产资料资本主义私人占有和生产社会化之间的矛盾，是资本主义的基本矛盾。这是生产力和生产关系之间的矛盾在资本主义社会的具体体现。资本主义越发展，科学技术以至社会生产力越发展，生产社会化的程度越高，不断发展的社会生产力就越成为资本的生产力，资本就越来越集中在少数资本家手里，资本主义基本矛盾尖锐化就越不可避免。</p><p>（2）资本主义经济危机的实质、根源、具体表现和周期性</p><p><font color="#faa755">生产相对过剩是资本主义经济危机的本质特征</font>。相对过剩是指相对于劳动人民有支付能力的需求来说社会生产的商品显得过剩，而不是与劳动人民的实际需求相比的绝对过剩。</p><p><font color="#faa755">经济危机的可能性是由货币作为支付手段和流通手段引起的</font>。但是这仅仅是危机的形式上的可能性。资本主义经济危机爆发的<font color="#faa755">根本原因</font>是资本主义的基本矛盾，这种基本矛盾具体表现为两个方面：</p><ul><li>第一，表现为生产无限扩大的趋势与劳动人民有支付能力的需求相对缩小的矛盾；</li><li>第二，表现为个别企业内部生产的有组织性和整个社会生产的无政府状态之间的矛盾。</li></ul><p>资本主义经济危机的周期性爆发的特点，使社会资本再生产也呈现出周期性特点，一般包括四个阶段：危机、萧条、复苏和高涨。</p><h3 id="第三节-资本主义政治制度和意识形态"><a class="header-anchor" href="#第三节-资本主义政治制度和意识形态"></a>第三节 资本主义政治制度和意识形态</h3><h4 id="考点-69-⭐-资本主义的国家、民主制度及其本质"><a class="header-anchor" href="#考点-69-⭐-资本主义的国家、民主制度及其本质"></a>考点 69 ⭐ 资本主义的国家、民主制度及其本质</h4><p>（1）资本主义国家的职能和本质</p><p>资本主义国家的职能是以服务于资本主义制度和资产阶级利益为根本内容的，是资产阶级进行政治统治的工具。资本主义国家的职能包括对内和对外两个基本方面，即对内实行政治统治和社会管理，对外进行国际交往和维护国家安全及利益。</p><p>资本主义国家作为资产阶级利益的体现，在经济上要求自由竞争、等价交换，政治上要求形式上的自由民主、正义平等，这些特征与奴隶制和封建制国家相比，是人类社会政治生活上的一大进步。但是，这种进步并没有改变资本主义国家作为剥削阶级对人民群众进行阶级统治和阶级压迫的工具的性质，并没有消除人们在政治生活方面实际上的不自由、不平等、不民主、不公正。资本主义国家只是以一种新的阶级剥削和压迫形式取代了以往旧的阶级剥削和压迫形式而已。</p><p>（2）资本主义的民主制度及其本质</p><p>资本主义政治制度包括资本主义的民主与法制、政权组织形式、选举制度、政党制度等。</p><p>资本主义民主制度是与资本主义生产方式相适应而发展起来的。资产阶级在反对封建专制主义的斗争中提出了符合自身利益和要求的“主权在民”“天赋人权”“分权制衡”“社会契约”“自由、平等、博爱”等政治思想。</p><p>资本主义法制是资本主义民主制度的重要内容。宪法是资本主义国家法律制度的核心，它所依据的基本原则有：私有制原则、“主权在民”原则、分权与制衡原则和人权原则。</p><p>资本主义国家政权采取的是分权制衡的组织形式，即国家的立法权、行政权、司法权分别由三个权力主体独立行使，形成各主体之间的“制衡”。</p><p>资本主义国家的选举制度是资产阶级制定某种原则和程序，通过竞选产生议会和国家元首的一种政治机制。从形式上看，竞选制度是公民参与国家事务的重要形式。从实际政治作用上看，选举制是协调统治阶级内部利益关系和矛盾的重要措施。</p><p>政党是特定阶级利益的集中代表，是代表一定阶级、阶层或集团的根本利益，为达到政治目的，特别是为了取得政权和保持政权而建立的一种政治组织。资本主义国家的政党是阶级和阶级斗争发展到一定历史阶段的产物，在国家政治生活中发挥着重要的作用。当代资本主义国家基本上实行的是政党制度。从政党制度的类型看，大致有两党制和多党制等形式。</p><p>（3）资本主义政治制度的进步性和局限性</p><p>资本主义政治制度的形成和发展在人类社会历史的发展进程中曾经起过重要的进步作用。但是，由于资本主义政治制度本质上是资产阶级进行政治统治和社会管理的手段和方式，是为资产阶级专政服务的，因此不可避免地有其历史的和阶级的局限性。</p><ul><li>其一，资本主义的民主是金钱操纵下的民主，实际是资产阶级精英统治下的民主。资本主义政治制度中的选举事实上是<br>有钱人的游戏，是资本玩弄民意的过程。</li><li>其二，法律名义上的平等掩盖着事实上的不平等。由于资本主义社会是建立在私有制和资本特权的基础上的，资本家和劳动者之间、富人与穷人之间存在着事实上严重的不平等，资本主义法律的实质是将这种不平等合法化。</li><li>其三，资本主义国家的政党制是一种维护资产阶级统治的政治制度，其多党制则是资产阶级选择自己的国家管理者，实现其内部利益平衡的政治机制。</li><li>其四，政党恶斗相互掣肘，决策效率低下，激化社会矛盾。</li></ul><h4 id="考点-70-资本主义的意识形态及其本质"><a class="header-anchor" href="#考点-70-资本主义的意识形态及其本质"></a>考点 70 资本主义的意识形态及其本质</h4><p>（1）资本主义意识形态的形成及其本质</p><p>作为资本主义国家意识形态的各种资产阶级的思想理论和观念，是资产阶级在长期的反对封建专制主义和宗教神学的斗争中逐步形成和发展起来的。这些思想理论和观念后来成为资本主义的意识形态，则是在资本主义国家产生之后由统治阶级根据自己政治统治的需要，在以往形成的资产阶级思想理论和观念的基础上自觉地建立起来的，成为资产阶级国家上层建筑的组成部分。</p><p>资本主义国家意识形态的本质，可以概括为两个方面：</p><ul><li>第一， 资本主义意识形态是资本主义社会条件下的观念上层建筑，是为资本主义社会形态的经济基础服务的；</li><li>第二，资本主义意识形态是资产阶级的阶级意识的集中体现。</li></ul><p>（2）辩证地分析资本主义意识形态</p><p>对于资本主义的意识形态，应该用辩证的观点来分析。对于资本主义意识形态中那些正确反映人类社会生活的一般规律的思想理论和观念，我们应该加以学习、参考和借鉴；而其中反映资产阶级利益和要求的、对社会生活进行了扭曲反映的、为了维护资产阶级政治统治需要而有意编造出来欺骗民众的虚假理论，则必须加以分析、鉴别和批判。</p><h2 id="第六章-资本主义的发展及趋势"><a class="header-anchor" href="#第六章-资本主义的发展及趋势"></a>第六章 资本主义的发展及趋势</h2><h3 id="第一节-垄断资本主义的形成与发展"><a class="header-anchor" href="#第一节-垄断资本主义的形成与发展"></a>第一节 垄断资本主义的形成与发展</h3><h4 id="考点-71-⭐-资本主义从自由竞争到垄断"><a class="header-anchor" href="#考点-71-⭐-资本主义从自由竞争到垄断"></a>考点 71 ⭐ 资本主义从自由竞争到垄断</h4><p>（1）资本主义发展的两个阶段</p><p>资本主义的发展经历了自由竞争资本主义和垄断资本主义两个阶段。</p><p>垄断资本主义的发展包括私人垄断资本主义和国家垄断资本主义两种形式。</p><p>（2）生产集中与资本集中</p><p><font color="#faa755">生产集中</font>：是指生产资料、劳动力和商品的生产日益集中于少数大企业的过程，其结果是大企业在社会生产中所占的比重不断增加。</p><p><font color="#faa755">资本集中</font>：是指大资本吞并小资本，或由许多小资本合并而成大资本的过程，其结果是越来越多的资本为少数大资本所支配。</p><p>生产集中和资本集中是资本家追求剩余价值和自由竞争的结果，也是生产社会化和资本社会化的重要表现。</p><p>（3）垄断的形成、本质及垄断组织</p><p>垄断的概念：垄断是指少数资本主义大企业，为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵与控制。</p><p>垄断产生的原因：</p><ul><li>当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以<font color="#33a3dc">获得高额利润</font>；</li><li>激烈的竞争给竞争各方带来的损失越来越严重，为了<font color="#33a3dc">避免两败俱伤</font>，企业之间会达成妥协，联合起来，实行垄断；</li><li>企业规模巨大，<font color="#33a3dc">形成对竞争的限制</font>，也会产生垄断。</li></ul><p>垄断是通过一定的垄断组织形式实现的。垄断组织是指在一个经济部门或几个经济部门中，占据垄断地位的大企业联合。最简单的、初级的垄断组织形式是短期价格协定。常见的垄断组织有卡特尔、辛迪加、托拉斯和康采恩等。尽管垄断组织的形式多样，但它们在本质上是一样的，即通过联合实现独占和瓜分商品生产和销售市场，操纵垄断价格，以攫取高额垄断利润。</p><p>（4）垄断与竞争</p><p>垄断是从自由竞争中形成的，是作为自由竞争的对立面产生的，但是，垄断并不能消除竞争，反而使竞争变得更加复杂和剧烈。</p><p>垄断资本主义阶段存在竞争的主要原因：</p><ul><li>一是垄断没有消除产生竞争的经济条件。竞争是商品经济的一般规律，垄断产生后，没有消除以资本主义私有制为基础的商品经济。</li><li>二是垄断必须通过竞争来维持。各个垄断组织通过竞争发展起来，还需要不断增强自己的竞争实力，巩固自己的垄断地位。</li><li>三是社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产都包下来。在垄断条件下，在垄断组织内部、垄断组织之间、垄断组织同非垄断组织之间以及非垄断的中小企业之间存在着广泛而激烈的竞争。</li></ul><p>垄断条件下的竞争同自由竞争相比，具有一些新特点：</p><ul><li>在竞争的目的上，自由竞争主要是获得更多的利润或超额利润，不断扩大资本的积累。垄断条件下的竞争的主要目的是要获得高额垄断利润，巩固、扩大已有的垄断地位。</li><li>在竞争手段上，自由竞争主要运用经济手段，而垄断条件下竞争的手段更加多样，不仅采取经济手段还采取非经济手段，使竞争更加复杂、激烈。</li><li>在竞争范围上，自由竞争时期，竞争主要是在经济领域，而且主要在国内市场上进行，而在垄断时期，竞争的规模扩大，范围遍及各个领域和部门，并由国内扩展到国外。</li></ul><p>总之，垄断条件下的竞争，规模大、时间长、手段残酷、程度更加激烈，具有更大的破坏性。</p><p>（5）金融资本与金融寡头</p><p>金融资本及其形成途径：金融资本是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。金融资本形成的主要途径包括金融联系、资本参与和人事参与等。</p><p>金融寡头控制社会的方式：金融寡头是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。</p><p>金融寡头在经济中的统治，主要是通过“参与制”（金融寡头通过掌握一定数量的股票来层层控制企业的制度）来实现的。</p><p>金融寡头在政治上对国家机器的控制，主要是通过同政府的多种途径的“个人联合”（亲自担任或指派代理人担任政府要职）来实现的。</p><p>金融寡头还通过建立政策咨询机构等方式对政府的政策施加影响，并通过掌握新闻科教文化等上层建筑的各个领域来左右和影响国家的内政外交与社会生活。</p><p>（6）垄断利润和垄断价格</p><p>垄断利润的概念：垄断资本的实质在于获取垄断利润，垄断利润是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的超过平均利润的高额利润。</p><p>垄断利润的来源：垄断资本所获得的高额利润，归根到底来自无产阶级和其他劳动人民创造的剩余价值。具体来说，垄断利润的来源包括：对本国无产阶级和其他劳动人民剥削的加强；通过控制市场占有其他企业特别是非垄断企业的利润;通过加强对其他国家劳动人民的剥削和掠夺获取的国外利润;通过资本主义国家政权进行有利于垄断资本的再分配，从而将劳动人民<br>创造的国民收入的一部分变成垄断资本的收入。</p><p>垄断利润的实现：垄断利润主要是通过垄断组织制定的垄断价格来实现的。</p><p>垄断价格的计算方法：垄断价格是垄断组织在销售或购买商品时，凭借其垄断地位规定的、旨在保证获取最大限度利润的市场价格。其公式为：垄断价格 = 成本价格 + 平均利润 + 垄断利润。</p><p>垄断价格的两种形式：垄断价格包括垄断高价和垄断低价两种形式。</p><ul><li>垄断高价是指垄断组织出售商品时规定的高于生产价格的价格；</li><li>垄断低价是指垄断组织在购买非垄断企业所生产的原材料等生产资料时规定的低于生产价格的价格。</li></ul><p>垄断价格的产生并没有否定价值规律，它是价值规律在垄断资本主义阶段作用的具体表现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;⭐ 表示选择题考点，理解&lt;/li&gt;
&lt;li&gt;🌙 表示论述题考点&lt;/li&gt;
&lt;li&gt;没有标记表示一般考点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;导论&quot;&gt;&lt;a class=&quot;header-anchor&quot; hre</summary>
      
    
    
    
    <category term="考研政治" scheme="https://whl123456.top/categories/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>考研政治规划</title>
    <link href="https://whl123456.top/2021/07/08/%E6%94%BF%E6%B2%BB/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E8%A7%84%E5%88%92/"/>
    <id>https://whl123456.top/2021/07/08/%E6%94%BF%E6%B2%BB/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E8%A7%84%E5%88%92/</id>
    <published>2021-07-08T11:13:33.000Z</published>
    <updated>2021-07-26T03:04:44.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考研规划"><a class="header-anchor" href="#考研规划"></a>考研规划</h2><p>考研政治考什么</p><ul><li>马克思主义基本原理概论（24%）</li><li>毛泽东思想和中国特色社会体系概论（30%）</li><li>中国近代史纲要（14%）</li><li>思想道德修养和法律基础（16%）</li><li>当代世界政治与经济（16%）</li></ul><p>考研政治学习规划及课程安排：</p><ul><li>基础概念和逻辑，4 h，基础班（4 月前）</li><li>知识点完整学习，60 h，强化班（8 月底）《考研政治核心考案》</li><li>选择题刷题练习，20 h，刷题班 500 题（9 ～ 10 月）《优题库 习题集》</li><li>重点知识归纳，12 h，冲刺班（10 月）《冲刺背诵笔记》</li><li>时事政治归纳，3 ～ 4 h，时政班（11 月）《时政与当代》</li><li>考前模拟考试</li><li>考前预测押题，3 ～ 4 h，《考前预测必备 20 题》</li></ul><h2 id="马克思主义基本原理概论"><a class="header-anchor" href="#马克思主义基本原理概论"></a>马克思主义基本原理概论</h2><p>恩格斯《反杜林论》将马原分为以下三部分：</p><ul><li>马克思主义哲学（方法）</li><li>马克思主义政治经济学（主体）</li><li>科学社会主义理论（目的和归宿）</li></ul><h3 id="马克思主义哲学"><a class="header-anchor" href="#马克思主义哲学"></a>马克思主义哲学</h3><ul><li>哲学的基本问题，不同流派</li><li>马克思主义哲学<ul><li>唯物论（世界的本原是什么）</li><li>辩证法（世界是怎样的）</li><li>认识论（如何认知世界）</li><li>唯物史观（人类历史发展规律）</li></ul></li></ul><hr><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6sfqsb0bxpw0.png" alt="image"></p><blockquote><p>世界观的摇摆不定会带来痛苦</p></blockquote><h4 id="唯物论"><a class="header-anchor" href="#唯物论"></a>唯物论</h4><div class=demo><p>世界的本原是什么？物质如何起决定性作用？</p><ul><li>阳明心学——主观唯心主义</li><li>佛教缘起性空、道家——客观唯心主义</li></ul></div><div class=demo><p>物质如何起决定性作用？</p><p>物种决定意识</p></div><h4 id="辩证法"><a class="header-anchor" href="#辩证法"></a>辩证法</h4><div class=demo><p>物质世界是怎样存在的？</p><p>普遍联系，永恒发展（两大总特征）</p></div><div class=demo><p>事物是怎样联系的？</p><p>一对一对联系，矛盾</p></div><div class=demo><p>事物为什么会发展？</p><p><font color="#faa755">对立统一</font></p><p>怎样发展？</p><p><font color="#faa755">量变质变</font></p><p>往哪里去发展？</p><p><font color="#faa755">否定之否定</font></p><blockquote><p>种子的生命周期</p></blockquote></div><p>辩证法的三大规律：对立统一，量变质变，否定之否定</p><h4 id="认识论"><a class="header-anchor" href="#认识论"></a>认识论</h4><div class=demo><p>认识的本质是什么？</p><p>对外部世界的<font color="#faa755">能动反应</font></p></div><div class=demo><p>认识的过程是怎样的？</p><ul><li>实践</li><li>感性认识（浅）</li><li>理性认识（深）</li><li>实践</li></ul></div><div class=demo><p>认识的结果有什么特点？</p><ul><li>真理（绝对性，相对性）</li><li>谬误</li></ul></div><h4 id="唯物史观"><a class="header-anchor" href="#唯物史观"></a>唯物史观</h4><div class=demo><p>历史进程中的决定性力量是什么？</p><ul><li>精神——唯心史观</li><li>物质（社会生产劳动）——唯物史观</li></ul></div><div class=demo><p>历史是什么人创造的？</p><ul><li>英雄——唯心史观</li><li>人民群众——唯物史观</li></ul></div><div class=demo><p>历史向前发展有什么特点？</p><ul><li>规律（决定）</li><li>主观能动性（选择）</li></ul><p>共同作用的结果</p></div><h3 id="马克思主义政治经济学"><a class="header-anchor" href="#马克思主义政治经济学"></a>马克思主义政治经济学</h3><ul><li><p>简单商品经济时期</p></li><li><p>发达商品经济时期</p><ul><li>自由竞争资本主义 ⭐</li><li>垄断竞争资本主义</li></ul></li></ul><p>以资本主义以前为简单商品经济时期，之后为发达商品经济时期</p><hr><div class=demo><p>商品价值的本质是什么？</p><ul><li>劳动</li><li>交换</li></ul></div><div class=demo><p>资本主义社会有什么不同？</p><p>劳动不再归劳动者所有，归资本家所有</p></div><div class=demo><p>为什么说资本主义社会存在着剥削？</p><p>劳动创造的价值不完全归劳动者所有（剩余价值）</p></div><h3 id="科学社会主义理论"><a class="header-anchor" href="#科学社会主义理论"></a>科学社会主义理论</h3><ul><li>社会主义</li><li>共产主义</li></ul><div class=demo><p>社会主义的发展进程</p><p>两个飞跃：</p><ul><li>空想到科学</li><li>理论到实践</li></ul></div><div class=demo><p>共产主义的基本特征</p><ul><li>物质财富极大丰富（产品）</li><li>精神境界极大提高</li><li>自由而全面的发展</li></ul></div><h2 id="思想道德修养和法律基础"><a class="header-anchor" href="#思想道德修养和法律基础"></a>思想道德修养和法律基础</h2><ul><li>思想修养（人生观、理想信念、中国精神）社会主义核心价值观</li><li>道德修养（道德的基本问题、不同时期的道德、不同领域的道德）</li><li>法律基础</li></ul><h3 id="思想修养"><a class="header-anchor" href="#思想修养"></a>思想修养</h3><div class=demo><p>人生观：</p><ul><li>人生目的（核心）</li><li>人生态度</li><li>人生价值</li></ul><p>人生目的决定人生态度，人生目的决定人生价值</p></div><div class=demo><p>理想信念</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2wxe27viwha0.png" alt="image"></p><p>理想通过实践变为现实</p></div><div class=demo><p>中国精神</p><ul><li>以爱国主义为核心的民族精神</li><li>以改革创新为核心的时代精神</li></ul></div><h3 id="道德修养"><a class="header-anchor" href="#道德修养"></a>道德修养</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.38fmmr2fts40.png" alt="image"></p><p>道德是上层建筑（由经济基础决定）</p><p>功能：（行为前）认识、（行为时）规范、（行为后）调节</p><p>不同时期的道德规范：传统美德、革命道德、社会主义道德</p><p>不同领域的道德规范：社会公德、职业道德、家庭美德、个人品德</p><h3 id="法律基础"><a class="header-anchor" href="#法律基础"></a>法律基础</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4cbq5434kxs0.png" alt="image"></p><h2 id="中国近代史纲要"><a class="header-anchor" href="#中国近代史纲要"></a>中国近代史纲要</h2><p>政治课里的历史课归根到底还是政治课</p><ul><li>近代开始：1840 年鸦片战争</li><li>清朝</li><li>1911 年 辛亥革命</li><li>中华民国<ul><li>北洋政府时期</li><li>1928 年 张学良东北易帜</li><li>国民政府时期</li></ul></li><li>现代开始：1949 新中国成立</li></ul><hr><ul><li>旧民主主义</li><li>1919 年五四运动</li><li>新民主主义</li></ul><h3 id="近代中国的国情"><a class="header-anchor" href="#近代中国的国情"></a>近代中国的国情</h3><ul><li>国情（1840 ～ 1949 年半殖民地半封建）</li><li>矛盾（主要矛盾）<ul><li><pre><code>帝国主义和中华民族</code></pre></li><li><pre><code>封建主义和人民大众</code></pre></li></ul></li><li>任务和对象<ul><li>反帝</li><li>反封建</li></ul></li><li>革命的性质：资产阶级民主革命。<font color="#d9730d">决定革命性质的不是领导者而是革命的任务和对象</font><ul><li>旧民主主义革命：资产阶级领导的资产阶级革命</li><li>新民主主义革命：无产阶级领导的资产阶级革命</li></ul></li></ul><h3 id="（资产阶级）旧民主主义革命"><a class="header-anchor" href="#（资产阶级）旧民主主义革命"></a>（资产阶级）旧民主主义革命</h3><p>1840 年鸦片战争到 1919 年五四运动</p><p>完整意义上的资产阶级民主革命：辛亥革命</p><ul><li>纲领，三民主义（不反帝，反封建不彻底）</li><li>精英革命，没有群众路线</li><li>民族资产阶级的软弱性，没有坚强的领导核心</li></ul><h3 id="新民主主义革命"><a class="header-anchor" href="#新民主主义革命"></a>新民主主义革命</h3><ul><li>五四运动，马克思主义广泛传播</li><li>中国共产党的成立，坚强的领导核心</li><li>大革命，第一次国共合作（北伐战争）</li><li>土地革命，农村包围城市，武装夺取政权</li><li>全面抗战，第二次国共合作</li><li>解放战争，建立新中国</li></ul><h3 id="新中国时期"><a class="header-anchor" href="#新中国时期"></a>新中国时期</h3><ul><li>过渡时期，1949 ～ 1956 年三大改造</li><li>探索时期，1956 ～ 1976 年</li><li>改革开放，1978 ～ 现今，中国特色社会主义道路</li><li>新时代，2012 ～ 现今，前面小康、前面脱贫、全面建设社会主义现代化强国、中华民族伟大复兴</li></ul><h2 id="毛泽东思想和中国特色社会体系概论"><a class="header-anchor" href="#毛泽东思想和中国特色社会体系概论"></a>毛泽东思想和中国特色社会体系概论</h2><p>毛泽东思想（集体智慧、正确的）：</p><ul><li>理论的形成</li><li>理论内容<ul><li>新民主主义革命理论（1949 年之前）</li><li>社会主义改造理论（1949 ～ 1956 年）</li><li>社会主义建设道路的初步探索（1956 ～ 1976 年）</li></ul></li></ul><hr><p>中特理论体系：</p><ul><li>邓小平理论、“三个代表”重要思想、科学发展观</li><li>习近平新时代中国特色社会主义思想<ul><li>新时代、新思想</li><li>总任务</li><li>布局理论：五位一体的总体布局 ⭐⭐、四个全面的战略布局 ⭐</li><li>内外条件，国防、外交、领导</li></ul></li></ul><h3 id="马克思主义中国化"><a class="header-anchor" href="#马克思主义中国化"></a>马克思主义中国化</h3><ul><li>新文化运动，资产阶级民主思想</li><li>十月革命，马克思主义</li><li>五四运动，马克思主义广泛传播</li><li>中共一大</li><li>六届六中全会 《论新阶段》，首次提出马克思主义中国化（寻找中国社会主义的革命道路）的命题</li><li>中共七大，实现了第一次飞跃：毛泽东思想</li><li>《论十大关系》，1956 年，第二次马克思主义中国化（寻找中国社会主义的建设道路）开始</li><li>改革开放，实现了第二次飞跃：中国特色社会体系</li></ul><h3 id="毛泽东思想"><a class="header-anchor" href="#毛泽东思想"></a>毛泽东思想</h3><p>新民主主义革命理论：</p><ul><li>革命路线（做什么，任务）：无产阶级领导的人民大众的反帝反封建反官僚资本主义革命</li><li>革命纲领<ul><li>政治：各革命阶级联合专政</li><li>经济：地主（土地直接没收）、官僚资产阶级（直接没收）、民主资产阶级（保护）</li><li>文化：民族、科学、大众</li></ul></li><li>革命道路（怎么做，方向）：农村包围城市，武装夺取政权</li><li>革命经验：统一战线、武装斗争、党的建设（三大法宝）</li></ul><hr><p>社会主义改造理论：</p><ul><li>农业（合作化）</li><li>手工业（合作化）</li><li>资本主义工商业（和平赎买，改造资本家）</li></ul><hr><p>社会主义建设道路的初步探索：</p><ul><li>《论十大关系》<ul><li>第二次马克思主义中国化开始</li><li>方针：调动一切积极因素，为社会主义服务</li><li>指导思想：独立自主，符合中国</li></ul></li><li>《关于正确处理人 民内部矛盾的问题》<ul><li>基本矛盾：生产力和生产关系的矛盾，经济基础和上层建筑的矛盾</li><li>主要矛盾：落后的农业国与先进的工业国之间的矛盾；人民日益增长的物质文化需要同当前发展不能满足人民需要状况之间的矛盾</li><li>两类矛盾：敌我矛盾，人民内部矛盾</li></ul></li><li>中国工业化道路：农业、轻工业 、重工业</li></ul><h3 id="中国特色社会体系"><a class="header-anchor" href="#中国特色社会体系"></a>中国特色社会体系</h3><p>邓小平理论： 什么是社会主义？怎样建设社会主义？</p><p>“三个代表”重要思想： 建设什么样的党？怎样建设党？</p><p>科学发展观： 实现什么样的发展？怎样发展？</p><p>习近平新时代中国特色社会主义思想（战略规划）：</p><ul><li>全面小康社会、 全面脱贫（建党一百年）</li><li>基本实现社会主义现代化（2035 年）</li><li>建成社会主义现代化强国、 实现中华民族伟大复兴（21 世纪中叶，建国 100 年）</li></ul><h2 id="当代时政"><a class="header-anchor" href="#当代时政"></a>当代时政</h2><p>当代（10%）</p><ul><li>当今世界形势（百年未有之大变局）</li><li>国际行为体</li><li>地区热点问题</li><li>中国对外战略，和平发展，合作共赢，人类命运共同体</li></ul><p>时事政治（6%）</p><ul><li>重大会议</li><li>重大改革举措</li><li>科技创新</li><li>整数周年纪念</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;考研规划&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#考研规划&quot;&gt;&lt;/a&gt;考研规划&lt;/h2&gt;
&lt;p&gt;考研政治考什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;马克思主义基本原理概论（24%）&lt;/li&gt;
&lt;li&gt;毛泽东思想和中国特色社会体系概论（30%）&lt;/l</summary>
      
    
    
    
    <category term="考研政治" scheme="https://whl123456.top/categories/%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="https://whl123456.top/2021/07/08/ComputerOperatingSystem/D_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://whl123456.top/2021/07/08/ComputerOperatingSystem/D_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-07-08T05:19:05.000Z</published>
    <updated>2021-07-16T07:47:09.793Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理概念"><a class="header-anchor" href="#内存管理概念"></a>内存管理概念</h2><p>内存地址从 0 开始，每个地址对应一个存储单元：</p><ul><li>如果计算机“按字节编址”则每个存储单元大小为 1 字节（1B） ，即 8 个二进制位</li><li>如果字长为 16 位的计算机按字编址，则每个有储单元大小为 1 个字，每字的大小为 16 个二进制位</li></ul><h3 id="内存管理的基本原理和要求"><a class="header-anchor" href="#内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h3><p>内存管理（Memory Management）是操作系统设计中最重要和最复杂的内容之一。虽然计算机硬件技术一直在飞速发展，内存容量也在不断增大，但仍然不可能将所有用户进程和系统所需要的全部程序与数据放入主存，因此操作系统必须对内存空间进行合理的划分和有效的动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。</p><p>有效的内存管理在多道程序设计中非常重要，它不仅可以方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。</p><p>内存管理的功能有：</p><ul><li><font color="#d9730d">内存空间的分配与回收</font>。由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li><li><font color="#d9730d">地址转换</font>。在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li><li><font color="#d9730d">内存空间的扩充</font>。利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li><li><font color="#d9730d">存储保护</font>。保证各道作业在各自的存储空间内运行，互不干扰。</li></ul><p>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p><h4 id="逻辑地址空间与物理地址空间"><a class="header-anchor" href="#逻辑地址空间与物理地址空间"></a>逻辑地址空间与物理地址空间</h4><p>编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的相对地址（或逻辑地址）。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及内存管理的具体机制。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</p><p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。</p><h4 id="程序装入和链接"><a class="header-anchor" href="#程序装入和链接"></a>程序装入和链接</h4><p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p><ul><li>编译。由编译程序将用户源代码编译成若干目标模块。</li><li>链接。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块。</li><li>装入。由装入程序将装入模块装入内存运行。</li></ul><p>程序的链接有以下三种方式。</p><ul><li><font color="#ea66a6">静态链接</font>。在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</li><li><font color="#ea66a6">装入时动态链接</font>。将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。</li><li><font color="#ea66a6">运行时动态链接</font>。对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul><p>内存的装入模块在装入内存时，同样有以下三种方式：</p><ol><li><font color="#ea66a6">绝对装入</font>。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，因此不需对程序和数据的地址进行修改。绝对装入方式<font color="#d9730d">只适用于单道程序环境</font>。另外，程序中所用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址。</li><li><font color="#ea66a6">可重定位装入</font>（静态重定位）。在多道程序环境下，多个目标模块的起始地址（简称始址）通常都从 0 开始，程序中的其他地址都是相对于始址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称静态重定位。静态重定位的特点是：<ul><li>一个作业装入内存时，<font color="#d9730d">必须给它分配要求的全部内存空间</font>，若没有足够的内存，则不能装入该作业。</li><li>此外，作业一旦进入内存，整个运行期间就<font color="#d9730d">不能在内存中移动</font>，也<font color="#d9730d">不能再申请内存空间</font>。</li></ul></li><li><font color="#ea66a6">动态运行时装入</font>（动态重定位）。程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种<font color="#d9730d">地址转换推迟到程序真正要执行时才进行</font>。因此，装入内存后的所有地址均为相对地址。这种方式<font color="#d9730d">需要一个重定位寄存器的支持</font>。动态重定位的特点如下：<ul><li>可以将程序分配到不连续的存储区中；</li><li>在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；</li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li></ul></li></ol><h4 id="内存保护"><a class="header-anchor" href="#内存保护"></a>内存保护</h4><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p><ol><li>在 CPU 中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器的值相比，判断有无越界。</li><li>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。</li></ol><p>当 CPU 调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行影响。</p><p>实现内存保护需要重定位寄存器和界地址寄存器，因此要注意两者的区别。重定位寄存器是用来“加”的，逻辑地址加上重定位寄存器中的值就能得到物理地址;界地址寄存器是用来“比”的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。</p><h3 id="覆盖与交换"><a class="header-anchor" href="#覆盖与交换"></a>覆盖与交换</h3><p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p><h4 id="覆盖"><a class="header-anchor" href="#覆盖"></a>覆盖</h4><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p><p>覆盖的基本思想如下：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p><p>覆盖技术的特点是，打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。</p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</p><h4 id="交换"><a class="header-anchor" href="#交换"></a>交换</h4><p>交换（对换）的基本思想是，把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争 CPU 运行的程序从辅存移到内存，这一过程又称换入。<a href="https://whl123456.top/2021/04/22/ComputerOperatingSystem/C_%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%B1%82%E6%AC%A1">中级调度</a></p><div class=demo>应该在外存（磁盘）的什么位置保存被换出的进程？<p>具有对换功能的操作系统中，通常把磁盘空间分为<font color="#d9730d">文件区</font>和<font color="#d9730d">对换区</font>两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的 I/O 速度比文件区的更快。</p></div><div class=demo>什么时候应该交换？<p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</p></div><div class=demo>应该换出哪些进程?可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间。（注意：<font color="#e03e3e">PCB 会常驻内存，不会被换出外存</font>）</div><p>例如，有一个 CPU 采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU 调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p><p>有关交换，需要注意以下几个问题:</p><ul><li>交换需要备份存储，通常是快速磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li><li>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比。</li><li>若换出进程，则必须确保该进程完全处于空闲状态。</li><li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li><li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li></ul><p>普通的交换使用不多，但交换策略的某些变体在许多系统（如 UNIX 系统）中仍发挥作用。交换技术主要在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p><h3 id="连续分配管理方式"><a class="header-anchor" href="#连续分配管理方式"></a>连续分配管理方式</h3><p><font color="#ea66a6">连续分配方式</font>是指为一个用户程序分配一个连续的内存空间。譬如某用户需要 1GB 的内存空间，连续分配方式就在内存空间中为用户分配一块连续的 1GB 空间。连续分配方式主要包括单一连续分配、固定分区分配和动态分区分配。</p><h4 id="单一连续分配"><a class="header-anchor" href="#单一连续分配"></a>单一连续分配</h4><p>内存在此方式下分为<font color="#d9730d">系统区</font>和<font color="#d9730d">用户区</font>：</p><ul><li>系统区仅供操作系统使用，通常在低地址部分；</li><li>用户区是为用户提供的、除系统区之外的内存空间。</li></ul><p>这种方式无须进行内存保护。因为内存中永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。（早期的 PC 操作系统 MS-DOS ）</p><ul><li><p>优点是简单、<font color="#d9730d">无外部碎片</font>，可以采用覆盖技术，不需要额外的技术支持。</p></li><li><p>缺点是只能用于单用户、单任务的操作系统中，<font color="#d9730d">有内部碎片</font>，存储器的利用率极低。</p></li></ul><h4 id="固定分区分配"><a class="header-anchor" href="#固定分区分配"></a>固定分区分配</h4><p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。固定分区分配在划分分区时有两种不同的方法：</p><ul><li>分区大小相等。用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。</li><li>分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区。</li></ul><p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的始址、大小及状态（是否已分配）。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为“已分配”；未找到合适分区时，则拒绝为该用户程序分配内存。</p><p>这种分区方式存在两个问题：</p><ul><li>一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间</li><li>二是主存利用率低，当程序小于固定分区大小时，也占用一个完整的内存分区空间，这样分区内部就存在空间浪费，这种现象称为内部碎片。</li></ul><p>固定分区是可用于多道程序设计的最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p><h4 id="动态分区分配"><a class="header-anchor" href="#动态分区分配"></a>动态分区分配</h4><p>动态分区分配又称可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先划分内存，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。</p><div class=demo>系统要用什么样的数据结构记录内存的使用情况?<p>有两种常用的数据结构：空闲分区表和空闲分区链。</p><ul><li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息。</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。</li></ul></div><div class=demo>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？应该用最大的分区进行分配？还是用最小的分区进行分配？又或是用地址最低的部分进行分配？<p>把一个新作业装入内存时，须按照一定的动态分区分配算法，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。</p></div><div class=demo>如何进行分区的分配与回收操作？假设系统采用的数据结构是“空闲分区表”如何回收?<p>分配操作：</p><ol><li>如果待分配进程大小小于空闲分区大小，修改空闲分区表的分区大小和起始地址</li><li>如果待分配进程大小等于空闲分区大小，从空闲分区表中删除该表项</li></ol><p>回收操作：</p><ol><li>情况一，回收区的后面有一个相邻的空闲分区。两个相邻的空闲分区合并为一个</li><li>情况二，回收区的前面有一个相邻的空闲分区。两个相邻的空闲分区合并为一个</li><li>情况三，回收区的前、后各有一个相邻的空闲分区。三个相邻的空闲分区合并为一个</li><li>情况四，回收区的前、后都没有相邻的空闲分区。新增一个表项。注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</li></ol></div><p>动态分区分配没有内部碎片，但是有外部碎片。</p><ul><li><font color="#ea66a6">内部碎片</font>，分配给某进程的内存区域中，如果有些部分没有用上。</li><li><font color="#ea66a6">外部碎片</font>，是指内存中的某些空闲分区由于太小而难以利用。</li></ul><p>动态分区在开始分配时是很好的，但之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片，内存的利用率随之下降。这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过<font color="#ea66a6">紧凑（Compaction）技术</font>来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际，上类似于 Windows 系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。</p><h4 id="动态分区分配算法"><a class="header-anchor" href="#动态分区分配算法"></a>动态分区分配算法</h4><p>在进程装入或换入主存时，若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p><ul><li>首次适应（First Fit）算法。空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</li><li>最佳适应（Best Fit）算法。空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空闲分区。算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</li><li>最坏适应（Worst Fit）算法。又称最大适应（Largest Fit）算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区，即挑选出最大的分区。算法思想：为了解决最佳适应算法的问题一即留下太多难以利用的小碎片，可以在每次分配时优先使用最太的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</li><li>邻近适应（Next Fit）算法。又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</li></ul><p>在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。在 UNIX 系统的最初版本中，就是使用首次适应算法为进程分配内存空间的，它使用数组的数据结构(而非链表)来实现。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此增加了查找的开销。</p><p>邻近适应算法试图解决这个问题。但实际上，它常常导致在内存的末尾分配空间（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配）分裂成小碎片。它通常比首次适应算法的结果要差。</p><p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。</p><p>最坏适应算法与最佳适应算法相反，它选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大内存块，因此性能也非常差。</p><p>Knuth 和 Shore 分别就前三种方法对内存空间的利用情况做了模拟实验，结果表明：首次适应算法可能比最佳适应法效果好，而它们两者一定比最大适应法效果好。另外要注意，在算法实现时，分配操作中最佳适应法和最大适应法需要对可用块进行排序或遍历查找，而首次适应法和邻近适应法只需要简单查找；在回收操作中，当回收的块与原来的空闲块相邻时（有三种相邻的情况，比较复杂），需要将这些块合并。在算法实现时，使用数组或链表进行管理。除了内存的利用率，这里的算法开销也是操作系统设计需要考虑的一个因素。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.morwas6goe8.png" alt="image"></p><h3 id="非连续分配管理方式"><a class="header-anchor" href="#非连续分配管理方式"></a>非连续分配管理方式</h3><p><font color="#ea66a6">非连续分配</font>允许一个程序分散地装入不相邻的内存分区。在连续分配管理方式中，我们发现，即使内存有超过 1GB 的空闲空间，但若没有连续的 1GB 空间，则需要 1GB 空间的作业仍然是无法运行的；但若采用非连续分配管理方式，则作业所要求的 1GB 内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续存储方式的。</p><p>非连续分配管理方式根据分区的大小是否固定，分为分页存储管理方式和分段存储管理方式。</p><p>在分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理方式和请求分页存储管理方式。下面介绍基本分页存储管理方式。</p><h4 id="基本分页存储管理方式"><a class="header-anchor" href="#基本分页存储管理方式"></a>基本分页存储管理方式</h4><p>基本分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p><p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p><p>分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。</p><p>将内存空间分为一个个大小相等的分区（比如：每个分区 4KB），每个分区就是一个“<font color="#ea66a6">页框</font>”（或称“页帧”、“内存块”、“物理块”、“物理页面”）。每个页框有一个编号，即“<font color="#ea66a6">页框号</font>”（或者“内存块号”、“页帧号”、“物理块号”、“物理页号”）页框号从 0 开始。</p><p>将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“<font color="#ea66a6">页</font>”或“页面”。每个页面也有一个编号，即“<font color="#ea66a6">页号</font>”页号也是从 0 开始。（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.41e5yjkjg9k0.png" alt="image"></p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。</p><p>（1）分页存储的几个基本概念</p><ul><li>页面和页面大小。进程中的块称为页（Page），内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块（Block）。进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。为方便地址转换，页面大小应是 2 的整数幂。同时页面大小应该适中，页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增多，降低内存的利用率。所以页面的大小应该适中，要在空间效率和时间效率之间权衡。</li><li>地址结构。地址结构包含两部分：前一部分为页号 P，后一部分为页内偏移量 W。地址长度为 32 位，其中 0 ～ 11 位为页内地址，即每页大小为 4KB；12 ～ 31 位为页号，地址空间最多允许 20 页。注意，地址结构决定了虚拟内存的寻址空间有多大。在实际问题中，页号、页内偏移、逻辑地址大多都是用十进制数给出的。</li><li><font color="#ea66a6">页表</font>。为了便于在内存中找到进程的每个页面所对应的物理块，系统为<font color="#33a3dc">每个进程建立一张页表</font>，它记录页面在内存中对应的物理块号，页表一般存放在内存中。页表是由页表项（<font color="#33a3dc">进程的每个页面对应一个页表项</font>）组成的，初学者容易混淆页表项与地址结构，页表项与地址都由两部分构成，而且<font color="#33a3dc">第一部分都是页号</font>，但页表项的<font color="#33a3dc">第二部分是物理内存中的块号</font>，而地址的第二部分是页内偏移；页表项的第二部分与地址的第二部分共同组成物理地址。在配置页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，<font color="#33a3dc">页表的作用是实现从页号到物理块号的地址映射</font>。</li></ul><div class=demo><p>Eg. 假设某系统物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节?</p><p>内存块大小 = 页面大小 = 4KB = 2<sup>12</sup>B，故 4GB 的内存被分成 2<sup>20</sup>B</p><p>内存块号的范围应该是 0 ～ 2<sup>20</sup>-1，故内存块号至少要用 20 bit 来表示，即 3B 来表示块号</p><p>页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组），因此页表项占 3B。</p></div><div class=demo><p>将进程地址空间分页之后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p>虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p><ol><li>要算出逻辑地址 A 对应的页号</li><li>要知道该页号对应页面在内存中的起始地址 P（需要查页表）</li><li>要算出逻辑地址在页面内的“偏移量”W</li><li>物理地址 = 页面始址 + 页内偏移量</li></ol><p>Eg. 在某计算机系统中，页面大小是 50B。某进程逻辑地址空间大小为 200B，则逻辑地址 110 对应的页号、页内偏移量是多少?</p><p>页号 = 逻辑地址 / 页面长度（取除法的整数部分） = 110 / 50 = 2</p><p>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）= 110 % 50 = 10</p><p>逻辑地址可以拆分为（页号，页内偏移量）通过页号查询页表，可知页面在内存中的起始地址</p><p>页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址</p></div><p>在计算机内部，地址是用二进制表示的，如果页面大小刚好是 2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分<br>成（页号，页内偏移量）</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2h42kymxoqe0.png" alt="image"></p><p>总结：页面大小 刚好是 2 的整数幂有什么好处？</p><ol><li>逻辑地址的拆分更加迅速——如果每个页面大小为 2KB，用二进制数表示逻辑地址，则末尾 K 位 即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就 可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。</li><li>物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内 存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5xxh5mgq1rk0.png" alt="image"></p><p>（2）基本地址变换机构</p><p>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。地址变换是借助于页表实现的。</p><p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址 F 和页表长度 M。 进程未执行时，页表的始址和页表长度 放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3xwmgmi5fr00.png" alt="image"></p><p>注意：页面大小是 2 的整数幂。设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：</p><ol><li>计算页号 P 和页内偏移量 W（如果用十进制数手算，则 P = A / L，W = A % L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号 P 和页表长度 M，若 P ≥ M，则产生越界中断，否则继续执行。（注意：页号是从 0 开始的，而页表长度至少是 1，因此 P = M 时也会越界）</li><li>页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度，取出该页表项内容 b，即为内存块号。（注意区分页表项长度、 页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li><li>计算 E = b * L + W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li></ol><div class=demo><p>Eg. 若页面大小 L 为 1K 字节，页号 2 对应的内存块号 b = 8，将逻辑地址 A = 2500 转换为物理地址 E。</p><p>等价描述：某系统<font color="#33a3dc">按字节寻址</font>，逻辑地址结构中，<font color="#33a3dc">页内偏移量占 10 位</font>，页号 2 对应的内存块号 b = 8， 将逻辑地址 A = 2500 转换为物理地址 E。</p><ol><li>计算页号、页内偏移量。页号 P = A / L = 2500 / 1024 = 2；页内偏移量 W = A % L = 2500 % 1024 = 452</li><li>根据题中条件可知，页号 2 没有越界，其存放的内存块号 b = 8</li><li>物理地址 E = b * L + W = 8 * 1024 + 425 = 8644</li></ol><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。</p></div><p>实际应用中，通常使一个页框恰好能放入整数个页表项。为了方便找到页表项，页表一般是放在连续的内存块中的</p><p>（3）具有快表的地址变换机构</p><p>由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：</p><ul><li>第一次是访问页表，确定所存取的数据或指令的物理地址；</li><li>第二次是根据该地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。</li></ul><p>为此，在地址变换机构中增设一个具有并行查找能力的<font color="#33a3dc">高速缓冲存储器</font>——快表，又称相联存储器（TLB），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5d6fhhmz3740.png" alt="image"></p><ol><li>CPU 给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此， 若快表命中，则访问某个逻辑地址仅需一次访存即可。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此， 若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表， 以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p><p>（4）两级页表</p><p>单级页表的问题?</p><ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</li></ul><p>若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面</p><p>两级页表的访存次数分析（假设没有快表机构） 第一次访存：访问内存中的页目录表，第二次访存：访问内存中的二级页表，第三次访存：访问目标内存单元。N 级页表访问一个逻辑地址需要 N + 1 次访存</p><h4 id="基本分段储存管理方式"><a class="header-anchor" href="#基本分段储存管理方式"></a>基本分段储存管理方式</h4><ol><li>分段。段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为 5 段，每段从 0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的），其逻辑地址由段号 S 与段内偏移量 W 两部分组成。由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高。段号的位数决定了每个进程最多可以分几个段；段内地址位数决定了每个段的最大长度是多少</li><li>段表。每个进程都有–张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。配置段表后，执行中的进程可通过查找段表，找到每段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射。每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。各个段表项的长度是相同的。于段表项长度相同，因此段号可以是隐含的，不占存储空间。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7gbmor8p72o0.png" alt="image"></p><p>分段、分页管理的对比</p><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。</p><p>段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</p><p>分段比分页更容易实现信息的共享和保护。</p><p>不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p><p>访问一个逻辑地址需要几次访存？</p><p>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存 分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存</p><p>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。</p><h4 id="段页式管理方式"><a class="header-anchor" href="#段页式管理方式"></a>段页式管理方式</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3voysntlxl00.png" alt="image"></p><p>段号的位数决定了每个进程最多可以分几个段</p><p>页号位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小、内存块大小是多少</p><p>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。 因此段页式管理的地址结构是二维的。</p><h2 id="虚拟内存管理"><a class="header-anchor" href="#虚拟内存管理"></a>虚拟内存管理</h2><p>传统存储管理方式的特征、缺点</p><p>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：</p><ul><li>作业很大时，不能全部装入内存，导致大作业无法运行；</li><li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li></ul><p>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</p><hr><p>局部性原理</p><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p><h3 id="虚拟内存的基本概念"><a class="header-anchor" href="#虚拟内存的基本概念"></a>虚拟内存的基本概念</h3><p>虚拟内存的定义和特征</p><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p><p>虚拟内存有一下三个主要特征：</p><ul><li>多次性：无需在作业运行时-次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。</li></ul><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此， 虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p><p>主要区别： 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。</p><p>操作系统要提供请求调页（或请求调段）功能，操作系统要提供页面置换（或段置换）的功能。</p><h3 id="请求分页管理方式"><a class="header-anchor" href="#请求分页管理方式"></a>请求分页管理方式</h3><h4 id="页表机制"><a class="header-anchor" href="#页表机制"></a>页表机制</h4><p>与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存；如果还没调入，那么也需要知道该页面在外存中存放的位置。</p><p>当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.517uhszagvs0.png" alt="image"></p><h4 id="缺页中断机构"><a class="header-anchor" href="#缺页中断机构"></a>缺页中断机构</h4><p>在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，然 后由操作系统的缺页中断处理程序处理中断。</p><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列。</p><p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。</p><h3 id="页面置换算法"><a class="header-anchor" href="#页面置换算法"></a>页面置换算法</h3><h4 id="最佳（OPT）置换算法"><a class="header-anchor" href="#最佳（OPT）置换算法"></a>最佳（OPT）置换算法</h4><h4 id="先进先出（FIFO）页面置换算法"><a class="header-anchor" href="#先进先出（FIFO）页面置换算法"></a>先进先出（FIFO）页面置换算法</h4><p>FIFO 算法还会产生所分配的物理块数增大而页故障数不减反增的异常现象，这由 Belady 于 1969 年发现，因此称为 Belady 异常 。</p><h4 id="最近最久未使（LRU）置换算法"><a class="header-anchor" href="#最近最久未使（LRU）置换算法"></a>最近最久未使（LRU）置换算法</h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p><h4 id="时钟（CLOCK）置换算法"><a class="header-anchor" href="#时钟（CLOCK）置换算法"></a>时钟（CLOCK）置换算法</h4><p>时钟置换算法是一种性能和开销较均衡的算法，又称 CLOCK 算法，或最近未用算法（NRU，Not Recently Used）</p><p>简单的 CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成 一个循环队列。当某页被访问时，其访问位置为 1。当需要淘汰一个页面时，只需检查页的访问位。 如果是 0，就选择该页换出；如果是 1，则将它置为 0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描中一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描）</p><h4 id="改进型的时钟置换算法"><a class="header-anchor" href="#改进型的时钟置换算法"></a>改进型的时钟置换算法</h4><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过， 就不需要执行 I/O 操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。 因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他 条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。这就是改进型的时钟置换算法的思想。 修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。 为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过， 且被修改过。 算法规则：将所有可能被置换的页面排成一个循环队列</p><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描 不修改任何标志位</p><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于 替换。本轮将所有扫描过的帧访问位设为 0</p><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于 替换。本轮扫描不修改任何标志位</p><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于 替换。 由于第二轮已将所有帧的访问位设为 0，因此经过第三轮、第四轮扫描一 定会有一个帧被选中，因此改进型 CLOCK 置换算法选择一个淘汰页面最多 会进行四轮扫描</p><h3 id="页面分配策略"><a class="header-anchor" href="#页面分配策略"></a>页面分配策略</h3><h3 id="抖动"><a class="header-anchor" href="#抖动"></a>抖动</h3><h3 id="工作集"><a class="header-anchor" href="#工作集"></a>工作集</h3><h3 id="地址翻译"><a class="header-anchor" href="#地址翻译"></a>地址翻译</h3>]]></content>
    
    
    <summary type="html">描述</summary>
    
    
    
    <category term="操作系统" scheme="https://whl123456.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://whl123456.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机 408 文章汇总</title>
    <link href="https://whl123456.top/2021/07/06/DataCollection/%E8%AE%A1%E7%AE%97%E6%9C%BA408%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/"/>
    <id>https://whl123456.top/2021/07/06/DataCollection/%E8%AE%A1%E7%AE%97%E6%9C%BA408%E6%96%87%E7%AB%A0%E6%B1%87%E6%80%BB/</id>
    <published>2021-07-06T04:02:12.000Z</published>
    <updated>2021-07-26T03:05:38.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机组成原理"><a class="header-anchor" href="#计算机组成原理"></a>计算机组成原理</h2><ol><li><a href="https://whl123456.top/2021/05/26/ComputerComposition/A_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/">计算机组成原理概述</a></li><li><a href="https://whl123456.top/2021/05/26/ComputerComposition/B_%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/">数据的表示和运算</a></li><li>存储系统</li><li>指令系统</li><li>中央处理器</li><li>总线</li><li>输入/输出系统</li></ol><h2 id="数据结构"><a class="header-anchor" href="#数据结构"></a>数据结构</h2><ol><li><a href="https://whl123456.top/2021/04/27/DataStructure/A_Introduction/">数据结构绪论</a></li><li><a href="https://whl123456.top/2021/04/27/DataStructure/B_LinearList/">线性表</a></li><li><a href="https://whl123456.top/2021/05/02/DataStructure/C_StacksAndQueues/">栈和队列</a></li><li><a href="https://whl123456.top/2021/05/07/DataStructure/D_String/">串</a></li><li><a href="https://whl123456.top/2021/05/07/DataStructure/E_Tree/">树与二叉树</a></li><li><a href="https://whl123456.top/2021/05/09/DataStructure/F_graph/">图</a></li><li><a href="https://whl123456.top/2021/05/12/DataStructure/G_Search/">查找</a></li><li><a href="https://whl123456.top/2021/05/13/DataStructure/H_Sort/">排序</a></li></ol><h2 id="操作系统"><a class="header-anchor" href="#操作系统"></a>操作系统</h2><ol><li><a href="https://whl123456.top/2021/04/18/ComputerOperatingSystem/A_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">操作系统概述</a></li><li><a href="https://whl123456.top/2021/04/18/ComputerOperatingSystem/B_%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">进程和线程</a></li><li><a href="https://whl123456.top/2021/04/22/ComputerOperatingSystem/C_%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/">处理机调度</a></li><li>内存管理</li><li>文件管理</li><li>输入/输出管理</li></ol><h2 id="计算机网络"><a class="header-anchor" href="#计算机网络"></a>计算机网络</h2><ol><li><a href="https://whl123456.top/2021/04/22/ComputerNetworks/A_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">计算机网络体系结构</a></li><li><a href="https://whl123456.top/2021/04/22/ComputerNetworks/B_%E7%89%A9%E7%90%86%E5%B1%82/">物理层</a></li><li>数据链路层</li><li>网络层</li><li>传输层</li><li>应用层</li></ol>]]></content>
    
    
    <summary type="html">计算机408文章汇总</summary>
    
    
    
    <category term="考研" scheme="https://whl123456.top/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="考研" scheme="https://whl123456.top/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>React</title>
    <link href="https://whl123456.top/2021/07/01/WebFrontEnd/React/"/>
    <id>https://whl123456.top/2021/07/01/WebFrontEnd/React/</id>
    <published>2021-07-01T10:33:22.000Z</published>
    <updated>2021-07-01T15:46:14.503Z</updated>
    
    <content type="html"><![CDATA[<p>React 是一个用于构建用户界面的 JavaScript 库。</p><ol><li>采用组件化模式、声明式编码，提高开发效率及组件复用率。</li><li>在 React Native 中可以使用 React 语法进行移动端开发。</li><li>使用虚拟 DOM 和优秀的 Diffing 算法，尽量减少与真实 DOM 的交互。</li></ol><p>关于虚拟 DOM：</p><ol><li>本质是 Object 类型的对象（一般对象）</li><li>虚拟 DOM 比较“轻”，真实DOM比较“重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性。</li><li>虚拟 DOM 最终会被 React 转化为真实 DOM，呈现在页面上。</li></ol><blockquote><p>A4-JSX创建虚拟DOM</p></blockquote><h2 id="使用-React"><a class="header-anchor" href="#使用-React"></a>使用 React</h2><h3 id="通过-script-标签引入"><a class="header-anchor" href="#通过-script-标签引入"></a>通过 script 标签引入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 react 核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 react-dom，用于支持 react 操作 DOM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入 babel，用于将 jsx 转为 js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意引入顺序</p></blockquote><h2 id="创建虚拟-DOM"><a class="header-anchor" href="#创建虚拟-DOM"></a>创建虚拟 DOM</h2><h3 id="使用原生-JS-语法创建（不推荐）"><a class="header-anchor" href="#使用原生-JS-语法创建（不推荐）"></a>使用原生 JS 语法创建（不推荐）</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1.创建虚拟 DOM</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> VDOM = React.createElement(<span class="string">&#x27;h1&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        id: <span class="string">&#x27;title&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;, React.createElement(<span class="string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="string">&#x27;Hello,React&#x27;</span>))</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2.渲染虚拟 DOM 到页面 </span></span></span><br><span class="line"><span class="javascript">    ReactDOM.render(VDOM, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>A3-JS创建虚拟DOM.html</p></blockquote><h3 id="使用-JSX-创建"><a class="header-anchor" href="#使用-JSX-创建"></a>使用 JSX 创建</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 此处一定要写 babel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 1.创建虚拟 DOM</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> VDOM =(</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">    )  <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 2.渲染虚拟 DOM 到页面 </span></span></span><br><span class="line"><span class="javascript">    ReactDOM.render(VDOM,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> TDOM = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;虚拟DOM&quot;</span>,VDOM);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;虚拟DOM&quot;</span>,<span class="keyword">typeof</span> VDOM);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;真实DOM&quot;</span>,TDOM);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">debugger</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>A4-JSX创建虚拟DOM.html</p></blockquote><h2 id="JSX-语法"><a class="header-anchor" href="#JSX-语法"></a>JSX 语法</h2><p>JSX 语法规则：</p><ol><li>定义虚拟 DOM 时，不要写引号。</li><li>标签中混入 JS 表达式时要用 <code>&#123;&#125;</code>。</li><li>样式的类名指定不要用 <code>class</code>，要用 <code>className</code>。</li><li>内联样式，要用 <code>style=&#123;&#123;key:value&#125;&#125;</code> 的形式去写。</li><li>只有一个根标签</li><li>标签必须闭合</li><li>标签首字母：若小写字母开头，则将该标签转为 html 中同名元素，若 html 中无该标签对应的同名元素，则报错。若大写字母开头，react 就去渲染对应的组件，若组件没有定义，则报错。</li></ol><blockquote><p>B-JSX语法规则</p></blockquote><h2 id="定义组件"><a class="header-anchor" href="#定义组件"></a>定义组件</h2><h3 id="函数式组件"><a class="header-anchor" href="#函数式组件"></a>函数式组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.创建函数式组件</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//此处的this是undefined，因为babel编译后开启了严格模式</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line">  /* </span><br><span class="line"><span class="javascript">    执行了ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>.......之后，发生了什么？</span></span><br><span class="line">      1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line">      2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="line">  */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>C1-定义组件函数式组件.html</p></blockquote><h3 id="类式组件"><a class="header-anchor" href="#类式组件"></a>类式组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.创建类式组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//render是放在哪里的？—— MyComponent的原型对象上，供实例使用。</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//render中的this是谁？—— MyComponent的实例对象 &lt;=&gt; MyComponent组件实例对象。</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;render中的this:&#x27;</span>,<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line">  /* </span><br><span class="line"><span class="javascript">    执行了ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span>/&gt;</span></span>.......之后，发生了什么？</span></span><br><span class="line">        1.React解析组件标签，找到了MyComponent组件。</span><br><span class="line"><span class="javascript">        <span class="number">2.</span>发现组件是使用类定义的，随后<span class="keyword">new</span>出来该类的实例，并通过该实例调用到原型上的render方法。</span></span><br><span class="line">        3.将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。</span><br><span class="line">  */</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="主键的三大属性"><a class="header-anchor" href="#主键的三大属性"></a>主键的三大属性</h2><h3 id="state"><a class="header-anchor" href="#state"></a>state</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1.创建组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//构造器调用几次？ ———— 1次</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">super</span>(props)</span></span><br><span class="line"><span class="javascript">      <span class="comment">//初始化状态</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// ⭐解决changeWeather中this指向问题</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.changeWeather = <span class="built_in">this</span>.changeWeather.bind(<span class="built_in">this</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//读取状态</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//changeWeather调用几次？ ———— 点几次调几次</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;changeWeather&#x27;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//获取原来的isHot值</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span></span><br><span class="line"><span class="javascript">      <span class="comment">// ⭐严重注意：状态必须通过setState进行更新，且更新是一种合并，不是替换。</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//this.state.isHot = !isHot //这是错误的写法</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//2.渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>state 简写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//1.创建组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//初始化状态</span></span></span><br><span class="line"><span class="javascript">    state = &#123;<span class="attr">isHot</span>:<span class="literal">false</span>,<span class="attr">wind</span>:<span class="string">&#x27;微风&#x27;</span>&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;isHot,wind&#125; = <span class="built_in">this</span>.state</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span>今天天气很&#123;isHot ? &#x27;炎热&#x27; : &#x27;凉爽&#x27;&#125;，&#123;wind&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// ⭐自定义方法————要用赋值语句的形式+箭头函数</span></span></span><br><span class="line"><span class="javascript">    changeWeather = <span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.setState(&#123;<span class="attr">isHot</span>:!isHot&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//2.渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>))</span></span><br><span class="line">      </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="props"><a class="header-anchor" href="#props"></a>props</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this);</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;name,age,sex&#125; = <span class="built_in">this</span>.props</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;jerry&quot;</span> <span class="attr">age</span>=<span class="string">&#123;19&#125;</span>  <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))</span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test2&#x27;</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;老刘&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// console.log(&#x27;@&#x27;,...p);</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  // ReactDOM.render(<span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;p.name&#125;</span> <span class="attr">age</span>=<span class="string">&#123;p.age&#125;</span> <span class="attr">sex</span>=<span class="string">&#123;p.sex&#125;/</span>&gt;</span>,document.getElementById(&#x27;test3&#x27;))</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test3&#x27;</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="对-props-进行限制"><a class="header-anchor" href="#对-props-进行限制"></a>对 props 进行限制</h4><blockquote><p>注意需要引入 prop-types.js</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/prop-types.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this);</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;name,age,sex&#125; = <span class="built_in">this</span>.props</span></span><br><span class="line"><span class="javascript">      <span class="comment">//props是只读的</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//对标签属性进行类型、必要性的限制</span></span></span><br><span class="line">  Person.propTypes = &#123;</span><br><span class="line"><span class="javascript">    name:PropTypes.string.isRequired, <span class="comment">//限制name必传，且为字符串</span></span></span><br><span class="line"><span class="javascript">    sex:PropTypes.string,<span class="comment">//限制sex为字符串</span></span></span><br><span class="line"><span class="javascript">    age:PropTypes.number,<span class="comment">//限制age为数值</span></span></span><br><span class="line"><span class="javascript">    speak:PropTypes.func,<span class="comment">//限制speak为函数</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//指定默认标签属性值</span></span></span><br><span class="line">  Person.defaultProps = &#123;</span><br><span class="line"><span class="javascript">    sex:<span class="string">&#x27;男&#x27;</span>,<span class="comment">//sex默认值为男</span></span></span><br><span class="line"><span class="javascript">    age:<span class="number">18</span> <span class="comment">//age默认值为18</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  <span class="comment">//渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;100&#125;</span> <span class="attr">speak</span>=<span class="string">&#123;speak&#125;/</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))</span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;tom&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test2&#x27;</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> p = &#123;<span class="attr">name</span>:<span class="string">&#x27;老刘&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">sex</span>:<span class="string">&#x27;女&#x27;</span>&#125;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// console.log(&#x27;@&#x27;,...p);</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  // ReactDOM.render(<span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&#123;p.name&#125;</span> <span class="attr">age</span>=<span class="string">&#123;p.age&#125;</span> <span class="attr">sex</span>=<span class="string">&#123;p.sex&#125;/</span>&gt;</span>,document.getElementById(&#x27;test3&#x27;))</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125;/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test3&#x27;</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;我说话了&#x27;</span>);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="props-的简写方式"><a class="header-anchor" href="#props-的简写方式"></a>props 的简写方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入prop-types，用于对组件标签属性进行限制 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/prop-types.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//创建组件</span></span></span><br><span class="line"><span class="javascript">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">//构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(props);</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">super</span>(props)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>,<span class="built_in">this</span>.props);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//对标签属性进行类型、必要性的限制</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">static</span> propTypes = &#123;</span></span><br><span class="line"><span class="javascript">      name:PropTypes.string.isRequired, <span class="comment">//限制name必传，且为字符串</span></span></span><br><span class="line"><span class="javascript">      sex:PropTypes.string,<span class="comment">//限制sex为字符串</span></span></span><br><span class="line"><span class="javascript">      age:PropTypes.number,<span class="comment">//限制age为数值</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">//指定默认标签属性值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">static</span> defaultProps = &#123;</span></span><br><span class="line"><span class="javascript">      sex:<span class="string">&#x27;男&#x27;</span>,<span class="comment">//sex默认值为男</span></span></span><br><span class="line"><span class="javascript">      age:<span class="number">18</span> <span class="comment">//age默认值为18</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this);</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> &#123;name,age,sex&#125; = <span class="built_in">this</span>.props</span></span><br><span class="line"><span class="javascript">      <span class="comment">//props是只读的</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//this.props.name = &#x27;jack&#x27; //此行代码会报错，因为props是只读的</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> (</span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age+1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">//渲染组件到页面</span></span></span><br><span class="line"><span class="javascript">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;jerry&quot;</span>/&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test1&#x27;</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;React 是一个用于构建用户界面的 JavaScript 库。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用组件化模式、声明式编码，提高开发效率及组件复用率。&lt;/li&gt;
&lt;li&gt;在 React Native 中可以使用 React 语法进行移动端开发。&lt;/li&gt;
&lt;li&gt;使用虚拟 DO</summary>
      
    
    
    
    <category term="Web" scheme="https://whl123456.top/categories/Web/"/>
    
    
    <category term="React" scheme="https://whl123456.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Sass</title>
    <link href="https://whl123456.top/2021/07/01/WebFrontEnd/Sass/"/>
    <id>https://whl123456.top/2021/07/01/WebFrontEnd/Sass/</id>
    <published>2021-07-01T00:29:50.000Z</published>
    <updated>2021-07-01T08:33:42.789Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sass 是一个 CSS 预处理器。</li><li>Sass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。</li><li>Sass 完全兼容所有版本的 CSS。</li><li>Sass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。</li><li>Sass 生成良好格式化的 CSS 代码，易于组织和维护。</li><li>Sass 文件后缀为 <code>.scss</code>。</li></ul><h2 id="快速入门"><a class="header-anchor" href="#快速入门"></a>快速入门</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义变量与值 */</span></span><br><span class="line"><span class="variable">$bgcolor</span>: lightblue;</span><br><span class="line"><span class="variable">$textcolor</span>: darkblue;</span><br><span class="line"><span class="variable">$fontsize</span>: <span class="number">18px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用变量 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$bgcolor</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$textcolor</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$fontsize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sass-变量"><a class="header-anchor" href="#Sass-变量"></a>Sass 变量</h3><p>变量用于存储一些信息，它可以重复使用。</p><p>Sass 变量可以存储以下信息：</p><ul><li>字符串</li><li>数字</li><li>颜色值</li><li>布尔值</li><li>列表</li><li>null 值</li></ul><p>Sass 变量使用 <code>$</code> 符号，变量声明后我们就可以在代码中使用它：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myFont</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$myColor</span>: red;</span><br><span class="line"><span class="variable">$myFontSize</span>: <span class="number">16px</span>;</span><br><span class="line"><span class="variable">$myWidth</span>: <span class="number">680px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="variable">$myFont</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="variable">$myFontSize</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$myWidth</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">680px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sass-作用域"><a class="header-anchor" href="#Sass-作用域"></a>Sass 作用域</h3><p>Sass 变量的作用域只能在当前的层级上有效果，如下所示 h1 的样式为它内部定义的 green，p 标签则是为 red。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myColor</span>: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="variable">$myColor</span>: green;   <span class="comment">// 只在 h1 里头有用，局部作用域</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 Sass 中我们可以使用 <code>!global</code> 关键词来设置变量是全局的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myColor</span>: red;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="variable">$myColor</span>: green !global;  <span class="comment">// 全局作用域</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 p 标签的样式就会变成 green。</p><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：所有的全局变量我们一般定义在同一个文件，如：_globals.scss，然后我们使用 <a href="https://www.runoob.com/sass/sass-mixin-include.html"><code>@include</code></a> 来包含该文件。</p><h2 id="Sass-嵌套规则与属性"><a class="header-anchor" href="#Sass-嵌套规则与属性"></a>Sass 嵌套规则与属性</h2><h3 id="Sass-嵌套规则"><a class="header-anchor" href="#Sass-嵌套规则"></a>Sass 嵌套规则</h3><p>Sass 嵌套 CSS 选择器类似于 HTML 的嵌套规则。</p><p>如下我们嵌套一个导航栏的样式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例中，ul, li, 和 a 选择器都嵌套在 nav 选择器中</p><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">6px</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sass-嵌套属性"><a class="header-anchor" href="#Sass-嵌套属性"></a>Sass 嵌套属性</h3><p>很多 CSS 属性都有同样的前缀，例如：font-family, font-size 和 font-weight ， text-align, text-transform 和 text-overflow。</p><p>在 Sass 中，我们可以使用嵌套属性来编写它们：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        family: Helvetica, sans-serif;</span><br><span class="line">        size: <span class="number">18px</span>;</span><br><span class="line">        weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    text: &#123;</span><br><span class="line">        align: center;</span><br><span class="line">        <span class="attribute">transform</span>: lowercase;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">text-transform</span>: lowercase;</span><br><span class="line">  <span class="attribute">text-overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sass-import"><a class="header-anchor" href="#Sass-import"></a>Sass @import</h2><p>类似 CSS，Sass 支持 @import 指令。</p><p>@import 指令可以让我们导入其他文件等内容。</p><p>CSS @import 指令在每次调用时，都会创建一个额外的 HTTP 请求。但，Sass @import 指令将文件包含在 CSS 中，不需要额外的 HTTP 请求。</p><p>Sass @import 指令语法如下：</p><p>注意：包含文件时不需要指定文件后缀，Sass 会自动添加后缀 .scss。此外，也可以导入 CSS 文件。</p><p>导入后我们就可以在主文件中使用导入文件等变量。以下实例，导入 variables.scss、colors.scss 和 reset.scss 文件。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;variables&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;colors&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;reset&quot;</span>;</span><br></pre></td></tr></table></figure><p>如果你不希望将一个 Sass 的代码文件编译到一个 CSS 文件，你可以在文件名的开头添加一个下划线。这将告诉 Sass 不要将其编译到 CSS 文件。</p><p>但是，在导入语句中我们不需要添加下划线。</p><p>Sass Partials 语法格式：<code>_filename;</code></p><p>以下实例创建一个 _colors.scss 的文件，但是不会编译成 _colors.css 文件</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$myPink</span>: <span class="number">#EE82EE</span>;</span><br><span class="line"><span class="variable">$myBlue</span>: <span class="number">#4169E1</span>;</span><br><span class="line"><span class="variable">$myGreen</span>: <span class="number">#8FBC8F</span>;</span><br></pre></td></tr></table></figure><p>如果要导入该文件，则不需要使用下划线：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;colors&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: Helvetica, sans-serif;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$myBlue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：请不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略。</p></blockquote><h2 id="Sass-mixin-与-include"><a class="header-anchor" href="#Sass-mixin-与-include"></a>Sass @mixin 与 @include</h2><ul><li><code>@mixin</code> 指令允许我们定义一个可以在整个样式表中重复使用的样式。</li><li><code>@include</code> 指令可以将混入（mixin）引入到文档中。</li></ul><h3 id="定义-mixin"><a class="header-anchor" href="#定义-mixin"></a>定义 mixin</h3><p>混入（mixin）通过 <code>@mixin</code> 指令来定义。 <code>@mixin name &#123; property: value; property: value; ... &#125;</code><br>以下实例创建一个名为 “important-text” 的混入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> important-text &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：Sass 的连接符号 <code>-</code> 与下划线符号 <code>_</code> 是相同的，也就是 <code>@mixin important-text &#123; &#125;</code> 与 <code>@mixin important_text &#123; &#125;</code> 是一样的混入。</p></blockquote><h3 id="使用-mixin"><a class="header-anchor" href="#使用-mixin"></a>使用 mixin</h3><p>@include 指令可用于包含一混入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">selector &#123;</span><br><span class="line">  <span class="keyword">@include</span> mixin-name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，包含 important-text 混入代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> important-text;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.danger</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入中也可以包含混入，如下所示：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> special-text &#123;</span><br><span class="line">  <span class="keyword">@include</span> important-text;</span><br><span class="line">  <span class="keyword">@include</span> link;</span><br><span class="line">  <span class="keyword">@include</span> special-border;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向混入传递变量"><a class="header-anchor" href="#向混入传递变量"></a>向混入传递变量</h3><p>混入可以接收参数。我们可以向混入传递变量。</p><p>定义可以接收参数的混入：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 混入接收两个参数 */</span></span><br><span class="line"><span class="keyword">@mixin</span> bordered(<span class="variable">$color</span>, <span class="variable">$width</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$width</span> solid <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myArticle</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> bordered(blue, <span class="number">1px</span>);  <span class="comment">// 调用混入，并传递两个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myNotes</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> bordered(red, <span class="number">2px</span>); <span class="comment">// 调用混入，并传递两个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例的混入参数为设置边框的属性 (color 和 width) 。</p><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myArticle</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myNotes</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混入的参数也可以定义默认值，语法格式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> bordered(<span class="variable">$color</span>: blue, <span class="variable">$width</span>: <span class="number">1px</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$width</span> solid <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在包含混入时，你只需要传递需要的变量名及其值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> sexy-border(<span class="variable">$color</span>, <span class="variable">$width</span>: <span class="number">1in</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">    color: <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    style: dashed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="keyword">@include</span> sexy-border(blue); &#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="keyword">@include</span> sexy-border(blue, <span class="number">2in</span>); &#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: blue;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1in</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: dashed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">border-color</span>: blue;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2in</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: dashed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时，不能确定一个混入（mixin）或者一个函数（function）使用多少个参数，这时我们就可以使用 <code>...</code> 来设置可变参数。</p><p>例如，用于创建盒子阴影（box-shadow）的一个混入（mixin）可以采取任何数量的 box-shadow 作为参数。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadows</span>...) &#123;</span><br><span class="line">      -moz-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">      -webkit-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">      <span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.shadows</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> box-shadow(<span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.shadows</span> &#123;</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览器前缀使用混入"><a class="header-anchor" href="#浏览器前缀使用混入"></a>浏览器前缀使用混入</h3><p>浏览器前缀使用混入也是非常方便的，如下实例：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> transform(<span class="variable">$property</span>) &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.myBox</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> transform(rotate(<span class="number">20deg</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.myBox</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br><span class="line">  -ms-<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">20deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sass-extend-与-继承"><a class="header-anchor" href="#Sass-extend-与-继承"></a>Sass @extend 与 继承</h2><p>@extend 指令告诉 Sass 一个选择器的样式从另一选择器继承。</p><p>如果一个样式与另外一个样式几乎相同，只有少量的区别，则使用 @extend 就显得很有用。</p><p>以下 Sass 实例中，我们创建了一个基本的按钮样式 <code>.button-basic</code>，接着我们定义了两个按钮样式 <code>.button-report</code> 与 <code>.button-submit</code>，它们都继承了 <code>.button-basic</code> ，它们主要区别在于背景颜色与字体颜色，其他的样式都是一样的。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button-basic</span>  &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-report</span>  &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-submit</span>  &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上代码转换为 CSS 代码，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button-basic</span>, <span class="selector-class">.button-report</span>, <span class="selector-class">.button-submit</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: none;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-report</span>  &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.button-submit</span>  &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @extend 后，我们在 HTML 按钮标签中就不需要指定多个类 class=“button-basic button-report” ，只需要设置 class=“button-report” 类就好了。</p><p>@extend 很好的体现了代码的复用。</p><h2 id="Sass-函数"><a class="header-anchor" href="#Sass-函数"></a>Sass 函数</h2><p>Sass 定义了各种类型的函数，这些函数我们可以通过 CSS 语句直接调用。</p><h3 id="Sass-字符串相关函数"><a class="header-anchor" href="#Sass-字符串相关函数"></a>Sass 字符串相关函数</h3><p>Sass String(字符串) 函数用于处理字符串并获取相关信息。</p><p>Sass 字符串的起始索引值从 1 开始，记住不是 0。</p><p>Sass 的字符串函数：</p><ul><li><code>quote(string)</code>：给字符串添加引号。</li><li><code>unquote(string)</code>：移除字符串的引号</li><li><code>str-index(string, substring)</code>：返回 substring 子字符串第一次在 string 中出现的位置。如果没有匹配到子字符串，则返回 null。</li><li><code>str-insert(string, insert, index)</code>：在字符串 string 中 index 位置插入 insert。</li><li><code>str-length(string)</code>：返回字符串的长度。</li><li><code>str-slice(string, start, end)</code>：从 string 中截取子字符串，通过 start-at 和 end-at 设置始末位置，未指定结束索引值则默认截取到字符串末尾。</li><li><code>to-lower-case(string)</code>：将字符串转成小写</li><li><code>to-upper-case(string)</code>：将字符串转成大写</li><li><code>unique-id()</code>：返回一个无引号的随机字符串作为 id。不过也只能保证在单次的 Sass 编译中确保这个 id 的唯一性。</li></ul><p>Sass 数字函数：</p><ul><li><code>abs(number)</code>：返回一个数值的绝对值。</li><li><code>ceil(number)</code>：向上取整</li><li><code>comparable(num1, num2)</code>：返回一个布尔值，判断 num1 与 num2 是否可以进行比较，单位是否相同或可以转换。</li><li><code>floor(number)</code>：向下取整</li><li><code>max(number...)</code>：返回最大值</li><li><code>min(number...)</code>：返回最小值</li><li><code>percentage(number)</code>：将数字转化为百分比的表达形式。</li><li><code>random()</code>：返回 0-1 区间内的小数</li><li><code>random(number)</code>：返回 1 至 number 之间的整数，包括 1 和 number。</li><li><code>round(number)</code>：返回最接近该数的一个整数，四舍五入。</li></ul><p>Sass 列表函数：</p><ul><li><code>append(list, value, [separator])</code>：将单个值 value 添加到列表尾部。separator 是分隔符，默认会自动侦测，或者指定为逗号（comma）或空格（space）。</li><li><code>index(list, value)</code>：返回元素 value 在列表中的索引位置。</li><li><code>is-bracketed(list)</code>：判断列表中是否有中括号</li><li><code>join(list1, list2, [separator, bracketed])</code>：合并两列表，将列表 list2 添加到列表 list1 的末尾。separator 是分隔符，默认会自动侦测，或者指定为逗号或空格。 bracketed 默认会自动侦测是否有中括号，可以设置为 true 或 false。</li><li><code>length(list)</code>：返回列表的长度</li><li><code>list-separator(list)</code>：返回一列表的分隔符类型。可以是空格（“space”）或逗号（“comma”）。</li><li><code>nth(list, n)</code>：获取第 n 项的值。</li><li><code>set-nth(list, n, value)</code>：设置列表第 n 项的值为 value。</li><li><code>zip(lists)</code>：将多个列表按照以相同索引值为一组，重新组成一个新的多维度列表。</li></ul><p>Sass <a href="https://www.runoob.com/sass/sass-map-func.html">Map 函数</a>:</p><ul><li><code>map-get(map, key)</code>：返回 Map 中 key 所对应的 value。如没有对应的 key，则返回 null 值。</li><li><code>map-has-key(map, key)</code>：判断 map 是否有对应的 key，存在返回 true，否则返回 false。</li><li><code>map-keys(map)</code>：返回 map 中所有的 key 组成的队列。</li><li><code>map-merge(map1, map2)</code>：合并两个 map 形成一个新的 map 类型，即将 map2 添加到 map1 的尾部</li><li><code>map-remove(map, keys...)</code>：移除 map 中的 keys，多个 key 使用逗号隔开。</li><li><code>map-values(map)</code>：返回 map 中所有的 value 并生成一个队列。</li></ul><p>Sass <a href="https://www.runoob.com/sass/sass-selector-func.html">选择器函数</a>：</p><ul><li><code>is-superselector(super, sub)</code>：比较两个选择器匹配的范围，即判断 super 选择器是否包含了 sub 选择器所匹配的范围，是的话返回 true，否则返回 false。</li><li><code>selector-append(selectors)</code>：将第二个 (也可以有多个) 添加到第一个选择器的后面。</li></ul><p>Sass <a href="https://www.runoob.com/sass/sass-introspection-func.html">Introspection 函数</a></p><p>Sass <a href="https://www.runoob.com/sass/sass-color-func.html">颜色函数</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sass 是一个 CSS 预处理器。&lt;/li&gt;
&lt;li&gt;Sass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。&lt;/li&gt;
&lt;li&gt;Sass 完全兼容所有版本的 CSS。&lt;/li&gt;
&lt;li&gt;Sass 扩展了 CSS3，增加了规则、变量</summary>
      
    
    
    
    <category term="Web" scheme="https://whl123456.top/categories/Web/"/>
    
    
    <category term="Sass" scheme="https://whl123456.top/tags/Sass/"/>
    
  </entry>
  
</feed>
