<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="https://halo123.top/atom.xml" rel="self"/>
  
  <link href="https://halo123.top/"/>
  <updated>2021-06-17T15:36:38.295Z</updated>
  <id>https://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>COⅠ基因</title>
    <link href="https://halo123.top/2021/06/17/Biology/CO%E2%85%A0%E5%9F%BA%E5%9B%A0/"/>
    <id>https://halo123.top/2021/06/17/Biology/CO%E2%85%A0%E5%9F%BA%E5%9B%A0/</id>
    <published>2021-06-17T15:30:01.000Z</published>
    <updated>2021-06-17T15:36:38.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="COⅠ基因简介"><a class="header-anchor" href="#COⅠ基因简介"></a>COⅠ基因简介</h2><p>编码线粒体细胞色素 C 氧化酶亚基 1（Cytochrome c Oxidase subunit 1，简称 COⅠ）</p><p>COⅠ基因位于动物线粒体DNA（mtDNA）的重链（H 链）的 tRNA-Lyr基因与 tRNA-Leu 基因之间，长度约为 1.6 kbp，COⅠ与细胞色素氧化亚基 2 （COⅡ）和亚基 3（COⅢ）共同构成参与级联反应的细胞色素氧化酶的核心结构。COⅠ基因为中度保守序列且碱基替换率较高，因而可作为优良的分子遗传标记被广泛地用于海洋动物的种及种以上阶元的分类及系统进化研究中。</p><h2 id="COⅠ基因的序列分析"><a class="header-anchor" href="#COⅠ基因的序列分析"></a>COⅠ基因的序列分析</h2><h3 id="COⅠ基因的核苷酸序列分析"><a class="header-anchor" href="#COⅠ基因的核苷酸序列分析"></a>COⅠ基因的核苷酸序列分析</h3><p>COⅠ基因序列分析是通过比较各类群个体间同源基因或基因片段的核酸序列，从而构建分子系统进化树，推断各类群间系统进化关系。目前利用 COⅠ基因的核苷酸序列构建分子系统进化树应用的最为广泛。</p><h3 id="COⅠ基因的氨基酸序列分析"><a class="header-anchor" href="#COⅠ基因的氨基酸序列分析"></a>COⅠ基因的氨基酸序列分析</h3><p>通过分析海洋动物 COⅠ的氨基酸序列来构建分子系统进化树。其优点在于可以避免由于密码子第 3 位的摇摆性而造成海洋动物间系统进化关系的不准确性。目前利用 COⅠ氨基酸序列探讨各类群间的系统进化关系尚处于起步阶段。</p><h3 id="COⅠ基因的-RFLP-分析"><a class="header-anchor" href="#COⅠ基因的-RFLP-分析"></a>COⅠ基因的 RFLP 分析</h3><p>RFLP（Restriction FragmentLengthPolymorphism）即限制性片段长度多态性，提出作为标记构建遗传连锁图谱的 。其分析技术是利用已知的限制性内切酶消化不同类群的同源 COⅠ基因的 DNA 分子, 电泳后 , 再用 DNA 探针杂交并放射自显影 ,从而得到与探针同源的 DNA 序列酶切图谱, 根据得到的非常稳定且特异的种间差异条带图谱计算各类群间遗传距离, 从而构建系统发育树。目前基于 COⅠ基因片段的 RFLP 分析技术在海洋动物中应用的较少 。</p><h2 id="参考文献"><a class="header-anchor" href="#参考文献"></a>参考文献</h2><ul><li>毕相东,杨雷,侯俊利等.COⅠ基因在海洋动物分子系统学研究中的应用[J].水产科学,2008(02):105-108.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;COⅠ基因简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#COⅠ基因简介&quot;&gt;&lt;/a&gt;COⅠ基因简介&lt;/h2&gt;
&lt;p&gt;编码线粒体细胞色素 C 氧化酶亚基 1（Cytochrome c Oxidase subunit 1，简称 COⅠ）&lt;/p&gt;</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>保护生物学复习资料整理</title>
    <link href="https://halo123.top/2021/06/17/Biology/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/%E4%BF%9D%E6%8A%A4%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    <id>https://halo123.top/2021/06/17/Biology/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/%E4%BF%9D%E6%8A%A4%E7%94%9F%E7%89%A9%E5%AD%A6/</id>
    <published>2021-06-17T14:40:48.000Z</published>
    <updated>2021-06-24T08:27:07.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程简介"><a class="header-anchor" href="#课程简介"></a>课程简介</h2><p>本课程是生物科学、生物技术专业的专业选修课之一。保护生物学是一门新兴的综合性学科，目标是<font color="#faa755">明确生物多样性的价值、生物多样性丧失的主要原因、人类活动对生物多样性的影响，掌握保护生物学的基本原理、方法和实施措施，自觉树立环境保护和可持续发展的意识</font>。它与进化论、生态学及社会学和人文哲学都相关联，从不同的角度阐述了生物保护的重要性和迫切性。</p><ul><li>保护生物学与生物多样性：保护生物学与及其发展、生物多样性及其测定、生物多样性的价值</li><li>生物多样性的兴衰与演变：生物多样性的形成与积累、生物多样性的波动与更迭、人类的诞生及早期的影响</li><li>生物多样性的丧失与保护：遗传多样性丧失与保护、物种多样性丧失与保护、生态系统多样性的保护</li></ul><h2 id="第一章-保护生物学及其发展"><a class="header-anchor" href="#第一章-保护生物学及其发展"></a>第一章 保护生物学及其发展</h2><h3 id="保护生物学的概念"><a class="header-anchor" href="#保护生物学的概念"></a>保护生物学的概念</h3><p>保护生物学的概念：从<font color="#faa755">保护生物及其环境</font>的角度出发，保护<font color="#d9730d">生物多样性</font>的科学。</p><p>保护生物学是论述全球生物多样性面临的严重丧失，并探讨<font color="#faa755">防止物种灭绝</font>的有效途径的新兴学科。</p><ul><li>论述全球生物多样性面临的严重丧失，<font color="#d9730d">基础研究</font></li><li>探讨防止物种灭绝的有效途径，<font color="#d9730d">应用研究</font></li></ul><h3 id="保护生物学的目的"><a class="header-anchor" href="#保护生物学的目的"></a>保护生物学的目的</h3><p>保护生物学的目的：</p><ul><li>强化<font color="#faa755">保护环境</font>的意识</li><li>树立<font color="#faa755">人与自然和谐</font>的观念</li><li>学习<font color="#faa755">保护生物多样性</font>的技术</li></ul><h3 id="保护生物学的诞生"><a class="header-anchor" href="#保护生物学的诞生"></a>保护生物学的诞生</h3><p>保护生物学的诞生：由生态学家米切尔·苏勒（Michel Soule）提出，<font color="#faa755">生物多样性在丧失</font>、<font color="#faa755">丧失的速度在加快</font></p><p>生物多样性：<font color="#d9730d">生物及其环境所组成的复合体以及与此相关的生态过程的多样化，及它们变化的多样化。</font></p><h3 id="保护生物学的研究对象"><a class="header-anchor" href="#保护生物学的研究对象"></a>保护生物学的研究对象</h3><p>保护生物学的研究对象：</p><ul><li><font color="#d9730d">生物多样性</font>，生物自身消长规律——产生、发展、消亡</li><li><font color="#d9730d">人类</font>，人类对其他物种带来的影响，人为的干扰和破坏</li></ul><h3 id="保护生物学的学科特点"><a class="header-anchor" href="#保护生物学的学科特点"></a>保护生物学的学科特点</h3><p>保护生物学的学科特点：</p><ul><li>保护生物学是一门<font color="#faa755">处理危机</font>的决策学科</li><li>保护生物学是一门<font color="#faa755">处理统计</font>现象的学科</li><li>保护生物学是一门<font color="#faa755">价值取向</font>的学科</li><li>保护生物学是具有<font color="#faa755">整体性和长远性</font>的学科</li><li>保护生物学是一门具有<font color="#faa755">伦理内涵</font>的学科</li></ul><h3 id="保护生物学与其他学科的关系"><a class="header-anchor" href="#保护生物学与其他学科的关系"></a>保护生物学与其他学科的关系</h3><p>保护生物学与其他学科的关系：保护生物学是由多门学科综合而成的新学科。它以<font color="#d9730d">资源学科和生物学科</font>为主，也涉及环境科学和社会科学。</p><h3 id="保护生物学思想的形成"><a class="header-anchor" href="#保护生物学思想的形成"></a>保护生物学思想的形成</h3><p>保护生物学思想的形成:</p><ul><li>国外保护思想的形成，现代保护生物学的许多观点在 100 多年前的欧洲科学著作中就已经有多体现。</li><li>国内保护思想的形成，我国自然保护意识的萌芽产生的更早，可以追溯到先秦的春秋战国时代。</li></ul><h3 id="人类对生物多样性丧失"><a class="header-anchor" href="#人类对生物多样性丧失"></a>人类对生物多样性丧失</h3><p>人类对生物多样性丧失的关注主要基于以下 4 个方面：</p><ul><li><font color="#d9730d">目前对生物多样性的威胁其广度和深度是前所未有的</font>；</li><li><font color="#d9730d">人口激增和科技进步，威胁与日俱增</font>；</li><li><font color="#d9730d">威胁因素的协同性，导致附加和倍增的恶果</font>；</li><li><font color="#d9730d">对生物多样性的危害最终将威胁人类自身</font>。</li></ul><h3 id="保护生物学的发展"><a class="header-anchor" href="#保护生物学的发展"></a>保护生物学的发展</h3><p>保护生物学的发展：</p><ul><li>1985 年美国成立了保护生物学学会：同时，创立 Conservation Biology 期刊，部分高校招收该学科的研究生，设立相关的国家基金并资助相关科学家。</li><li>我国起步较晚，起步于 20 世纪 90 年代中期，但是近几年来发展较快。</li></ul><h3 id="我国保护生物学概况"><a class="header-anchor" href="#我国保护生物学概况"></a>我国保护生物学概况</h3><p>我国保护生物学概况：</p><ul><li>广泛开展了自然环境和资源的调查工作：</li><li>建成了一批自然保护区，新的保护区的规划和建设正在进行之中；</li><li>自然保护的科研、教育、宣传、立法和国际合作等工作已全面展开；</li><li>部分珍稀物种保护和引种驯养工作已积极开展起来，建立了一批各种类型的动植物园、拯救中心；</li><li>一些保护生物学研究机构相继建立。</li></ul><h3 id="保护生物学的研究内容"><a class="header-anchor" href="#保护生物学的研究内容"></a>保护生物学的研究内容</h3><p>保护生物学的研究内容：</p><ul><li><font color="#d9730d">多样性的现状</font>。</li><li><font color="#d9730d">物种灭绝</font>。灭绝是保护生物学的主要研究内容，灭绝的研究目的是<font color="#e03e3e">预测生物多样性灭绝的趋势，阐明灭绝的原因，采取措施防止灭绝现象的发生</font>。</li><li><font color="#d9730d">进化的潜能、生存力分析</font>。种群为什么会灭绝？——所有物种个体被消灭了。灭绝是<font color="#e03e3e">种群丧失了进化的潜能</font>。功能性灭绝——白暨豚</li><li><font color="#d9730d">群落和生态系统</font>。<font color="#e03e3e">物种多样性（物种的丰富度和均匀度）</font>的持久性比单一型好。人类必须尽力保护复杂的生态系统，使物种能够共同生存。</li><li><font color="#d9730d">生境的恢复</font>。<font color="#e03e3e">自然生境的丧失，会引起生物群落结构功能的一系列变化</font>。（土地退耕、土地的合理使用），修复退化的土地和枯竭的生物群落生境，是保护生物学的一项重要工作。</li><li><font color="#d9730d">物种的回归自然和圈养繁殖</font>。人工饲养繁殖一些濒危物种，是迁地（异地）保护的一种方法，其目的是为了物种的复壮甚至重建野生生物种群。</li><li><font color="#d9730d">生物技术在物种保护中的应用</font>。 对未知物种进行定名和描述，完成物种的调查和编目工作；解决小种群遗传多样性损失和近交衰退问题；种群遗传结构和适应潜力分析；物种和群落的长期保存；生物安全问题。</li></ul><h3 id="保护生物学的研究趋势"><a class="header-anchor" href="#保护生物学的研究趋势"></a>保护生物学的研究趋势</h3><p>保护生物学的研究趋势（热点）：</p><ul><li>小种群的生存机制（生存概率）——最小生存种群</li><li>确定和保护生物多样性热点地区</li><li>关键种保护</li><li>功能群保护</li><li>生物技术的应用</li><li>物种濒危和濒危灭绝机制</li><li>生境破碎问题和恢复</li><li>自然保护区建设的理论</li><li>立法和公众教育</li></ul><p>——<font color="#e03e3e">遏制并扭转由人类造成的生物多样性下滑的趋势</font></p><h2 id="第二章-生物多样性及其测定"><a class="header-anchor" href="#第二章-生物多样性及其测定"></a>第二章 生物多样性及其测定</h2><h3 id="生物多样性"><a class="header-anchor" href="#生物多样性"></a>生物多样性</h3><p>生物多样性（Biodiversity）：<font color="#e03e3e">生物及其环境所组成的复合体以及与此相关的生态过程的多样化，及它们变化的多样化</font>。</p><p>生物多样性四大要素：</p><ul><li><font color="#faa755">生命有机体</font>：基因、物种、其他生命物质</li><li><font color="#faa755">生态复合体</font>：生物与环境构成的整体（群落、生态系统、景观）</li><li><font color="#faa755">多样性</font>：变异、数量、多度</li><li><font color="#faa755">变异性</font>：生态功能、生态过程</li></ul><p><font color="#e03e3e">各种各样的生物、生态复合体、生态过程，以及与之相关的各种变化的总和。</font></p><h3 id="遗传多样性"><a class="header-anchor" href="#遗传多样性"></a>遗传多样性</h3><p>遗传多样性（Genetic diversity）是生物多样性在基因层次上的表达，是生物体内决定性状的遗传因子及其组合的多样性。</p><h4 id="遗传多样性的定义"><a class="header-anchor" href="#遗传多样性的定义"></a>遗传多样性的定义</h4><ul><li>广义：<font color="#e03e3e">地球上所有生物携带遗传信息的总和</font>（McNeely, 1990）</li><li>狭义：<font color="#e03e3e">种内不同群体之间或同一群体内不同个体的遗传变异的总和</font>（施立明，1993）</li></ul><p>遗传多样性的三大要素：</p><ul><li><font color="#faa755">单一物种</font></li><li><font color="#faa755">各种基因</font></li><li><font color="#faa755">种下分类单元</font></li></ul><p>概括<font color="#faa755">遗传差异</font></p><h4 id="遗传多样性的产生"><a class="header-anchor" href="#遗传多样性的产生"></a>遗传多样性的产生</h4><ul><li>基因自身的变异<ul><li><font color="#faa755">突变</font>：染色体畸变，基因突变</li><li><font color="#faa755">重组</font>：同源重组，特定重组，异常重组</li></ul></li><li>外部条件途径：杂交、人工选择、基因流动</li></ul><p>染色体畸变：</p><ul><li><font color="#e03e3e">数目的变化</font>：倍变（单倍体、二倍体、三倍体），非倍变（单体、缺体、三体）；</li><li><font color="#e03e3e">结构的变化</font>：缺失，重复，易位，倒位</li></ul><p>基因畸变：</p><ul><li><font color="#e03e3e">突变的类型</font>：形态变化、生化变化、失去功能、获得功能、致死突变、条件致死</li><li><font color="#d9730d">突变的分子基础</font>：<ul><li><font color="#faa755">自发突变</font>：DNA 复制错误（转换、颠倒、移码突变、缺失或重复），自发损伤（脱嘌呤、脱氨基、氧化损伤）</li><li><font color="#faa755">诱发突变</font>：诱发剂（碱基类似物、嵌合剂、辐射、黄曲霉），影响结果（同义突变、错义突变、无义突变）</li></ul></li></ul><h4 id="遗传多样性的表达层次"><a class="header-anchor" href="#遗传多样性的表达层次"></a>遗传多样性的表达层次</h4><ul><li>分子水平上：DNA 序列变化，基因数目，染色体数量和形态等</li><li>个体水平上：多态现象、个体的生理和行为</li><li>群体水平上：不同亚种、品种、品系之间，不同种群之间</li></ul><h4 id="遗传多样性的测定"><a class="header-anchor" href="#遗传多样性的测定"></a>遗传多样性的测定</h4><ul><li>表型性状的分析</li><li>细胞水平的分析</li><li>分子水平的分析</li></ul><p>（一）表型性状的分析<br>表型性状的分析操作方法：选取性状 → 确定遗传基础 → 遗传变异的度量和分析<br>表型性状的分析存在缺陷：</p><ul><li>不能分析多基因编码的数量性状</li><li>单基因控制的性状少</li><li>只能分析有两个以上的等位基因的位点</li><li>不能客观地估计遗传变异性</li></ul><p>（二）细胞水平的分析：染色体标记<br>细胞水平的分析操作方法：细胞培养至中期 → 染色，制片，显微观察 → 度量和分析<br>遗传多样性主要表现在染色体变异程度上；观察的个体和细胞越多越好</p><p>（三）分子水平的分析——五大类</p><ul><li><font color="#e03e3e">蛋白质分析</font>：同工酶</li><li><font color="#e03e3e">传统 Southern 杂交 DNA 分析</font>：限制性片段长度多态（RFLP）</li><li><font color="#e03e3e">以 PCR 为基础的 DNA 分析</font>：随机扩增多态 DNA（RAPD）、扩增片段长度多态(AFLP)</li><li><font color="#e03e3e">以重复序列为基础的 DNA 分析</font>：微卫星 DNA（SSR）、简单重复序列间 DNA 多态（ISSR）、对 DNA 的直接测序</li><li><font color="#e03e3e">对 DNA 的直接测序</font></li></ul><p><font color="#d9730d">同工酶或等位酶分析</font>：20 世纪 50 年代一些科学家发现，同一种酶具有多种不同形式，它们催化同样的反应，只是<font color="#faa755">反应的最适 pH 和最适底物浓度不同</font>，因此将<font color="#faa755">这类结构不同、功能相似的酶称为同工酶</font>：即具有同一底物专一性的不同分子形式的酶。</p><p>同工酶分析的优点</p><ul><li>同工酶电泳具有<font color="#faa755">实验简便、成本低等</font>优点，可以方便地检测许多个体</li><li><font color="#faa755">酶电泳技术和染色方法成熟</font></li><li>一批同工酶基因位点的变异可以<font color="#faa755">比较客观</font>地代表基因组的变异</li></ul><p>同工酶分析的缺点</p><ul><li>相对于 DNA，酶的取材要求严格</li><li>酶活性可能<font color="#faa755">受环境和生理状态影响</font>，信息量偏低</li><li>只能检测编码酶蛋白的基因位点，所检测的位点数目受限；</li><li>受酶电泳和染色方法所限，常用的酶系统一般在<font color="#faa755"> 30 个</font>左右，因此一批等位酶位点的变异并不一定代表整个基因组的变异；</li><li><font color="#faa755">有一些隐藏的变异性</font>可能无法通过酶电泳技术检测出来，因此酶电泳技术可能会低估遗传变异的水平</li><li>在频危物种内，往往表现出很少的<font color="#faa755">多态</font>性，这时获得的信息量也偏少。</li></ul><hr><p><font color="#d9730d">限制性片段长度多态性（RFLP）分析</font></p><p>该技术是将核 (n)DNA、叶绿体 (cp)DNA、线粒体 (mt)DNA 或者总 DNA 提取出来，用<font color="#faa755">已知的限制性内切酶</font>进行酶切。然后电泳印迹，再与 DNA 探针杂交，并放射自显影，从而得到与探针同源的 DNA 序列。</p><p>RFLP 的基本步骤</p><ol><li>提取：提取DNA</li><li>酶切：利用限制性内切酶来识别模板DNA上的基因位点，进行切割</li><li>电泳：用琼脂糖电泳分离</li><li><font color="#faa755">转膜：转移到硝酸纤维素或尼龙膜上</font></li><li><font color="#faa755">探针标记：用专一序列的探针DNA在膜上与模板DNA杂交</font></li><li><font color="#faa755">自显影：显色或荧光，自显影显示与探针同源的DNA片段</font></li></ol><p>优点：</p><ol><li>多位点性，高变异性</li><li>具有高度个体特异性，信息量大</li><li>一个探针可以检测多以位点，稳定性及重复性强</li><li>条件符合孟德尔遗传规律，子代的每条条带几乎都可以在双亲中找到</li></ol><p>缺点：</p><ol><li>限制性内切酶的种类有限</li><li>RFLP 分析需要比较完善的实验条件，主要具备酶切、标记、分子杂交等技术的实验室</li><li>工作量大、成本高</li><li><font color="#faa755">放射性标记存在的安全问题</font></li></ol><hr><p>以 PCR 为基础的 DNA 分析：</p><ul><li><font color="#d9730d">聚合酶链反应（PCR）</font></li><li><font color="#d9730d">随机扩增多态 DNA(RAPD）</font>：用一组短而随机排列的核苷酸单链作为引物，对样本 DNA 进行 PCR 扩增</li></ul><p><font color="#faa755">优点</font>：</p><ol><li>所需样本量少</li><li>检测方法方便快速</li><li>效率高</li><li>引物无种属特异性，一套引物可用于不同物种的研究</li></ol><p><font color="#faa755">缺点</font>：</p><ol><li>实验重复性较差，影响了不同条件下实验的可比性</li><li>每个标记能提供的信息量小</li><li>有假阳性和假阴性结果</li><li>为显性标记，不能提供完整的遗传信息</li></ol><p><font color="#d9730d">扩增片段长度多态（AFLP）分析</font>：基于 RFLP 和 PCR 技术发明的指纹技术。</p><p>基本步骤：</p><ol><li>基因组DNA提取和纯化</li><li>限制性酶切及连接</li><li>预扩增</li><li>选择性 PCR 扩增</li><li>凝胶电泳</li><li>银染</li><li>数据分析</li></ol><p>优点：</p><ol><li>准确性高，灵敏度高，快速高效，结果稳定</li><li>所需DNA量少</li><li>多态性的检出率高</li><li>重复性好</li><li>可以在不知道基因组序列的情况下进行研究</li></ol><p>缺点：</p><ol><li>操作技术要求严格</li><li>有假阳性和假阴性的结果</li><li>有时出现凝胶背景杂乱</li></ol><hr><p>SSR 技术（简单重复序列标记）<font color="#d9730d">针对重复序列</font></p><p>基本步骤：</p><ol><li>提取DNA</li><li>加入重复序列两端保守序列引物</li><li>PCR 扩增</li><li>电泳检测</li><li>染色</li><li>读带</li></ol><hr><p>DNA 序列分析</p><p>优点：</p><ol><li>序列差异程度的衡量标准统一</li><li>提供足够多的研究分析的信息</li><li>可以解释不同层次的变异<br>缺点：</li><li>成本相对较高</li><li>研究位点大小和数量受限制</li></ol><h4 id="遗传多样性的计算"><a class="header-anchor" href="#遗传多样性的计算"></a>遗传多样性的计算</h4><p><font color="#ea66a6">杂合度</font>（heterozygosity）:某物种群体中含有杂合基因个体所占的比例。<br><font color="#d9730d">基因异合度</font>（gene diversity）：某物种群体中随机抽取两个的等位基因不相同的平均概率。<br><font color="#d9730d">遗传距离</font>（genetic divstance）:不同群体之间遗传分化的程度，一般用不同种群DNA核苷酸的平均差异数量表示<br><font color="#d9730d">固定系数</font>（fixation indices）:不同群体之间后代配子非相关的程度。</p><h4 id="遗传多样性研究的意义"><a class="header-anchor" href="#遗传多样性研究的意义"></a>遗传多样性研究的意义</h4><ol><li>指导人类生存和社会发展的基础</li><li>指导制定保护策略和措施</li><li>预测物种未来的发展趋势</li><li>有助于追溯生物进化的历史</li><li>探究现存生物进化的潜能</li><li>可以评估现存的各种生物的生存状况</li></ol><h3 id="物种多样性（Species-diversity）"><a class="header-anchor" href="#物种多样性（Species-diversity）"></a>物种多样性（Species diversity）</h3><h4 id="物种的概念"><a class="header-anchor" href="#物种的概念"></a>物种的概念</h4><p>Mayr 于 1982 年定义了生物学物种的概念：物种是在自然界中<font color="#faa755">占据特殊生态位</font>的<font color="#faa755">种群</font>的一个<font color="#faa755">生殖集群</font>，在<font color="#faa755">生殖</font>上与其他的物种相<font color="#faa755">隔离</font>。</p><p><font color="#d9730d">物种的固有特征</font>：</p><ol><li>物种是客观存在的</li><li>物种的非连续性</li><li>物种的生殖属性和表型属性的协调</li></ol><h4 id="物种多样性的概念"><a class="header-anchor" href="#物种多样性的概念"></a>物种多样性的概念</h4><p>指一定区域内物种多样性及其变化，包括一定区域内生物区系的状况，形成、演化，分布格局及其维持机制，是生物多样性在物种水平上的表现形式。</p><p><font color="#d9730d">物种多样性的3方面含义</font>：</p><ol><li>一定区域内物种的总和</li><li>物种分布的均匀程度</li><li>现有生物格局的形成、演化过程及维持机制</li></ol><h4 id="物种多样性的指标"><a class="header-anchor" href="#物种多样性的指标"></a>物种多样性的指标</h4><p><font color="#faa755">物种丰富度</font>（species richness）：一个区域内所有物种数目或某特定类群的物种数目。<br><font color="#faa755">物种均匀度</font>（species evenness）：一个区域内各个物种数量的一致程度，也叫物种相对多度。<br><font color="#faa755">特有物种比例</font>（endemic species ratio）：一定区域内特有物种与该区域物种总数的比值。</p><h4 id="物种多样性的表达"><a class="header-anchor" href="#物种多样性的表达"></a>物种多样性的表达</h4><p>物种多样性分布地区差异</p><ol><li>从<font color="#faa755">地区</font>看，热带和亚热带国家的生物多样性比较高；</li><li>从<font color="#faa755">生物群落</font>看，热带雨林是物种最多的地方；</li><li>从<font color="#faa755">特有物种分布</font>看，只生活在地球某个特定地区的物种分布也是不均匀的，特有物种越多，物种丰富度越高。</li></ol><p>物种特有性格局<br><font color="#d9730d">特有性</font>（endemism）：一切不属于世界性分布的属或种都可以称之为分布区内的特有属或特有种。</p><p>Myers 所划分的 18 个物种多样性热点地区，均为植物及其他类群特有性比较高的地区。如：新喀里多尼亚有特有植物 1400 种，占该地区植物种类的 89%；马达加斯加有特有植物 4900 种，占该地区植物种类的 82%。</p><p>物种多样性的时间格局<br><font color="#e03e3e">总体进化格局</font>：物种的总量在逐渐增加  。<br><font color="#e03e3e">大尺度时间格局</font>： 在某个地质时期内，物种总量比较恒定 。<br><font color="#e03e3e">生态演替格局</font>：受到干扰后，物种重新有序定居的规律。<br><font color="#e03e3e">季节变化格局</font>：物种数量随季节产生的周期性变化。</p><p>物种多样性的空间格局<br><font color="#e03e3e">纬度格局</font>：物种多样性随纬度变化表现出来的变化规律，一般是极地物种多样性最低，随纬度的降低，物种多样性增加，在热带雨林达到最大。</p><p>无论从<font color="#faa755">区域物种多样性水平上</font>，还是从<font color="#faa755">群落物种多样性水平上</font>都表现出这样的规律。</p><ul><li>哺乳动物、鱼类、爬行动物等大多数脊椎动物，随纬度降低物种多样性增加；</li><li>鸟类：热带地区种类最多，但鸟类多样性的纬度梯度特征比较复杂；</li><li>软体动物、蜻蜓、蝴蝶等很多无脊椎动物，也表现出明显的纬度梯度特征；</li><li>两栖类、地衣、海洋底栖生物、寄生蜂、土壤线虫等在北纬35度附近物种多样性达到最大值。</li></ul><p><font color="#e03e3e">海拔格局</font>：物种多样性海拔高度表现出来的变化规律，一般是海拔越高，物种越少。</p><p>群落类型及环境因素在沿海拔和沿纬度梯度变化方面有很大的相似性：沿海拔梯度每升高 1000m，气温降低 6℃，相当于沿纬度梯度往北递进 500 ～ 750 Km。</p><p><font color="#e03e3e">经度格局</font>：物种多样性经度不同表现出来的变化，一般是大陆上南北走向的沿海地区物种要多于内陆。<br><font color="#e03e3e">栖息地格局</font>：物种多样性随栖息地条件表现出来的变化，一般栖息地面积越大，<font color="#faa755">环境越多样</font>，物种就越多。</p><p>物种多样性空间分布格局的形成机制：<br><font color="#faa755">气候因子假说</font>：适宜的气候因子允许较多的物种生存。<br><font color="#faa755">气候变率假说</font>：稳定的气候为物种分化创造了条件。<br><font color="#faa755">生境异质性假说</font>：物理因子或生物因子的复杂性孕育了较多的生态位。<br><font color="#faa755">能量假说</font>：物种丰富性程度，由每个物种所分配到的能量所决定，<br><font color="#faa755">竞争假说</font>：一方面竞争有利于减小生态位宽度，另一方面竞争排斥减少物种数目。</p><h4 id="物种多样性的测定"><a class="header-anchor" href="#物种多样性的测定"></a>物种多样性的测定</h4><p>直接测定</p><ul><li><font color="#d9730d">物种丰富度调查</font>：物种编目。具体方法：物种分类、鉴定，汇集成册，登记，建立数据库。<font color="#faa755">外推法</font>：用样方计算某个特定类群已知物种和未知物种的比值，再外推到整个地区。昆虫</li><li><font color="#d9730d">物种多度调查</font>：植物(样方法)、标记重捕法(鱼类)、夹日法(小鼠)……</li><li><font color="#d9730d">特有物种数量调查</font></li></ul><p>间接测定</p><ul><li><font color="#d9730d">α 多样性指数</font>：测量单一地区或生物群落中的物种丰富度</li><li><font color="#d9730d">β 多样性指数</font>：测定不同地区或群落物种多样性沿环境梯度而出现的变化</li><li><font color="#d9730d">γ 多样性指数</font>：度量整体大区域的多样性，也称为尺度物种多样性</li></ul><p>化石测定，测定物种多样性进化中的时间格局</p><ul><li><font color="#d9730d">缺失法</font>：某个物种的化石在某个地层是否消失<br>+<font color="#d9730d">标记重捕法</font>：把一系列岩层按年代顺序排列，从第一层开始记录有化石的物种</li></ul><h4 id="物种多样性的研究趋势"><a class="header-anchor" href="#物种多样性的研究趋势"></a>物种多样性的研究趋势</h4><ul><li>物种多样性的编目；</li><li>物种多样性的形成、演化、空间格局及维持机制等理论的问题需深入讨论；</li><li>物种的濒危状况、灭绝速率及灭绝原因；</li><li>特有现象的形成及格局需要进一步研究；</li><li>大尺度上探讨我国物种多样性的空间格局及生态因子的关系。</li></ul><h3 id="生态系统多样性"><a class="header-anchor" href="#生态系统多样性"></a>生态系统多样性</h3><h4 id="生态系统的概念"><a class="header-anchor" href="#生态系统的概念"></a>生态系统的概念</h4><p>生态系统是在一定空间范围内，生物与非生物通过<font color="#faa755">能量流动</font>、<font color="#faa755">物质循环</font>和<font color="#faa755">信息交流</font>共同构成的一个生态学单位，是<font color="#faa755">生物群落与其环境形成的生态复合体</font>。</p><ul><li>具有一定的结构与功能</li><li>生产者、消费者、分解者——食物链、食物网</li></ul><p><font color="#faa755">主要是指生物圈内的生境、生物群落和生态过程的多样化，以及它们变化的多样化。</font></p><p>生态系统多样性包含多个层次的多样性：</p><ul><li>群落多样性：群落的组成、结构和动态方面的多样性</li><li>生态位多样性、物种多样性、营养多样性</li><li>生态系统多样性</li></ul><p><font color="#faa755">生态系统多样性的影响因素</font>：</p><ul><li>物理环境：水热条件，地形，干扰……</li><li>物种：生物影响环境</li><li>物质循环、能量流动</li></ul><p><font color="#faa755">生态系统多样性的变化</font>：</p><ul><li>物理环境的变化</li><li>生物的进化</li><li>生物区系的变化</li></ul><p>中国陆地生态系统分类：《中国植被的分类》将其分成 595 类生态系统，其中：森林生态系统：248 类、灌丛生态系统（包括灌草丛生态系统）：126 类、草原生态系统：55 类、荒漠生态系统：52 类、草甸生态系统：77 类、沼泽（湿地）（红树）：37 类、以及荒漠和农田</p><h4 id="关键地区"><a class="header-anchor" href="#关键地区"></a>关键地区</h4><p>确定生物多样性关键地区必须具备 4 个原则：丰富性、特殊性、受威胁的程度、经济价值</p><p>中国生物多样性保护的关键地区，陈灵芝（1993）确定了中国生物多样性关键地区 35 个：</p><ul><li>具有<font color="#faa755">国际意义</font>的陆地生态系统 14 个；</li><li>具有<font color="#faa755">全国意义</font>的陆地生态系统 5 个；</li><li><font color="#faa755">湿地和淡水域</font>生物多样性关键地区 5 个；</li><li><font color="#faa755">海洋</font>生物多样性关键地区11个。</li></ul><p>具有<font color="#faa755">国际意义</font>的陆地生态系统 14 个；</p><ul><li>青海可可西里地区</li><li>四川西部高山峡谷区</li><li>西藏东南部山地</li><li>云南西部高山峡谷区</li><li>云南西双版纳地区</li><li>广西西南石灰岩地区</li><li>广东、广西、湖南、江西南岭山地</li><li>云南、贵州、四川、湖北边境山地</li><li>海南中南部山地地区</li><li>河北北部山地</li><li>秦岭太白山地区</li><li>长白山地区</li><li>浙江、福建山地地区</li><li>台湾中央山脉</li></ul><h4 id="生态系统多样性的表达"><a class="header-anchor" href="#生态系统多样性的表达"></a>生态系统多样性的表达</h4><p>生态系统的服务</p><p>生态系统的服务是生态系统内部多样性的表达，它代表了生态系统中的功能与过程：</p><ul><li><font color="#faa755">供给服务</font>：提供资源，衡量产量、库存和生产潜力</li><li><font color="#faa755">调解服务</font>：调节作用，净化环境、调节气候等</li><li><font color="#faa755">文化服务</font>：赋予人类的非物质好处</li><li><font color="#faa755">支持服务</font>：支撑生命</li></ul><h4 id="生态系统多样性的测定"><a class="header-anchor" href="#生态系统多样性的测定"></a>生态系统多样性的测定</h4><p>调查</p><p><font color="#e03e3e">各地区、每群落至少调查3块样地！</font></p><ul><li>A 区：调查直径 5 cm 以上的乔木种类、每种的数量</li><li>B 区：调查灌木及胸径 5 cm 以下的乔木的种类和每种数量</li><li>C 区：调查草本种类和数量</li></ul><p>对生态系统进行评估</p><p>千年生态系统评估：<font color="#faa755">生态系统为人类提供的服务</font></p><p>对服务功能的测量，<font color="#faa755">多元分析途径</font>：测量每项服务，分析它们之间的关系</p><ul><li>尺度：空间尺度、时间尺度</li><li>供给功能：流量、<font color="#faa755">储存量</font></li><li>调节功能：弹性</li><li>文化服务：很难衡量</li><li>支持服务：通过其他服务的状况加以推测，考察长期的变化</li></ul><p>对未来趋势的分析，千年生态系统评估提出四种假设：</p><ul><li>全球协同：全球性共同应对可能出现的问题</li><li>实力秩序：地区性解决可能出现的问题</li><li>适应组合：各个地区主动开展对生态系统的管理</li><li>技术乐园：全世界共同主动开展对生态系统的管理</li></ul><h2 id="第三章-生物多样性的价值"><a class="header-anchor" href="#第三章-生物多样性的价值"></a>第三章 生物多样性的价值</h2><h3 id="价值类型及划分"><a class="header-anchor" href="#价值类型及划分"></a>价值类型及划分</h3><h4 id="考察的途径"><a class="header-anchor" href="#考察的途径"></a>考察的途径</h4><p>生物多样性 → 生态系统及功能 → 人类福利：<font color="#faa755">生态系统对人类的重要性</font>：包括生态系统结构的价值，生态系统功能上的价值<br>生物多样性 → 生态系统及功能 → 物种及遗传 → 人类福利：<font color="#faa755">生态系统与各物种之间的相互关系和作用，以及对物种和遗传多样性的维持</font><br>生物多样性 → 物种及遗传 → 人类福利：<font color="#faa755">地球上其他物种对人类的重要性</font><br>生物多样性 → 人类福利：<font color="#faa755">考察生物多样性与人类的关系</font></p><h4 id="价值的类型"><a class="header-anchor" href="#价值的类型"></a>价值的类型</h4><p><font color="#faa755">使用价值</font>：为实现某种需要而人为划定的效用价值。提供食物、原料、能源等。直接使用价值、间接使用价值、选择价值<br><font color="#faa755">非使用价值</font>：生命主体不受任何影响的内在价值。大自然本身。存在价值</p><h3 id="可使用价值"><a class="header-anchor" href="#可使用价值"></a>可使用价值</h3><h4 id="直接使用价值"><a class="header-anchor" href="#直接使用价值"></a>直接使用价值</h4><p>指生物多样性能满足人类生产和生活需要的价值，能相对容易的被观察和计算，可以用货币估价。</p><ul><li><font color="#faa755">消耗性自用价值</font>：指那些没有经过市场，直接消耗的自然产品的价值，这部分价值通过估计市场价值的机制来确定</li><li><font color="#faa755">消耗性生产价值</font>：指那些商业性收获，供正规市场上交换的生物资源价值。</li></ul><p>消耗性使用价值</p><ul><li>竹林、树林：提供工业和建筑材料</li><li>野生植物：药用价值</li><li>野生动物：药用价值</li><li>提供肉食，蛋白</li><li>提供粮食</li><li>提供水果</li></ul><p>非消耗性的价值——娱乐文化价值</p><ul><li>生物多样性的娱乐价值也称为美学价值、宜人价值。</li><li>也包含了间接使用价值和非使用价值的成分</li></ul><p>生态旅游、文化</p><h4 id="间接使用价值"><a class="header-anchor" href="#间接使用价值"></a>间接使用价值</h4><ul><li>与生态系统有关的价值，一般用大自然的各种服务来表达</li><li>不能直接统计，可以间接估计</li><li><font color="#faa755">具有多样性的生态系统在全球的</font><font color="#d9730d">大环境</font><font color="#faa755">中所起到的稳定水文、保持土壤、维持区域环境的动态平衡等方面的作用</font></li></ul><p><font color="#faa755">生态系统的服务保障人类的福利</font></p><ul><li>供给服务：直接关系到人类的物质生活</li><li>调节服务：提供基本的生活条件</li><li>文化服务：非物质好处</li><li>支持服务：前三类服务的保证</li></ul><p><font color="#faa755">生态价值</font></p><ul><li>蛛网假说：物种越多，网越稳定。<font color="#d9730d">群落整体稳定的重要性</font></li><li>铆钉假说：物种的生态作用各不相同，有些是关键物种或关键类群</li><li>指南假说：每个物种都携带不同的信息，犹如大自然这本书中的一页。保护其他物种，也就是保护我们人类自己。</li><li>冗余假说：物种数量有最小阈值</li><li>补偿/关键种假说：物种的作用存在一定阈值</li><li>单峰假说</li><li>非线性假说</li><li>不确定假说</li><li>零假说：物种的增减对生态系统没什么影响</li><li>弱相互作用假说：协同合作</li></ul><h4 id="选择价值"><a class="header-anchor" href="#选择价值"></a>选择价值</h4><p>指生物多样性在科学上的一切可能价值，介于可使用价值与非使用价值之间</p><ul><li><font color="#faa755">潜在价值</font>，很多物种的功能特性还没有被人们所了解，都具有潜在价值</li><li>借鉴价值</li><li>遗产价值：保持生物多样性为未来的人类提供多方面的选择，从而使其有能力应对将来生态和社会经济中有可能发生的不可预料的事件。</li></ul><h3 id="非使用价值"><a class="header-anchor" href="#非使用价值"></a>非使用价值</h3><h4 id="物种的存在价值"><a class="header-anchor" href="#物种的存在价值"></a>物种的存在价值</h4><ul><li>每个物种都用自己的地位与作用</li><li>物种没有贵贱之分</li><li><font color="#d9730d">人类没有权利去灭绝任何一个物种</font></li></ul><h4 id="地球的整体价值"><a class="header-anchor" href="#地球的整体价值"></a>地球的整体价值</h4><p>地球是一个巨大的有机体，存在生命现象与规律，具有自我调节和内稳的能力。人类活动对地球生态系统的干扰</p><h3 id="价值类型"><a class="header-anchor" href="#价值类型"></a>价值类型</h3><ol><li>直接使用价值<ul><li>产品及加工品直接使用价值，林业、农业、畜牧业、渔业、医药业、工业、消费性利用价值</li><li>文化服务价值，旅游观光价值、科学文化价值、蓄力使役价值</li></ul></li><li>间接使用价值，有机物生产、维持大气平衡、物质循环、水土保持、净化环境</li><li>选择价值，已发现价值、潜在使用价值、潜在保留价值</li><li>存在价值，确保自己或别人将来能利用某种资源或某种效益</li></ol><h3 id="价值评估方法"><a class="header-anchor" href="#价值评估方法"></a>价值评估方法</h3><h4 id="货币估价"><a class="header-anchor" href="#货币估价"></a>货币估价</h4><ul><li><font color="#faa755">直接销售估价</font>：可以在市场出售或交易的生物产品</li><li><font color="#faa755">替代品估价</font>：用已有商品的货币价值去估算尚不清楚的资源价值</li><li><font color="#faa755">费用支出估价</font>：对与生物多样性有关的行业消费综合估价（旅游）</li><li><font color="#faa755">合同价值估价</font>：适用于与自然开发有关的企业或活动</li></ul><h4 id="支付意愿"><a class="header-anchor" href="#支付意愿"></a>支付意愿</h4><p>人们对某个价值可以或愿意接受的程度。</p><ul><li><font color="#faa755">预防支出（避免支出）</font>：避免某个事物消失，人们主动承担的预防性费用</li><li><font color="#faa755">产品函数</font>：用已有价格推算未知价值</li><li><font color="#faa755">享乐支付</font></li><li><font color="#faa755">酌情评价</font>：问卷调查诱导人们提出对事物的偏好程度</li><li><font color="#faa755">选择模型</font>：问卷调查让人们进行选择</li><li><font color="#faa755">参与式评估</font></li></ul><h4 id="环境评估"><a class="header-anchor" href="#环境评估"></a>环境评估</h4><p>目前国际上不断流行的方法之一，主要靠成本-效益分析来衡量环境的价值，或评价人类活动给环境可能带来的损失和影响。</p><ul><li><font color="#faa755">市场监测</font></li><li><font color="#faa755">资本投入</font></li><li><font color="#faa755">绿色 GDP 分析</font></li><li><font color="#faa755">环境效应分析</font></li></ul><h2 id="第四章-生物多样性的形成与积累"><a class="header-anchor" href="#第四章-生物多样性的形成与积累"></a>第四章 生物多样性的形成与积累</h2><h3 id="遗传多样性的由来"><a class="header-anchor" href="#遗传多样性的由来"></a>遗传多样性的由来</h3><h4 id="生命的起源"><a class="header-anchor" href="#生命的起源"></a>生命的起源</h4><p>抛开神创论和其他谬论，地球上生命的起源可以归纳为三类：<font color="#d9730d">宇宙起源</font>、<font color="#d9730d">地球起源</font>、<font color="#d9730d">多空间起源</font></p><p>生命的<font color="#faa755">宇宙起源</font>，宇宙大爆炸：至今 136 ～ 138 亿年，<font color="#e03e3e">地球上的生命来自宇宙</font>：</p><ul><li>太空中有水：火星、木星木卫二、土星卫星等</li><li>陨石中有生命物质：单糖、糖醇、糖酸、氨基酸、二氨基酸等</li><li>太空中发现有微生物：地外细菌、有水的木卫二和土卫六中也可能存在微生物</li></ul><p>生命的<font color="#faa755">地球起源</font>——地球上的生命是地球自己产生的：<br><font color="#d9730d">生命化学起源</font>：地球上的生命是在地球温度逐步下降以后，在极其漫长的时间内，由<font color="#faa755">非生命物质经过极其复杂的化学过程</font>，一步一步地演变而成的。</p><ul><li>地壳、原始海洋和大气形成</li><li><font color="#d9730d">蛋白质-核酸共同起源说</font>：小分子原材料先结合成磷酰化氨基酸，然后再沿两条途径交织循环，最后复制出蛋白质和核酸。</li></ul><p>生命<font color="#faa755">多空间起源</font>——多起源说，适宜的地方都可能形成生命</p><ul><li>高温、高压、高盐、极端pH、高寒、高旱等极端环境中也存在生命——菌类、螨虫</li><li><font color="#faa755">古核生物</font>：一些生长在极端特殊环境中的生物。</li></ul><h4 id="细胞的形成"><a class="header-anchor" href="#细胞的形成"></a>细胞的形成</h4><p>细胞萌芽</p><ul><li>地球上的无机物质经过一系列化学反应产生出有机物质，在一定条件下有聚体成蛋白质、RNA、DNA等团聚体。</li><li><font color="#e03e3e">超级循环组织</font>：化学大分子自组织系统，可实现各类团聚体之间的复杂合作，称为准物种。</li><li><font color="#faa755">生物膜的形成</font>：经过漫长的过程，原始的生命体被原始膜包裹起来，保护里面的有机物质，独立于环境，变成原始生物</li></ul><p>原核细胞</p><ul><li>最早的细胞是无细胞核的，称为原核细胞。</li><li>原核细胞一般是单细胞独立生活的，称为原核生物。</li><li>原核生物是地球上最早的真正生物，可能形成与原始海洋、淡水湖泊或太空。</li><li>原核生物在进化中主要分成两类：<font color="#faa755">细菌</font>和<font color="#faa755">古细菌</font>。<ul><li>真细菌：所有细菌、放线菌、衣原体、支原体等原核生物</li><li>古细菌：产烷球菌、盐菌、硫氧化菌等</li></ul></li></ul><p><font color="#faa755">三类生物：古菌、细菌、真核生物</font></p><p>真核细胞</p><p>真核细胞与原核细胞的不同之处：</p><ul><li>需要氧来完成有丝分裂，生存所需的氧是生物自身创造出来的</li><li>出现有效保护遗传物质的细胞核，细胞核应该源自细胞膜的内陷</li><li>逐渐出现细胞器，细胞器应该源自细胞的内共生</li></ul><p><font color="#e03e3e">细胞器的出现标志着地球真核生物时代的开始</font></p><h4 id="基因的形成"><a class="header-anchor" href="#基因的形成"></a>基因的形成</h4><p>早期的遗传物质：RNA、DNA、蛋白质、脂质（脂肪：甘油+三分子脂肪酸，类脂：固醇）</p><p>遗传密码及演变：遗传密码是指核苷酸中的每三对碱基能组成一个信息，指挥生成一种氨基酸，称为<font color="#faa755">三联体密码</font>。</p><ul><li>密码的三对碱基通常不稳定，克服不稳定的通用机制是慢慢演变出<font color="#faa755">同义密码</font>和<font color="#faa755">中性氨基酸</font></li></ul><p>遗传密码的演变可能经历 5 个阶段：：</p><ol><li><font color="#faa755">原始三联体密码</font> (GNC)：GAC——天冬氨酸、GUC——缬氨酸、GGC——甘氨酸、GCC——丙氨酸</li><li><font color="#faa755">GNY</font>：Y 代表 C 或者 U ——4 种氨基酸</li><li><font color="#faa755">RNY</font>：Y 代表 C 或者 U，R 代表 G或者 A —— 8 种氨基酸，生命开始复杂化</li><li><font color="#faa755">RNN</font>：13 种氨基酸，<font color="#d9730d">起始密码子 AUG 出现，生物的遗传复制有了一定的顺序——标志着遗传信息准确传递的开始</font></li><li><font color="#faa755">NNN</font>：20 种氨基酸，<font color="#d9730d">无义密码子 UAA、UAG、UGA 出现——标志着生物复制机制的成熟</font></li></ol><p>缬氨酸、丙氨酸、天冬氨酸、甘氨酸含量多，最常见。G、C比A、U含量多</p><p>遗传基因的组建：</p><ul><li>原核细胞：DNA能自我复制，通过拟有性生殖方式与别的DNA结合组成新的DNA。</li><li>真核细胞：DNA被束缚在细胞核中，演变成染色体，形成基因。</li><li>基因靠突变来改变自己：有利突变：通常会得到保留、有害突变：即可得到保留，也可随个体死亡而被淘汰、中性突变：靠随机过程固定</li><li>生物的基因库不是僵化不变的，而是经常在更新和优化之中。</li></ul><h3 id="物种多样性的兴起"><a class="header-anchor" href="#物种多样性的兴起"></a>物种多样性的兴起</h3><h4 id="物种的概念-v2"><a class="header-anchor" href="#物种的概念-v2"></a>物种的概念</h4><p>早期的物种概念：</p><ul><li>17 世纪英国博物学家 Ray 首次使用物种（species）一词，认为<font color="#faa755">形状相同或相似的个体应该属于同一物种</font>，并有别于其他类似的集合——<font color="#d9730d">物种形态学概念</font>(Morphological species concept, <font color="#e03e3e">MSC</font>)</li><li>法国博物学家Buffon提出物种进化与繁殖中断等想法</li><li>19世纪初，法国博物学家Lamarck率先提出生物进化</li><li>1859年，Darwin出版《物种起源》</li><li><font color="#d9730d">物种进化概念</font>(Evolutionary species concept, <font color="#d9730d">ESC</font>)：物种是一个在时间和空间上都相对独立的进化分支，是由祖裔关系的种群之合；每个物种有独有的特征与血统，独特的历史命运，以及独特的进化潜力和趋势，从而有别和分离于其他类似分支。</li></ul><p>现代物种概念：</p><ul><li><font color="#e03e3e">物种生物学概念</font>(Biological species concept, <font color="#e03e3e">BSC</font>)：物种是一组相互繁殖的个体所组成的种群，亦称<font color="#faa755">同类交配群</font>，并与其他繁殖群在生死上相互隔离。</li><li><font color="#e03e3e">现代进化综合论</font> (新达尔文理论，Modern evolutionary synthesis, <font color="#e03e3e">MES</font>)：新的物种实际上是旧种群<font color="#faa755">基因频率变化与重新固定</font>的结果，物种只是基因型与表型在时空上变化的产物。</li><li><font color="#e03e3e">系统发生学概念</font> (Phylogenetic species concept, <font color="#e03e3e">PSC</font>)：物种是共享一个以上可鉴别特征单源的最小群体。单源（Monophyletic）：指具有共同祖先或亲缘关系紧密的所有个体，它们能用共同的生殖隔离机制与其他单源并行进化。可鉴别特征：指生物化学和分子生物学特征，尤其是基因的一致。</li></ul><p>物种的基本特征：</p><ol><li>一个物种的所有个体都必须具有相对稳定和普遍一致的<font color="#faa755">形态</font>；</li><li>一个物种的所有个体都必须具有相同的<font color="#faa755">生理遗传特征</font>，必须属于同一个生殖交配集群；</li><li>一个物种必须能代表<font color="#faa755">生物进化中的独立分支</font>；</li><li>一个物种必须是以<font color="#faa755">群体方式</font>生活在特定的地理区内。</li></ol><h4 id="物种的形成"><a class="header-anchor" href="#物种的形成"></a>物种的形成</h4><p>物种形成（Speciation）是指一个新种产生的过程，是生物进化的过程之一。</p><p>物种形成模式：<br><font color="#d9730d">异域形成物种</font>——某个原有物种在不同地域里演变成两个以上物种的过程，断裂形成物种（allopatric）、外迁形成物种（peripatric）</p><ul><li><font color="#faa755">断裂形成物种</font>：在出现大的地理变化或物种活动范围过大时发生，断裂后的物种通常会被两类障碍长期隔离：剪切式、围壕式</li><li><font color="#faa755">外迁形成物种</font>：原有大群的部分个体离开主群，到另一个地方占据生态位，形成小而孤立的外围种群。</li></ul><p><font color="#d9730d">同域形成物种</font>——由于某种原因，某个原有物种在同一个地域内演变成两个以上物种的过程。</p><ul><li>分布区边缘形成物种（parapatric）：局部地理障碍、新的生态位</li><li>分布区内部形成物种（sympatric）：可能与食物等生态因素或基因变化有关</li></ul><p><font color="#d9730d">杂交形成物种</font>——不同物种之间发生了基因交换，从而生成了新的物种，需要具备 4 个条件：</p><ol><li>两个杂交物种必须是<font color="#faa755">亲缘关系</font>很近的物种，染色体组能彼此吻合；</li><li>杂交产生的后代不能再与原种回交，否则新种会很快消失；</li><li>新种要<font color="#faa755">占据新的生境和生态位</font>，不能与父母种发生竞争；</li><li>新种必须<font color="#faa755">适应新的环境</font>，否则会被很快淘汰。</li></ol><h4 id="物种的发展"><a class="header-anchor" href="#物种的发展"></a>物种的发展</h4><p>物种的维持，物种维持的根本机制：<font color="#faa755">隔离</font>（isolation）</p><ul><li><font color="#faa755">合子前隔离</font>——交配前隔离/前隔离</li><li><font color="#faa755">合子后隔离</font>——交配后隔离/后隔离</li></ul><p><font color="#d9730d">合子前隔离</font>，能够避免不同物种的交配机制，以维持物种的独立性。</p><ul><li>生态隔离：地理隔离、时间隔离、生态位隔离</li><li>生殖隔离：行为隔离、机械隔离、配子隔离</li></ul><p><font color="#d9730d">合子后隔离</font>，采取消灭杂交后代的机制，不让杂交后代有维持发展的机会。</p><ul><li>杂种不活</li><li>杂种不育，骡子、狮虎兽</li><li>杂种衰败</li></ul><p><font color="#d9730d">物种的巩固</font>（Reinforcement）：新物种形成之后要经历的一系列过程，能使物种的隔离得到强化，从而推动物种的稳定与发展</p><p><font color="#e03e3e">物种的巩固过程</font>：</p><ol><li>必须经过<font color="#faa755">自然选择——适者生存</font>，稳定性选择、前进行选择、平衡多态性选择</li><li>要主动在<font color="#faa755">遗传上发生改变</font>；染色体数量、结构的变化，基因突变</li><li>要主动在<font color="#faa755">行为上进行调整</font>，尤其是有性生殖动物的交配行为；</li><li>要主动<font color="#faa755">实现适应性转型</font>，在生活习性上产生新的适应，也要在形态、生理、解剖结构上产生适应性变化；</li><li>在经历建群效应的磨砺时，会增强隔离的程度。</li></ol><p><font color="#d9730d">物种多样化</font>（Diversification）：塑造物种多样化的 8 条途径：</p><ol><li>物种的线系渐变</li><li>物种的间断平衡：停滞——爆发</li><li>物种的并行形成</li><li>物种的适应辐射</li><li>不等的进化速度</li><li>不等的寿命</li><li>进化的不可逆性</li><li>物种的非适应进化</li></ol><h3 id="地球生物圈的形成"><a class="header-anchor" href="#地球生物圈的形成"></a>地球生物圈的形成</h3><p><font color="#d9730d">生物圈</font>（Biosphere）：是指地球有生物存在的部分，是地球表面不连续的一个薄层，不同地方厚度有所不同。包括岩石圈的上层、整个土壤圈、水圈、大气的下层，海平面以上 10000 m ～ 海平面以下 11000 m 全部有生命活动的空间区域。</p><h4 id="物理环境的形成"><a class="header-anchor" href="#物理环境的形成"></a>物理环境的形成</h4><p>物理环境：阳光、土地、空气、水</p><ul><li><font color="#d9730d">土地的生成</font>。土地：指生物生活所在的陆地，主要包括岩石圈和土壤圈</li><li>岩石圈的形成</li><li>土壤圈的形成。土壤是岩石圈表面能够生长植物的疏松表层。五大成土因素——母质、气候、地形、生物、时间</li><li>水圈的形成。水圈：指地球上有水的地方，包括海洋、河流、湖泊、地下水、冰川、大气中的水蒸气等。地球形成初期就有水蒸气，但是很快被太阳风驱散了。水的形态：液态水、固态水、气态水</li><li>大气的形成。地球经历过 3 种不同的大气：第一大气：来自地壳熔化和宇宙的热扩散，以 He、H<sub>2</sup> 为主；第二大气：来自火山喷发和地热排气，以 CO<sub>2</sup>、N<sub>2</sup>、H<sub>2</sup>O 为主，也有微量的 O<sub>2</sup>；第三大气：主要成分为 N<sub>2</sup>、O<sub>2</sup> ，还有 CO<sub>2</sup>、Ar。</li></ul><p>大气的垂直结构：</p><ol><li>对流层：水汽，属于生物圈</li><li>平流层：臭氧层</li><li>中间层</li><li>暖层</li><li>散逸层：外大气层</li></ol><h4 id="生物群落的构建"><a class="header-anchor" href="#生物群落的构建"></a>生物群落的构建</h4><p><font color="#d9730d">生物群落</font>（community）:是指特定空间或特定生境下生物种群有规律的组合，它们之间以及它们与环境之间彼此影响，相互作用，具有一定的形态结构与营养结构，并执行一定的功能。</p><p>生物对环境的适应</p><p>物种形成后面临的两大问题：</p><ol><li>如何使自己的适应潜力达到最大化，以便最大限度地适应环境，充分利用环境中的资源？</li><li>如何应对外界的各种不利因素，处理好与其他生物的争端？</li></ol><p>（一）如何使自己的适应潜力达到最大化，以便最大限度地适应环境，充分利用环境中的资源？五种策略：</p><ol><li><font color="#faa755">预备性适应</font>：通过遗传物质的多样化</li><li><font color="#faa755">响应性适应</font>：生物会根据环境出现相应的基因与特征上的改变</li><li><font color="#faa755">特化性适应</font>：进化出特殊的性状或器官</li><li><font color="#faa755">器官强化适应</font>：原有的器官不断得到强化</li><li><font color="#faa755">机能改变适应</font>：原有的次要机能转化为主要机能</li></ol><p>（二）如何应对外界的各种不利因素，处理好与其他生物的争端？三种策略：</p><ul><li><font color="#faa755">种内竞争</font>：优胜劣汰</li><li><font color="#faa755">种间竞争</font>：生态位相同或相似的物种，减少对有限资源的共同依赖</li><li><font color="#faa755">协同进化</font>：各个物种在适应上产生同步变化，都进化出对自己有利的变异，最终实现互利或互相制约</li></ul><p>生物对环境的塑造</p><p>地球物理环境与生物之间的协同进化：</p><ul><li>生物彻底改变地球<font color="#faa755">大气</font>的组成；</li><li>生物可以利用 CO<sup>2</sup> 生成<font color="#faa755">岩石</font>；</li><li>生物加速岩石风化；</li><li>生物死亡形成有机质，生成<font color="#faa755">土壤圈</font>；</li><li>生物推动地球<font color="#faa755">碳、氮循环</font>；</li><li>生物储备并提高能源；</li><li>生物能调节地球的<font color="#faa755">水循环和气候</font>。</li></ul><p><font color="#d9730d">群落食物网的形成</font></p><p>食物网：多条食物链相联，构成的网状结构</p><ul><li><font color="#faa755">初级食物网</font>：开始于单细胞原核生物出现之后，存在 30 亿年以上。化学自养/光自养生物 → 以菌或藻类为食的多细胞后生动物</li><li><font color="#faa755">次级食物网</font>：开始于两侧对称动物大批形成之后，存在不到 1 亿年。<font color="#e03e3e">现代食物网的雏形，出现了捕食性的无脊椎动物</font></li><li><font color="#faa755">现代食物网</font>：开始于脊椎动物世代，存在至今。</li></ul><h4 id="生态系统的成熟"><a class="header-anchor" href="#生态系统的成熟"></a>生态系统的成熟</h4><p><font color="#faa755">熵：无序与混乱</font></p><p>热力学第二定律：热量总是从高温物体向低温物体自然传递。分子的热运动总是自发地从有序向无序发展。</p><p><font color="#e03e3e">抗熵</font>：克服熵增，地球上的地壳、板块、大气圈、水圈等都是抗熵的产物。</p><p><font color="#faa755">新陈代谢的本质就是生物不断从环境吸取负熵（有序），让体内合成大于分解，以消除不断产生的熵。</font></p><p><font color="#d9730d">地球的抗熵机制</font></p><ol><li>自然选择</li><li>绿色植物把太阳能转变成生物化学能</li><li>生物的多样性</li><li>生物由简单到复杂、由低等到高等，以及生物体结构的不断改变</li><li>生物的繁殖和遗传</li><li>生物的新陈代谢</li><li>生物体内的酶</li><li>生物群落中的食物网：协同抗熵</li><li>生物的许多行为和生理现象</li><li>生物在生态系统中的分工，生产者、消费者、分解者</li></ol><p><font color="#d9730d">生物多样性积累</font></p><h2 id="第五章-生物多样性的波动与更迭"><a class="header-anchor" href="#第五章-生物多样性的波动与更迭"></a>第五章 生物多样性的波动与更迭</h2><h3 id="遗传多样性的演变"><a class="header-anchor" href="#遗传多样性的演变"></a>遗传多样性的演变</h3><h4 id="基因结构的改变"><a class="header-anchor" href="#基因结构的改变"></a>基因结构的改变</h4><p>基因：启动子、外显子、<font color="#faa755">内含子</font></p><p><font color="#d9730d">基因的重复</font></p><ul><li>基因组倍增：整条染色体发生重复</li><li>基因倍增：多拷贝</li><li>碱基序列倍增：基因延长</li></ul><p><font color="#d9730d">非编码序列</font><br><font color="#faa755">非编码序列：染色体上不能指挥生成氨基酸的碱基序列</font>，既能表现成内含子，也能散布在整个核酸链上。</p><ul><li><font color="#faa755">内含子</font>：基因内部的非编码序列，基因进化的产物</li><li>真核生物拥有大量基因以外的非编码序列：<font color="#faa755">重复碱基序列</font>（卫星、小卫星、微卫星）</li><li>非编码序列可能源于基因的倍增，含有丰富的遗传信息。</li></ul><p><font color="#d9730d">超常的变化</font></p><ol><li><font color="#faa755">不等交换</font>：DNA 双链之间的错位 → 假基因</li><li><font color="#faa755">复制滑移</font>：正在复制的 DNA 链与模板链配对时发生的滑移</li><li><font color="#faa755">选择性剪接</font>：同样的RNA用不同方式剪接形成不同的mRNA，最终生成不同的蛋白质</li><li><font color="#faa755">外显子改组</font>：两个以上不同的基因片段发生重组，形成新基因——<font color="#d9730d">高等生物产生新基因的重要途径</font></li><li><font color="#faa755">基因转换</font>：正在复制的DNA双链，一条的后代加上了另一条的部分序列，复制出异型的基因——<font color="#d9730d">异源DNA错配</font></li><li><font color="#faa755">基因移动</font>：基因或其中某些序列位置发生了变化</li><li><font color="#faa755">基因重叠</font>：在原有的基因上转录出额外的 RNA，产生功能不同的额外蛋白质——<font color="#d9730d">低等生物体内比较常见</font></li><li><font color="#faa755">基因分享</font>：某个基因及其产物蛋白质都具有双重的身份，能在不同情况下发挥不同功能</li><li><font color="#faa755">水平传递</font>：基因不仅能在同种个体之间传递，<font color="#d9730d">也能在不同物种个体之间传递——病毒</font></li></ol><h4 id="遗传组成的改变"><a class="header-anchor" href="#遗传组成的改变"></a>遗传组成的改变</h4><p>（一）<font color="#d9730d">组成复杂化</font>——<font color="#d9730d">核酸</font>、<font color="#d9730d">蛋白质</font>、脂质</p><ol><li><font color="#faa755">同类生物之间的核酸差异越来越大</font></li><li><font color="#faa755">基因逐渐稀薄</font>，生物越高等，非编码序列越多</li><li><font color="#faa755">基因指挥出现多元化</font>，一个基因组指挥生成多个蛋白组</li><li>核酸中的<font color="#faa755">碱基替换</font>越来越频繁，非编码序列</li><li><font color="#faa755">核酸出现三级结构</font></li><li>蛋白质中<font color="#faa755">氨基酸替换</font>越来越明显，一些结构和化学性质相近的氨基酸会出现替换</li><li>蛋白质出现<font color="#faa755">协同进化</font></li><li><font color="#faa755">蛋白质出现四级结构</font></li></ol><p>（二）<font color="#d9730d">发展分支化</font></p><ol><li>基因分化出不同的<font color="#faa755">家族</font></li><li><font color="#faa755">基因家族会由于新种形成而再度分化</font></li><li><font color="#faa755">蛋白质也会在不同物种中不断分化</font>，同种蛋白在不同物种中的氨基酸组成可能不同</li></ol><p><font color="#d9730d">基因家族</font>：来源于同一个祖先，由一个基因通过重复等途径产生的，在结构和功能上具有明显的相似性的一组基因。</p><p>（三）<font color="#d9730d">遗传保守化</font></p><ol><li><font color="#faa755">蛋白质具有一定的保守性，很强的同源性</font></li><li><font color="#faa755">蛋白中氨基酸的替换速度几乎是恒定的</font>，平均 10 亿年替换一个氨基酸</li><li><font color="#faa755">重要的遗传物质进化速度都比较慢</font>，越重要，变化越小，进化越慢</li><li><font color="#faa755">核酸具有双重性</font>，不仅能用于复制，还有类似于酶的<font color="#d9730d">催化作用</font></li></ol><p><font color="#d9730d">保守结构域</font>：生物进化或者一个蛋白家族中具有不变或相同的结构域。</p><h4 id="个体和种群变化"><a class="header-anchor" href="#个体和种群变化"></a>个体和种群变化</h4><p>（一）<font color="#d9730d">形态特征的变化</font></p><ul><li><font color="#faa755">得到保留的关键特征带动了随后的转型</font>，脊椎的出现是高等动物进化的起点</li><li><font color="#faa755">分化后的形态特征能同时向复杂化与简单化两个方向发展</font></li><li><font color="#faa755">阶段性特征能引发出随后更复杂的特征——再生式进化</font></li></ul><p>（二）<font color="#d9730d">行为特征的变化</font></p><ul><li><font color="#faa755">植物与动物的行为模式是沿着不同方向发展的</font>，植物：非意识的对环境刺激的应激反应，向光、向地、向化、向水等，动物：有意识的后天行为 ，是基因、激素、神经等共同作用的结果</li><li><font color="#faa755">动物的行为是由简到繁逐渐多样的</font>，动物越高等，后天行为就越多。学习行为不断重复，能够固定成本能。</li><li><font color="#faa755">行为的物质基础是逐渐复杂化的</font>，植物行为：激素、化学物质，动物行为：基因、激素、神经共同调控</li><li><font color="#faa755">动物的行为是随时进化的，也是协同进化的</font></li></ul><p>（三）<font color="#d9730d">种群的遗传变化</font></p><ol><li>等位基因在某个种群中形成<font color="#faa755">固定的频率</font></li><li>在性染色体不同的物种中，种群的遗传组成还存在<font color="#faa755">伴性变化</font></li><li>种群遗传组成变化至少会受到四种因素的影响：<font color="#faa755">突变</font>、<font color="#faa755">基因流动</font>、<font color="#faa755">遗传漂变</font>：基因频率在种群中随机增减、<font color="#faa755">自然选择</font></li><li>种群的长期遗传改变和积累不仅能使基因库之间出现差异，还能使种群内部出现<font color="#faa755">遗传多态</font></li></ol><h3 id="物种多样性的更替"><a class="header-anchor" href="#物种多样性的更替"></a>物种多样性的更替</h3><h4 id="寒武纪时期的生物类群"><a class="header-anchor" href="#寒武纪时期的生物类群"></a>寒武纪时期的生物类群</h4><p><font color="#d9730d">埃迪卡拉生物群</font>：形态奇特，大小不等，寿命短，亲缘关系不清楚。</p><p><font color="#d9730d">矿化小壳动物群</font>——跨越隐生宙和显生宙</p><ul><li>晚于埃迪卡拉生物群，震旦纪末期出现，寒武纪初期大量繁盛，具有外壳的多门类海生无脊椎动物群。</li><li>具有特殊矿化骨骼的动物——几丁、磷质、硅质、钙质等</li><li>亲缘关系：海绵动物、腔肠动物、环节动物、腕足动物、软体动物、棘皮动物等。</li></ul><h4 id="寒武纪时期的生物类群-v2"><a class="header-anchor" href="#寒武纪时期的生物类群-v2"></a>寒武纪时期的生物类群</h4><p><font color="#d9730d">寒武纪生物类群</font>——<font color="#faa755">无脊椎动物为主</font></p><ul><li>生物“门”特别丰富，达 100 多个门。</li><li>节肢动物、海绵动物、腔肠动物、软体动物、棘皮动物等。</li><li><font color="#faa755">寒武纪生物类群是地球上第一个生物多样性的高峰，掀开了显生宙这一生物多样性演化的新纪元。</font></li></ul><p><font color="#faa755">云南澄江生物群</font><br><font color="#faa755">湖北清江生物群</font></p><h4 id="寒武纪后的古生代类群"><a class="header-anchor" href="#寒武纪后的古生代类群"></a>寒武纪后的古生代类群</h4><p><font color="#d9730d">奥陶纪生物类群</font>——<font color="#faa755">海洋无脊椎动物</font></p><p>分化程度远超寒武纪，新增了苔藓动物门。</p><p><font color="#faa755">生物侵蚀革命</font>：由于海洋中生物多样性的不断扩增，不仅改善了海洋群落的营养结构，促进物种的协同进化，还使生物侵蚀越来越强烈。</p><p>陆地上出现了原始非维管植物。</p><hr><p><font color="#d9730d">志留-泥盆纪生物类群</font></p><p>生物类群：水生——海洋动物（腔肠动物、头足类软体动物菊石、鱼类）</p><p><font color="#faa755">泥盆纪是原始鱼类时代</font></p><p>生物类群：</p><ul><li>水生——海洋动物（腔肠动物、头足类软体动物菊石、鱼类）</li><li>陆生——植物（开始高等植物的演化）、动物（节肢动物、昆虫、<font color="#faa755">两栖动物鱼石螈</font>）</li></ul><hr><p><font color="#d9730d">石炭-二叠生物类群</font></p><p>生物类群：</p><ul><li>海洋——无脊椎动物（棘皮动物、腔肠动物、软体动物、原动物等）</li><li>海洋——脊椎动物（各种鱼类）</li><li>陆地——植物（蕨类、裸子植物）</li><li>陆地——动物（无脊椎动物：昆虫）（脊椎动物：淡水鱼、两栖动物、爬行动物）</li></ul><h4 id="中生代以后的生代类群"><a class="header-anchor" href="#中生代以后的生代类群"></a>中生代以后的生代类群</h4><p><font color="#d9730d">三叠纪的生物类群</font></p><p>生物类群：</p><ul><li>海洋——群落不断复杂、固着生物不断减少、运动型生物增多</li><li>陆地——植物（蕨类植物不断减少，针叶林增多）</li><li>陆地——动物（昆虫，两栖动物，爬行动物）</li></ul><hr><p><font color="#faa755">侏罗-白垩生物类群</font></p><p>生物类群：</p><ul><li>陆地：以恐龙为主</li><li>陆地：其他爬行动物：海洋（沧龙、蛇颈龙、鱼龙、鳄等）、陆地（蜥蜴、蛇、龟）、天空（翼龙）</li><li>陆地植物：白垩纪出现了花被子植物，进而带动蜂的进化</li><li>海洋：爬行动物——沧龙、蛇颈龙、鱼龙、鳄等</li><li>海洋：脊椎动物——鲨鱼、鱼类</li><li>海洋：无脊椎动物 ——软体动物、棘皮动物、海绵动物、腔肠动物、苔藓动物、原生动物等</li></ul><hr><p><font color="#d9730d">新生代的生物类群</font><br>生物类群：</p><ul><li>哺乳动物、鸟类为主</li><li>海洋——鲸、海豚、海牛、海豹、海狮等</li><li>陆地动物：哺乳动物、爬行动物</li><li>陆地植物：森林、草原、荒漠</li></ul><h3 id="地球生物圈的演变"><a class="header-anchor" href="#地球生物圈的演变"></a>地球生物圈的演变</h3><h4 id="物理环境的变迁"><a class="header-anchor" href="#物理环境的变迁"></a>物理环境的变迁</h4><p>（一）<font color="#d9730d">土地的变迁</font><br>四大分布格局：</p><ol><li><font color="#faa755">偏颇格局</font>：陆地分布不均匀，主要集中在南半球</li><li><font color="#faa755">收敛格局</font>：各板块靠拢，直到形成统一的泛大陆Pangaea</li><li><font color="#faa755">伸展格局</font>：泛大陆解体，海洋重新开通，陆地板块散布到地球的各处</li><li><font color="#faa755">现代格局</font>：上一格局进一步调整，出现过7次大的变化</li></ol><p>（二）<font color="#d9730d">水域的变迁</font><br>海洋的变迁：</p><ol><li><font color="#faa755">海洋数量和位置发生变迁</font>，太平洋、大西洋、印度洋、北冰洋、地中海</li><li><font color="#faa755">地球的海平面出现波动</font>，与气温有关</li><li><font color="#faa755">地球冰川循环出现</font>，冰期气温下降，海水冻结，海平面下降，生物灭绝</li></ol><p>（三）<font color="#d9730d">大气的变迁</font></p><p>第三大气：O<sup>2</sup>、CO<sup>2</sup> 含量的波动</p><ol><li>大气的氧含量是在波动之中的</li><li>CO<sup>2</sup> 含量是在波动中下降的</li><li>地球表层的大气温度始终是在波动之中的</li></ol><h4 id="生物成员的更迭"><a class="header-anchor" href="#生物成员的更迭"></a>生物成员的更迭</h4><p>生物的调整：</p><ol><li>生物多样性的增减</li><li>各类生物的更迭</li></ol><p>（一）<font color="#d9730d">波动与更迭</font></p><p><font color="#faa755">生物多样性的演变特征</font>：</p><ol><li>多样性程度越来越高：<font color="#faa755">复化</font>：低等 → 高等，上升式进化；<font color="#faa755">分化</font>：主干 → 分支；<font color="#faa755">递进</font>：强势类群灭绝，弱势类群冠状辐射</li><li>生物多样性波动：<font color="#faa755">灭绝</font>。背景灭绝率：没有特殊情况下地球生物自然发生的灭绝速率。大灭绝的原因：<font color="#faa755">灾变、物理环境巨变、多因素综合</font></li></ol><p>（二）<font color="#d9730d">植物的更迭</font></p><p>低等植物：藻类</p><p>高等植物：维管植物，包括蕨类、苔藓、裸子植物、被子植物</p><ol><li>苔藓、蕨类、种子蕨逐渐成为优势</li><li>裸子植物逐渐成为优势类群</li><li>被子植物逐渐成为优势类群</li></ol><p><font color="#faa755">植物更迭的特点</font>：</p><ol><li>种类由少到多</li><li>生物多样性整体每次更迭后都会有所增加，主要源于新物种或类群的爆发辐射</li><li>更迭中出现过 5 次变革：植物登陆 → 维管束出现 → 森林出现 → 种子出现 → 有花植物出现</li><li>功能和作用不断复杂化</li></ol><p>（三）<font color="#d9730d">动物的更迭</font></p><ol><li>海洋无脊椎动物逐渐成为优势</li><li>鱼类逐渐成为优势</li><li>两栖动物和昆虫成为优势</li><li>爬行动物成为优势</li><li>哺乳动物和鸟类成为优势</li></ol><p><font color="#faa755">动物更迭的特点</font>：</p><ol><li>种类由少到多</li><li>生物多样性整体每次更迭后都会有所增加，主要源于新物种或类群的爆发辐射</li><li><font color="#faa755">更迭中出现过5次变革</font>：<font color="#faa755">脊椎动物出现 → 两栖动物登陆 → 羊膜卵爬行动物出现 → 哺乳动物出现 → 鸟类出现</font></li><li>功能和作用不断复杂化</li></ol><h4 id="生态系统的调整"><a class="header-anchor" href="#生态系统的调整"></a>生态系统的调整</h4><p><font color="#faa755">生态系统的波动主要起因于两方面动力</font>：</p><ol><li>长期的压力：生境变化、生物物种</li><li>短期的冲击：灾祸事件起到敲击效应，使长期的压力爆发</li></ol><p>（一）<font color="#d9730d">脉冲式波动</font></p><p>短期的冲击：</p><ul><li>行星或彗星撞击——引起海啸、山火、酸雨等</li><li>宇宙干扰——地球附近的新星、超新星、γ 射线、伴生星系运行、太阳系摆动等</li><li>大陆板块漂移——板块移动，火山喷发</li><li>火山泛布玄武岩的循环</li><li>海平面下降</li><li>全球冷暖交替</li><li>笼气枪喷——甲烷笼气</li><li>海水的逆向沉浮</li></ul><p>（二）<font color="#d9730d">结构性调整</font></p><ol><li>不断增加多样性和复杂性，以提高整体的组织化水平</li><li>扩大对空间的利用，以增加系统的结构层次</li><li><font color="#faa755">提高物质与能量转化率，以克服资源的不足</font></li><li><font color="#faa755">固定物质与能量的流动，以增强系统的稳定性</font>。植物 → 动物，海洋→陆地。生物越高等，生态系统越复杂，能量和物质输入就越多，抗熵能力越强</li><li>不断出现变革，以推动系统的发展</li></ol><p>（三）<font color="#d9730d">系统的转换</font></p><h2 id="第六章-人类的诞生及早期的影响"><a class="header-anchor" href="#第六章-人类的诞生及早期的影响"></a>第六章 人类的诞生及早期的影响</h2><h3 id="人类的起源"><a class="header-anchor" href="#人类的起源"></a>人类的起源</h3><h4 id="低等的灵长动物"><a class="header-anchor" href="#低等的灵长动物"></a>低等的灵长动物</h4><p><font color="#d9730d">灵长类起源</font>，哺乳纲——真兽亚纲——灵长目</p><ul><li>2.16 亿年前，哺乳动物</li><li>1.6 亿年前，真兽</li><li>1 亿年前，<font color="#faa755">真统兽</font></li><li>灵长动物最早可能在 8500 万年前形成</li><li>沿原猴和猴猿两个方向辐射发展</li></ul><p><font color="#d9730d">灵长类分化</font></p><ul><li>原猴：湿鼻类，低等灵长动物</li><li>猴猿：低等的跗猴，高等类人猿</li></ul><p>猴猿：</p><ul><li>低等——跗猴</li><li>高等——<font color="#faa755">真猴</font>（新大陆阔鼻猴、旧大陆狭鼻猴）、猿、人</li></ul><p><font color="#d9730d">低等灵长类</font></p><ul><li>原猴——<font color="#faa755">岛屿</font></li><li>跗猴——人类诞生的基础</li></ul><h4 id="高等的灵长动物"><a class="header-anchor" href="#高等的灵长动物"></a>高等的灵长动物</h4><p>高等灵长动物包括新大陆猴类、旧大陆猴类、猿类、人类</p><p><font color="#e03e3e">高等灵长动物起源</font></p><ul><li>5000 万年前</li><li>4700 万年，麦氏文猴——原猴</li><li>4500-4000 万年，中华曙猿、世纪曙猿、巴黑尼曙猿</li><li>始新世晚期，缅甸双猴</li><li>3500 万年前，非洲亚辟猴</li></ul><p>高等灵长动物包括新大陆猴类、旧大陆猴类、猿类、人类</p><p>（一）<font color="#e03e3e">真猴的起源与发展</font></p><ul><li><font color="#faa755">旧大陆猴类</font>：亚洲、非洲。鼻孔近而向下，拇指可对握，尾短或无，具有两个前臼齿，有的能识别色彩</li><li><font color="#faa755">新大陆猴类</font>：南美、中美。鼻孔远而侧向，拇指不能对握，尾长而能支撑或卷曲，具有三个前臼齿，多数色盲</li></ul><p><font color="#faa755">高等灵长动物进化的第一次分手——新大陆与旧大陆的猴类分手</font></p><p>旧大陆猴类——主流</p><ul><li>3400 万年前，<font color="#faa755">猿类出现——高等灵长动物进化的第二次分手</font></li><li>2400 万年前，东非大峡谷，狭鼻猴出现</li></ul><p>新大陆猴类——独立进化</p><p>（二）<font color="#e03e3e">猿类的起源与发展</font></p><p>猿类：前臂变长，没有尾巴</p><ul><li>原上猿，始新世末期，非洲埃及</li><li>上新猿：醉猿，欧洲、亚洲</li><li>树猿：非洲</li></ul><p><font color="#e03e3e">高等灵长动物进化的第三次分手——小型猿类与大型猿类分手，人科诞生</font></p><p>（三）<font color="#d9730d">人科中的古猿</font></p><p><font color="#faa755">非洲猿</font>，距今1800万-1500万年前，化石见于东非和沙特，可能起源于酋猿。</p><p>高等灵长动物进化的第四次分手 ——非洲猿类与亚洲猿类分手</p><p>第五次分手-大猩猩与人族分手</p><p>高等灵长动物进化的第六次分手 ——黑猩猩与人类分手</p><h4 id="人科的早期猿类"><a class="header-anchor" href="#人科的早期猿类"></a>人科的早期猿类</h4><p><font color="#e03e3e">高等灵长动物进化</font>：</p><ul><li>第一次分手——<font color="#faa755">新大陆与旧大陆的猴类分手</font></li><li>第二次分手——<font color="#faa755">猴与猿的分手</font></li><li>第三次分后——<font color="#faa755">小型猿类与大型猿类分手，人科诞生</font></li><li>第四次分手——<font color="#faa755">非洲猿类与亚洲猿类分手</font></li><li>第五次分手——<font color="#faa755">大猩猩与人族分手</font></li><li>第六次分手——<font color="#faa755">黑猩猩与人类分手</font></li></ul><p>（一）<font color="#e03e3e">人族中的先驱</font></p><p>土根山猿初人：直立行走</p><ul><li><font color="#faa755">始祖地猿</font>：距今580万-440万年前，真正完全直立行走</li></ul><p><font color="#faa755">摆脱对森林的依赖</font>：——人族有别于森林古猿与大猩猩的主要特点</p><p>（二）<font color="#faa755">人族中的南猿</font></p><p>南方古猿：距今420万-200万年前，化石见于南非</p><p>始祖地猿 → 南方古猿 → 粗壮南猿（进化盲端）、人类。距今240万年前</p><h3 id="人类的分化"><a class="header-anchor" href="#人类的分化"></a>人类的分化</h3><h4 id="分化的机制"><a class="header-anchor" href="#分化的机制"></a>分化的机制</h4><p>（一）<font color="#e03e3e">撒哈拉泵机理</font>，指非洲撒哈拉地区周期性的环境变化。</p><ul><li>湿态：雨水多，湖泊河流增多，草原，动植物增多</li><li>干态：雨水少，湖泊河流减少，荒漠和沙漠，动植物减少</li></ul><ol><li>320万年前，南方古猿在非洲境内分化</li><li>270-250万年前，非洲粗壮南猿出现分化</li><li>180-80万年前，非洲直立人向亚欧大陆扩散</li><li>13.3-12.2万年前，非洲智人向亚欧大陆扩散</li><li>6-3万年前，干态</li><li>2700-2100年前，干态</li></ol><p>（二）<font color="#e03e3e">非洲单源分化</font>，认为人类应该是在撒哈拉泵的作用下由非洲向世界各地扩散的，然后又在扩散中分化出不同的人种。</p><p><font color="#faa755">非洲单源分化的过程</font>：</p><ul><li>早期人类走出非洲，在亚欧大陆分化出不同的直立人，以及其他早期人类</li><li>智人走出非洲，取代世界各地其他直立人，分化出现代智人</li></ul><p><font color="#faa755">非洲单源分化的遗传学证据</font>：</p><ul><li>现代人母系线粒体DNA都源于15-14万年前的东非女性</li><li>欧、亚、非42个民族的线粒体基因在16万年、6.5万年、4.5万年分别出现过3次分化</li><li>现代人父系Y染色体都源于9万年前的非洲男性</li><li>非洲高等灵长动物彼此的亲缘关系很近</li></ul><p>（三）<font color="#e03e3e">世界多源分化</font></p><p>认为人类虽然有共同的祖先，但系统树不是单链的，而是分散灌丛式的，即世界各地的智人可能是土生土长的，由当地的先人直接演化而来。</p><p><font color="#faa755">世界多源分化的证据</font>：</p><ul><li>形态学证据：现代人大多带有本地区先人的特征</li><li>遗传学证据：6万年前的澳大利亚智人与同期其他地区的智人在DNA组成上差异甚远</li></ul><h4 id="早期的人类"><a class="header-anchor" href="#早期的人类"></a>早期的人类</h4><p>分化早期：250万-60万年前，9种比较原始的人类<br>分化晚期：40万-10万年前，3种比较进步的人类</p><p><font color="#e03e3e">非洲的原始人</font></p><ol><li><font color="#faa755">能人</font>：距今250万-140万年前，非洲，起源于南猿，会使用石器、狩猎，经常树栖，可能有语言。</li><li><font color="#faa755">卢多尔夫人</font>：距今240万-160万年前，肯尼亚</li><li><font color="#faa755">匠人</font>：距今190万-130万年前，头骨薄、两性异形明显，脑容量加大，直立身高可达190cm，精于制造石器，会用火，是最早发出声音或使用符号的人，社会组织性较强。</li><li><font color="#faa755">格鲁吉亚人</font>：距今180万-160万年前，地中海东部格鲁吉亚</li><li><font color="#faa755">直立人</font>：头骨坚硬，平均身高180cm，脑容量超过1100cm<sup>3</sup>，发源地在非洲。继续在非洲大陆发展、走出非洲，到欧亚大陆发展。<font color="#faa755">石斧文化</font>。重庆巫山人、云南元谋人、陕西蓝田人、北京猿人、南京猿人……</li><li><font color="#faa755">前人</font>：先驱人，是直立人向欧洲扩散的时候衍生出来的人种。距今120万-50万年前，西班牙。</li><li><font color="#faa755">西布兰诺人</font>：距今90万-80万年前，意大利罗马附近。</li><li><font color="#faa755">海德堡人</font>：直立人到达欧洲后发展起来的第二批原始人，生活在距今80万-10万年前，主要分布在欧洲各地，脑容量接近智人，是智人的93%，平均身高180cm。</li><li><font color="#faa755">罗德西亚人</font>：距今60万-12万年前，非洲</li><li><font color="#faa755">尼安德特人</font>：简称尼人，生活在距今40万-2.2万年前，化石见于德国。身材矮胖，平均身高160cm，脑容量超过智人，适应寒冷的气候。可能起源于海德堡人，也可能直接起源于直立人</li><li><font color="#faa755">弗洛里斯人</font>：距今10万-1.2万年前，身材矮小，平均1m左右，脑容量不足现代智人的1/3。<font color="#d9730d">岛屿特化种</font>、<font color="#d9730d">侏儒性智人</font></li><li><font color="#faa755">智人</font>：形成于20万年前，1.2万年以前的属于早期智人，1.2万年农业革命以来属于现代智人。远古智人、长者智人。非洲以外的直立人直接演变成智人：广西柳江人、四川资阳人、江苏双沟下草湾人、北京周口店山顶洞人、内蒙古河套人</li></ol><h4 id="晚期的人类"><a class="header-anchor" href="#晚期的人类"></a>晚期的人类</h4><p><font color="#e03e3e">现代的智人</font>，1.2万年以来，农耕和畜牧业兴起，人类发展进入了现代智人。</p><p>1.2万年以来，农耕和畜牧业兴起，人类发展进入了现代智人。</p><ul><li><font color="#faa755">黄种人</font>：蒙古利亚人，分布在亚洲、北美、南美等地，发源于亚洲中部和东部</li><li><font color="#faa755">白种人</font>：欧罗巴人，分布在欧洲、亚洲、美洲、北非、大洋洲等地，发源于地中海</li><li><font color="#faa755">黑种人</font>：尼格罗人，分布在非洲、大洋洲、南亚等地，发源于南亚</li><li><font color="#faa755">棕种人</font>：澳大利亚人，分布在大洋洲，发源于南亚</li></ul><h3 id="先人的影响"><a class="header-anchor" href="#先人的影响"></a>先人的影响</h3><h4 id="先人的扩散"><a class="header-anchor" href="#先人的扩散"></a>先人的扩散</h4><p>（一）<font color="#d9730d">在非洲大陆的扩散</font>，直立人在180万年前开始扩散，进入亚欧大陆，分别在欧洲和亚洲进行分化。</p><p><font color="#faa755">智人在非洲的扩散路线</font></p><ol><li>15万-6万年前，发源地→非洲南部，Capoid人的祖先</li><li>8万-5万年前，发源地→非洲西部，定居中非和西非，称为Pygmies人的祖先</li><li>7万-5万年，发源地→阿拉伯半岛，扩散到中东、东南亚等地</li><li>5万-4.5万年前，发源地→地中海，定居高加索</li></ol><p>（二）<font color="#d9730d">在欧亚大陆的扩散</font></p><p><font color="#faa755">智人在欧亚大陆的扩散路线</font></p><ol><li>6万-3万年前，智人跨越红海进入阿拉伯半岛，分为3组进行扩散，阿拉伯半岛→沿海岸向印度、南亚扩散→中国、澳大利亚、日本；阿拉伯半岛→西伯利亚、蒙古</li><li>4.5万-1万年前，早期智人在沙特形成第二扩散中心。沙特→<font color="#faa755">巴基斯坦</font>、印度；沙特→捷克、意大利；巴基斯坦→哈萨克斯坦、东南亚</li><li>5万-1.5万年前，由埃及扩散到高加索的早期智人形成第二扩散中心，高加索→欧洲、东西伯利亚、中国</li></ol><p>（三）<font color="#d9730d">在其他地区的扩散</font></p><p>智人向美洲的扩散路线是单一的，白令海峡、太平洋西岸</p><h4 id="先人的智慧"><a class="header-anchor" href="#先人的智慧"></a>先人的智慧</h4><p>（一）<font color="#d9730d">生理的改变</font>：</p><ul><li>脑容量扩增</li><li>人脑的扩增与熟食有一定的关系，也比性成熟逐渐推迟有关</li><li>大脑的变化会带动很多基因发生改变，语言、手……</li><li>人类身体各部位的进化速度是不等的</li></ul><p>（二）<font color="#d9730d">工具的发明</font></p><p>人类使用工具大致经历了3个明显不同的时代：</p><ol><li><font color="#faa755">石器时代</font>。旧石器时代：距今250万年-1.2万年（农业革命）；新石器时代：需要磨制的抛光石器、陶瓷</li><li><font color="#faa755">铜器时代</font>。冶金术，青铜的出现，世界各地进入青铜时代的时间不等</li><li><font color="#faa755">铁器时代</font>。史前制造工具的最高阶段，以铁和钢质工具为标志</li></ol><p>（三）<font color="#d9730d">社会的形成</font></p><p>史前社会可能出现过4种形态：游团、部落、酋帮、国家。所有的社会通过组织手段来维持人类的生存和社会运转。</p><p>自组织手段至少表现在5个方面：</p><ol><li>互助合作的加强</li><li>沟通交流的改善</li><li>文化艺术的萌发</li><li>宗教信仰的产生</li><li>社会等级的形成</li></ol><h4 id="先人与自然"><a class="header-anchor" href="#先人与自然"></a>先人与自然</h4><p>（一）<font color="#d9730d">转变生活方式</font></p><ul><li>食物种类发生变化：水果、杂食→腐肉、植物→狩猎、采集→种植农作物</li><li>居住方式发生变化：天然洞穴→人工修筑的居所</li><li>衣着的改变：树叶、兽皮→棉花、亚麻</li><li>出行：步行→骑马→马车</li></ul><p>（二）<font color="#d9730d">使用和驾驭火</font></p><p><font color="#faa755">火对先人的影响</font>：</p><ul><li>火使人类逐渐改变了饮食习惯</li><li>火给人类生理形态带来了巨大的改变</li><li>火成为人类生存不可缺失的工具和武器</li><li>学会保存火种和人工取火使人类智力出现飞跃</li></ul><p>（三）<font color="#d9730d">冲击其他物种</font></p><p><font color="#faa755">第6次生物大灭绝：第四纪灭绝</font></p><p>先人对其他物种的冲击主要表现在4个方面：</p><ul><li>人类直接过度猎杀能使大型哺乳动物灭绝</li><li>人类的扩散迁移导致原产物种灭绝</li><li>人类的生存对原有物种构成威胁</li><li>人类活动改变了原有的生态系统</li></ul><p>人类对自然资源的过度开发：铜矿、森林</p><h2 id="第七章-遗传多样性丧失与保护"><a class="header-anchor" href="#第七章-遗传多样性丧失与保护"></a>第七章 遗传多样性丧失与保护</h2><h3 id="物种的遗传障碍"><a class="header-anchor" href="#物种的遗传障碍"></a>物种的遗传障碍</h3><h4 id="基因层次的遗传障碍"><a class="header-anchor" href="#基因层次的遗传障碍"></a>基因层次的遗传障碍</h4><p>生物存在三个不同层次的基因库：物种、种群、个体</p><p>三类基因：有利基因、有害基因、中性基因</p><p>（一）<font color="#d9730d">物种的遗传负担</font></p><p><font color="#faa755">遗传负担</font>（genetic load）/遗传负荷/遗传负载：物种的某些基因由于某种原因而产生了不利或致死的变化，使该物种不得不在遗传上携带和承受来自这些变化的负载。</p><p>成为遗传负担的变化有一下4种形式：</p><ol><li><font color="#faa755">突变负担</font>：有害基因的突变。隐性不可见、隐性可见、隐性纯合致死、显性有害</li><li><font color="#faa755">分离负担</font>：有性生殖物种在繁殖后代时因为基因分离而出现的<font color="#e03e3e">不利的纯合基因</font></li><li><font color="#faa755">替代负担</font>：某个基因被另一个有害基因替代</li><li><font color="#faa755">自我排斥负担</font>：亲缘关系很近的个体携带相互排斥的等位基因</li></ol><p>（二）<font color="#d9730d">基因的表达障碍</font></p><ul><li><font color="#faa755">基因反应规范</font>（Reaction norm）：同一个基因在不同环境中能表现出不一致的表型。</li><li><font color="#faa755">遗传力</font>（Heritability）：生物性状在表达时真正属于基因遗传那部分的比值。</li></ul><p>（三）<font color="#d9730d">近交与远交衰退</font></p><ul><li><font color="#faa755">近交</font>：亲缘关系很近的两个个体发生交配</li><li><font color="#faa755">远交</font>：亲缘关系极远的个体出现交配繁殖。相同物种的远缘个体交配；不同物种的个体交配：杂交</li></ul><h4 id="种群层次的遗传障碍"><a class="header-anchor" href="#种群层次的遗传障碍"></a>种群层次的遗传障碍</h4><p>（一）<font color="#d9730d">种群间的遗传差异</font></p><ol><li>库存的基因不同，基因数量不同</li><li>等位基因不同，出现的频率不一样</li><li>相同的基因也可能有不同的功能或表达</li></ol><p>原因：</p><ul><li>隔离</li><li>不同种群由于长期孤立而缺乏基因交流</li><li>环境不同</li></ul><p>（二）<font color="#d9730d">个体间的遗传差异</font></p><ol><li>一个种群中只有<font color="#faa755">有效种群</font>的个体才参与繁殖，有效个体：参与繁殖的</li><li>种群中不同个体的<font color="#faa755">繁殖能力</font>存在差异</li><li>真正参与繁殖的雌雄个体数量不等，<font color="#faa755">雌雄比例</font>会影响后代的有效种群大小</li><li>种群中的个体数量每年可能是不等的，波动种群的个体遗传贡献率要低于稳定种群，后代的有效种群大小取决于<font color="#faa755">波动的程度</font></li></ol><p>（三）<font color="#d9730d">小种群的遗传障碍</font></p><ol><li><font color="#faa755">遗传漂变（genetic drift）</font>：指种群中的基因频率在围绕长期形成的平均值出现随机增减时，小种群会由于个体过少而经受不住这种波动，使基因在波动中丢失，最终引起基因频率改变，造成遗传多样性的急剧下降。</li><li><font color="#faa755">遗传瓶颈/建群效应</font>： 指由于个体数量过少，基因丢失过多，使种群长时间无法恢复物种原有遗传品质的现象。</li><li><font color="#faa755">统计变化</font>：种群的个体数量围绕环境容纳量随机增减</li><li><font color="#faa755">阿雷效应</font>：种群由于数量少而无法行驶社会功能</li><li><font color="#faa755">环境效应</font>：种群由于数量少而无法经受环境的随机波动</li><li><font color="#faa755">灭绝旋涡</font>：小种群在遗传漂变、遗传瓶颈、统计变化、阿雷效应，以及各种环境效应的共同作用下，能使自己的个体数量一次比一次少。</li></ol><h4 id="岛屿物种与异质种群"><a class="header-anchor" href="#岛屿物种与异质种群"></a>岛屿物种与异质种群</h4><p>（一）<font color="#d9730d">岛屿物种及特征</font>，格外关注的原因：特有物种、生境岛</p><p><font color="#faa755">岛屿物种的特点</font>：</p><ol><li>岛屿是生物多样性的热点地区</li><li>岛屿物种对岛屿有很强的依赖性，通常具有普遍的流动性</li><li>岛屿的特有物种比较多</li><li>岛屿物种由于缺少天敌和疾病，竞争能力普遍很差</li><li>岛屿物种数量存在条件性平衡</li></ol><p>（二）<font color="#d9730d">异质种群及特征</font></p><p><font color="#faa755">异质种群/动态种群/符合种群/集合种群</font>：指具有<font color="#d9730d">斑块分布</font>特点的物种，在一定时间内，<font color="#faa755">通过个体扩散迁移而相互联系的所有局部小种群的集合</font>。</p><p><font color="#faa755">斑块</font>：生物可以居住的较小连续空间</p><p><font color="#faa755">异质种群的特点</font>：</p><ol><li>有已占和未占斑块</li><li>个体在斑块之间能都迁移</li><li>局部种群有灭绝或者重建事件</li></ol><h3 id="人为的遗传丧失"><a class="header-anchor" href="#人为的遗传丧失"></a>人为的遗传丧失</h3><h4 id="遗传构成的人为改变"><a class="header-anchor" href="#遗传构成的人为改变"></a>遗传构成的人为改变</h4><ul><li><font color="#d9730d">干扰自然种群</font></li><li><font color="#d9730d">驯化改良物种</font></li><li><font color="#d9730d">监禁野生动物</font>，包括动物园里的，和人为饲养的特种经济动物。</li></ul><h4 id="监禁个体的人为后果"><a class="header-anchor" href="#监禁个体的人为后果"></a>监禁个体的人为后果</h4><p>（一）<font color="#d9730d">繁殖障碍</font>：</p><ul><li>个体发情和配对非常困难</li><li>性竞争的缺失能降低繁殖率</li><li>社群结构的改变使个体无法繁殖</li><li>无法避免的近交能造成近交衰退</li><li>监禁环境常常不能使动物进入繁殖状态</li><li>人工配对导致个体的染色体不合，造成繁殖异常，甚至频繁流产</li><li>缺少正确的育幼机制，死亡率增高</li></ul><p>（二）<font color="#d9730d">异常行为</font></p><ul><li>应激和恐惧，尤其是刚刚进入人工环境的动物</li><li>规癖和刻板，出现长时间机械性重复动物</li><li>异食，改变食性，吃平时根本不吃或不喜欢吃的食物</li><li>性压抑，并有物种的特异性</li><li>野性丧失</li></ul><p>（三）<font color="#d9730d">遗传衰退</font><br><font color="#faa755">监禁动物的基本特征</font>：</p><ul><li>种群中的个体数量开始时短期上升，但最终会下降</li><li>种群中的个体存活率在保持一段时间后会大幅度降低</li><li>基因杂合率从一开始就直线下降</li><li>种群中的雄性个体会越来越多</li></ul><p>（四）<font color="#d9730d">人工选择</font></p><ul><li>谱系混乱</li><li>基因改变</li><li>性状改变</li></ul><h4 id="基因的人为修饰改造"><a class="header-anchor" href="#基因的人为修饰改造"></a>基因的人为修饰改造</h4><p><font color="#d9730d">遗传工程与转基因</font></p><p><font color="#faa755">遗传工程</font>：利用各种分子技术来改变或提取生物基因，并将其植入到其他生物体里，以获取人类所希望的相应产物。</p><p><font color="#d9730d">转基因的潜在风险</font></p><ul><li>转基因食品可能会伤害人体的健康</li><li>转基因生物会改变许多基因的原有品质</li><li>容易出现风险基因的转移</li><li>能污染自然基因库</li><li>扰乱生物进化历程</li></ul><p><font color="#d9730d">转基因产品的限制</font></p><ul><li>《国际生物多样性公约》</li><li>成立了专门的组织</li><li>转基因产品问世和投入市场之前开展风险评估和检测，进行野外实验，制定相应的防范措施</li><li>控制转基因作物的种植</li><li>加强行政管理</li></ul><h3 id="遗传多样性保护"><a class="header-anchor" href="#遗传多样性保护"></a>遗传多样性保护</h3><h4 id="种群的遗传管理"><a class="header-anchor" href="#种群的遗传管理"></a>种群的遗传管理</h4><p>（一）<font color="#d9730d">自然大种群</font></p><p>管理目标：P219</p><ul><li>了解种群的遗传结构、相互关系，以及基因多样性的大小</li><li>防止有害基因突变的积累，保持基因的长期多样性</li><li>让种群成为有遗传活力的种群，以维持物种的进化潜力</li></ul><p>实现方法：P220-221</p><ol><li>清楚物种分类</li><li>制定适宜的管理单元：ESU（进化重要单元）、OCU（可操作保护单元）、MU（地理管理单元）</li><li>监测物种纯性，防止基因渗入</li><li>监测种群繁殖适合度</li><li>监测物种的适应性遗传变异</li><li>监测环境变化</li><li>具体物种具体分析</li><li>依托群落整体</li></ol><p>（二）<font color="#d9730d">自然小种群</font></p><p>管理目标：P221</p><ul><li>了解小种群的现状和形成原因</li><li>密切监视个体的近交程度及衰退</li><li>让小种群逐渐摆脱灭绝旋涡，恢复成大种群</li></ul><p>实现方法：P221-222</p><ol><li>界定好小种群</li><li>甄别小种群遗传多样性情况</li><li>对多样性丧失不严重的小种群开展风险评价，预测种群未来变化</li><li>对多样性丧失严重的小种群深入研究</li><li>设法补救</li><li>异质种群管理手段，消除小种群，实现基因流动</li></ol><p>（三）<font color="#d9730d">监禁小种群</font></p><p>管理目标：P222</p><ul><li>设法克服小种群的近交衰退和遗传变异下降</li><li>增加个体的繁殖适合度</li><li>让监禁小种群称为物种恢复的源泉</li></ul><p>实现方法：P222-223</p><ol><li>搞清血谱关系</li><li>密切监测种群的遗传多样性</li><li>设法减少近亲繁殖</li><li>增加种群繁殖适合度</li><li>增加个体的繁殖适合度</li><li>维持大的监禁种群</li><li>减小人工选择压力</li><li>让世代数量达到最小，尽快让物种返回自然</li><li>调整繁殖单元大小</li><li>人为转移个体，提高物种的整体安全性</li></ol><h4 id="物种的迁地保护"><a class="header-anchor" href="#物种的迁地保护"></a>物种的迁地保护</h4><p>（一）<font color="#d9730d">迁地保护的流程</font></p><p><font color="#faa755">迁地保护</font>：把某些极度濒危的物种个体移出，直接转移到其他种群，或在人工环境中增加数量，然后放归野外原产地或重新建立种群，从而使物种得到恢复的一系列措施和方法。</p><p>（二）<font color="#d9730d">迁地保护的场所</font></p><ul><li>野外生境：包括原产地和新的适合栖息的环境</li><li>人工环境</li></ul><p><font color="#faa755">保护物种的人工迁地场所必备条件</font>：</p><ol><li>明确物种保护目标</li><li>迁地繁殖场所必须开展种群遗传学研究，让监禁种群有合格的遗传品质</li><li>有有效方法克服小种群问题，减少遗传多样性丧失</li><li>有足够的财力资金支持</li></ol><p>（三）<font color="#d9730d">迁地保护物种</font></p><ol><li>濒危物种</li><li>同等条件下，优先保护分类上独特的物种或分布狭窄的地区特有种</li><li>为了获得资金机构的资助，要选择旗舰物种</li></ol><h4 id="迁地保护的方法"><a class="header-anchor" href="#迁地保护的方法"></a>迁地保护的方法</h4><p>（一）<font color="#d9730d">野外移出和保存</font></p><p>植物采集原则：</p><ol><li>从整个分区挑选5个以上种群采集样本，让其尽可能代表整个分布区；如果种群少于5个，按实际种群量的70%抽取；</li><li>每个种群最好选采10-50个植株，使遗传代表性达到最大；</li><li>按样本特征来确定每棵植株采多少个样本，以保证样本的统计可靠性；</li><li>每次采集样本不可过多，要让野外仍留有一定的繁殖群，以防不测。</li></ol><p>动物捕捉原则：</p><ol><li>分布区中残存种群较多时可选5个以上种群，每个种群选3-5只个体；</li><li>残存种群较少时，选1-2个种群，每个种群1-3只个体；</li><li>分布区只剩一个孤立种群时，最好按实际数量情况来保留部分个体；</li><li>种群已经崩溃时，可活捕全部个体。</li></ol><p>保存遗传物质：种子库、细胞库、基因库、精子库等。</p><p>（二）<font color="#d9730d">动植物人工繁育</font></p><p><font color="#faa755">植物人工繁育</font>：</p><ol><li><font color="#faa755">种子保存</font>，一般要建种子银行；</li><li><font color="#faa755">花粉保存</font>，一般使用超低温；</li><li><font color="#faa755">组织保存</font>，一般要对植物组织进行培养、冷冻，以及液氮保存，大多用于对植物的无性克隆；</li><li><font color="#faa755">植株培育</font>，一般要有大棚、控温、控湿、控光等设施和设备，多用于普通幼苗和克隆幼苗的培育。</li></ol><p><font color="#faa755">动物人工繁育</font>：</p><ol><li>精子采集</li><li>人工授精</li><li>体外受精</li><li>胚胎移植</li><li>显微注射</li><li>克隆</li><li>冷冻</li><li>人工孵化</li></ol><p><font color="#faa755">人工繁育的最终目标</font>：</p><ul><li>设法让动植物能在监禁环境中产生后代</li><li>设法让繁殖出的后代能够重返家园</li></ul><p>（三）<font color="#d9730d">物种的重新引入</font></p><p>迁地保护存在的问题：</p><ol><li>有的再引入后可能<font color="#e03e3e">远离释放地</font>，向其他意想不到的地区扩散；</li><li>被释放的动物带有野外所没有的<font color="#e03e3e">疾病</font>，把疾病传染给野生个体；</li><li>被释放的动物<font color="#e03e3e">不再适应野外生活</font>；</li><li>被释放的个体被亲缘种<font color="#e03e3e">遗传淹没</font>，杂交后原种消失；</li><li>被释放的个体已经有近交衰退等<font color="#e03e3e">遗传障碍</font>，不易被野外伙伴接受；</li><li>人为制造的难度。</li></ol><p><font color="#faa755">再引入成功的影响因素</font>：</p><ol><li>最好使用<font color="#e03e3e">野生源</font>种群的个体，而不是圈养源的个体；</li><li>一次性释放的个体不能过少，最好多于100个；</li><li>必须消除过去使物种濒危或数量下降的因素；</li><li>采用软释放；</li><li>释放地最好有野生的个体。</li></ol><h2 id="第八章-物种多样性丧失与保护"><a class="header-anchor" href="#第八章-物种多样性丧失与保护"></a>第八章 物种多样性丧失与保护</h2><h3 id="物种的生存危机"><a class="header-anchor" href="#物种的生存危机"></a>物种的生存危机</h3><h4 id="物种受威胁类型"><a class="header-anchor" href="#物种受威胁类型"></a>物种受威胁类型</h4><p><font color="#faa755">IUCN</font>（世界自然保护联盟）：1948年成立<br><font color="#faa755">《IUCN物种红色名录等级与标准》</font></p><p><font color="#e03e3e">IUCN的等级标准</font>，IUCN在评估地球上的物种灭绝风险的时候，把除了微生物以外的分类单元划分为9个不同等级。</p><ol><li>灭绝（EX）</li><li>野外灭绝（EW）</li><li>极危（CR）</li><li>濒危（EN）</li><li>易危（VU）</li><li>近危（NT）</li><li>无危（LC）</li><li>数据缺乏（DD）</li><li>未评估（NE）</li></ol><p>级别Ⅸ：未评估（not evaluated, NE）<br>级别Ⅷ：数据不足（data deficient, DD）<br>级别Ⅶ：略需关注（least concern, LC）分布很广或个体数量很多的物种。<br>级别Ⅵ：近危（near threatened, NT）<br>级别Ⅴ：易危（vulnerable, VU）野外灭绝的风险比较高<br>级别Ⅳ：濒危（endangered, EV）野外灭绝的风险很高<br>级别Ⅲ：极危（critically endangered, CE）<br>级别Ⅱ：野外灭绝（extinct in the wild, ew）<br>级别Ⅰ：灭绝（extinct, EX）</p><p>真正受威胁的:级别Ⅴ：易危（vulnerable, VU）野外灭绝的风险比较高、级别Ⅳ：濒危（endangered, EV）野外灭绝的风险很高、级别Ⅲ：极危（critically endangered, CE）</p><p>IUCN的等级标准</p><p>等级调整的原则：</p><ol><li>如果5年以上不再满足原来较高等级的标准，就可以将其降级</li><li>属于错误划分的，可以随时调整，但调整时要重新全面评估</li><li>某个成员应该属于更高的风险等级，可以随时进行调整</li></ol><h4 id="物种的现代灭绝"><a class="header-anchor" href="#物种的现代灭绝"></a>物种的现代灭绝</h4><p><font color="#e03e3e">现代灭绝的特征</font></p><p>与灭绝相关的概念:</p><ol><li><font color="#faa755">局部灭绝</font>（local extinction）/种群灭绝, 物种灭绝前所经历的一系列局部种群的消失，它是极危物种的表征之一。</li><li><font color="#faa755">生态灭绝</font>（ecological extinction）/功能灭绝, 物种在经历局部灭绝时原有的生态功能与作用也随之消失。</li><li><font color="#faa755">人类世灭绝</font>（Anthropocene extinction）, 与人类活动有关的现代物种灭绝。</li></ol><p><font color="#faa755">人类世灭绝与背景灭绝率不同的表现</font>：</p><ol><li>量级加倍</li><li>超额灭绝</li><li>灭绝速度加快</li></ol><p><font color="#e03e3e">物种灭绝的现状</font></p><ul><li>根据IUCN的最新评估，近500年地球至少有791个物种已经灭绝，有63个野外灭绝，854个物种退出了进化的舞台。</li><li>这些灭绝大多发生在北美洲、大洋洲和非洲。</li><li>还有不少物种属已消失多年，但尚无确凿证据证明其灭绝。</li><li>地球近500年来实际灭绝的物种可能在1100种左右。</li></ul><p><font color="#e03e3e">物种灭绝的趋势</font></p><ol><li>大陆上的鸟类和哺乳动物将会加大灭绝的数量。</li><li>未来的灭绝速率要比背景灭绝率高2-4个量级。</li><li>未来大型动物可能会率先消失。</li><li>未来将会出现系列连锁灭绝。</li><li>未来的物种灭绝仍会表现出时滞性。</li><li>不同物种对外来威胁的忍受能力将存在很大差异，从而表现出灭绝过滤器效应。</li><li>有三类特征之一的物种未来更容易灭绝：对生境有特殊要求的物种、遗传变异小的物种、新生和衰老物种</li></ol><h4 id="现代物种的衰落"><a class="header-anchor" href="#现代物种的衰落"></a>现代物种的衰落</h4><p><font color="#e03e3e">地区间差异</font></p><ul><li>亚、非、拉地区情况都比较严重；</li><li>特有哺乳动物中受威胁程度最高的是欧洲，特有鸟类最高的是北美，特有两栖动物最高的是中美洲……</li><li>受威胁的陆地脊椎动物一般分布在热带地区；</li><li>陆地哺乳动物受威胁最厉害的是东南亚等，海洋的主要是日本和加勒比地区；</li><li>鸟类受威胁是世界性的；</li><li>爬行动物受威胁严重的地方是东南亚等；</li><li>两栖动物受威胁比较集中的是加勒比地区；</li><li>淡水物种受威胁主要集中在东非和南非；</li><li>地中海地区受威胁的物种有19%；</li><li>中国是受威胁最严重的国家之一。</li></ul><p><font color="#e03e3e">受威胁趋势</font></p><p>能揭示物种受威胁趋势的指标主要有两种：</p><ol><li>世界自然基金会（WWF）推出的<font color="#faa755">地球生命力指数</font>（Living Planet Index, LPI）：单一物种不同种群个体数量的年变化：A1,A2, ……An，所有物种的平均值：（A1+A2+…An）/n，绘制曲线来揭示整体种群变化趋势。</li><li>IUCN的<font color="#faa755">红色名录指数</font>：在不采取保护措施的情况下，物种能活下来的概率。</li></ol><h3 id="人类的直接威胁"><a class="header-anchor" href="#人类的直接威胁"></a>人类的直接威胁</h3><h4 id="对地球的挤占"><a class="header-anchor" href="#对地球的挤占"></a>对地球的挤占</h4><p><font color="#e03e3e">扩张生存空间</font></p><ul><li><font color="#faa755">致危因素1——人居与商业发展</font>，居住面积和其他非农业用地面积扩张。</li><li><font color="#faa755">致危因素2——农林牧业与水产</font></li></ul><p><font color="#e03e3e">掠用矿物能源</font></p><ul><li><font color="#faa755">致危因素3——能源与矿物开采</font>，使用和开采速度越来越惊人；能量与矿物开发让人类越来越强大，进化速度越来越快；对地球的伤害越来越重</li></ul><p><font color="#e03e3e">铺设道路管线</font></p><p><font color="#faa755">致危因素4——交通运输与管线</font>，陆地交通，水域交通，通讯输送</p><p>给其他物种带来的威胁：</p><ul><li>对物种栖息地的线性切割造成生境破碎</li><li>引起物种的意外死亡</li></ul><h4 id="对物种的伤害"><a class="header-anchor" href="#对物种的伤害"></a>对物种的伤害</h4><p><font color="#e03e3e">索取野生资源</font></p><p><font color="#faa755">致危因素5——对生物资源的索取</font></p><p><font color="#e03e3e">侵扰其他物种</font></p><p><font color="#faa755">致危因素6——侵扰其他物种</font>，战争、动乱、旅游、非目标收获</p><p><font color="#e03e3e">修饰改造自然</font></p><p><font color="#faa755">致危因素7——修饰改造自然</font></p><ul><li>对火和水的控制</li><li>对自然或半自然生境施加的干涉管理</li></ul><h4 id="对生境的改变"><a class="header-anchor" href="#对生境的改变"></a>对生境的改变</h4><p><font color="#e03e3e">扰乱种间关系</font></p><p><font color="#faa755">致危因素8——物种和基因入侵</font></p><p>外来物种对当地原有物种的侵害主要通过4条途径：<font color="#e03e3e">竞争、捕食、杂交、疾病</font></p><p>入侵后果：</p><ol><li>使原有的物种减少</li><li>使原有的生物群落或生态系统出现危机</li><li>能改变原有的种间关系，使原有的基因消失</li><li>能携带新的疾病或寄生虫</li><li>能造成人类经济上的巨大损失</li></ol><p><font color="#e03e3e">污染自然生境</font></p><p><font color="#faa755">致危因素9——人类的各种污染</font></p><p><font color="#e03e3e">引发自然灾变</font></p><p><font color="#faa755">致危因素10——灾害性地质事件</font><br><font color="#faa755">致危因素11——极端的气候变化</font></p><p>对气候变化敏感的物种：</p><ol><li>要求特定生境或小生境的物种；</li><li>耐受阈值比较狭窄的物种；</li><li>依靠环境触发或暗示的物种；</li><li>依靠种间关系生存的物种；</li><li>扩散能力差的物种。</li></ol><h3 id="物种多样性保护"><a class="header-anchor" href="#物种多样性保护"></a>物种多样性保护</h3><h4 id="需要采取的行动"><a class="header-anchor" href="#需要采取的行动"></a>需要采取的行动</h4><ul><li>就地保护：针对致危因素在物种原产地所采取的的各种保护行动。</li><li>迁地保护</li></ul><p>（一）<font color="#e03e3e">生境保护与管理</font></p><ul><li>生境保护：寻找合适的地点来建立或扩大合法保护物种的区域</li><li>生境管理：对某个地点或区域开展保护性管理、对外来及“问题”物种进行控制、对生境和自然过程进行恢复</li></ul><p><font color="#faa755">保护物种，让其摆脱各种生存危机，最终实现与人类的共存。 </font></p><p>物种管理措施：</p><ul><li>可持续开发和利用</li><li>控制收货量和贸易量</li><li>保持种群容纳量</li><li>限制个体过量增长</li><li>……</li></ul><p>（二）<font color="#e03e3e">宣传教育与管理</font></p><ol><li>必须开展教育和提高意识，让人们增加对物种的理解，增强保护物种的能力，同时约束人类自己的行为</li><li>使用政策与法律手段来约束人们的行为</li><li>改善民生与经济</li></ol><h4 id="需要开展的研究"><a class="header-anchor" href="#需要开展的研究"></a>需要开展的研究</h4><p><font color="#e03e3e">研究类别的划分</font></p><p>一、搞清楚物种的基本信息的<font color="#faa755">基础研究</font></p><ul><li>分类单元</li><li>种群个体数量</li><li>分布范围</li><li>生态习性</li><li>生境状况</li><li>受威胁原因</li><li>……</li></ul><p>二、研究如何制定各种保护规划或行动计划</p><ul><li>物种恢复计划</li><li>保护行动计划</li><li>分布区管理计划</li><li>生境管理计划</li><li>……</li></ul><p>三、研究如何监测物种的各种变化</p><ul><li>种群趋势监测</li><li>生境质量检测</li><li>贸易监测</li><li>……</li></ul><p><font color="#e03e3e">种群术语的界定</font></p><ul><li><font color="#faa755">种群</font>（population）：某个分类单元中的所有个体</li><li><font color="#faa755">个体数量</font>（population size）/种群大小：所有成熟个体的数量</li><li><font color="#faa755">亚种群</font>（subpopulation）：非行政划分的生物学意义上的亚种群，彼此有地理等形式的隔离，个体间很难有基因的交换</li><li><font color="#faa755">成熟个体</font>（mature individual）：具有繁殖能力的个体</li><li><font color="#faa755">世代</font>（generation）长度：种群中每代个体更迭的时间</li><li><font color="#faa755">种群个体减少</font>（reduction）：种群中成熟个体数量出现了一定比例的下降，但不是由于正常波动</li><li><font color="#faa755">持续下降</font>（continuing decline）：种群个体数量在最近、目前和未来都表现出下降</li><li><font color="#faa755">种群极度波动</font>（extreme fluctuation）：种群出现高峰与低谷相差10倍以上的迅速增长或下降，并可能导致灭绝。</li><li><font color="#faa755">严重断裂</font>（severely fragmented）：占有区50%以上都已成为斑块，每个斑块又小到无法支持有活力的种群；或斑块之间彼此距离过大，而且50%以上的个体都生活在斑块内。</li><li><font color="#faa755">出现范围</font>（extent of occurrence）:使用最小外凸多边形法绘制的区域，包含所有已知、推测或预计出现个体的地点，但不包括偶尔游荡到的地点。</li><li><font color="#faa755">占有面积</font>（area of occupancy）:维持日常生活所需的最适或最小生境面积。</li></ul><h4 id="需要回答的问题"><a class="header-anchor" href="#需要回答的问题"></a>需要回答的问题</h4><p>（一）<font color="#e03e3e">种群生存力分析</font></p><ul><li><font color="#faa755">种群生存力分析</font>（population viability analysis, PVA），用来估计物种在一定时间内灭绝的概率，最终目标是确定和估计出最小可存活种群（minimumviable population,MVP）。</li><li><font color="#faa755">最小可存活种群</font>：以一定概率存活一定时间的最小种群大小。</li></ul><p>（二）<font color="#e03e3e">可持续收获资源</font></p><p>从理论上讲，只要不破坏繁殖能力，资源物种就会既被人类开发利用，又能自我维持而不至于灭绝。</p><p>只要种群个体数量能控制在K/2以上，那么种群不仅不会衰退，还会以最快的增长速度不断提供新生个体。</p><p>净增长量l=出生量R-不可替代死亡M1-可替代死亡M2</p><p>最大获取量H=出生量R-不可替代死亡M1=可替代死亡M2+净增长量l</p><p>（三）<font color="#e03e3e">使用代表性物种</font></p><p><font color="#faa755">代表性物种选择的原则</font>：</p><ul><li>分布广、种群大</li><li>能举一反三，在生物学或生态学特征上能代表其他物种或类群，也能可靠而敏感的指示其他物种</li><li>个体之间对环境变化反应的差异较小，能满足抽样的要求</li><li>最好是人们对其生活史比较了解的生态或分类知名群</li><li>繁殖地比较容易进入，能快速统计，易于监测</li><li>最好有特殊的生境需求以增加覆盖面</li></ul><p>常用代表性物种：</p><ul><li><font color="#faa755">指示性物种</font>（indicator species）,对人类活动非常敏感，能提早警示环境变化的物种。</li><li><font color="#faa755">伞护性物种</font>（umbrella species），能对生境或群落起伞护性作用的物种。</li><li><font color="#faa755">旗舰物种</font>（flagship species），能够吸引公众的知名物种。</li></ul><h2 id="第九章-生态系统多样性的保护"><a class="header-anchor" href="#第九章-生态系统多样性的保护"></a>第九章 生态系统多样性的保护</h2><h3 id="生态系统的变化"><a class="header-anchor" href="#生态系统的变化"></a>生态系统的变化</h3><h4 id="系统结构的改变"><a class="header-anchor" href="#系统结构的改变"></a>系统结构的改变</h4><p>（一）<font color="#e03e3e">林地生态系统</font>，以森林为主的林地生态系统，形成于新生代初期，由简单的植被演替出亚热带和热带森林。</p><p><font color="#faa755">森林的作用</font>：</p><ul><li>陆地生物生存的重要支撑</li><li>调节气候，涵养水源，保持水土</li><li>净化空气，天然制氧厂，“地球之肺”</li><li>贮存有机碳，调节碳、氮循环</li><li>……</li></ul><ol><li><font color="#faa755">森林面积奔溃式缩减，出现陡跌效应</font></li><li><font color="#faa755">现有森林分布不均匀</font></li><li><font color="#faa755">森林质量严重衰退</font></li><li><font color="#faa755">热带森林消失过快，20世纪90年代以来的消失速度超过了80年代</font></li><li><font color="#faa755">北方林在欧洲和北美有所恢复，1990-2000年间年净增290万hm2</font></li><li><font color="#faa755">人工林虽然逐年增加，但造林强度非常不均，六个森林大国的造林量占总量的70%。人工林还存在许多缺点。</font></li><li><font color="#faa755">与森林有关的陆地生物群系不断减少</font></li></ol><p>（二）<font color="#e03e3e">旱地生态系统</font>，陆地表面干旱指数小于0.65的地方，干旱指数=年平均降雨量/年平均蒸发量</p><ol><li><font color="#faa755">旱地自然生态系统结构比例出现变化</font>，林缘林地、草原比值下降，荒漠比值上升</li><li><font color="#faa755">森林向草原过渡的林缘林地不断缩减，草原也在不断缩减</font></li><li><font color="#faa755">荒漠不断扩张</font></li><li><font color="#faa755">地中海旱地减少</font></li><li><font color="#faa755">旱地中人工生态系统正在不断扩大</font></li><li><font color="#faa755">缺水日趋严重</font></li></ol><p>（三）<font color="#e03e3e">水域生态系统</font>，地球上最大的一类生态系统，包括海洋、海岸、南北极地、岛屿、内陆水域等。</p><ol><li><font color="#faa755">海洋信风带和西风带出现2点突出变化</font>：过渡捕捞导致海洋食物链结构发生改变；人类活动对海底造成破坏</li><li><font color="#faa755">海岸出现4点突出变化</font>：生物多样性持续下降；入海口遭受污染；海岸保护功能下降；珊瑚礁出现徒跌效应</li><li><font color="#faa755">南极出现3点突出变化</font>：海冰融化；食物网发生变化，顶级捕食者缺失；有害物质汇集</li><li><font color="#faa755">北极出现3点突出变化</font>：海冰和永冻层融化；生物组成发生变化；外部物质输入增多</li><li><font color="#faa755">岛屿的生物多样性不断受到人类冲击，岛屿上的森林消失过快</font></li><li><font color="#faa755">陆地水域出现3点突出变化</font>：湿地丧失；大范围污染和衰退；水流不畅</li></ol><h4 id="服务功能的削弱"><a class="header-anchor" href="#服务功能的削弱"></a>服务功能的削弱</h4><p>（一）<font color="#e03e3e">供给服务的转型</font></p><p>越来越多的资源偏向于满足人类的需求。</p><ol><li>只有与高强度人工管理有关的服务才出现了增量</li><li>海洋鱼类资源难以满足人类需求</li><li>天然林木材衰竭</li><li>淡水透支，迫使人们加大对地下水的利用强度</li><li>对能源的转化加剧，导致地球能源储备锐减</li></ol><p>（二）<font color="#e03e3e">调节服务的减弱</font></p><p>生态系统无法发挥原有的正常调节功能。</p><ol><li>调节气候的能力减弱</li><li>控制灾害的能力减弱</li><li>环境自净能力减弱</li></ol><p>（三）<font color="#e03e3e">总体弱化的趋势</font></p><ul><li>与自然有关的服务会越来越弱</li><li>与人类有关的服务会越来越强</li><li>人类对生态系统服务的需求和使用强度有增无减</li><li>生态系统非线性变化越来越多</li><li>能影响弱化趋势的不良管理仍然在各国流行</li></ul><h4 id="自然生境的改变"><a class="header-anchor" href="#自然生境的改变"></a>自然生境的改变</h4><p><font color="#faa755">生境衰退</font>（degradation）：现存的生境在质量上出现下降<br><font color="#faa755">生境丧失</font>（loss）、<font color="#faa755">生境破碎</font>（fragmentation）：物种栖息地格局上发生改变</p><p><font color="#e03e3e">生境的丧失</font></p><ol><li>人类涉足的土地面积广，原始生境消失过多</li><li>自然栖息地越来越多转变成人类用地</li><li>自然水域生境中湿地丧失过多，物种丧失和受威胁比例高</li><li>自然陆地生境丧失最多的是各类森林</li><li>人类开发利用山地，造成生境衰退</li><li>在物种丰富度或特有程度比较高的地方，大量的人为土地转型导致的副作用已经越来越明显</li></ol><p><font color="#e03e3e">生境的破碎</font></p><p><font color="#faa755">生境破碎化/生境片段化/生境岛屿化</font>：面积大而连续的生境被人为缩小或切割成两个以上小块生境的过程。</p><p><font color="#e03e3e">破碎的后果</font>：使原本连续分布的物种出现种群被动隔离，特别是那些要求大范围生境、原始生境、扩散能力低、种群波动大、对生境有特殊需求的物种，受到的影响最严重</p><ul><li>切割后残留的生境一般质量很低</li><li>生境的切割会使生境边缘面积增大，核心面积缩小，出现边际效应</li><li>破碎生境中的植物组成、丰富度、相对多度发生改变</li><li>破碎生境中的动物组成发生改变</li><li>生境破碎后碳循环将发生改变</li><li>生境破碎使许多物种出现涟漪效应</li><li>有些物种对生境破碎的耐受程度很低</li><li>破碎的孤立生境不仅能使生物个体的扩散受到限制，还能增加个体被动迁出和意外死亡的机会</li></ul><h3 id="人为的驱动因素"><a class="header-anchor" href="#人为的驱动因素"></a>人为的驱动因素</h3><h4 id="直接驱动力"><a class="header-anchor" href="#直接驱动力"></a>直接驱动力</h4><p>直接驱动力：可辨认的、明显导致生态系统变化的人为因素</p><p><font color="#e03e3e">环境的陡变</font></p><ul><li><font color="#faa755">自然生物群系面积的陡减</font></li><li><font color="#faa755">人工生态系统面积的陡增</font></li><li><font color="#faa755">气候的非正常变化</font></li></ul><p><font color="#e03e3e">过量的输出</font></p><ul><li><font color="#faa755">淡水输出过度</font></li><li><font color="#faa755">资源输出过度</font></li></ul><p><font color="#e03e3e">异常的输入</font></p><ul><li><font color="#faa755">氮元素人为增多</font></li><li><font color="#faa755">磷元素人为增多</font></li><li><font color="#faa755">各类污染物质不断增多</font></li><li><font color="#faa755">外来物种不断增多</font></li></ul><h4 id="间接驱动力"><a class="header-anchor" href="#间接驱动力"></a>间接驱动力</h4><p>间接驱动力：那些能左右一个或多个直接驱动力，并最终使生态系统产生变化的因素。</p><p><font color="#e03e3e">人口的增长</font><br><font color="#e03e3e">经济的增长</font><br><font color="#e03e3e">社会性活动</font></p><ul><li>社会政治和管理</li><li>科学和技术</li><li>文化和信仰</li></ul><h4 id="驱动力变化"><a class="header-anchor" href="#驱动力变化"></a>驱动力变化</h4><p><font color="#faa755">驱动力发展阶段</font>：</p><ul><li>20万-5万年前，影响极轻</li><li>5万-1万年前，早期移民有局部性影响</li><li>1万-500年前，农业革命产生较大范围的影响</li><li>1500年-1750年，殖民地开发使影响扩大到全球</li><li>1750年-1950年，工业革命使人类影响日益加重</li><li>1950年-现在，地球不堪重负，生态系统出现不利于人类的变化</li></ul><p><font color="#e03e3e">人类的需求</font></p><ul><li><font color="#faa755">粮食需求增加</font></li><li><font color="#faa755">淡水需求增加</font></li><li><font color="#faa755">自然资源需求增加</font></li><li><font color="#faa755">生态系统转型需求增加</font></li></ul><p><font color="#e03e3e">驱动相关性</font></p><ul><li><font color="#faa755">相对性</font>，在某一特定时间内，能导致生态系统变化的所有可能因素中，只有某个（某几个）驱动力能发挥暂时的支配作用。</li><li><font color="#faa755">串联性</font>，很多驱动因素可以联结成因果关系链，甚至“环”。</li><li><font color="#faa755">同步性</font>，有些驱动力能共同驱动生态系统的变化，同步发挥作用。</li><li><font color="#faa755">错综性</font></li><li><font color="#faa755">引领性</font>，在众多可能的因素中，总有某个属于有引领作用的因素。</li><li><font color="#faa755">局限性</font>，相关性强的组合是有限的。</li></ul><p><font color="#e03e3e">驱动的趋势</font></p><ul><li><font color="#faa755">生境变化</font>，20世纪，受生境变化影响最大的生态系统是热带森林、温带草原、内陆水域和海洋。</li><li><font color="#faa755">气候变化</font></li><li><font color="#faa755">外来物种</font>——岛屿</li><li><font color="#faa755">过度开发</font>——热带草原、海洋</li><li><font color="#faa755">氮、磷污染</font>——温带草原、内陆水域、海岸</li></ul><h3 id="生态系统的保护"><a class="header-anchor" href="#生态系统的保护"></a>生态系统的保护</h3><h4 id="策略性措施"><a class="header-anchor" href="#策略性措施"></a>策略性措施</h4><p>（一）<font color="#e03e3e">改变管理方式</font></p><ul><li><font color="#faa755">倡导适应性管理/风险管理</font>，在缺少成功模式的情况下，面对各种各样的不确定性，为实现既定目标而采取的一组<font color="#faa755">实验性策略或措施</font>。</li><li><font color="#faa755">提高决策质量</font></li><li><font color="#faa755">开展决策分析</font></li></ul><p>（二）<font color="#e03e3e">调整发展对策</font></p><p>人类应摈弃目前的各自为政（实力秩序），应全世界联合起来（全球协同），走适应性管理（适应组合）和技术发展（技术乐园）的道路，才有可能最终解决生态系统衰退的问题。</p><p>（三）<font color="#faa755">选设关键地区</font></p><p><font color="#faa755">选设原则</font>：</p><ol><li>物种的丰富程度</li><li>地区的特殊性</li><li>物种受到威胁的严重程度</li></ol><h4 id="尝试性方法"><a class="header-anchor" href="#尝试性方法"></a>尝试性方法</h4><p>生态系统的变化方向</p><ul><li>持续恶化→系统形态转变</li><li><font color="#faa755">良性发展→减缓/恢复</font></li></ul><p>（一）<font color="#e03e3e">景观动态的保护</font></p><p><font color="#faa755">景观</font>（landscape）：由众多生态系统镶嵌而成的，它既包含各种生态功能和过程，也包含人类经济和文化活动。</p><p><font color="#faa755">景观三要素</font>：斑块（块状区域）、廊道（线性结构）、基质（周围环境）</p><p>景观动态保护</p><ol><li>景观要素必须完整</li><li>保持景观的连通性</li><li>确定适宜的管理单元</li></ol><p>（二）<font color="#e03e3e">综合途径的保护</font></p><p><font color="#faa755">生态学方法论</font>：利用生态学原理开展生态系统保护。</p><p><font color="#faa755">人类学方法论</font>：通过公平的方式促进人类对自然资源的保护和可持续利用，解决生态系统退化和人类需求增长的矛盾。</p><ul><li>制度与管理</li><li>经济与激励</li><li>社会与行为</li><li>技术开发与推广</li><li>知识对策</li></ul><p>（三）<font color="#e03e3e">生态系统的恢复</font></p><ul><li>选择地点——有意义、代表性的区域</li><li>恢复景观——重构景观完整性</li><li>生境创建——人为创造新的生境</li><li>生境转移——把可能破坏的生境转移到附近某个安全地点</li></ul><h4 id="自然保护区"><a class="header-anchor" href="#自然保护区"></a>自然保护区</h4><p>自然保护区是指对<font color="#faa755">专门用来保护和维持生物多样性的某个陆地和/或海洋区域</font>，它是一个自然资源所在的区域，也是一个与文化资源有关的区域，还是一个用法律或其他有效手段来管理的区域。</p><p><font color="#e03e3e">保护区的划定</font></p><p>IUCN划分：</p><ol><li>严格自然保留地/荒野保护区</li><li>国家公园</li><li>自然遗迹纪念地</li><li>生境/物种管理区</li><li>受保护的陆地/海洋景观</li><li>资源管理自然保护区</li></ol><p>国际性自然保护区：具有国际保护地位的保护区，最有名的是世界遗产地、生物圈保护区、国际重要湿地保护区</p><p><font color="#e03e3e">保护区的设计</font></p><ul><li>必须满足设计目的——保护对象</li><li>尽可能设计成最佳形状——圆形</li><li>选择适宜的面积——最小种群</li><li>构成整体的保护区网络——减少孤立</li><li>合理优化空间布局</li><li>合理组建内部结构——核心区、缓冲区、环境敏感区</li><li>削弱与周围环境的硬边界</li></ul><p><font color="#e03e3e">保护区的管理</font></p><ul><li>按保护区的不同类型来制定不同的管理目标</li><li>尽力减少人类对保护区的干扰</li><li>按人类干扰程度制定管理强度</li><li>必须设法克服保护区孤岛化</li><li>让当地居民参与保护区管理</li><li>坚持对保护区进行检测</li></ul>]]></content>
    
    
    <summary type="html">仅供参考</summary>
    
    
    
    <category term="生物技术复习资料" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="复习资料" scheme="https://halo123.top/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    <category term="保护生物学" scheme="https://halo123.top/tags/%E4%BF%9D%E6%8A%A4%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>从基因层面对棘皮动物对称性研究</title>
    <link href="https://halo123.top/2021/06/09/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E5%AF%B9%E7%A7%B0%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
    <id>https://halo123.top/2021/06/09/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E5%AF%B9%E7%A7%B0%E6%80%A7%E7%A0%94%E7%A9%B6/</id>
    <published>2021-06-08T16:35:01.000Z</published>
    <updated>2021-06-17T13:06:21.227Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms | Communications Biology (nature.com)</a></p></blockquote><p>Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms</p><p>从基因组学去洞察棘皮动物躯体蓝图从双侧对称转变到五辐射对称</p><h2 id="Abstract"><a class="header-anchor" href="#Abstract"></a>Abstract</h2><p>Echinoderms are an exceptional group of bilaterians that develop pentameral adult symmetry from a bilaterally symmetric larva. However, the genetic basis in evolution and development of this unique transformation remains to be clarified. Here we report newly sequenced genomes, developmental transcriptomes, and proteomes of diverse echinoderms including the green sea urchin (<em>L. variegatus</em>), a sea cucumber (<em>A. japonicus</em>), and with particular emphasis on a sister group of tvhe earliest-diverged echinoderms, the feather star (<em>A. japonica</em>). We learned that the last common ancestor of echinoderms retained a well-organized Hox cluster reminiscent of the hemichordate, and had gene sets involved in endoskeleton development. Further, unlike in other animal groups, the most conserved developmental stages were not at the body plan establishing phase, and genes normally involved in bilaterality appear to function in pentameric axis development. These results enhance our understanding of the divergence of protostomes and deuterostomes almost 500 Mya.</p><blockquote><p>棘皮动物是一类特殊的对称动物，幼虫两侧对称发育为成体则是五辐射对称。这种进化的遗传基础和独特的变态发育有待解释。在这里，我们报告了新测序的基因组、发育转录组和多种棘皮动物的蛋白质组，其中包括绿海胆（ <em>L. variegatus</em>）、海参（<em>A. japonicus</em>）和一类早期的分支——海羽星（<em>A. japonica</em>）。我们获悉，棘皮动物最后的共同祖先，保留着和半索动物类似的有序的 Hox 基因簇，并且基因簇参与了内骨骼的发育。进一步的研究发现，棘皮动物不像其他动物群，其最保守的发育阶段并不是在躯体蓝图（body plan）构建时期，而涉及两侧对称的基因在五辐射对称的发育中可能发挥作用。通过这些研究结果更加肯定了——原口动物和后口动物产生分歧在差不多 500 万年前。</p></blockquote><h2 id="Introduction"><a class="header-anchor" href="#Introduction"></a>Introduction</h2><p>Bilateral symmetry is highly conserved throughout animal evolution. Echinoderms, a group closely related to chordates, are exceptional in this regard, developing pentameral symmetry as adults from bilaterally symmetric larvae. Even sea cucumbers, which show worm-like bilateral structures as adults, retain pentameral symmetry patterning along their oral-aboral axis (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1a</a>)<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR1">1</a></sup>. Understanding the development of pentameral symmetry would provide important insight into the evolutionary mechanisms of major structural changes in evolution<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR2">2</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR3">3</a></sup>. To probe the genetic and developmental transitions behind the evolution of these unique echinoderm features, we sequenced genomes of the green sea urchin (<em>Lytechinus variegatus</em>) and the feather star (<em>Anneissia japonica</em>), representing nearly 500 Mya of evolutionary history. We also added developmental transcriptomic datasets for other echinoderms (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a> and “Methods”), such as the sea cucumber (<em>Apostichopus japonicus</em>), and proteome analyses of feather star skeleton to broadly analyze five living echinoderm classes. These data provide fundamental genomic, transcriptomic, and proteomic insights of body plan evolution in echinoderms, and enhance our understanding of the divergence of protostomes and deuterostomes.</p><blockquote><p>在整个动物进化过程中，两侧对称形式是高度保守的。但作为一个与脊索动物有着密切相关的棘皮动物，在这方面是例外的，其从两侧对称的幼虫发育成五辐射对称的成体。即使是海参，在成年时表现出类似蠕虫的两侧结构，也沿着它们的口-口轴保持着五辐射对称模式（图 1a）。了解五辐射对称的发展将为了解演化过程中主要结构变化的演化机制提供重要的信息。为探究这些独特的棘皮动物特征进化背后的遗传和发育转变，我们对绿海胆（<em>Lytechinus variegatus</em>）和海羽星 (<em>Anneissia japonica</em>）的基因组进行了测序，两者有近 5 亿年的进化史。我们还补充了其他棘皮动物的发育转录组的数据集（补充 表1-22 和 “方法”章节），比如海参（<em>Apostichopus japonicus</em>）和海羽星骨骼的蛋白质组，以此去分析现存的五种棘皮动物。这些数据为棘皮动物躯体蓝图进化的基因组学、转录组学和蛋白质组学提供了基础，并加深了我们对原口动物和后口动物差异的理解。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/EchinodermsAndTheirEvolutionaryDiversity.png" alt="EchinodermsAndTheirEvolutionaryDiversity"></p><p><strong>a</strong> Echinoderm species of five living classes were analyzed in this study. Pentameral symmetry can also be observed in the transverse section of the sea cucumber (top), which otherwise shows apparent bilaterality. <strong>b</strong> Evolutionary rate and the phylogenetic tree constructed by RAxML software using the 1196 orthologous protein sequences identified by reciprocal best blast hit (RBBH). The values on branches represent bootstrap values. <strong>c</strong> Schematic representation of genomic organization of ambulacrarian Hox clusters. Arrows and horizontal lines represent Hox genes and chromosomal DNAs, respectively. Dashed lines indicate the presence of unconnected scaffolds. See Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">13</a> for more detailed Hox cluster structures. Hox cluster structures of <em>S. kowalevskii</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a></sup>, <em>A. japonicus</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a></sup>, <em>S. purpuratus</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a></sup><em>, O. spiculata</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a></sup> and <em>A. planci</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a></sup> are according to the previous studies.</p><blockquote><p><strong>a</strong> 对5个现存纲的棘皮动物种类进行了分析。尽管海参是明显的两侧对称，但横切面（上）可以观察到五辐射对称。<strong>b</strong> 利用 RBBH (reciprocal best blast hit, RBBH）鉴定的 1196 条同源蛋白序列，利用 RAxML 软件构建进化速率和系统发育树。分支上的值表示自展支持率（bootstrap values）。<strong>c</strong> 步带动物的 Hox 基因组组织示意图：箭头和水平线分别代表 Hox 基因和染色体 DNA。虚线表示存在未连接的序列片段。Hox 簇结构详见补充图 13。<em>S. kowalevskii</em>. <em>A. japonicus</em>, <em>S. purpuratus</em>, <em>O. spiculata</em> 和 <em>A. planci</em> 的 Hox 簇结构均为前人研究所得。</p></blockquote><h2 id="Results"><a class="header-anchor" href="#Results"></a>Results</h2><h3 id="Genetic-changes-behind-echinoderm-evolution"><a class="header-anchor" href="#Genetic-changes-behind-echinoderm-evolution"></a>Genetic changes behind echinoderm evolution</h3><blockquote><p>棘皮动物进化背后的遗传变化</p></blockquote><p>The estimated genome sizes were 952 Mb for green sea urchin and 553 Mb for the feather star (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>), with 30,238 and 26,838 protein-coding genes, respectively (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">18</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Basic features of these genomes such as GC content, gene length, and exon number were comparable to those of chordate and hemichordate species (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>). Genome-wide analysis with 1196 one-to-one orthologs (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1b</a>, Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>, and Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a>) robustly corroborated recent reports<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR4">4</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR5">5</a></sup> that Echinodermata consists of the early diverged Crinoidea (including feather star), Asterozoa (including brittle star and sea star), and Echinozoa (including sea urchin and sea cucumber). This is consistent with paleontological evidence that suggests echinoderms first evolved with a stemmed, or imperforate extra-axial morphology<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR3">3</a></sup>. We also found that the overall protein sequences of an early diverged echinoderm species, the feather star, showed a relatively low evolutionary rate. Meanwhile, echinoderms showed only slightly diverged protein sequences from vertebrates, as opposed to an ascidian, a species with highly derived morphological features, and with significantly diverged genomic sequences from vertebrates (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">8</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">26</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">28</a>).</p><blockquote><p>估计绿海胆的基因组大小为 952 Mb 和 海羽星的基因组大小为 553 Mb （补充 图 1），分别有 30238 和 26838 个蛋白质编码基因（补充 表 18-20 和 23）。这些基因组的 GC 含量、基因长度和外显子数等基本特征与脊索类和半脊索类相似（补充 图 2-7）。通过全基因组分析得到 1196 条同源序列（图 1b，补充 图 7 和 表 23-24），有力地证实了最近的报道的棘皮动物门由早期独立分支出的海百合亚门（包括海羽星）、海星亚门（包括海蛇尾和海星）和海胆亚门（包括海胆和海参）组成。这与古生物学的证据相一致，棘皮动物首先进化出有茎或无轴的形态。我们还发现，棘皮动物的早期独立分支海羽星的整体蛋白质序列显示出相对较低的进化率。与此同时，在棘皮动物的基因组序列与脊椎动物的有较大差异的情况下，对比蛋白质序列棘皮动物的与脊椎动物的仅略有不同，而与形态结构与典型的脊索动物有很大差异海鞘（脊索动物）相反（补充 图 8 和 补充 表 26-28）。</p></blockquote><p>Given that echinoderms evolved unique features without significant genome-wide changes detected, we tested abundance in sets of gene families that may have played critical roles in the evolution of the echinoderm features. We first tested if numbers of genes potentially involved in development (such as genes involved in cell-cell communications) have expanded in the common ancestor of echinoderms (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">10</a>). In contrast to our expectation, GO term enrichment analysis suggested that no such terms were enriched in the echinoderm-expanded gene set (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11</a>). Rather, GO terms such as “cell communication”, or “signal transduction”, were present in echinoderm-contracted genes (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11a</a>). Further, genes potentially involved in cytoskeletal regulation appear to have experienced extensive modifications during echinoderm evolution. For example, the “plectin repeat domain”, one of the important domains of cytolinkers that connect cytoskeletal elements with each other and to junctional complexes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR6">6</a></sup>, was not found in any of the five echinoderm species (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">12</a>). Similarly, genes potentially involved in actin cytoskeleton regulation such as BCAR1/CAS and PIP5K were found to be positively selected during echinoderm evolution (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">29</a>), suggesting substantial modifications of cytoskeletal function during echinoderm evolution.</p><blockquote><p>鉴于棘皮动物进化出了独特的特征，但没有检测到重大的全基因组变化，我们测试了大量可能在棘皮动物特征的进化中发挥关键作用的基因家族。我们首先测试了在棘皮动物的共同祖先中，其潜在参与发育的基因（比如参与细胞间通讯的基因）的数量是否已经增加（补充 图 10 ）。但与我们的预期相反，通过 GO 术语富集分析（GO term enrichment analysis）表明，在棘皮动物扩展的基因集合中没有这样的术语（term）富集（补充 图 11）。但 GO 术语（GO term）例如“细胞通讯”或“信号传导”存在于棘皮动物的收缩基因（echinoderm-contracted genes）中。此外，可能参与细胞骨架调控的基因似乎在棘皮动物进化过程中经历了大量的修饰。例如，胶凝素重复结构域（plectin repeat domain）是将细胞骨架元素相互连接和连接复合体的细胞连接物的重要结构域之一，但在 5 种棘皮动物中均未发现。我们发现，在棘皮动物进化过程中BCAR1/CAS 和 PIP5K 等可能参与肌动蛋白细胞骨架调控的基因被正向选择了下来（补充 表 29），这表明在棘皮动物进化过程中细胞骨架功能发生了重大改变。</p></blockquote><h3 id="Hox-clusters-in-ambulacrarians"><a class="header-anchor" href="#Hox-clusters-in-ambulacrarians"></a>Hox clusters in ambulacrarians</h3><blockquote><p>步带类动物的 Hox 基因簇</p></blockquote><blockquote><p>步带类动物是由棘皮动物门与半索动物门组成的一类动物</p></blockquote><p>We next analyzed genes in the Hox cluster, since previous studies implied that echinoderms may have undergone extensive changes to the genomic-arrangement of these genes early in their evolution<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a></sup>, but this is controversial<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a></sup>. By analyzing the echinoderm genomes, together with BAC sequencing and fluorescent in situ hybridization (FISH) experiments on feather star (see Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">13</a>), we found that <em>A. japonica</em> have 10 clustered Hox genes (Hox1 through Hox11/13a), together with two posterior genes (Hox11/13b and Hox11/13c) located with inverse directions more than 360 kb apart from the cluster of 10 Hox genes (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">14</a>). This situation is reminiscent of hemichordate Hox gene clusters, which consist of 12 genes with the inversion/translocation of two posterior genes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a></sup>. The consistent differences of Hox genes in feather star from those of hemichordates (<em>Saccoglossus kowalevskii</em> and <em>Ptychodera flava</em><sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a></sup>) were that the two posterior genes have face-to-face orientations, and two additional posterior genes (Hox11/13d and Hox11/13e) are present as reported in other echinoderm genomes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a></sup>. These characteristics in turn suggest that the last common ancestor of echinoderms retained a canonical arrangement of 10 Hox genes, while its posterior genes had increased in number and changed their locations. This view accordingly indicates that the changes previously noted with the Hox gene clusters of echinoderms<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a></sup>, including the loss of Hox4 or Hox6 and the inversion/translocation of anterior genes, are lineage-specific events, and therefore are unlikely to be involved in the establishment of pentameral body plan. On the other hand, the involvement of the posterior Hox genes, are important candidates in the establishment of the pentameral body plan (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1c</a>).</p><blockquote><p>我们接下来分析了 Hox 基因簇中的基因，在此前的研究表明，棘皮动物在进化早期可能经历了大量的基因组排列的改变，但这一说法是有争议的。通过分析棘皮动物基因组，并结合海羽星 BAC 测序和荧光原位杂交（FISH）实验（见补充 图 13），我们发现 <em>A. japonica</em>  有 10 个聚合在一起的 Hox 基因簇（Hox1 到 Hox11/13a），以及 2 个在后部的距离这 10 个 Hox 基因簇位置超过 360 kb 的并且方向相对的基因（Hox11/13b 和 Hox11/13c）（补充图 14）。这种情况让人想起了半索动物的 Hox 基因簇，同样该基因簇由 12 个基因组成，其中 2 个在后部的基因有倒位或易位现象。海羽星与一些半索动物（<em>Saccoglossus kowalevskii</em> 和 <em>Ptychodera flava</em>）在后部的这 2 个 Hox 基因存在方向不一致的差异，并且有报道称，在棘皮动物基因组中还存在另外 2 个在后部的基因（Hox11/13d 和 Hox11/13e）。 种种迹象表明，棘皮动物的最后一个共同祖先保留了 10 个 Hox 基因簇的典型排列，在演化过程中其在后部的基因数量发生了增加并且它们的位置发生了改变。以上观点表明棘皮动物 Hox 基因簇的变化，包括 Hox4 、Hox6 和在前部的基因的倒位/易位，是特殊的世系事件，不太可能参与建立五辐射对称的躯体蓝图。同时说明，在后部的 Hox 基因是参与建立五辐射对称的躯体蓝图重要候选基因（图 1c）。</p></blockquote><h3 id="Echinoderm-embryogenesis-show-hourglass-like-conservation"><a class="header-anchor" href="#Echinoderm-embryogenesis-show-hourglass-like-conservation"></a>Echinoderm embryogenesis show hourglass-like conservation</h3><blockquote><p>棘皮动物胚胎发生呈保守沙漏形式</p></blockquote><p>We next tested if evolution of echinoderm embryogenesis follows the developmental hourglass model<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR11">11</a></sup> as supported in several animal groups<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR12">12</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR14">14</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR15">15</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR16">16</a></sup>. The phylotype hypothesis of the hourglass model predicts that anatomical features of most conserved-embryonic phase represent the body plan of their animal phylum<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR11">11</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR17">17</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR18">18</a></sup>. We tested if the developmental stages most critical for the pentameral body plan show the highest transcriptomic conservation. Recent studies reported that the transcriptomic conservation is instead around blastula to gastrula in sea urchins<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR19">19</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR20">20</a></sup>, however, these studies only examined embryonic sea urchins. We thus analyzed gene expression profiles by covering early-to-late embryos of four diverse echinoderm species, including the publicly available data of purple sea urchins<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR21">21</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR22">22</a></sup> and a sea cucumber<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR23">23</a></sup> (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">15</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">16</a>). Unexpectedly, while the hourglass-like conservation was observed, the most conserved phase was not bracketing the pentameral establishing stages (defined as stages when first pentameral symmetric structures appear), but it was instead during gastrulation (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2a</a> and Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">17–18</a>). This mismatch between the most conserved phase and the phase for establishing the body plan was also supported by pair-wise comparisons of one-to-one orthologs (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a>). These results suggested that, unlike in other animal groups such as vertebrates, the phase for establishing the body plan in echinoderms has experienced substantial diversification during their evolution, further implying that the phylotype hypothesis may not fit within echinoderm embryogenesis. However, a potential caveat of this conclusion would be that the conservation signals from adult rudiments could have been obscured by larval tissues, as adult rudiments share only a small proportion of embryo in early metamorphic stages. Similar analyses with dissected adult rudiment, or single-cell RNAseq technology could clarify this point. While possible contribution of pleiotropic constraints were supported between the closely related species as reported previously<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR24">24</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR25">25</a></sup> (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a>), further studies are needed to clarify the evolutionary mechanism behind the unique evolution of echinoderm embryos.</p><blockquote><p>我们接下来试验棘皮动物胚胎发生的进化是否遵循发育沙漏模型，该模型已被几个动物群体验证支持。系统发育假说（the phylotype hypothesis）的沙漏模型预测出的动物躯体蓝图特征会在解剖学中最保守胚胎时期的表现出来。我们对构建五辐射对称的躯体蓝图最关键的发育阶段进行实验，检测这些时期转录组是否会高度保守。最近研究报道，海胆的从囊胚到原肠胚转录组是保守的，然而，这些研究只检测了海胆胚胎。因此，我们分析了包括公开数据的紫海胆和海参在内的 4 种不同棘皮动物从早期至晚期胚胎的基因表达谱。出乎意料的是，虽然观察到沙漏样保守，但最保守的阶段并不是五辐射对称建立阶段（定义为五辐射对称结构首先出现的阶段），而是在原肠胚形成的阶段（图 2a 和补充图 17 ~ 18）。这种最保守的时期和建立躯体蓝图的时期之间的不匹配也被一对一的同源序列的配对比较所支持（补充图 19）。这些结果表明，与脊椎动物等其他动物不同，棘皮动物的躯体蓝图建立阶段在进化过程中经历了大量的变化，进一步表明系统发育假说可能不适用于棘皮动物胚胎发生。然而，这一结论的一个潜在提示是，来自成体雏形的保守信号可能被幼虫组织所掩盖，因为成体雏形只占早期变态阶段的胚胎的一小部分。用解剖的成体雏形或单细胞 RNAseq 技术进行类似的分析可以阐明这一点。虽然先前报道的近亲缘物种之间可能存在多向性限制（补充图 20 和 21），但需要进一步的研究来阐明棘皮动物胚胎独特进化背后的机制。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/%E8%83%9A%E8%83%8E%E6%B2%99%E6%BC%8F.png" alt="胚胎沙漏"></p><blockquote><p>图引自 The developmental hourglass model: a predictor of the basic body plan? doi：10.1242/dev.107318 用于理解胚胎沙漏，与原文无关</p></blockquote><h3 id="Partial-co-option-in-pentameral-body-plan-establishment"><a class="header-anchor" href="#Partial-co-option-in-pentameral-body-plan-establishment"></a>Partial co-option in pentameral body plan establishment</h3><blockquote><p>局部选配在五辐射对称的躯体蓝图建立</p></blockquote><p>Paleontological studies suggested the possible evolution of pentameral body axes through changes in the mechanisms of bilateral symmetry<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR26">26</a></sup> (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2b</a>). However, developmental genes that control the pentameral symmetry remains largely unknown. We thus focused on genes that are involved in Left/Right-patterning and other axis-forming in bilaterians<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR27">27</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR28">28</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR29">29</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR30">30</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR31">31</a></sup> and examined expression patterns of their homologs in the feather star, particularly at the attachment and cystidean stages when the pentameral body plan forms (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Among the genes examined, <em>pitx</em> exhibited relatively strong expression in the calyx, where the pentameral structure first becomes evident (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2c–d</a>,). Weak expression of <em>chordin</em> was also detected in the calyx (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Meanwhile, expression of <em>bmp2/4</em>, <em>nodal</em>, <em>lefty</em> and <em>not</em> were detected most during gastrula to doliolaria stages (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>), but not in the calyx (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>), implying that these genes are possibly involved in the body patterning during bilateral planktonic development rather than pentameral body plan development. These results suggest that evolution of the pentameral body plan may have associated partial co-option of genes involved in existing body axes, which in part, coincides with paleontological predictions that modification of bilateral patterning system contributed to the pentameral body plan establishment<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR26">26</a></sup>.</p><blockquote><p>古生物学研究表明，五辐射对称可能是通过两侧对称机制的进化的而来。然而，控制五辐射对称的发育基因在很大程度上仍然未知。因此，我们把重点放在了涉及两侧对称动物左/右模式和其他轴形成的基因上，并研究了它们在海羽星中的同源基因的表达模式，特别是在五辐射对称形成时的附着和囊状体阶段（补充图 22 及 23）。在检测的基因中，<em>pitx</em> 基因在五边形结构首先变得明显的杯状结构中表达较强（图 2c ~ d）。在杯状结构中也检测到微弱的 <em>chordin</em> 表达（补充图 23）。同时，<em>bmp2/4</em>、<em>nodal</em>、<em>lefty</em> 和 <em>not</em> 的表达在原肠胚到桶形幼虫阶段最多（补充图22），但在杯状结构中不表达（补充图 23），这意味着这些基因可能参与了两侧浮游生物体型的发育，而不是五辐射体型的发育。这些结果表明，五辐射躯体蓝图的进化可能与参与现有体轴的部分基因共同选择有关，这在一定程度上与古生物学的预测一致，即两侧模式系统的修改有助于五辐射躯体蓝图的建立。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/fig2.3y7jx8k9d7a0.png" alt="fig2"></p><p><strong>a</strong> Mid-embryonic conservation found in echinoderm species. Based on expression distance (expDists, see also Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">17</a>) of orthologous groups (defined by orthomcl<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR57">57</a></sup>), an evolutionary conservation of developmental stages were estimated for three taxonomic levels (Lv-Sp, Lv-Sp-Apj, Lv-Sp-Apj-Anj, see also “methods”). The vertical axis represents percentages of the stage being included in the most (top 1%) conserved stage-combinations<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a></sup> (Ptop). Changes of the Ptop scores were significant among stages (Friedman test). Error bars represent S.D. of Ptop values. In each species, the developmental phase in which pentameral body plan establishment begins is colored in gray. <strong>b</strong> Possible evolutionary transition from bilateral symmetry to pentameral symmetric body plan suggested by paleontological studies<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR61">61</a></sup>. The basal echinoderms had a bilaterally symmetric ambulacral system that is arranged in a 2–1–2 pattern (left); consisting of one unpaired ambulacrum (1) and two ambulacra with a distal bifurcation (2&amp;3, 4&amp;5) and a single unpaired ambulacrum (1). <strong>c</strong> Feather star development from bilateral symmetry to pentameral symmetry. <a href="http://a.nc">a.nc</a> aboral nerve center, ar archenteron, ap adhesive pit, dt digestive tract, es enteric sac, hc hydrocoel, <a href="http://l.sc">l.sc</a> left somatocoel, o.rn oral ring nerve, po podia, <a href="http://r.sc">r.sc</a> right somatocoel, st stomodeum. <strong>d</strong> <em>pitx</em> gene expression detected in embryos of attachment stage and cystidean stage. In cystidean embryos, <em>pitx</em> was expressed in the tissues around the gut (arrows) and the inner tissue of the whole stalk (arrowheads). Scale bars: 100 μm. The expression was detected by in situ hybridization with whole mount (left) and sectioned specimens (right).</p><blockquote><p><strong>a</strong> 在棘皮动物物种中发现的胚胎中期保守。基于直系同源基因簇（由 orthomcl 定义）的表达距离（expDists，见补充图 17），对 3 个分类水平（Lv-Sp, Lv-Sp-Apj, Lv-Sp-Apj-Anj，见“methods”）的发育阶段的进化保守性进行了估计。纵轴表示包含在最保守阶段（top 1%）中的阶段百分比（Ptop）。Ptop 得分在各阶段间变化显著（Friedman检验）。误差棒表示 Ptop 值的标准差。在每个物种中，建立五辐射对称躯体蓝图开始的发育阶段用灰色表示。<strong>b</strong> 古生物学研究表明，可能从两侧对称进化到五辐射对称躯体蓝图。基本的棘皮动物具有两侧对称的步带系统，步带系统按 2-1-2 模式排列（左）；由一个不配对的布带（1）和两个具有远端分叉的步带（2&amp;3,4&amp;5）和一个单一的不配对的步带（1）组成。<strong>c</strong> 海羽星由两侧对称向五辐射对称发展。<a href="http://a.nc">a.nc</a> 口神经中枢，ar 原肠，ap 粘连窝，dt 消化道，es 肠囊，hc 积液腔，<a href="http://l.sc">l.sc</a> 左体腔，o.rn 口环神经，po 足，<a href="http://r.sc">r.sc</a> 右体腔，st 口腔。<strong>d</strong> <em>pitx</em> 基因在附着期（attachment stage）和囊体期（cystidean stage）胚胎中的表达。在囊体期胚胎中，<em>pitx</em> 在肠道周围组织（箭头）和整个茎的内部组织（箭头）中表达。比例尺：100 μm。左为整体装片，右为切片标本，采用原位杂交法检测表达。</p></blockquote><h3 id="Proteome-analyses-of-echinoderm-skeleton"><a class="header-anchor" href="#Proteome-analyses-of-echinoderm-skeleton"></a>Proteome analyses of echinoderm skeleton</h3><blockquote><p>棘皮动物骨骼的蛋白质组分析</p></blockquote><p>Mineralized endoskeleton is another notable feature of echinoderms. Despite the widely conserved endoskeleton structures in echinoderms, some of the proteins first identified in sea urchin biomineralization, such as MSP130, have not been identified in the skeleton of other echinoderm species. The MSP130 gene was suggested to have originated in prokaryotes and was introduced into metazoan genomes, including echinoderms, by horizontal gene transfer<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR32">32</a></sup>. An MSP130-like gene involved in biomineralization has also been identified in a polychaete<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR33">33</a></sup>. The authors suggest that the MSP130 gene was present in the common ancestor to bilaterians, rather than being introduced into protostomes and deuterostomes in separate lateral transfer events. The MSP130 protein was then co-opted into skeleton formation at some point in echinoderm evolution. The gene was duplicated in sea urchins and the resulting paralogues acquired repetitive regions<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR32">32</a></sup>. The MSP130 gene is present in other echinoderm genomes, but is not utilized in the proteome of brittle stars<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR34">34</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR35">35</a></sup> or sea stars<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a></sup>. Here, we performed a proteome analysis and identified 280 proteins that are included within the mineral of the adult feather star skeleton (see “Methods”). These skeletal proteins included a protein similar to the urchin MSP130 proteins, suggesting that the ancestral echinoderm had co-opted this single protein into biomineralization (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a>). A number of other genes encoding skeletal proteins and domains conserved between the purple sea urchin (<em>S. purpuratus</em>) and the feather star were also identified (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig3">3</a>). Among these, we found two proteins with C-type lectin domains, which are also found on the urchin spicule matrix proteins. C-type lectin proteins are absent in sea star skeletons<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a></sup>, and present in only a few copies in brittle star skeletons<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR34">34</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR35">35</a></sup>. Sea urchin skeletons utilize a large number of C-type lectins, mostly with repetitive stretches of acidic amino acids<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR37">37</a></sup>, while the feather star and brittle star proteins lack these repetitive domains (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">25</a>). A possible evolutionary scenario to explain these differences is that the ancestral skeletal C-type lectin genes experienced extensive duplication and acquisition of repetitive domains in the sea urchin lineage. The use of C-type lectins in the sea star skeleton was lost, while the C-type lectins in the feather star and brittle star skeletal proteomes remain largely unchanged. Together, these results suggest that the precursors to all of the genes and domains used in echinoderm skeleton were already present in the common ancestor to echinoderms, which emerged 589.7 Mya (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>). Additionally, these skeleton-related genes may have undergone frequent duplication and loss in specific lineages, together with frequent changes in gene expression, since expression of MSP130-like genes and C-type lectin genes in the skeleton forming cells were lost in some lineages, even though these genes exist in their genomes. In summary, our study highlights the genomic, transcriptomic and proteomic changes behind the evolution of unique features in echinoderms, and offers an exceptional case in understanding the general tendency for the evolution of body plans.</p><blockquote><p>内骨骼矿化是棘皮动物的另一个显著特征。尽管棘皮动物的内骨骼结构十分保守，但一些的蛋白质最早被鉴定是在矿化海胆中，如 MSP130，尚未在其他棘皮动物的骨骼中发现。MSP130 基因被认为起源于原核生物，并通过水平基因转移引入包括棘皮动物在内的后生动物的基因组。一个涉及生物矿化的类似 MSP130 基因（MSP130-like gene）也在多毛纲动物中被鉴定出来。作者认为，MSP130 基因存在于两侧动物的共同祖先中，而不是在单独的水平转移中被引入到原口动物和后口动物中。在棘皮动物进化的某个阶段，MSP130 蛋白参与了骨骼的形成。该基因在海胆中发生重复，由此导致旁系同源基因获得重复域。MSP130 基因存在于其他棘皮动物基因组中，但在海蛇尾和海星的蛋白质组中没有表达。在这里，我们进行了蛋白质组分析，并鉴定了包括成体海羽星骨骼的矿物质在内的 280 个蛋白质（见方法）。这些骨骼蛋白中包含一种类似于海胆 MSP130 蛋白的蛋白质，这表明棘皮动物的祖先利用了这一个蛋白质进行生物矿化（补充图 24）。此外，还发现了一些其他的基因，这些基因编码了紫色海胆（<em>S. purpuratus</em>）和海羽星之间的骨骼蛋白和保守域。其中，我们发现了两个具有 C 型凝集素结构域（C-type lectin domains）的蛋白，它们也存在于海胆骨针基质蛋白（spicule matrix proteins）上。C 型凝集素蛋白在海星骨骼中不存在，而在海羽星的骨骼中仅存在少数拷贝。海胆骨骼利用了大量的 C 型凝集素，且大多数是酸性氨基酸的重复延伸，而海羽星和海蛇尾蛋白缺乏这些重复的结构域（补充图 25）。一个可能的进化方案，用来解释这些差异是在海胆谱系中，祖先的骨骼 C 型凝集素基因经历了重复并且获得了重复结构域。海星骨骼中 C 型凝集素消失了，而海羽星和海蛇尾骨骼蛋白质组中的 C 型凝集素基本保持不变。结合这些结果表明，棘皮动物骨骼中使用的所有基因和结构域的前体已经存在于 589.7 百万年前棘皮动物的共同祖先中。此外，这些与骨骼相关基因可能在特定谱系中发生频繁的重复和丢失，以及基因表达发生的频繁变化，因为在某些谱系中，在骨架形成的细胞中即使类似 MSP130 基因和 C 型凝集素基因存在于它们的基因组中，但它们不表达。综上所述，我们的研究突出了棘皮动物独特特征进化背后的基因组、转录组和蛋白质组的变化，并为理解躯体蓝图进化的一般趋势提供了一个案例。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/fig3.5agk1rrq6q80.png" alt="fig3"></p><p><strong>a</strong> SEM image of a skeletal element isolated from the feather star (<em>A. japonica</em>). <strong>b</strong> Proteins present in the feather star skeletal proteome were isolated from adult skeleton and identified by comparison of LC/MS/MS data to the genes computationally identified in the feather star genome. These proteins were compared to those found in skeletal proteomes of the sea urchin <em>S. purpuratus</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR62">62</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR63">63</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR64">64</a></sup>, the sea star <em>P. miniata</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a></sup> and the brittle star <em>O. spicullata</em> <sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR35">35</a></sup>. The most prevalent proteins are shown in the figure, along with the number of different proteins from the listed groups present in each species’ proteome. The feather star skeletal proteome contains members of each of the protein families shown. The other echinoderm species are missing some of these proteins in their skeletal proteome and the number of members in each protein family varies between groups.</p><blockquote><p><strong>a</strong> 从海羽星（<em>A. japonica</em>）分离出来的骨骼元素的扫描电镜图像。<strong>b</strong> 从海羽星成体骨骼中分离出的骨骼蛋白质组，并通过 LC/MS/MS 数据与海羽星基因组中计算鉴定的基因进行了鉴定。将这些蛋白质与海胆（<em>S. purpuratus</em>）、海星（<em>P. miniata</em>）和海蛇尾（<em>O. spicullata</em>）的骨骼蛋白质组中的蛋白质进行了比较。图中显示了最常见的蛋白质，每个物种有不同数量的蛋白质组。海羽星的骨骼蛋白质组涵盖了所展示的所有蛋白质家族的成员。其他棘皮动物的骨骼蛋白质组中或多或少缺少的部分蛋白质，每个蛋白质家族成员的数量不相同。</p></blockquote><h2 id="Methods"><a class="header-anchor" href="#Methods"></a>Methods</h2><h3 id="Animal-care-and-use"><a class="header-anchor" href="#Animal-care-and-use"></a>Animal care and use</h3><p>Animal care and experimental procedures and were conducted in strict accordance with guidelines approved by the Animal Experiments Committee of University of Tokyo (approval ID: 14–03, 16–2). All efforts were made to minimize suffering. Individual animals and embryos were selected blindly from wild types.</p><h3 id="DNA-extraction-library-construction-and-genome-sequencing"><a class="header-anchor" href="#DNA-extraction-library-construction-and-genome-sequencing"></a>DNA extraction, library construction, and genome sequencing</h3><p><em>Lytechinus variegatus</em>: Genomic DNA was extracted from sperms from a single male. We first constructed five different short-insert libraries (394, 424, 479, 496, and 522 bp. See also Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>) from the genomic DNA samples and sequenced them using the Illumina HiSeq 4000 system to survey the genome complexity. After obtaining the genome size, we further constructed four mate-pair libraries (2–18 Kb. See also Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>) from the same DNA sample, and sequenced them for further assembly. The DNA and genome we obtained in this project is independent from those available through EchinoBase (<em>Lytechinus variegatus</em> genome v.2.2).</p><p><em>Anneissia japonica</em>: After collecting adult feather stars in the cove of Koajiro, Sagami Bay (Misaki, Japan) by scuba diving, sperms from a single male was collected during the breeding season when the gonads were ripe with mature gametes. Sperms were embedded in ~0.5% low-melting agarose plugs (SeaPlaque GTG Agarose, Lonza), and in-gel digestion of proteins was performed by immersing the plugs in digestion buffer (10 mM Tris-Cl pH 7.5, 50 mM NaCl, 10 mM EDTA, 0.5% SDS, 200 mg/mL Proteinase K) at 55 °C, overnight. The gel-plugs were washed repeatedly with TE buffer and stored in TE at 4 °C until use. DNA was released from the gel-plugs using GELase (Epicenter). The DNA was further purified using QIAGEN Genomic-tip 20/G (QIAGEN) and dissolved in TE. Five different short-insert libraries (277, 324, 381, 450, and 477 bp) were constructed and sequenced with Illumina HiSeq 4000 system to survey the genome complexity. After obtaining the genome size, we further constructed six mate-pair libraries (2–18 Kb) and sequenced them for further assembly (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>).</p><h3 id="K-mer-based-estimation-of-genome-sizes"><a class="header-anchor" href="#K-mer-based-estimation-of-genome-sizes"></a>K-mer-based estimation of genome sizes</h3><p>We first compared the performances in genome size estimation by K-mer frequency method and GenomeScope. The genome size of green sea urchin estimated by GenomeScope was about 650 Mbp, while that of kmerfreq method was about 952 Mbp. Considering that the genome size estimated by kmerfreq was closer to the genome size estimated from <em>C</em>-value (0.92, <a href="http://www.genomesize.com/">www.genomesize.com</a>) than GenomeScope, we decided to apply kmerfreq method for the genome size estimation. Following formula was used for estimating genome size: <em>Genome</em> size (bp) = K-mer number/<em>average</em> depth <em>of K-mer</em>. Based on the rate of occurrence of K-mers in each genome, the read depths for feather star and green sea urchin were estimated as 147 and 124, respectively, leading to genome size estimations of approximately 553 Mb for feather star and 952 Mb for green sea urchin (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>).</p><h3 id="Raw-read-filtering-and-error-correction-of-short-read-libraries"><a class="header-anchor" href="#Raw-read-filtering-and-error-correction-of-short-read-libraries"></a>Raw read filtering and error correction of short-read libraries</h3><p>HiSeq raw reads with the following features were regarded as low-quality reads and were filtered out: [1] Reads containing &gt;10 bp adapter sequences; [2] Reads in the small insert libraries (refer to Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>) having &gt;10 bp overlap; [3] Reads having <em>N</em>’s &gt;10% of their length; [4] PCR duplicates (paired-end reads completely identical); [5] Reads containing &gt;40 bp low-quality (phred quality score ≤ 5) bases. After the filtering process, we further corrected the qualified K-mers. In brief, K-mers with sequencing errors are usually low in frequency, and we thus corrected these K-mer sequences by refering to high-frequent reads. If the erroneous sites could not be corrected, the low-frequency K-mers from the reads were trimmed. No error correction was made for the long-insert libraries (refer to Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>), as these were only used for scaffolding. The SOAPec_bin_v2.03 software was used to correct the error within reads. Command line: SOAPec_bin_v2.03/bin/KmerFreq_AR -q 33 -b 100000000000 -k 17 -p output reads_files_list; SOAPec_bin_v2.03/bin/Corrector_AR -Q 33 -k 17 <a href="http://output.freq.cz">output.freq.cz</a> output.freq.cz.len reads_files_list.</p><h3 id="Gene-set-and-genomes-obtained-from-public-database"><a class="header-anchor" href="#Gene-set-and-genomes-obtained-from-public-database"></a>Gene set and genomes obtained from public database</h3><p>Refer to Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a> for the publicly available gene set and genomes used in this project.</p><h3 id="Genome-assembly"><a class="header-anchor" href="#Genome-assembly"></a>Genome assembly</h3><p>Genome sequences with the filtered and/or corrected data were assembled by Platanus software. The assembly was carried out using the following steps: (a) Contig construction: Reads from short-insert (&lt;1 Kb) libraries were split into K-mers and used to construct a de Bruijn graph. Short branches caused by errors were removed by “tip removal” step and short repeats were resolved by K-mer extension. Bubble structures caused by heterozygosity or errors were removed. At last, subgraphs without any junctions represent the contigs. (b) Scaffold construction: All the filtered clean reads were re-aligned onto the contig sequences, and the scaffolds were constructed by weighting the consistent rate and paired-end reads relationships on the contigs. Heterozygous regions were removed as bubble or branch structures on the graph by the “bubble removal” or “branch cut” step. These simplification steps are characteristic of Platanus and especially effective for assembling complex heterozygous regions. © Gap filling: Paired-end reads have one end mapped on the contig with the other end located in the gap region were used to fill the gaps in the genome assembly by GapCloser1.10 software. Then the very short assembly sequences (contig shorter than 500 bp) were removed in the genome assembly. The detailed command lines of the Platanus assembly were shown as below: Feather star: platanus assemble -o contig.fa -f short_clean_reads.fq -k 69 -u 0.2 -m 200; platanus scaffold -c contig.fa -b contigBubble.fa -o scaffold.fa -IP R1.fq R2.fq -OP R1.fq R2.fq -u 0.2. Green sea urchin: platanus assemble -o contig.fa -f short_clean_reads.fq -k 29 -u 0.3 -m 200; platanus scaffold -c contig.fa -b contigBubble.fa -o scaffold.fa -IP R1.fq R2.fq -OP R1.fq R2.fq -u 0.3. Results by K-mer analysis Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>, and statististics of feather star and green sea urchin genomes are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">3</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">4</a>.</p><h3 id="Assessment-of-assembled-genomes"><a class="header-anchor" href="#Assessment-of-assembled-genomes"></a>Assessment of assembled genomes</h3><p>The completeness of the feather star and green sea urchin assemblies was assessed by the BUSCO program (version 2.0), using the eukaryotic and metazoan libraries (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">6–8</a>). Reads from the short-inserts libraries were also mapped to these assembled genomes by BWA and SAMtools software (bwa index -a bwtsw genome.fa; bwa aln -t 6 genome.fa reads.fq; samtools view -b -S out.sam &gt; out.bam; samtools flagstat out.bam) to assess the genomic quality (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">9</a>). In addition, coverage ratio of de novo assembled transcripts obtained by Trinity &lt;ver. 2.2.0 &gt; (perl Trinity --JM 200 G --seqType fq --left reads_R1.fq --right reads_R2.fq --SS_lib_type FR -output out) and TGICL software (tgicl -F transcripts.fasta) over the sequenced genomes using BLAT software (blat genome.fa transcript.fa -t = dna -q = rna out.psl) (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">10–13</a>. De novo assembled the transcripts (made by the RNAseq data we obtained for each species) were also aligned to the fileterd genome and confirmed that 98.64% transcripts in feather star and 99.53% transcripts in green sea urchin were aligned.</p><h3 id="GC-content-of-genome"><a class="header-anchor" href="#GC-content-of-genome"></a>GC content of genome</h3><p>GC content of the feather star and green sea urchin genomes were estimated using a sliding window approach. Briefly, a 500 bp sliding window (250 bp stepwise) was employed to scan along the genome and calculate the GC content, and found that the average GC content of feather star and green sea urchin is about 33.22% and 33.71%, respectively. Both of these values were found to be similar with those of hemichordate and most chordate species except lamprey (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>).</p><h3 id="Repeat-annotation"><a class="header-anchor" href="#Repeat-annotation"></a>Repeat annotation</h3><p>Tandem repeats in the genomes were identified using Tandem Repeat Finder<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR38">38</a> (v4.04 <a href="http://tandem.bu.edu/trf/trf.html">http://tandem.bu.edu/trf/trf.html</a>) with default parameters (trf sequence.txt 2 7 7 80 10 50 2000 -d -h, these number means: Match, Mismatch, Delta, PM, PI, Minscore, and MaxPeriod), and non-interspersed repeats in the genome using RepeatMasker<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR38">38</a> (open-4–0–5) with default parameters (-nolow (Not mask low_complexity DNA or simple repeats) -no_is (Skips bacterial insertion element check) -norna (Does not mask small RNA (pseudo) genes) -parallel 1 (The number of processors to use in parallel)). Transposable elements (TEs) were identified on both the DNA and protein levels. On the DNA level, RepeatModeler (v1.0.4) and RepeatScout<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR39">39</a> (version 1.0.5) was used to build repeat libraries. In feather star, LTR_FINDER<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR40">40</a> (v1.0.5) software were additionally used to build de novo repeat libraries. RepeatMasker was performed on both de novo libraries and repbase (RepBase16.02) separately to identify homologous repeats with default parameters with format set with 2 (-w 2-table). On the protein level, RM-BLASTX within RepeatProteinMask was used to query the TE protein database with -noLowSimple and <em>P</em>-value 0.0001 (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">3</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">14</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">17</a>).</p><h3 id="Prediction-of-protein-coding-genes"><a class="header-anchor" href="#Prediction-of-protein-coding-genes"></a>Prediction of protein-coding genes</h3><p>Prediction of protein-coding genes was based on integration of three different methods, namely, ab initio prediction, homology-based annotation and RNAseq-based annotation. For ab initio prediction, Augustus<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR41">41</a> (v2.5.5, --uniqueGeneId=true [output gene identifyers] --noInFrameStop=true [Do not report transcripts with in-frame stop codons] --gff3=on [output in gff3 format] —strand=both [–strand=forward and --strand=backward]) and GENSCAN<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR42">42</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR43">43</a> (v1.0, -mini_cds 150 -cds_ns 10) software were used to predict genes. In feather star, SNAP<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR44">44</a> (using ** species for gene prediction) and GlimmerHMM<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR45">45</a> (v3.02, using ** species for gene prediction, and -f [Do not make partial gene predictions] -g [Print output in gff format]) softwares were also used in this analysis. These four software programs were trained by using lamprey, human, ciona, and zebrafish, respectively. Short genes (CDS length &lt; 150 bp) and low-quality genes (gaps covered more than 10% of the coding region) were discarded. Proteins from human (Ensembl:GRCh38), mouse (Ensembl: GRCm38), chicken (Ensembl: Gallus_gallus-5.0), green anole lizard (Ensembl: AnoCar2.0), Xenopus tropicalis (Ensembl: JGI_4.2), zebrafish (Ensembl: GRCz10), sea lamprey (Ensembl: Pmarinus_7.0), lancelet (LanceletDB: v18h27.r3_ref), <em>Ciona instestinalis</em> (NCBI: GCA_000224145.1), acorn worm (NCBI: GCF_000003605.2) and purple sea urchin (NCBI: GCF_000002235.4) were used in the homology-based annotation using tblastn with <em>e</em>-value 1e-5. Blast hits that correspond to reference proteins were concatenated by Solar software and low-quality records were filtered out. Sequence of each reference protein was extended to upstream and downstream by 2 Kb to represent the protein-coding region with default parameters. GeneWise software was used to predict gene structure contained in each protein-coding region. For each gene locus, the longest coding region and/or highest genewise score was retained. In RNAseq-based method, the coding sequences defined by transcripts was aligned against the genome by BLAT<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR46">46</a> (v34, identity &gt; 90%, coverage &gt; 90%), thereby defining the splicing orientation of coding region. Then, PASA software was used to link the spliced alignments with default parameters. The EvidenceModeler<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR47">47</a> (EVM, ver. 1.1) software was further used to integrate data derived from the three methods into an EVM-derived gene set with default parameters, the weight of de novo, homolog and complementary DNA (cDNA) are 1, 5, and 10. Finally, 26,838 and 30,238 protein-coding gene models were annotated in feather star and green sea urchin genome, respectively (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">18</a>).</p><h3 id="Annotation-of-gene-function-non-protein-coding-genes"><a class="header-anchor" href="#Annotation-of-gene-function-non-protein-coding-genes"></a>Annotation of gene function, non-protein-coding genes</h3><p>InterProScan (v4.8) was used to screen these genes’ protein sequences against five databases (including: Pfam, release 27.0, prints, release 42.0, prosite, release 20.97, ProDom, 2006.1, and smart, release 6.2) to determine the InterPro and GO number of those predicted protein-coding genes. In addition, KEGG, COG, NR, Uniprot/SwissProt, and UniProt/TrEMBL databases were searched for homology-based functions (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a>) using blastp (v2.2.26) with <em>e</em>-value (1e-5). For non-coding genes, tRNAscan-SE 53 (v1.3) software for eukaryotes was used for tRNA annotation in the genomic assembly with default parameters. Ribosomal RNA (rRNA) annotation was based on homology information of invertebrate rRNA collections using BLASTN (v2.2.26) with <em>e</em>-value set as 1e-5. The small nuclear RNA (snRNA) and microRNA (miRNA) were predicted by INFERNAL software (v0.81) against the Rfam database (Release 9.1) with default parameters. The statistical results are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>.</p><p>Potential functions of protein-coding genes were predicted using InterProScan<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR48">48</a> (v4.5), against five databases (Pfam, release 27.0, PRINTS, release 42.0, PROSITE, release 20.97, ProDom, 2006.1, and SMART, release 6.2). In addition, KEGG, COG, NR, Uniprot/SwissProt and UniProt/TrEMBL databases were searched for homology-based functions (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a>). For non-coding genes, the tRNAscan-SE<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR49">49</a> (v1.3) software for eukaryote was used for tRNA annotation in the genomic assembly. rRNA annotation was based on homology information of invertebrate rRNA collections using BLASTN (v2.2.26) with <em>e</em>-value (1e-5). The snRNA and miRNA were predicted by INFERNAL software (v0.81) against the Rfam database (Release 9.1). The statistical results are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>.</p><h3 id="Gene-family-analysis"><a class="header-anchor" href="#Gene-family-analysis"></a>Gene family analysis</h3><p><em>orthoMCL</em>: orthoMCL<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR50">50</a> was used to find ortholog genes and/or gene families (ortholog groups) among different species. Amphioxus (<em>Branchiostoma floridae</em>), zebrafish (<em>Danio rerio</em>), ciona (<em>Ciona intestinalis</em>), Drosophila (<em>Drosophila melanogaster</em>), chicken (<em>Gallus gallus</em>), acorn worm (<em>Saccoglossus kowalevskii</em>), green sea urchin (<em>Lytechinus variegatus</em> [Lv]), purple sea urchin (<em>Strongylocentrotus purpuratus</em> [Sp]), medaka (<em>Oryzias latipes</em>), mouse (<em>Mus musculus</em>), brittle star (<em>Ophiothrix spiculata</em>), feather star (<em>Anneissia japonica</em> [Anj]), lamprey (<em>Petromyzon marinus</em>), sea cucumber (<em>Apostichopus japonicus</em> [Apj]), sea star (<em>Acanthaster planci</em>), frog (<em>Xenopus laevis</em>), turtle (<em>Pelodiscus sinensis</em>) gene set were prepared and used here. Gene families and ortholog genes identified by this OrthoMCL is shown in Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">5</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">6</a>. For ortholog groups identified among echinoderms were 15618 for Lv-Sp-Apj-Anj, 14758 for Lv-Apj-Anj, 15035 for Lv-Sp-Apj, 14231 for Lv-Sp and 13649 for Lv-Anj.</p><p><em>Reciprocal best blast hit (RBBH), 1:1 orthologs</em>: We also analyzed the ortholog genes by RBBH method. We first selected feather star as the reference species, and aligned the protein sequences in all other 16 species to feather star gene set and vice versa by blast. Second, the aligned results were filtered by <em>e</em>-value (1e-5) and retained only the reciprocal best blast hit for each gene-gene pairs. Third, orthologous gene pairs in all of the 16 species were extracted. Finally, we identified 1196 ortholog genes among these 17 species.</p><h3 id="Phylogenetic-tree-construction-and-divergence-time"><a class="header-anchor" href="#Phylogenetic-tree-construction-and-divergence-time"></a>Phylogenetic tree construction and divergence time</h3><p><em>Molecular phylogenetic analysis</em>: 1196 RBBH ortholog genes (1,447,456 aa) in each species were combined into a super-gene in the same gene order, followed by phylogenetic analysis using RaxML<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR51">51</a> (with PROTGAMMAAUTO model, <em>Drosophila melanogaster</em> was used as the outgroup species) through these super-genes (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1b</a> and Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">25</a>). Both of the reconstructed phylogenetic trees robustly showed three clusters, including echinoderms, acorm worm, and chordates. Among them, feather star was the earliest diverging species in echinoderms, brittle star and sea star form one branch, sea urchin and sea cucumber form another branch.</p><p><em>Divergence time estimation</em>: To estimate the divergence time, the super-genes prepared above were analyzed by MCMCtree software, together with several calibration points downloaded from TimeTree website (<a href="http://www.timetree.orgs/">http://www.timetree.orgs</a>) (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>).</p><h3 id="Relative-evolutionary-rates-of-species"><a class="header-anchor" href="#Relative-evolutionary-rates-of-species"></a>Relative evolutionary rates of species</h3><p>To determine the relatively evolutionary rates of echinoderm species, the super-genes, which we produced from 1196 RBBH orthologs were used. LINTRE software and RRT (Tajima’s relative rate test) analysis were employed, and <em>Drosophila</em> was used as an outgroup to determine the root of the whole tree (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">8</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">26</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">28</a>. In addition to the LINTRE analysis, R-package “APE” was also used to deduce robust conclusion (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">9</a>).</p><h3 id="Expansion-and-contraction-of-gene-families"><a class="header-anchor" href="#Expansion-and-contraction-of-gene-families"></a>Expansion and contraction of gene families</h3><p>To identify expanded and contracted gene families in the common ancestor of echinoderms, the gene family result generated from OrthoMCL were used and analyzed by CAFE software (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11</a>). Profiles of GO terms, protein domains and KEGG pathways of these expanded and contracted genes are shown in Extended data 1 (Extended_data1.xlsx).</p><h3 id="Domains-lost-in-echinoderms"><a class="header-anchor" href="#Domains-lost-in-echinoderms"></a>Domains lost in echinoderms</h3><p>Domains found in any of the chordate species, but not found in any of the the echinoderm species were defined as domains lost in echinoderm lineage. Six echinoderm species (<em>Apostichopus japonicus</em>, <em>Lytechinus variegatus</em>, <em>Acanthaster planci</em>, <em>Ophiothrix spiculata</em>, <em>Anneissia japonica</em>, and <em>Strongylocentrotus purpuratus</em>) and nine chordate species (<em>Mus musculus</em>, <em>Branchiostoma floridae</em>, <em>Ciona intestinalis</em>, <em>Petromyzon marinus</em>, <em>Oryzias latipes</em>, <em>Gallus gallus</em>, <em>Xenopus laevis</em>, <em>Pelodiscus sinensis</em>, and <em>Danio rerio</em>) were blasted (&gt;50% identity and &gt;30% align ratio) to the acorn worm (<em>Saccoglossus kowalevskii</em>) protein gene set and searched for potential domains lost in echinoderms. Seven-hundred forty-seven genes were identified to be the lost genes in echinoderms. Among these genes, six genes were not found in any of the nine chordate species, but found in acorn worm. These genes were enriched with GO terms of biosynthetic process, metabolism process, and the establishment of localization.</p><h3 id="Hox-cluster-analysis"><a class="header-anchor" href="#Hox-cluster-analysis"></a>Hox cluster analysis</h3><p><em>Cloning of Hox genes</em>: To further confirm sequences of Hox genes in the feather star, a total of nine hox genes had been cloned from <em>Anneissia japonica</em> using RT-PCR (Tsurugaya et al., in preparation).</p><p><em>Preparation of A. japonica BAC library</em>: We constructed BAC library, using genomic DNA prepared from the male gonadal pinnules that contained testes. The DNA was partially digested with the restriction enzyme MboI, size-fractionated, and cloned into the vector pCCBAC1(EPICENTER). The bacterial strain DH10B T1 phage resistant (Invitrogen) was used for transfecting the BACs for constructing the library. Single clones were picked into 384-well plates and preserved. Two batches of libraries were produced, which were named Oj1 (average insert size ~100 kb, 35,712 clones) and Oj2 (average insert size ~78 kb, 45,977 clones).</p><p><em>Screening and cloning of BAC clones containing hox genes</em>: Using the cDNA fragments of nine hox genes (hox1, hox2, hox4, hox5, hox7, hox8, hox9/10, hox11/13a, and hox11/13c. Tsurugaya et al., in preparation), we screened the BAC library of <em>A. japonica</em> for the clones that contained Hox genes and their neighboring regions. This screening yielded 23 clones in total, which, however, were not contiguous but separated into four groups.</p><p><em>FISH analysis</em>: Probes for FISH were derived from clones out of the <em>A. japonica</em> BAC library. BAC clones used for FISH were Oj1–26E10 (containing hox1), Oj2–17D15 (hox2), Oj2–75D03 (hox4 and hox5), Oj2–78N14 (hox7 and hox8), Oj1–50I03 (hox8 and hox9/10), and Oj2–102A05 (hox11/13c). BAC clone DNAs were isolated using Qiagen Plasmid Midi Kit (Qiagen) and labeled with biotin or digoxigenin by using Nick Translation Kit (Roche). Hybridization mix was prepared as described previously (3). Two color-chromosomal FISH was carried out as described previously (1, 2) with the following modifications. Blastula or early gastrula stage embryos were treated with 0.08% colchicine (Sigma) in sea water for 30 min. Embryos were fixed in methanol glacial acetic acid (3:1) fixative at 4 °C overnight, then transferred to 100% ethanol, and stored at –20 °C. To prepare metaphase spreads, 80 µL of 60% acetic acid was added to a microfuge tube containing 50–100 embryos. Three minutes later, embryos were dropped onto a prewarmed (48 °C) slide glass, and left until dry (about 30 min). Before hybridization, the slides were treated with 0.5% pepsin (1:100, Wako) in 0.01 N HCl for 3 min, and washed in phosphate-buffered saline (PBS) three times. Then the slides were post-fixed in 1% paraformaldehyde in PBS at r.t. for 30 min, and washed in PBS twice. After dehydration, the air-dried slides were treated with acetone at r.t. for 10 min, and dried again. Following the denaturation of chromosomal DNA and dehydration, hybridization was carried out at 43 °C for 16 h. FISH images were taken using an Olympus BX60 microscope equipped with an Olympus DP70 camera.</p><p><em>Identification of clustered Hox genes</em>: In scaffold 288292 (about 1.86 Mbp in length), hox1, hox2, hox3, hox4, hox5, hox6, hox7, hox8, hox9/10, and hox11/13a were identified. The ten Hox genes were aligned in the order, spanning about 480 kb in length, with the 3ʹend of hox1 about 392 kb away from the end of the scaffold. In scaffold 287987 (about 96 kb), hox11/13b and hox11/13c were identified. To see whether the 12 Hox genes form a single cluster, we carried out two color-chromosomal FISH, using the BAC clones (described above) as probes. The FISH analysis revealed that the eight genes contained in the BAC clones were in close vicinity to one another on a single chromosome (comprising of two sister chromatids). However, the gene order or relative positions of the two scaffolds on the chromosome could not be clarified, leaving four possible gene orders of 12 Hox genes undetermined. Thus, it is suggested that 12 Hox genes are present on a single chromosome, forming two subclusters separated by at least 400 kb in the genome of <em>Anneissia japonica</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a>, hox11/13d and hox11/13e, in another scaffolds 2266 and 6788, respectively. This suggests that the two genes are localized apart from the subcluster of ten Hox genes, which situation is consistent with the previous report showing that Hox11/13d and Hox11/13e do not reside in the Hox gene cluster in echinoderm genomes<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a>.</p><h3 id="Embryo-collection-and-RNA-extraction"><a class="header-anchor" href="#Embryo-collection-and-RNA-extraction"></a>Embryo collection and RNA extraction</h3><p><em>Lytechinus variegatus</em>: Adult green sea urchins were originally obtained from Reeftopia in Florida (FL) or from the Duke Marine lab in Beaufort NC. <em>L. variegatus</em> total RNA was prepared from wild type embryos per timepoint using TRIzol (Invitrogen) and DNase treatment. RNA quantitation and integrity were determined using a Qubit® 2.0 Fluorometer (Life Technologies) and a 2100 Bioanalyzer (Agilent Technologies). Total RNA was subjected to three iterations of polyA selection using Dynabeads (Life Technologies) prior to cDNA synthesis. Following stages were collected for RNA extraction and fixation; 2 cell (1 h post fertilization), 60 cell (2.5 hpf), EB (Early Blastula, 4 hpf), HB (Hatched Blastula, 7 hpf), TVP (Thickened Vegetal Plate, 10 hpf), MB (Mesenchyme Blastula, 12 hpf), EG (Early Gastrula, 13 hpf), MG (Mid Gastrula, 15 hpf), LG (Late Gastrula,18 hpf), EP (Early Pluteus, 36 hpf), LP (Late Pluteus, 48 hpf), 7 wpf (7 weeks post fertilization), 8 wpf (8 weeks post fertilization), 1 day post metamorphosis, 1 week post metamorphosis, and adult. In addition, RNA from larval region of 8 weeks post fertilization (8 wpf Larva), and rudiment region of 8 weeks post fertilization (8 wpf Rudiment) were also extracted by dissecting the 8 wpf embryo. Results based on analyses with RNAseq data from two cell to Late pluteus were published<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR52">52</a>. Two independent biological samples were prepared for all the sampled stages.</p><p><em>Apostichopus japonicus</em>: Embryos of fertilized eggs, 4 cell (2 h post fertilization (hpf)), morula (6 hpf), blastula (14 hpf), gastrula (29 hpf), late gastrula (34 hpf), early auricularia larva (48 hpf), mid-auricularia larva (69 hpf), late auricularia larva (15 days post fertilization (dpf)), metamorphosis 1–4 (17–19 dpf), doliolaria larva (19 dpf), pentactula larva (27 dpf), and juvenile (51 dpf) stage were collected and used for this study, as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR23">23</a>. Three independent biological samples were prepared for all the sampled stages.</p><p><em>Anneissia japonica</em>: Adult <em>Anneissia japonica</em> (previously called as <em>Oxycomanthus japonicus</em>, see Summers et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR53">53</a> for the nomenclature) were collected from rocky substrate of about 10 m depth at Koajiro, Sagami Bay, and kept in the sea until the day of spawning. Spawning check was carried out at every neap tide days during October and November, 2015. Spawning was observed in the evening of 20th and 21st of October, 2015, and seven females spawned in total. The obtained eggs were very fragile and surrounded by mucus. Small amounts of the spawned unfertilized eggs were separated in 1.5 mL tubes (100 μL each) for RNA extraction and fixation. The rest of the eggs were inseminated immediately by diluting concentrated sperm, which were directly collected from genital pinnules. The fertilized eggs were washed with filtered sea water several times to remove the mucous, and separated in the filtered sea water in plastic vessels for culture. The culture was done at room temperature (about 10–20 °C). Following stages were collected for RNA extraction and fixation (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">15</a>); 2 cells (1.5 h post fertilization), 8 cells (2.5 hpf), 32 cells (3.5 hpf), gastrula (8 hpf), hatching stage (17 hpf), early doliolaria (24 hpf), mid-late doliolaria (36 hpf), attachment stage (3–4 days pf), early cystidean (4–7 days pf), late cystidean (7–9 days pf), early pentacrinoid (3 weeks pf), late pentacrinoid (1.5 months pf), juvenile (2.5 months pf), arm branching stage (6–7 months pf), and adult (9 months pf). For the RNA extraction, more than 50 μL of specimens were diluted in the 10x volume of TRIzol reagent (Invitrogen). The tissue of the specimens were destructed by pipetting with a micro syringe or grinding with a pestle and mortar in the TRIzol reagent, and immediately stored in –80 °C. For the fixation, specimens were fixed with 4% paraformaldehyde in 0.5 M NaCl and 0.1 M 3-(N-morpholino) propanesulfonic acid (MOPS), pH 7.0 for several days at room temperature (about 22 °C). Fixed specimens were washed with 70% ethanol three times, and stored in 70% ethanol at –20 °C. Two independent biological samples were prepared for all the sampled stages.</p><h3 id="RNA-sequencing-and-gene-expression-data"><a class="header-anchor" href="#RNA-sequencing-and-gene-expression-data"></a>RNA sequencing and gene expression data</h3><p>After adjusting total RNA amounts between samples, non-stranded sequencing libraries (with the TruSeq protocol) were constructed and sequenced using the Illumina HiSeq 4000 platform. For the sea cucumber (<em>A. japonicus</em>) samples, Quartz-seq amplified libraries were made as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. Qualities of raw reads were evaluated using FastQC program (<a href="http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/">http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/</a>). Read length and single/paired information are as follows; <em>L. variegatus</em> (100 bp, paired-end), <em>A. japonica</em> (150 bp, paired-end), <em>A. japonicus</em> (100 bp, single-end). Adapter sequences of Quartz-Seq samples (Mm early stages 2-cell-blastocyst) were removed using the fastq-mcf program (<a href="https://code.google.com/p/ea-utils/wiki/FastqMcf">https://code.google.com/p/ea-utils/wiki/FastqMcf</a>) as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. RNAseq data were then mapped to genomes of each species using HISAT2 program<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR54">54</a> (ver. 2.05), and calculated relative expression levels by StringTie<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR55">55</a> (ver. 1.3.5) with species-specific GTF files.</p><p><em>Apostichopus japonicus</em>: For the gene expression levels of Japanese sea cucmber, genome and GTF files reported by Zhang et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a> were used.</p><p><em>Strongylocentrotus purpuratus</em>: Developmental transcriptomes of the purple sea urchin was obtained from SRA (Accession: PRJNA81157), sequenced by Tu et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR21">21</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR22">22</a>. The dataset contained developmental stages of 0 hpf, 10 hpf, 18 hpf, 24 hpf, 30 hpf, 40 hpf, 48 hpf, 56 hpf, 64 hpf, 72 hpf, four arm larva, vestibular invagi, pentagonal disc, tube foot protrusion, post metamorphosis, young juvenile, adult.</p><h3 id="Identification-of-conserved-stages"><a class="header-anchor" href="#Identification-of-conserved-stages"></a>Identification of conserved stages</h3><p>Whole embryonic, comparative transcriptomic analysis was performed as previously described to find evolutionarily conserved developmental stages<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. Relative expression levels (TPM) of ortholog groups (defined by orthomcl<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR57">57</a>) were calculated from the RNAseq data, and then compared their dissimilarities (expDists) among developmental stages of different species. In calculating dissimilarity (1 – Spearman) of ortholog-group-based whole-embryonic transcriptomes (expDists), phylogenetic relationship [Anj(Apj(Sp,Lv))] were taken into consideration to avoid unwanted bias arising from simple pair-wise comparisons<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR58">58</a>. By randomly picking-up one biological replicate sample for each developmental stage (in each species), 100 expression tables (100 biological replicate included expression table, or BRI-exp data) were created (method reported in Hu et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>). We used this 100 BRI table to test statistical significance of changes in Ptop scores (Friedman test).</p><h3 id="Whole-mount-in-situ-hybridization"><a class="header-anchor" href="#Whole-mount-in-situ-hybridization"></a>Whole-mount in situ hybridization</h3><p>Digoxigenin (Dig) labeled riboprobe for <em>pitx</em> gene of <em>A. japonica</em> was prepared from PCR-amplified fragments (911 bp) using following primiers: 5ʹ-GAACGATTCGCTTCCGATGC-3ʹ (forward primer), 5ʹ-TGAGACCGGCGTATTGACAC-3ʹ (reverse primer). Whole-mount in situ hybridization (WISH) was conducted following the protocol for the planktonic larvae of a stalked crinoid <em>Metacrinus rotundus</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR59">59</a> with some modifications. Specimens were fixed with 4% paraformaldehyde (PFA) in 0.5 M NaCl and 0.1 M 3-(N-morpholino) propanesulfonic acid (MOPS), pH 7.0 for over 1 day, and stored at –20 °C in 70% ethanol. The fixed specimens were washed three times with PBST (1× phosphate-buffered saline with 0.1% Tween 20), treated with 0.2 µg/mL proteinase K in PBST at 37 °C for 20 min, re-fixed with 4% PFA at 4 °C for 30 min, washed three times with PBST, and then incubated in hybridization buffer (50% formamide, 5× SSC, 100 µg/mL yeast RNA, 50 µg/mL heparin, 1% Tween 20) at 55 °C for 4–6 h. Hybridization was carried out with 0.2 µg/mL probes in the hybridization buffer at 55 °C for 5 days. The protocol after hybridization was as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR59">59</a>. WISH finished samples were observed and photographed under the BX-51 optical microscope (Olympus).</p><h3 id="Proteomic-analysis"><a class="header-anchor" href="#Proteomic-analysis"></a>Proteomic analysis</h3><p>Proteins were isolated from adult feather skeleton and analyzed as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a>. All organic material was removed from the skeleton by extensive washing with sodium hypochlorite followed by guanidine isothiocyanate. The skeleton was demineralized with acetic acid followed by dialysis. Both soluble and insoluble protein fractions were analyzed. Proteins were separated by sodium dodecyl sulfate–polyacrylamide gel electrophoresis. Each lane was excised into 20 equal sized segments and processed. In-gel digestion with trypsin was performed on each fraction, followed by analysis by nano Liquid chromatography–mass spectrometry (LC-MS/MS) with a Waters nanoAcquity high-performance liquid chromatography system interfaced to a ThermoFisher Q Exactive hybrid quadrupole-orbitrap mass spectrometer. The mass spectrometer was operated in a data-dependent mode. Data were used to search predicted peptides from the <em>A. japonica</em> genome using Mascot and then parsed into the Scaffold algorithm for validation and filtering, using a 95% protein identification score with at least two peptides per protein.</p><h3 id="Statistics-and-reproducibility"><a class="header-anchor" href="#Statistics-and-reproducibility"></a>Statistics and reproducibility</h3><p>Alpha levels of 0.05 were regarded as statistically significant throughout the study, unless otherwise specified. Experiments were repeated multiple times to confirm the reproducibility of the data. See details for individual experiments in the “Methods” sections above.</p><h3 id="Reporting-summary"><a class="header-anchor" href="#Reporting-summary"></a>Reporting summary</h3><p>Further information on research design is available in the <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM5">Nature Research Reporting Summary</a> linked to this article.</p><h2 id="Data-availability"><a class="header-anchor" href="#Data-availability"></a>Data availability</h2><p>Genomic sequence data and assembled genomes for the following species are available through the NCBI database at the indicated BioProject accession IDs: Brittle star genome (PRJNA182997), feather star genome (PRJNA553656), and green sea urchin genome (PRJNA553643). RNAseq data are available for the following species at the indicated BioProject accession IDs: green sea urchin RNAseq data (PRJNA554218), feather star RNAseq data (PRJNA553591), and Japanese sea cucumber RNAseq data (PRJNA553613). Cloned sequences of Hox genes of the feather star (hox1 LC462021, hox2 LC462022, hox4 LC462023, hox5 LC462024, hox7 LC462025, hox8 LC462026, hox9/10 LC462027, hox11/13a LC462028, hox11/13c LC462029) are also available through the NCBI database at the indicated nucleotide accession IDs. Assembled genomes and gene sets can also be accessed through the DRYAD database<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR60">60</a> at <a href="https://hub.pubmedplus.com/10.5061/dryad.rbnzs7h7n">https://doi.org/10.5061/dryad.rbnzs7h7n</a>. Proteomic data are available via the ProteomeXchange with identifier PXD019526. Source data for Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2a</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig3">3b</a> can be found in Supplementary Data <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM3">1</a> and Supplementary Data <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM4">2</a>.</p><h2 id="Code-availability"><a class="header-anchor" href="#Code-availability"></a>Code availability</h2><p>No custom or proprietary software was used in the analysis. Versions and parameters for each software package used are described in the reporting summary and elsewhere in the “Methods.”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.nature.com/articles/s42003-020-1091-1#MOESM1&quot;&gt;Genomic insights of body plan transitions from bilat</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程</title>
    <link href="https://halo123.top/2021/05/31/Java/Java-J-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://halo123.top/2021/05/31/Java/Java-J-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-31T08:16:54.000Z</published>
    <updated>2021-06-01T06:17:14.669Z</updated>
    
    <content type="html"><![CDATA[<p>参考：《Java 多线程与 Socket 实战微服务框架》</p><h2 id="多线程的概念"><a class="header-anchor" href="#多线程的概念"></a>多线程的概念</h2><h3 id="进程与线程"><a class="header-anchor" href="#进程与线程"></a>进程与线程</h3><p>现在的操作系统都是多任务操作系统。多任务操作系统允许多个进程在同一个 CPU 上运行。进程也是操作系统进行资源分配的最小单位，每个进程都有独立的代码和数据空间，称为<font color="#ea66a6">进程的上下文</font>。CPU 从一个进程切换到另一个进程所做的动作被称为<font color="#ea66a6">上下文切换</font>。操作系统通过频繁的上下文切换来让这些进程看起来像在同时运行一样。</p><p>进程的运行需要较多的资源，因此，操作系统能够同时运行的进程数量是有限的。进程间的切换和通信也存在较大的开销。为了能并行执行更多的任务，提升系统的效率，才引入了线程的概念。线程间的切换开销比进程间的切换开销小得多。</p><p>线程是 CPU 调度的最小单位，它是进程的一部分，只能由进程创建。一个可以进程拥有多个线程，这线线程共享进程的资源和程序代码。也就是说，一个 Java 进程（JVM 进程）至少有一个线程（称为主线程），对应到代码中就是 <code>main</code> 方法所在的线程。通过主线程就可以创建更多线程。此外，线程又分为用户线程和守护线程。两者的区别在于，后者会随主线程结束而结束。一旦所有的用户线程都结束，程序就会停止，所有守护线程也随之终止。</p><p>受操作系统的限制，每个操作系统用户能够同时运行的进程数是有限的，每个进程能够开启的线程数也有上限。在同一个 CPU 核心上，多线程以抢占或主动让出时间片的形式轮流执行。基于同一段代码可以创建多个线程，这些线程共享进程的数据空间，但每个线程有独立的运行栈和程序计数器。</p><h3 id="并发与并行"><a class="header-anchor" href="#并发与并行"></a>并发与并行</h3><p>并发与并行是一个相对资源的概念。</p><ul><li><font color="#ad1a72">并发</font>是指两个或多个事件在同一时间间隔内发生。</li><li><font color="#ad1a72">并行性</font>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。</li></ul><p>如果我们在同一时间，在多台计算机上同时运行多个任务，这些任务就是在“并行”地执行。同理，如果一台计算机拥有多个 CPU ，这些 CPU 分别在执行多个运算任务，尽管这个计算机的其他资源，比如内存，是多个任务所共享的，但相对 CPU 这一资源来说，这些任务是“并行”的，这被称为“多 CPU 并行”。如果一个 CPU 拥有多个核心，并允许多个线程在不同的核心上同时执行，则称为“多核并行”。</p><p>与之相对应的是，在同一个资源上，通过某些调度算法，让用户看起来计算机是在同时执行多个任务，这就是并发。比如，在单个 CPU 上，通过一定的调度算法，“同时”执行多个任务，让这些任务看起来在一个时间段是“并行”执行的。即使在同一时刻，CPU 也只能执行这些计算任务中的一个。</p><h3 id="线程状态"><a class="header-anchor" href="#线程状态"></a>线程状态</h3><p>线程和进程一样拥有 7 种状态：新建（NEW）、就绪（RUNNABLE 或 READY）、运行（RUNNING）、阻塞（BLOCKED）、等待（WAITING）、计时等待（TIME_WAITING）、终止（TERMINATED 或 DEAD）。线程在存续过程中，其状态会在这 7 种状态之间转换。</p><blockquote><p>Java 5 以前，等待和计时等待也被归于阻塞状态，所以也有 5 种状态的说法。</p></blockquote><ul><li>新建（NEW）：线程被新创建时的状态。</li><li>就绪（RUNNABLE 或 READY）：线程正在参与竞争 CPU 的使用权</li><li>运行（RUNNING）：线程获取到了 CPU 的使用权，正在执行。</li><li>阻塞（BLOCKED）：阻塞状态指的是线程为了等待某个对象的“锁”，而暂时放弃 CPU 的使用权，且不再参与 CPU 使用权的竞争。直到条件满足（超时退出、被中断或唤醒）时，该线程才重新回到就绪状态，重新参与竞争 CPU。</li><li>等待（WAITING）：线程无线等待某个对象的“锁”，或等待另一个线程结束的状态。</li><li>计时等待（TIME_WAITING）：线程在一段时间内等待某个对象的“锁”，或者主动休眠，亦或者等待另一个线程结束。除非被中断，否则时间一到，（超时）线程将会自动回到就绪态。被中断的方法通常会抛出中断异常（InterruptedException），超时的方法会抛出超时异常（TimeoutException）。</li><li>终止（TERMINATED 或 DEAD）：遇到以下情况，线程将终止。线程所运行的代码段被执行完毕，或执行过程中出现异常，亦或者受到外界干预而中断执行。</li></ul><h2 id="Tread-线程类"><a class="header-anchor" href="#Tread-线程类"></a>Tread 线程类</h2><h3 id="基本用法"><a class="header-anchor" href="#基本用法"></a>基本用法</h3><p>通过继承 Tread 类，覆盖其 <code>run()</code> 方法即可编写一个线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>start()</code> 方法后，<code>run()</code> 方法中的代码并不一定立即开始执行。 <code>start()</code> 方法只是将线程变为可就绪状态，什么时候运行是由操作系统决定的。</p></blockquote><h3 id="常用方法介绍"><a class="header-anchor" href="#常用方法介绍"></a>常用方法介绍</h3><p>Thread 类中常用的实例方法</p><ul><li><code>t.start()</code>：启动线程 t 的状态从新建转换为就绪</li><li><code>t.checkAccess()</code>：检查当前线程是否有权限访问线程 t</li><li><code>t.interrupt()</code>：尝试通知线程 t 中断，需要在线程的任务代码中使用</li><li><code>t.isInterrupted()</code>：用于检查是否要求中断。当此方法返回 true 时，当前线程应判断是否要中断执行，如果此时不中断执行，再次调用此方法将返回 false。</li><li><code>t.setPriority()</code>：设置线程 t 的优先级（1 ~ 10），值越大，得到执行的将会越高</li><li><code>t.isDaemon()</code>：判断线程 t 是否为守护线程</li><li><code>t.setDaemon(true)</code>：仅用于在调用 <code>start()</code> 前设置线程 t 为守护线程</li><li><code>t.isAlive()</code>：判断线程 t 是否存活</li><li><code>t.join(1000L)</code>：当前线程等待线程 t 终止。参数为超时时间。</li><li><code>t.setName(&quot;Thread1&quot;)</code>：为线程设置一个名称</li></ul><p>Thread 类中常用的静态方法</p><ul><li><code>Thread.yield()</code>：让当前线程让出 CPU，并转为就绪状态，重新参与 CPU 使用权的竞争。只有优先级大于等于当前进程的线程才可能获得 CPU 使用权。</li><li><code>Thread.sleep(100L)</code>：让当前线程让出 CPU，睡眠（阻塞）100 毫秒，然后回到就绪状态，重新参与 CPU 使用权的竞争。</li><li><code>Thread.currentThread()</code>：得到当前线程对象的引用。</li></ul><h3 id="wait-和-sleep-的区别"><a class="header-anchor" href="#wait-和-sleep-的区别"></a><code>wait</code> 和 <code>sleep</code> 的区别</h3><p><code>wait()</code> 方法时所有 Object 类的方法，是线程同步的重要手段之一。虽然两者都可以让程序阻塞指定的毫秒数，并且都可以通过 <code>interrupt()</code> 方法打断，但两者有很大的不同：</p><ul><li><code>wait()</code> 方法必须在 <code>synchronized</code> 同步块或方法中使用；</li><li><code>wait()</code> 方法会释放由 <code>synchronized</code> 锁上的对象锁，而 <code>sleep()</code> 则不会</li><li>由 <code>wait()</code> 方法形成的阻塞，可以通过针对同一对象锁的 <code>synchronized</code> 作用域用 <code>notify()</code> 或 <code>notifyAll()</code> 来唤醒，而 <code>sleep()</code> 则无法被唤醒，只能定时醒来或被 <code>interrupt()</code> 方法中断。</li></ul><h3 id="sleep-和-yield-的区别"><a class="header-anchor" href="#sleep-和-yield-的区别"></a><code>sleep</code> 和 <code>yield</code> 的区别</h3><p>区别如下：</p><ul><li>线程执行 <code>sleep()</code> 方法后转入阻塞态，并在睡眠一段时间后自动醒来，回到就绪态。而执行 <code>yield()</code> 方法后，当前线程转入的是就绪态。</li><li>当前线程执行 <code>sleep()</code> 方法后，其他线程无论优先级高低，都有机会得以运行；而执行 <code>yield()</code> 方法只会给那些具有相同或更高优先级的线程运行的机会。</li><li><code>sleep()</code> 方法需要声明抛出 <code>InterruptedException</code>，而 <code>yield()</code> 方法没有声明任何异常。</li><li><code>sleep()</code> 方法比 <code>yield()</code> 方法具有更好的可移植性（与操作系统的 CPU 调度有关）。如果在循环中使用 <code>yield()</code> 方法，则在 Linux 上容易导致“死循环”——当前线程在 <code>yield()</code> 后总是又立即抢占到 CPU，导致其他线程得不到执行。</li></ul><h2 id="Runnable-接口"><a class="header-anchor" href="#Runnable-接口"></a>Runnable 接口</h2><p>处理继承 Thread 类外，还可以通过实现 Runnable 接口来编写线程代码。实践经验告诉我们，尽量使用接口而不是继承来进行开发。使用 Runnable 接口可以将线程对象本身与线程所要执行的代码分离，同时避免 Java 的单继承限制。而且线程池也只能接受 Runnable 或 Callable 接口类型的对象作为任务。因此，建议使用 Runnable 或 Callable 接口的形式开发多线程。</p><p>下面是 Runnable 接口使用的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程处于阻塞状态时，中断线程，就会抛出异常。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a class="header-anchor" href="#线程池"></a>线程池</h2><p>线程的创建和销毁会消耗资源。在大量并发的情况下，频繁地创建和销毁线程会严重影响系统的性能。因此，通常需要预先创建多个线程，并集中管理起来，形成一个线程池。在需要用到线程时，从线程池中拿出一个线程直接使用，执行完毕时再放回线程池。</p><h3 id="Executors"><a class="header-anchor" href="#Executors"></a>Executors</h3><p>从 Java 5 开始，可以使用 <code>java.util.concurrent.Executors</code> 类来创建线程池：</p><p>（1）创建固定大小的线程池 <code>Executors.newFixedThreadPool(20)</code></p><p>上面的代码创建了一个有着 20 个线程的固定大小线程池。又新任务时，如果池中没有空闲池可用，就加入队列等待。队列大小的上限是 <code>Integer.MAX_VALUE</code>。其优点时避免了线程创建和销毁的开销；缺点是池大小的配置容易过高或过低。无论过高或过低都会影响性能。如果希望自定义队列大小，则使用 <a href="#ThreadPoolExecutor">ThreadPoolExecutor</a></p><p>（2）创建可变大小的线程池 <code>Executors.newCachedThreadPool()</code></p><p>上面代码创建了一个可缓存空闲线程 60 秒的线程池。有新任务时，如果池中没有空闲线程可用，则创建一个新线程并添加到池中，池的大小上限是 <code>Integer.MAX_VALUE</code>。超过 60 秒未被使用的线程将被销毁。其优点是能按需创建线程，并尽可能地回收或复用它们。该方法适用于执行生存期较短的任务。其缺点是池大小的上限太大，“洪峰”来临时容易在短期内创建并持有大量线程。如果希望自定义大小和线程的最大空闲时长，则使用 <a href="#ThreadPoolExecutor">ThreadPoolExecutor</a></p><p>（3）创建一个只有一个线程的线程池 <code>Executors.newSingleThreadExecutor()</code></p><p>该方法等同于 <code>Executors.newFixedThreadPool(1)</code></p><p>（4）创建一个支持定时或周期性任务执行的线程池 <code>Executors.newScheduledThreadPool(2)</code></p><h3 id="ExecutorsService"><a class="header-anchor" href="#ExecutorsService"></a>ExecutorsService</h3><p>通过 Executors 创建的线程池都实现了 ExecutorsService 接口，调用它的 <code>execute</code> 或 <code>submit</code> 方法即可向线程池提交任务。下面介绍了 ExecutorsService 接口的主要方法。</p><ul><li><code>shutdown()</code>：异步关闭线程池。调用后将不再向线程池提交新任务，但允许继续执行已提交到线程池的任务。调用后立即返回，不会阻塞当前线程。</li><li><code>shutdownNow()</code>：立即异步关闭线程池</li></ul><h3 id="ThreadPoolExecutor"><a class="header-anchor" href="#ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h3 id="基本用法-v2"><a class="header-anchor" href="#基本用法-v2"></a>基本用法</h3><h2 id="Callable-与-Future"><a class="header-anchor" href="#Callable-与-Future"></a>Callable 与 Future</h2><h2 id="线程安全与效率"><a class="header-anchor" href="#线程安全与效率"></a>线程安全与效率</h2><h3 id="什么是线程安全"><a class="header-anchor" href="#什么是线程安全"></a>什么是线程安全</h3><h3 id="线程同步"><a class="header-anchor" href="#线程同步"></a>线程同步</h3><h3 id="饥饿与公平"><a class="header-anchor" href="#饥饿与公平"></a>饥饿与公平</h3><h3 id="锁与死锁"><a class="header-anchor" href="#锁与死锁"></a>锁与死锁</h3><h3 id="线程中断"><a class="header-anchor" href="#线程中断"></a>线程中断</h3><h2 id="volatile-关键字"><a class="header-anchor" href="#volatile-关键字"></a>volatile 关键字</h2><h2 id="synchronized-关键字"><a class="header-anchor" href="#synchronized-关键字"></a>synchronized 关键字</h2><h2 id="wait-notify-notifyAll"><a class="header-anchor" href="#wait-notify-notifyAll"></a>wait notify notifyAll</h2><h2 id="CAS-操作"><a class="header-anchor" href="#CAS-操作"></a>CAS 操作</h2><h2 id="atomic-包"><a class="header-anchor" href="#atomic-包"></a>atomic 包</h2><h2 id="Lock-自旋锁"><a class="header-anchor" href="#Lock-自旋锁"></a>Lock 自旋锁</h2><h2 id="Condition-条件变量"><a class="header-anchor" href="#Condition-条件变量"></a>Condition 条件变量</h2><h2 id="线程安全容器"><a class="header-anchor" href="#线程安全容器"></a>线程安全容器</h2><h2 id="ThreadLocal-类"><a class="header-anchor" href="#ThreadLocal-类"></a>ThreadLocal 类</h2><h2 id="CountDownLatch-计数器"><a class="header-anchor" href="#CountDownLatch-计数器"></a>CountDownLatch 计数器</h2><h2 id="CyclicBarrier-栅栏"><a class="header-anchor" href="#CyclicBarrier-栅栏"></a>CyclicBarrier 栅栏</h2><h2 id="Semaphore-信号量"><a class="header-anchor" href="#Semaphore-信号量"></a>Semaphore 信号量</h2><h2 id="fork-join-框架"><a class="header-anchor" href="#fork-join-框架"></a>fork join 框架</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：《Java 多线程与 Socket 实战微服务框架》&lt;/p&gt;
&lt;h2 id=&quot;多线程的概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#多线程的概念&quot;&gt;&lt;/a&gt;多线程的概念&lt;/h2&gt;
&lt;h3 id=&quot;进程与线程&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://halo123.top/2021/05/30/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://halo123.top/2021/05/30/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-30T09:32:51.000Z</published>
    <updated>2021-05-31T16:22:52.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-的幂【简单】"><a class="header-anchor" href="#2-的幂【简单】"></a>2 的幂【简单】</h2><div class="tag link"><a class="link-card" title="231. 2 的幂" href="https://leetcode-cn.com/problems/power-of-two/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">231. 2 的幂</p><p class="url">https://leetcode-cn.com/problems/power-of-two/</p></div></a></div><h3 id="题目描述"><a class="header-anchor" href="#题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code>，请你判断该整数是否是 <code>2</code> 的幂次方。</p><ul><li>如果是，返回 <code>true</code> ；</li><li>否则，返回 <code>false</code> 。</li></ul><blockquote><p>如果存在一个整数 $x$ 使得 $n = 2^{x}$ ，则认为 $n$ 是 2 的幂次方。</p></blockquote><div class="tabs" id="2的幂"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2的幂-1">示例 1</button></li><li class="tab"><button type="button" data-href="#2的幂-2">示例 2</button></li><li class="tab"><button type="button" data-href="#2的幂-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2的幂-1"><p>输入：<code>n = 1</code></p><p>输出：<code>true</code></p><p>解释：$2^{0}=1$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2的幂-2"><p>输入：<code>n = 8</code></p><p>输出：<code>true</code></p><p>解释：$2^{3}=8$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2的幂-3"><p>输入：<code>n = 5</code></p><p>输出：<code>false</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="题解"><a class="header-anchor" href="#题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/">位运算</a> 参考题解：</p><p>若 $n = 2^{x}$ 且 $x$ 为自然数（即 $n$ 为 2 的幂），则一定满足一下条件：</p><ul><li>恒有 <code>n &amp; (n-1) == 0</code>（<code>&amp;</code> 表示与运算，两位同时为“1”，结果才为“1”，否则为 0）</li><li>一定满足 <code>n&gt;0</code></li></ul><p>因为 $n$ 二进制最高位为 1，其余所有位为 0；$n−1$ 二进制最高位为 0，其余所有位为 1</p><table><thead><tr><th>2<sup>x</sup></th><th>n</th><th>n-1</th><th>n &amp; (n-1)</th></tr></thead><tbody><tr><td>2<sup>0</sup></td><td>0001</td><td>0000</td><td>0</td></tr><tr><td>2<sup>1</sup></td><td>0010</td><td>0001</td><td>0</td></tr><tr><td>2<sup>2</sup></td><td>0100</td><td>0011</td><td>0</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isPowerOfTwo(<span class="number">8</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfTwo(<span class="number">19</span>)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="4-的幂-【简单】"><a class="header-anchor" href="#4-的幂-【简单】"></a>4 的幂 【简单】</h2><div class="tag link"><a class="link-card" title="342. 4 的幂" href="https://leetcode-cn.com/problems/power-of-two/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">342. 4 的幂</p><p class="url">https://leetcode-cn.com/problems/power-of-two/</p></div></a></div><h3 id="题目描述-v2"><a class="header-anchor" href="#题目描述-v2"></a>题目描述</h3><p>题目类似于 2 的幂。给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false 。</p><h3 id="题解-v2"><a class="header-anchor" href="#题解-v2"></a>题解</h3><p>如果 $n$ 是 4 的幂，那么 $n$ 一定也是 2 的幂。因此我们可以首先判断 $n$ 是否是 2 的幂，在此基础上再判断 $n$ 是否是 4 的幂。</p><p>如果 $n$ 是 4 的幂，那么 $n$ 的二进制表示中有且仅有一个 1 ，并且这个 1 出现在从低位开始的第<font color="#faa755">偶数</font>个二进制位上。</p><p>我们可以构造一个整数 $mask$，使它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。我们将 $n$ 和 $mask$ 进行按位与运算，如果结果为 0，说明 $n$ 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">4</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">16</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">19</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="位-1-的个数【简单】"><a class="header-anchor" href="#位-1-的个数【简单】"></a>位 1 的个数【简单】</h2><div class="tag link"><a class="link-card" title="191. 位1的个数" href="https://leetcode-cn.com/problems/number-of-1-bits/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">191. 位1的个数</p><p class="url">https://leetcode-cn.com/problems/number-of-1-bits/</p></div></a></div><h3 id="题目描述-v3"><a class="header-anchor" href="#题目描述-v3"></a>题目描述</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><div class="tabs" id="位1的个数"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#位1的个数-1">示例 1</button></li><li class="tab"><button type="button" data-href="#位1的个数-2">示例 2</button></li><li class="tab"><button type="button" data-href="#位1的个数-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="位1的个数-1"><p>输入：<code>00000000000000000000000000001011</code></p><p>输出：<code>3</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="位1的个数-2"><p>输入：<code>00000000000000000000000010000000</code></p><p>输出：<code>1</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="位1的个数-3"><p>输入：<code>11111111111111111111111111111101</code></p><p>输出：<code>31</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="字符串题解"><a class="header-anchor" href="#字符串题解"></a>字符串题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 骚操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># bin() 返回一个整数 int 或者长整数 long int 的二进制表示。</span></span><br><span class="line">    <span class="comment"># print(bin(n))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="位运算题解"><a class="header-anchor" href="#位运算题解"></a>位运算题解</h3><p>在 Java 中 <code>Integer.bitCount()</code> 方法用于统计二进制中 1 的个数，其源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&gt;&gt;&gt;</code> 表示无符号右移</li><li><code>&amp;</code> 与运算，当两位同时为“1”，结果才为“1”，否则为 0</li></ul><p>代码中的十六进制数的二进制表示如下：</p><table><thead><tr><th>原文</th><th>二进制</th></tr></thead><tbody><tr><td><code>0x55555555</code></td><td><code>01010101 01010101 01010101 01010101</code></td></tr><tr><td><code>0x33333333</code></td><td><code>00110011 00110011 00110011 00110011</code></td></tr><tr><td><code>0x0f0f0f0f</code></td><td><code>00001111 00001111 00001111 00001111</code></td></tr><tr><td><code>0x3f</code></td><td><code>00000000 00000000 00000000 11111111</code></td></tr></tbody></table><p>如果把这些二进制序列看作一个循环的周期序列的话，那么：</p><ul><li>第一个序列的周期是 2，每个周期是 01；</li><li>第二个序列的周期是 4，每个周期是 0011；</li><li>第三个序列的周期是 8，每个周期是 00001111；</li><li>第四个序列的周期是 16，每个周期是 11111111。</li></ul><p>原理是：先两个两个一组，求二进制 1 的个数，并且用两位二进制存储在原处，然后四个四个一组，求二进制位 1 的个数，再把它存储以 4 位二进制到原处。以此类推直到计算完成。</p><p><a href="https://segmentfault.com/a/1190000015763941">算法原型</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) + ((i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x00ff00ff</span>) + ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x0000ffff</span>) + ((i &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>767 的二进制中的 1 的位数计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          二进制                       十进制</span><br><span class="line">1  0   1  1   1  1   1  1   1  1     10 11 11 11 11</span><br><span class="line"> 01     10     10     10     10       1 2  2  2  2</span><br><span class="line">         \     &#x2F;       \     &#x2F;           \&#x2F;    \&#x2F;</span><br><span class="line"> 01       0100           0100         1   4    4</span><br><span class="line">               \       &#x2F;                   \  &#x2F;</span><br><span class="line"> 01               1000                1      8</span><br><span class="line">     \          &#x2F;                       \   &#x2F;</span><br><span class="line">         1001                             9</span><br></pre></td></tr></table></figure><!-- 这里先模拟代码执行一遍：假设 `i = 5`，对应的二进制表示为 `0b0101`（1）`i = i - ((i >>> 1) & 0x55555555);`+ `i >>> 1` 的结果为 `0b0010` 等于 2+ `2 & 0x55555555` 等于 `0b0010 & 0b0101 = 0b0000` 十进制结果为 0 + `i - 0b0000` 结果等于 `0b0101`，即第一段代码运行后 `i = 0b0101`（2）`i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);`+ `i & 0x33333333` 等于 `0b0101 & 0b0011 = 0b0001`+ `i >>> 2` 等于 `0b0001`+ `((i >>> 2) & 0x33333333)` 等于 `0b0001 & 0b0011 = 0b0001`+ `(i & 0x33333333) + ((i >>> 2) & 0x33333333)` 等于 `0b0001 + 0b0001 = 0b0010`（3）`i = (i + (i >>> 4)) & 0x0f0f0f0f;`+ `(i >>> 4)` 等于 `0b0000`+ `(i + (i >>> 4))` 等于 `0b0010`+ `(i + (i >>> 4)) & 0x0f0f0f0f` 等于 `0b0010 & 0b1111 = 0b0010`（4）`i = i + (i >>> 8);` 和 `i = i + (i >>> 16);` 结果都是 `0b0010`（5）`i & 0x3f` 等于 `0b0010 & 0b1111 = 0b0010` 等于十进制的 2，即求得 5 的二进制表示中有 2 个 1。 --><p>如果以 <code>0b11111111</code> 为例可以看到每一步的变化</p><ul><li><code>i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</code> 运算完后 <code>i = 0b10101010</code> 。</li><li><code>i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</code> 运算完后 <code>i = 0b01000100</code>。</li><li><code>i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i = i + (i &gt;&gt;&gt; 8);</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i = i + (i &gt;&gt;&gt; 16);</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i &amp; 0x3f</code> 返回 <code>0b00001000</code> 等于 8</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-的幂【简单】&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#2-的幂【简单】&quot;&gt;&lt;/a&gt;2 的幂【简单】&lt;/h2&gt;
&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;231. 2 的幂&quot; h</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://halo123.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://halo123.top/tags/LeetCode/"/>
    
    <category term="位运算" scheme="https://halo123.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>千种植物转录组计划</title>
    <link href="https://halo123.top/2021/05/29/Biology/%E5%8D%83%E7%A7%8D%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E7%BB%84%E8%AE%A1%E5%88%92/"/>
    <id>https://halo123.top/2021/05/29/Biology/%E5%8D%83%E7%A7%8D%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E7%BB%84%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-29T09:40:01.000Z</published>
    <updated>2021-06-07T09:16:23.398Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.nature.com/articles/s41586-019-1693-2">https://www.nature.com/articles/s41586-019-1693-2</a></p><p style="text-align:center; font-size:30px; ">One thousand plant transcriptomes and the phylogenomics of green plants</p><h2 id="Abstract"><a class="header-anchor" href="#Abstract"></a>Abstract</h2><p>Green plants (Viridiplantae) include around 450,000–500,000 species <sup>[<a href="#ref-CR1">1</a>,<a href="#ref-CR2">2</a>]</sup> of great diversity and have important roles in terrestrial and aquatic ecosystems. Here, as part of the One Thousand Plant Transcriptomes Initiative, we sequenced the vegetative transcriptomes of 1,124 species that span the diversity of plants in a broad sense (Archaeplastida), including green plants (Viridiplantae), glaucophytes (Glaucophyta) and red algae (Rhodophyta). Our analysis provides a robust phylogenomic framework for examining the evolution of green plants. Most inferred species relationships are well supported across multiple species tree and supermatrix analyses, but discordance among plastid and nuclear gene trees at a few important nodes highlights the complexity of plant genome evolution, including polyploidy, periods of rapid speciation, and extinction. Incomplete sorting of ancestral variation, polyploidization and massive expansions of gene families punctuate the evolutionary history of green plants. Notably, we find that large expansions of gene families preceded the origins of green plants, land plants and vascular plants, whereas whole-genome duplications are inferred to have occurred repeatedly throughout the evolution of flowering plants and ferns. The increasing availability of high-quality plant genome sequences and advances in functional genomics are enabling research on genome evolution across the green tree of life.</p><blockquote><p>绿色植物（Viridiplanta）约有 45 万至 50 万不同物种，它们在陆地和水生生态系统中起着重要的作用。作为“千种植物转录组计划”的一部分，我们对泛植物界中的 1124 种物种的转录组进行了测序，包括绿色植物（Viridiplanta）、灰藻门（Glaucophyta）和红藻门（Rhodophyta）。我们的分析为研究绿色植物的进化提供了一个健壮的系统基因组框架。在大多数推测的物种关系、跨多个物种树和超级矩阵的分析中得到了很好的支持。但在质体之间和核基因树的几个重要的节点之间产生了矛盾，凸显出了植物基因组进化的复杂，其中包括多倍性、物种快速形成和灭绝。祖先变异的不完全谱系分选、多倍体化和基因家族的大规模扩张时不时打断绿色植物进化史。尤其，我们发现，尽管在开花植物和蕨类植物的进化过程中推测发生了多次的全基因组的复制，但大规模的基因家族扩张是要早于绿色植物、陆生植物和维管植物的起源。此外，测序得到越来越多的高质量植物基因组序列和功能基因组学的进步，使得研究跨越绿色生命之树的基因组进化成为可能。</p></blockquote><h2 id="Main"><a class="header-anchor" href="#Main"></a>Main</h2><p>Viridiplantae comprise an estimated 450,000–500,000 species<sup>[<a href="#ref-CR1">1</a>,<a href="#ref-CR2">2</a>]</sup>, encompass a high level of diversity and evolutionary timescales<sup>[<a href="#ref-CR3">3</a>]</sup>, and have important roles in all terrestrial and most aquatic ecosystems. This ecological diversity derives from developmental, morphological and physiological innovations that enabled the colonization and exploitation of novel and emergent habitats. These innovations include multicellularity and the development of the plant cuticle, protected embryos, stomata, vascular tissue, roots, ovules and seeds, and flowers and fruit (Fig. 1). Thus, plant evolution ultimately influenced environments globally and created a cascade of diversity in other lineages that span the tree of life. Plant diversity has also fuelled agricultural innovations and growth in the human population<sup>[<a href="#ref-CR4">4</a>]</sup>.</p><blockquote><p>绿色植物约有 45 万至 50 万种，拥有丰富的多样性和长时间的进化历程，并在所有陆地和大多数水生生态系统中发挥着重要的作用。这种生态多样性源于进化，形态和生理上的改变，使得移植、扩张、发展新的栖息地成为可能。这些改变包括多细胞化，植物角质层进化，保护胚胎，气孔，维管组织，根系，胚珠，种子以及花和果实（图片 1）。因此，植物进化最终影响了全球的生态环境，并贯穿了生命之树，创造了许多不同的世系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/Fig1.png" alt="Fig. 1: Diversity within the Viridiplantae."></p><div class="tabs" id="fig1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fig1-1">Description</button></li><li class="tab"><button type="button" data-href="#fig1-2">描述</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fig1-1"><p><strong>a</strong>–<strong>e</strong>, Green algae. <strong>a</strong>, <em>Acetabularia</em> sp. (Ulvophyceae). b, <em>Stephanosphaera pluvialis</em> (Chlorophyceae). c, <em>Botryococcus</em> sp. (Trebouxiophyceae). d, <em>Chara</em> sp. (Charophyceae). e, <em>‘Spirotaenia’</em> sp. (taxonomy under review) (Zygnematophyceae). f–p, Land plants. f, Notothylas orbicularis (Anthocerotophyta (hornwort)). g, Conocephalum conicum (Marchantiophyta (thalloid liverwort)). h, Sphagnum sp. (Bryophyta (moss)). i, Dendrolycopodium obscurum (Lycopodiophyta (club moss)). j, Equisetum telmateia (Polypodiopsida, Equisetidae (horsetail)). k, Parablechnum schiedeanum (Polypodiopsida, Polypodiidae (leptosporangiate fern)). l, Ginkgo biloba (Ginkgophyta). m, Pseudotsuga menziesii (Pinophyta (conifer)). n, Welwitschia mirabilis (Gnetophyta). o, Bulnesia arborea (Angiospermae, eudicot, rosid). p, Paphiopedilum lowii (Angiospermae, monocot, orchid). a, Photograph reproduced with permission of Thieme Verlag, Stuttgart66. b–e, Photographs courtesy of M. Melkonian. f–j, l–n, p, Photographs courtesy of D.W.S. k, Photograph courtesy of R. Moran. o, Photograph courtesy of W. Judd.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fig1-2"><p>a-e，绿藻类。a，</p><p>TODO</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>Phylogenomic approaches are now widely used to resolve species relationships<sup>[<a href="#ref-CR5">5</a>]</sup> as well as the evolution of genomes, gene families and gene function<sup>[<a href="#ref-CR6">6</a>]</sup>. We used mostly vegetative transcriptomes for a broad taxonomic sampling of 1,124 species together with 31 published genomes to infer species relationships and characterize the relative timing of organismal, molecular and functional diversification across green plants.</p><blockquote><p>系统基因组学方法现在被广泛用于解决物种关系、基因组的进化、基因家族和基因功能。我们利用从 1124 种植物中通过分类学的抽样，获得样品的植物转录组，并结合 31 个已发表的基因组来推断物种关系，描绘出绿色植物的有机体、分子和功能多样性的诞生的相对时间。</p></blockquote><p>We evaluated gene history discordance among single-copy genes. This is expected in the face of rapid species diversification, owing to incomplete sorting of ancestral variation between speciation events7. Hybridization8, horizontal gene transfer9, gene loss following gene and genome duplications10 and estimation error can also contribute to gene-tree discordance. Nevertheless, through rigorous gene and species tree analyses, we derived robust species tree estimates (Fig. 2 and Supplementary Figs. 1–3). Gene-family expansions and genome duplications are recognized sources of variation for the evolution of gene function and biological innovations11,12. We inferred the timing of ancient genome duplications and large gene-family expansions. Our findings suggest that extensive gene-family expansions or genome duplications preceded the evolution of major innovations in the history of green plants.</p><blockquote><p>我们评估了单拷贝基因之间的基因史的不一致性。这是预期在面对快速物种多样化，由于不完整的分类祖先变异之间的物种事件</p></blockquote><h2 id="Integrated-analysis-of-genome-evolution"><a class="header-anchor" href="#Integrated-analysis-of-genome-evolution"></a>Integrated analysis of genome evolution</h2><h2 id="Primary-acquisition-of-the-plastid"><a class="header-anchor" href="#Primary-acquisition-of-the-plastid"></a>Primary acquisition of the plastid</h2><h2 id="The-history-of-Viridiplantae"><a class="header-anchor" href="#The-history-of-Viridiplantae"></a>The history of Viridiplantae</h2><h2 id="Synthesis"><a class="header-anchor" href="#Synthesis"></a>Synthesis</h2><h2 id="Methods"><a class="header-anchor" href="#Methods"></a>Methods</h2><h2 id="Data-availability"><a class="header-anchor" href="#Data-availability"></a>Data availability</h2><h2 id="Code-availability"><a class="header-anchor" href="#Code-availability"></a>Code availability</h2><h2 id="References"><a class="header-anchor" href="#References"></a>References</h2><ol><li id="ref-CR1">Corlett, R. T. Plant diversity in a changing world: status, trends, and conservation needs. Plant Divers. 38, 10–16 (2016). </li><li id="ref-CR2">Lughadha, E. N. et al. Counting counts: revised estimates of numbers of accepted species of flowering plants, seed plants, vascular plants and land plants with a review of other recent estimates. Phytotaxa 272, 82–88 (2016).</li><li id="ref-CR3">Kumar, S., Stecher, G., Suleski, M. & Hedges, S. B. TimeTree: a resource for timelines, timetrees, and divergence times. Mol. Biol. Evol. 34, 1812–1819 (2017).</li><li id="ref-CR4">Schery, R. W. Plants for Man 2nd edn (Prentice-Hall, 1972).</li><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --></ol><h2 id="Acknowledgements"><a class="header-anchor" href="#Acknowledgements"></a>Acknowledgements</h2><h2 id="Author-information"><a class="header-anchor" href="#Author-information"></a>Author information</h2><h2 id="Ethics-declarations"><a class="header-anchor" href="#Ethics-declarations"></a>Ethics declarations</h2><h2 id="Additional-information"><a class="header-anchor" href="#Additional-information"></a>Additional information</h2><h2 id="Extended-data-figures-and-tables"><a class="header-anchor" href="#Extended-data-figures-and-tables"></a>Extended data figures and tables</h2><h2 id="Supplementary-information"><a class="header-anchor" href="#Supplementary-information"></a>Supplementary information</h2><h2 id="Rights-and-permissions"><a class="header-anchor" href="#Rights-and-permissions"></a>Rights and permissions</h2><h2 id="About-this-article"><a class="header-anchor" href="#About-this-article"></a>About this article</h2><h2 id="Further-reading"><a class="header-anchor" href="#Further-reading"></a>Further reading</h2><h2 id="Comments"><a class="header-anchor" href="#Comments"></a>Comments</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://www.nature.com/articles/s41586-019-1693-2&quot;&gt;https://www.nature.com/articles/s41586-019-1693-2&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
    <category term="植物学" scheme="https://halo123.top/tags/%E6%A4%8D%E7%89%A9%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>棘皮动物的演化</title>
    <link href="https://halo123.top/2021/05/29/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
    <id>https://halo123.top/2021/05/29/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E7%9A%84%E8%BF%9B%E5%8C%96/</id>
    <published>2021-05-29T08:14:01.000Z</published>
    <updated>2021-06-20T07:42:15.598Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 主要参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="寒武纪的余烬：棘皮动物篇（上）" href="https://zhuanlan.zhihu.com/p/51287717"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">寒武纪的余烬：棘皮动物篇（上）</p><p class="url">https://zhuanlan.zhihu.com/p/51287717</p></div></a></div><div class="tag link"><a class="link-card" title="寒武纪的余烬：棘皮动物篇（下）" href="https://zhuanlan.zhihu.com/p/51585435"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">寒武纪的余烬：棘皮动物篇（下）</p><p class="url">https://zhuanlan.zhihu.com/p/51585435</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客 0：后口动物的征途" href="https://zhuanlan.zhihu.com/p/27155535"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客 0：后口动物的征途</p><p class="url">https://zhuanlan.zhihu.com/p/27155535</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客１：绽放的奇葩" href="https://zhuanlan.zhihu.com/p/27155622"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客１：绽放的奇葩</p><p class="url">https://zhuanlan.zhihu.com/p/27155622</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客２：亦步亦趋" href="https://zhuanlan.zhihu.com/p/27155675"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客２：亦步亦趋</p><p class="url">https://zhuanlan.zhihu.com/p/27155675</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客３：爬起来，走两步" href="https://zhuanlan.zhihu.com/p/27155812"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客３：爬起来，走两步</p><p class="url">https://zhuanlan.zhihu.com/p/27155812</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客４：异界妖花" href="https://zhuanlan.zhihu.com/p/27155892"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客４：异界妖花</p><p class="url">https://zhuanlan.zhihu.com/p/27155892</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客５：群魔乱舞" href="https://zhuanlan.zhihu.com/p/27155947"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客５：群魔乱舞</p><p class="url">https://zhuanlan.zhihu.com/p/27155947</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客 6：刚柔并济" href="https://zhuanlan.zhihu.com/p/352015660"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客 6：刚柔并济</p><p class="url">https://zhuanlan.zhihu.com/p/352015660</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客7：Alura Une" href="https://zhuanlan.zhihu.com/p/356406403"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客7：Alura Une</p><p class="url">https://zhuanlan.zhihu.com/p/356406403</p></div></a></div>              </div>            </details><details ><summary> 其他参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="【维基百科】棘皮动物" href="https://en.wikipedia.org/wiki/Echinoderm"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/wiki.68zrhewkzwk0.png"/></div><div class="right"><p class="text">【维基百科】棘皮动物</p><p class="url">https://en.wikipedia.org/wiki/Echinoderm</p></div></a></div><div class="tag link"><a class="link-card" title="【马里兰大学古生物学】棘皮动物 1" href="https://www.geol.umd.edu/~tholtz/G331/lectures/331echin1.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【马里兰大学古生物学】棘皮动物 1</p><p class="url">https://www.geol.umd.edu/~tholtz/G331/lectures/331echin1.html</p></div></a></div><div class="tag link"><a class="link-card" title="【马里兰大学古生物学】棘皮动物 2" href="https://www.geol.umd.edu/~tholtz/G331/lectures/331echin2.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【马里兰大学古生物学】棘皮动物 2</p><p class="url">https://www.geol.umd.edu/~tholtz/G331/lectures/331echin2.html</p></div></a></div><div class="tag link"><a class="link-card" title="【鬼谷说】棘皮动物：六亲不认的演化步伐" href="https://www.bilibili.com/video/BV1Nb411h7bc"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【鬼谷说】棘皮动物：六亲不认的演化步伐</p><p class="url">https://www.bilibili.com/video/BV1Nb411h7bc</p></div></a></div><div class="tag link"><a class="link-card" title="「派大星」入选「十大海洋新物种」名单" href="https://www.zhihu.com/question/450637881"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">「派大星」入选「十大海洋新物种」名单</p><p class="url">https://www.zhihu.com/question/450637881</p></div></a></div>              </div>            </details><div class="tag link"><a class="link-card" title="【网站推荐】可视化进化树" href="https://www.evogeneao.com/en/explore/tree-of-life-explorer"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【网站推荐】可视化进化树</p><p class="url">https://www.evogeneao.com/en/explore/tree-of-life-explorer</p></div></a></div><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.24fzifdt0w74.png" alt="进化树"></p><p>该网站通过点击两个物种，可以直观的看到两个物种的关系。</p><h2 id="棘皮动物-Key-Points"><a class="header-anchor" href="#棘皮动物-Key-Points"></a>棘皮动物 Key Points</h2><ul><li>现存的棘皮动物约有 7000 种，已灭绝的物种约有 13000 种，它们的栖息地从浅海到数千米的深海都有广泛分布。</li><li>棘皮动物和脊索动物同属于后口动物（Deuterostomes），即在胚胎的原肠胚期其原口形成为肛门而与之相对的后口形成嘴部的动物。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.6y77h6fg2q80.png" alt="原口动物和后口动物"></p><ul><li>棘皮动物属于无脊椎动物中的高等门类，同时也是后口动物中比较原始的类群，是生物进化史中极为重要的一环</li><li>棘皮动物只存在海洋中，没有涉足陆地和淡水，且几乎都是底栖动物。</li><li>最早鉴定的棘皮动物在寒武纪</li><li>棘皮动物深海和浅海，包括其他生物稀少的区域都有分布，很少有其他群落如此丰富。</li><li>在地质学上，棘皮动物的价值在于它们的骨化骨骼，有的石灰石地层全部由分解了的海百合骨骼构成。可以为了解地质环境提供有价值的线索。</li><li>大多数棘皮动物能够无性繁殖，再生组织、器官和四肢；在某些情况下，它们可以从单个肢体完成再生，如下图所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5b3zosjzwa80.png" alt="断臂再生"></p><ul><li>由于棘皮动物成体次辐射对称，例如海星多出几条或少几条腕并不会对其生命产生太多影响。</li><li>棘皮动物线粒体基因排列顺序相当保守，海参纲和海胆纲间几乎完全一致，二者与海星纲间仅存在一个大片段的倒位，海百合纲中的基因重排也较为有限，仅在蛇尾纲内出现了较多的基因重排现象</li><li>古生物证据却显示，棘皮动物不同纲之间存在有 450 ～ 550 百万年的分化距离</li></ul><h3 id="分类和演化"><a class="header-anchor" href="#分类和演化"></a>分类和演化</h3><p>在胚胎的早期发育过程中，在后口动物中，胚孔（第一个形成的开口）变成了肛门，而在原口动物中，胚孔变成了嘴。在后口动物中，口发育较晚，位于囊胚的另一端，与囊胚孔相对，而肠道将两者连接起来棘皮动物的幼虫具有双侧对称，但在变态过程中，当它们的身体重组并发展出棘皮动物特有的辐射对称。</p><p>成年棘皮动物的特征是拥有一个水管系统和一个由胶原纤维网连接的小骨组成的钙质内骨骼。骨片可以形成棘、叉棘、刺等结构，突出于体表之外，使体表粗糙不平。不同形式的棘行使防卫、清除体表沉积物等功能。故称之为棘皮动物。</p><p>目前现存的棘皮动物门（Echinodermata）下有以下 5 纲：</p><ul><li>海星纲（Asteroidea）；</li><li>蛇尾纲（Ophiuroidea）；</li><li>海胆纲（Echinoidea）；</li><li>海参纲（Holothuroidea）；</li><li>海百合纲（Crinoidea）；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/image.6rj5hl0h26c0.png" alt="棘皮动物"></p><h4 id="系统发生"><a class="header-anchor" href="#系统发生"></a>系统发生</h4><p>早期棘皮动物的系统发生不确定，主要是不确定蛇尾纲是要分到海星亚门中还是海胆亚门中。后来，2014 年对所有棘皮动物的 219 个基因进行了分析，得出了如下的系统发育树【<a href="https://doi.org/10.1098/rspb.2014.0479">DOI 链接</a>】。2015 年，一项对 23 种棘皮动物的 RNA 转录组的独立分析得出了同一棵树，如下图所示【<a href="https://doi.org/10.1371/journal.pone.0119627">DOI 链接</a>】。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5x76pwdj7hg0.png" alt="棘皮动物的系统发生树"></p><h4 id="化石历史"><a class="header-anchor" href="#化石历史"></a>化石历史</h4><p>已知最古老的棘皮动物化石可能是来自澳大利亚前寒武纪的 <em>Arkarua</em>。它是一个盘状的化石，边缘有放射状的脊，中央有一个有放射状线标记的五角形凹陷。然而，没有立体或内部结构显示水管系统的存在，鉴定结果不确定。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Arkarua_adami_pennetta.3ax8b8efiym0.png" alt="Arkarua_adami_pennetta"></p><p>最早被普遍接受的棘皮动物出现在下寒武纪早期，棘皮动物留下了大量的化石记录。有一种假说认为，所有棘皮动物的祖先都是简单的、能动的、两侧对称的动物，有嘴、肠和肛门。这种祖先采用了附着的生活方式和悬浮进食，并发展了辐射对称，因为这对这种生存更有利。所有的棘皮动物的幼虫直到现在都是两侧对称的，而且在变态时都发育成径向对称。海星和海百合在变成成体的过程中仍然附着在海床上。</p><p>第一批棘皮动物后来演化出了可以自由活动的群体。棘皮动物早期演化出具有坚硬的内骨骼板和供取食的纤毛状槽。古生代棘皮动物，附着于基质上，口腔面朝上。嘴朝上可能是最原始的状态，在某个阶段，除了海百合的其他大部分的棘皮动物，都改变成为了嘴朝下的姿势。在此之前，腕可能有一个进食功能，就像现在海百合的功能一样。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%871.mg0f1h8wnkw.jpg" alt="早期的几类棘皮动物"></p><blockquote><p>图片引用自 Deciphering the early evolution of echinoderms with Cambrian fossils【<a href="http://doi.org/10.1111/pala.12138">DOI 链接</a>】</p></blockquote><h2 id="棘皮动物门介绍"><a class="header-anchor" href="#棘皮动物门介绍"></a>棘皮动物门介绍</h2><h3 id="生物学特征"><a class="header-anchor" href="#生物学特征"></a>生物学特征</h3><blockquote><p>参考：许崇任《动物生物学》（第 2 版）</p></blockquote><p>棘皮动物成体五辐射对称，幼体全部两侧对称。身体表面具有棘、刺，突出表体之外。一部分体腔形成了特殊的水管系统、血系统和围血系统。骨骼全部起源于中胚层，由钙化的骨片组成。神经系统没有神经节和中枢神经系统。</p><p>由于棘皮动物为辐射卵裂，以肠腔法形成了中胚层和真体腔，原胚孔最终形成了成体的肛门，成体的口在原肠孔相对的一端另外形成，其发育过程与原始的脊索动物类似，属于演化中最原始的后口动物。</p><h4 id="外部形态"><a class="header-anchor" href="#外部形态"></a>外部形态</h4><p>棘皮动物的成体是五辐射对称（或是 5 的倍数辐射对称），即沿中轴可以将身体分为 5 个相等的部分。由于它们的幼虫期是两侧对称的，因此推测成体的五辐射对称应为次生性的，与腔肠动物原始的辐射对称形式完全不同。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%872.26vf7j26v1a8.png" alt="海星幼虫与从幼虫中脱落的海星"></p><blockquote><p>海星幼虫与从幼虫中脱落的海星</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Haeckel_Asteridea_Larvae.oinaxeny2ow.jpg" alt="Haeckel_Asteridea_Larvae"></p><blockquote><p>海星的幼虫</p></blockquote><p>以海星为例，身体由体盘和腕构成。体盘有口的较平的一面称为口面，口面中央有口。另一面略凸称反口面，中央有肛门。腕一般有 5 条，从体盘伸出。在腕的腹面中部有一条步带沟，其中有 2 ~ 4 排管足生出，管足末端有吸盘。腕之间为间步带区，反口面有一个在间步带区的多孔的筛板。腕的顶端靠下有眼点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Asterias_rubens,_dissection.1lif2idd80qo.svg" alt="海星的解剖示意图"></p><ol><li>幽门胃（Pyloric stomach）</li><li>肠和肛门（Intestine and anus）</li><li>直肠盲囊（Rectal sac）</li><li>石管（Stone canal）</li><li>筛板（Madreporite）</li><li>幽门盲囊（Pyloric caecum）</li><li>消化腺（Digestive glands）</li><li>贲门胃（Cardiac stomach）</li><li>生殖腺（Gonad）</li><li>辐水管（Radial canal）</li><li>步带沟（Ambulacral ridge）</li></ol><h4 id="体壁与骨骼"><a class="header-anchor" href="#体壁与骨骼"></a>体壁与骨骼</h4><p>棘皮动物的体壁由表皮层和表皮层下的结缔组织构成，称为真皮。外面是一层薄的角质层，下面是一层单纤毛的柱状上皮，柱状上皮之下是结缔组织。真皮下是肌肉层，肌肉层内为体腔膜。其他的无脊椎动物体璧不是真皮层。</p><p>棘皮动物的骨骼都起源于中胚层，称为内骨骼，是由许多钙质的骨片组成，骨片上有小孔，位于体壁的结缔组织内。骨片可以形成棘、叉棘、刺等结构，突出于体表之外，使体表粗糙不平。不同形式的棘行使防卫、清除体表沉积物等功能。另外，体壁上还有表皮和体腔上皮向外凸起形成的皮鳃， 表皮和体腔上皮上都有纤毛，分别打动水流和体腔液，进行气体交换。</p><h4 id="水管系统"><a class="header-anchor" href="#水管系统"></a>水管系统</h4><p>水管系统是一个相对封闭的管状系统，担负着棘皮动物运动的功能。海盘车的水管系统包括筛板、石管、环水管、辐水管、管足、吸盘、坛囊几个部分。环水管上有帖氏体，可能有产生体腔细胞的作用。水管系统的内壁是体腔上皮，里面充满液体。管足的外壁是纤毛上皮，与内壁的体腔上皮之间有肌肉层。水管系统内的液体与海水等渗，运动时相当于一个液压系统，使得管足可以伸缩，管足末端的吸盘可以借液压产生的真空吸附在物体上。水管的其他部分共同起着控制、协调系统内水流的作用。实验证明水管系统内的液体是不与外界交换的。</p><h4 id="血系统和围血系统"><a class="header-anchor" href="#血系统和围血系统"></a>血系统和围血系统</h4><p>棘皮动物没有专门的循环器官，但有与其他动物不同的血系统和一套围血系统。在棘皮动物发达的真体腔内充满体腔液，靠体腔上皮细胞的纤毛打动，体腔液完成营养物质的输送。血系统包括一套与水管系统相应的管道，有与辐水管平行的辐血管、与环水管平行的环血管、位于反口面的胃血管和分支，以及与石管平行的轴窦。 血系统的管道中有液体，轴窦和筛板附近的背囊均有搏动能力。包围在血系统之外还有一套围血系统，围血系统是体腔的一部分，形成围绕在血系统之外的一套窦隙。关于棘皮动物血系统和围血系统的作用目前尚了解不多</p><h4 id="消化系统"><a class="header-anchor" href="#消化系统"></a>消化系统</h4><p>棘皮动物的消化系统以海盘车为例，口面中央有一圈围口膜，之间是口，连接口的是贲门胃，贲门胃之后是幽门胃，有 5 对幽门盲囊分布在腕内，后有一短的直肠连通肛门。消化管的上皮有纤毛，腺细胞可分泌消化酶。棘皮动物有肉食性的，也有植食性的。海盘车取食双壳类时，用腕上的吸盘将壳吸住拉开，然后贲门胃翻出，包住食物，先进行初步体外消化，再吞咽回体内。消化的营养物质由幽门盲囊吸收贮存。海星纲的肛门虽然存在，但是已经丧失了机能。消化后的食物残渣仍然由口排出。海蛇尾以小动物或海底沉积物为食，以较为活动的腕送人口中，或腕上的刺和管足送入口中。海胆纲的动物有一咀嚼器，是由复杂的骨片组成，上面有 齿可以用来取食岩石上的海藻。海胆的食性复杂，可以取食小动物，也可以取食植物。它们的消化管很长，食物残渣由肛门排出。海参类为沉积取食或悬浮取食，以触手将食物送入口中。海参的消化管长度是身体的 3 ~ 4 倍，在消化管后端有 1 对分支很多的呼吸树，起呼吸的作用。海百合是悬浮取食，管足上的纤毛将黏着的食物颗粒逐渐送入口中。</p><h4 id="神经系统"><a class="header-anchor" href="#神经系统"></a>神经系统</h4><p>棘皮动物的神经系统是分散的，没有神经节和中枢神经系统。海盘车有3个神经系统，它们是外胚层起源的外神经系统（ectoneural nervous system）、中胚层起源的内神经系统（ento-neural nervous system）和下神经系统（hyponeural nervous system）。外神经系统在口面的表皮细胞下，包括围口膜边缘的1个神经环和由此神经环发出的辐神经，辐神经沿步带沟中部一直延伸到腕的末端，并发出神经到管足和坛囊。内神经系统是.上皮下神经丛在步带沟外边缘加厚形成的1对边缘神经索，发出的神经到步带骨板的肌肉上，并在体腔膜下形成神经丛，支配体壁肌肉。下神经系统也称为体腔神经，位于围血系统的体壁上，在体腔膜下。棘皮动物的感觉器官只有感光的眼点，眼点位于腕的顶端。但是棘皮动物整个表皮中有大量神经感觉细胞，除司触觉外，还能够对光和化学刺激作出反应。</p><h4 id="生殖和发育"><a class="header-anchor" href="#生殖和发育"></a>生殖和发育</h4><p>除了少数海蛇尾和海参外，棘皮动物大多是雌雄异体。如海盘车的生殖腺位于间步带区，一般为 5 对（或 5 的倍数）。生殖孔在反口面靠近腕基部的中央盘上，生殖细胞排出体外受精。受精卵是辐射卵裂，发育后经内陷法形成原肠，再由腔肠法形成中胚层和 3 对体腔囊，即前体腔囊、中体腔囊和后体腔囊。原肠胚时的胚孔最终发育成为成体的肛门，而成体的口则是在原肠孔相对的另一端形成的。棘皮动物各纲的幼虫形态不相同，但基本结构是一样的。棘皮动物的幼虫期是两侧对称的，经变态后形成了辐射对称的幼虫。例如在变态过程中，海盘车的羽腕幼虫右侧的前体腔囊和中体腔囊退化，后体腔囊形成了后来的体腔，左侧的中体腔囊形成了整个水管系统，包括环水管、辐水管以及管足，并逐渐从两侧对称成为辐射对称的形式，说明棘皮动物的五辐射对称是次生性的。</p><h3 id="棘皮动物门的分类"><a class="header-anchor" href="#棘皮动物门的分类"></a>棘皮动物门的分类</h3><p>棘皮动物全部是海洋底栖生活，广泛分布在从浅海到数千米的深海，现存 6000 多种，而化石种类则多达 20000 多种。沿海常见的海星、海蛇尾、海胆、海参等都属于棘皮动物。棘皮动物依据生活方式可分为游在亚门（Eleutherozoa，也叫游走亚门、无柄亚门或活动亚门）和有柄亚门（Pelmatozoa，也叫固着亚门）两大类。1963年，美国无脊椎动物学家巴里·费尔根据棘皮动物体内独特的水管系统，提出了新的分类方案。</p><h4 id="依据生活方式分类"><a class="header-anchor" href="#依据生活方式分类"></a>依据生活方式分类</h4><ul><li>有柄亚门（Pelmatozoa）<ul><li>海蕾纲（Blastoidea）†</li><li>海百合纲（Crinoidea）</li><li>海座星纲（Edrioasteroids）†</li></ul></li><li>游在亚门（Eleutherozoa）<ul><li>海星纲（Asteroidea）</li><li>海胆纲（Echinoidea）</li><li>海参纲（Holothuroidea）</li><li>蛇尾纲（Ophiuroidea）</li></ul></li></ul><blockquote><p>†表示已灭绝</p></blockquote><p><font color="#faa755">有柄亚门</font>：附着或固着生活，在生活史中至少有一个时期具固着用的柄。</p><ul><li>海百合纲（Crinoidea）：海百合纲是棘皮动物中最原始的一类，以柄营固着生活（海百合），或无柄营自由生活（海羽星）。5个腕的基部多分支，使身体看似杯状，但口面和反口面均在同一个面。现存 630 余种。</li></ul><hr><p><font color="#faa755">游在亚门</font>：自由生活，生活史中没有具固着生活的柄。</p><ul><li>海星纲：身体呈星形，中央盘和 5 个（或 5 的倍数）腕之间的界限与海蛇尾比不明显，腕的口面有步带沟，步带沟中有 2 ~ 4 排管足。</li><li>海蛇尾纲：腕细长，与中央盘的界限非常明显，没有步带沟，管足没有坛囊和吸盘。筛板位于口面。本纲是棘皮动物中最大的一类，现存约有 2000 种，分布极广。</li><li>海胆纲：5 个腕向反口面愈合，呈圆球形或扁圆形的骨骼包住身体。体表头长有可以活动的刺。现存种类约 900 种。</li><li>海参纲：身体沿口面和反口面延长，成为长圆柱形，无腕，并以步带区和间步带区附着。口和肛门分别在身体的两端，出现次生性的两侧对称。骨片小而分散，无互相关连的骨板，故体表没有棘和叉棘。口为一圈管足形成的触手所包围。现存种类有 1100 余种。</li></ul><h4 id="依据水管系统分类"><a class="header-anchor" href="#依据水管系统分类"></a>依据水管系统分类</h4><ul><li>海胆亚门（Echinozoa）：<ul><li>海旋板纲（Helicoplacoidea）†</li><li>海蛇函纲（Ophiocistioidea）†</li><li>海蒲团纲（Camptostromatoidea）†</li><li>海盘囊纲（Cyclocystoidea，也称环海林檎纲）†</li><li>海参纲（Holothuroidea）</li><li>海胆纲（Echinoidea）</li></ul></li><li>海扁果亚门（Homalozoa）† ：<ul><li>海桩纲（Stylophora）†</li><li>海笔纲（Homostelea）†</li><li>海箭纲（Homoiostelea）†</li><li>栉海林檎纲（Ctenocystoidea）†</li></ul></li><li>海百合亚门（Crinozoa）：<ul><li>海百合纲（Crinoidea）</li><li>海林檎纲（Cystoidea）†</li><li>拟海百合纲（Paracrinoidea）†</li><li>始海百合纲（Eocrinoidea）†</li><li>海蕾纲（Blastoidea）†</li><li>拟海蕾纲（Parablastoidea）†</li><li>垫海蕾纲（Edrioblastoidea）†</li><li>海座星纲（Edrioasteroidea）†</li><li>鳞海林檎纲（Lepidocystoidea）†</li></ul></li><li>海星亚门（Asterozoa）：<ul><li>海星纲（Asteroidea）</li><li>蛇尾纲（Ophiuroidea）</li><li>体海星纲（Somasteroidea）†</li></ul></li></ul><p>1973年斯普林克尔（J.Sprinkle）有在此基础上从海百合亚门中划分出海蕾亚门（Blastozoa），下设海蕾纲（Blastoidea）、拟海蕾纲（Parablastoidea）、海林檎纲（Cystoidea）及始海百合纲（Eocrinoidea）4纲。</p><h3 id="棘皮动物的进化地位"><a class="header-anchor" href="#棘皮动物的进化地位"></a>棘皮动物的进化地位</h3><p>棘皮动物与一般的无脊椎动物不同，它的卵裂、早期胚胎发育、中胚层的产生、体腔的形成以及骨骼由中胚层产生等，都与脊索动物有相同的地方，而不同于无脊椎动物。从成体口的形成和肛门的形成看，棘皮动物也与脊椎动物相同，所以棘皮动物与脊椎动物都属于后口动物。基于以上事实，科学家现在普遍认为，脊索动物与棘皮动物有共同的祖先。</p><h2 id="化石分析演化历史"><a class="header-anchor" href="#化石分析演化历史"></a>化石分析演化历史</h2><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/1.4hhmjjeama20.svg" alt="棘皮动物演化关系图"></p><h3 id="与半索动物的分别"><a class="header-anchor" href="#与半索动物的分别"></a>与半索动物的分别</h3><p>有研究通过对现存的生物进行基因组测序，通过生物信息学分析，得出棘皮动物门和半索动物门的分开大概在 5.3 亿年前的前寒武纪时期。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.2p55tzf01j00.png" alt="image"></p><blockquote><p>The sea cucumber genome provides insights into morphological evolution and visceral regeneration. <a href="https://doi.org/10.1371/journal.pbio.2003790">DOI 链接</a>】</p></blockquote><p>在寒武纪的化石群中发现了一些难以归类的动物化石，具有一些后口动物的特征命名为 Ctenoimbricata 其中有一个生物名为爬胃虫（<em>Herpetogaster collinsi</em>）化石以及复原图如下，此外还有澄江化石群的长柄火炬虫（<em>Phlogites longus</em>）【<a href="https://figshare.com/articles/figure/_Phlogites_longus_from_the_Lower_Cambrian_Chengjiang_biota_/531245">参考链接</a>】</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.za063wx1w1s.png" alt="爬胃虫"></p><p>通过图片我们可以了解到，此时这种生物是两侧对称，头部有着触手，可能是用于捕获海里的浮游生物，而基部有着类似管状的“脚”，可能是用于固着在海床中。如果觉得抽象，幸运的是现存一种名为海苹果（<em>Pseudocolochirus violaceus</em>）的海参，有着类似的滤食行为。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/海苹果.63qik8szmd80.jpg" alt="海苹果" style="object-fit: cover; border-radius: 10px; width: 50%;" /><p>顺便放一段海苹果的进食视频</p><div class="tag link"><a class="link-card" title="海苹果进食" href="https://www.bilibili.com/video/BV1Rs411p73A"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">海苹果进食</p><p class="url">https://www.bilibili.com/video/BV1Rs411p73A</p></div></a></div><blockquote><p>需要注意的是，这里使用海苹果只是作为演示，不能作为海苹果与爬胃虫之间的进化关系的证明，也不代表爬胃虫的进食方式和海苹果一样。</p></blockquote><h3 id="然后寒武纪来了"><a class="header-anchor" href="#然后寒武纪来了"></a>然后寒武纪来了</h3><p>寒武纪来了，生命大爆发，这一时期的生物有一个特点就是有壳和一定的骨骼，可能因为地质变动，为海洋带来了大量的碳酸钙，同时也是因为有了壳的保护，才能适应当时的竞争环境得以生存。也正因为壳和骨骼的存在，也相对容易的通过化石遗迹保留下来，得以我们去窥看 5 亿多年前的初代目。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4pox3z79k5y0.png" alt="image"></p><blockquote><p>图片来自于：Plated Cambrian Bilaterians Reveal the Earliest Stages of Echinoderm Evolution 【<a href="https://doi.org/10.1371/journal.pone.0038296">DOI 链接</a>】</p></blockquote><p>海笔纲动物的消化道已经扭转了 90 度，肛门转到体侧，所以那条像是尾巴的东西并不是长在身体的“后”部。</p><p>海箭纲的消化道发生了扭转，在口和肛门附近都有一根介于像是“须腕”或者“尾巴”的东西，口旁的也许有辅助进食的功能，肛门旁的可能固定身体或者爬行。</p><p>海桩纲动物的身体结构分为两种：左边一种保留了更多两侧对称的特征，可以在海底自由爬行。它们有一根分段的须腕，口生在须腕的前段和后段之间；右边的完全不对称，基本营固着生活。海桩纲不同于其他棘皮动物的另一个特征是具有类似鳃裂的结构，它们也许就是用口吸入海水，再从鳃裂流出，过滤其中的食物。这种进食方式倒是典型的后口动物式的。</p><p>这些棘皮动物一是打破了两侧对称的构型，外部器官和内脏都发生偏转，身体越长越“歪”；二是除了“身体”之外，在身体侧方，以及口或肛门的附近还延伸出一些类似附肢的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.um0wk3ysoow.png" alt="image"></p><p>这里列出的早期的棘皮动物化石，看到它们只能一脸问号，难以相信它们是刚刚分化的近亲。虽然外表差异极大，但冷静下来它们还是有一定的共同之处</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%877.3vzej82jji00.png" alt="图片7"></p><p>就比如图中红色部分：步带沟；蓝色和绿色部分：体盘；黄色部分：茎和固着器。基本的部件都还有。</p><p>个人认为，在寒武纪这个神奇的世中，棘皮动物和三叶虫这类节肢动物选择了底栖生活，一方面说明海底确实有着足够的食物支持生长，但海旋板纲、海座星纲、始海百合纲它们的嘴是朝上，并且固着在海底，可能通过步带沟将食物送入嘴中。</p><h3 id="百「花」齐放——海百合亚门"><a class="header-anchor" href="#百「花」齐放——海百合亚门"></a>百「花」齐放——海百合亚门</h3><p>海百合亚门，在富含浮游生物的海水滋养下，这类滤食动物异常繁盛。它们的萼上丛生着多达数十条羽状的修长须腕，在海水中有节奏地舒卷张合，把经过的浮游生物送入口中。它的茎由数十段骨片连结而成，骨片之间可以弯曲扭转，使得海百合极其坚韧而又灵活。群集的海百合在海流中起伏摇荡，组成壮观的水下花潮。无数的三叶虫，甲壳类和无颌鱼类在花海中穿梭；细小的海螺，海星和海蛇尾攀附在海百合上，成为海洋生物的一片绿洲。在海百合的冲击下，始海百合类逐渐衰落，最终淡出了历史舞台。</p><p>海百合是古生代和中生代海相沉积层中最丰富的化石类群之一。海百合死后，肌体腐烂，萼部和茎部会分离解体，由于形状和重量的差别，被海水挟带，经常会沉积在不同地方，分别形成数量可观的化石群。茎部骨板是圆形的薄片，中央有五角形的空洞，成堆形成的化石像是一串串的古代钱币。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.3hgj140momk.png" alt="image"></p><p>海百合纲一直延续到 4 亿 5000 万年后，成为现存棘皮动物中唯一的固着滤食类群。</p><p>因其骨化骨骼，在不同的时期可以看到夺目的身姿，下图展示了，不同时期的海百合的种类数目变化</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.9dg9ylbvjtw.png" alt="海百合数目变化"></p><p>可以看到，古生代的海百合种类最多也是海百合最繁盛的时期，但在二叠纪生物大灭绝后，只有少量海百合幸存了下来，但生命力顽强的它们又逐渐的恢复，现存至今。</p><p>海百合虽过着滤食生活，但在演化史中也出现过多种生活形式。下图是奥陶纪和至留纪时期的海百合化石复原图，它们有着较长的茎，吸附于海底中或缠绕于珊珊等生物上。固着是它们的基本形式，而有着较长的茎一方面在进食上有着优势，另一方面也可以减少一些在海底的生物攻击其体盘。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/OrdovicianCrinoidReconstruction.png" alt="奥陶纪海百合复原图"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.68e03qyd9n80.png" alt="志留纪海百合复原图"></p><p>在泥盆纪更出现了一些具有主动捕食形式的海百合，© <a href="https://doi.org/10.4202/app.2010.0020">Jan Bohatý</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4fxw8nbk0os0.png" alt="泥盆纪海百合复原图"></p><p>在侏罗纪出现了，可以固着在漂浮物上的海百合，其中可能原因是植物数组貌似，洪水泛滥将枝干冲入海中，有了这个先天条件，能固着在漂浮物中上的海百合有了一定的被动移动的能力，被选择保留下来自然也不意外。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1pl4ofwlcojk.png" alt="侏罗纪海百合复原图"></p><p>在白垩纪，出现了一种脱离固定的一条演化路线，它们就如同水母一般，可能用其滤食的腕足，拨动海水游动。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4ipn0x2roae0.png" alt="白垩纪海百合"></p><p>目前现存的海百合在中也存在固着和可以游动（但运动能力有限，可以称为半附着）的这两类海百合，但已经不如古生代时期海底花园那样繁盛。</p><blockquote><p>图片来自于：<a href="http://www.fossilcrinoids.com/index.html">fossilcrinoids.com</a></p></blockquote><h3 id="不「走」寻常路——海星亚门"><a class="header-anchor" href="#不「走」寻常路——海星亚门"></a>不「走」寻常路——海星亚门</h3><p>海星亚门可能起源于类似海座星纲的生物，海座星纲生物过着固定的滤食生活，口是朝上的，用着步带沟将食物送入嘴中，我们知道，固着有着局限性，在环境好时可以躺平，但环境一旦恶劣也难逃灭绝之难。</p><p>说起来也是神奇，这时候这类生物想要突破怎么办，基本的框架都已经搭建好了，突然变成“派大星”也十分困难，但它们翻了个身子就解决了这个问题，用曾经灵活的“舌头”来走路，在这个竞争激烈的环境中，能动对于不能动简直就是降维打击。同时，由于腕上有吸盘，可以打开贝壳，海星也走上了捕食者的道路。</p><h3 id="两个极端的「胜利」——海胆亚门"><a class="header-anchor" href="#两个极端的「胜利」——海胆亚门"></a>两个极端的「胜利」——海胆亚门</h3><p>海参和海胆它们作为进化关系的兄弟，你可能会诧异，这两个家伙现在一点都不像啊，但它们在寒武纪时期就分道扬镳至少有 4.7 亿年，两者选择了不同的进化路线，一个害怕疼就全点防御，海参选择了躺平挨打，但在它们之间有一个类海蛇函纲的生物</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1mo60vhi54ps.png" alt="海蛇函"></p><p>它们可能选择了中间的道路，好不容易挺过二叠纪大灭绝但可能因为环境的改变淡出了历史舞台，而看似胜利的海参和海胆终究逃不过人类的餐桌（误）</p><p>海胆点满了防御，海参则点满了回血和控制。</p><p>海参在遇到危险时，将自己的一部分内脏吐出来，一方面可以缠绕对方，另一方面可以给对方吃，吃饱了也就不攻击本体，而海参通过较强的恢复能力再生。此外，海参还可以通过改变自身的颜色，来较少被发现了可能。</p><h2 id="为什么棘皮动物能存活下来"><a class="header-anchor" href="#为什么棘皮动物能存活下来"></a>为什么棘皮动物能存活下来</h2><p>在经历过大大小小的生物大灭绝事件后，棘皮动物仍在海洋中占着一席之地，更加不可思议的是它们演化出在千变万化的身体形态，但在生活习性上却十分保守，绝大多数过着底栖的生活，未曾涉足陆地和淡水。你可能认为它们“不思进取”，这固然有些道理，没有较大的选择压力，大家在海底“躺平”生活相安无事。我个人认为其关键点有以下几个：</p><ul><li>适应范围广，棘皮动物从深海到浅海，都有分布，并且是广泛分布，正所谓不要把鸡蛋放到一个篮子里，在生物灭绝中，一部分原因可能是没有波及到，但更多的原因可能是其拥有较高的适应能力存活下来。</li><li>再生能力强，面对攻击“缺胳膊少腿”，对于棘皮动物来说只是家常便饭，这种壁虎断尾式的生存方式，无疑保全自身东山再起，更有甚者仅通过断臂就可“克隆”自己。</li><li>辐射对称妙，大自然的规律告诉了我们，这个世界的两侧对称动物的世界，但棘皮动物辐射对称一定程度上限制了其演化的上限，像海参通过“拉长”自己，使自己看起来两侧对称，但实际还是辐射对称。虽然上限低，但辐射对称也有一定好处，除了上述收到攻击时“缺胳膊少腿”时可以多些“胳膊”和“腿”，再遗传变异中多些或少些“胳膊”和“腿”都没太大问题。辐射对称起初是为了滤食而生，定了这个基调，却能演化出千奇百怪的用途，不禁感叹自然的鬼斧神工。</li></ul><blockquote><p>这里引出一个问题：为什么海星通常有五条腕？五辐对称在自切上有优势，通过选择中就被保留了下来。</p></blockquote><h2 id="话题外"><a class="header-anchor" href="#话题外"></a>话题外</h2><h3 id="「派大星」"><a class="header-anchor" href="#「派大星」"></a>「派大星」</h3><p>2021 年 3 月 19 日，全球权威海洋生物学数据库《世界海洋生物目录》发布了 <a href="https://lifewatch.be/en/worms-top10-2020">2020 年度「十大海洋新物种」名单</a>，深海海星新物种 Astrolirus patricki Zhang Zhou, Xiao &amp; Wang, 2020 （中文名又称「派大星」背板海星）入选了 2020 年度「十大海洋新物种」名单。这一新物种的命名者是从小看《海绵宝宝》长大的 90 后博士研究生张睿妍，她表示，「派大星」背板海星目前所发现的所有标本全部都栖息于海绵之上，就像海绵宝宝与派大星一样，是一对难舍难分的「铁哥们」。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%873.27uo7ocvdt7o.png" alt="十大海洋新物种"></p><blockquote><p>发表文章：A new sponge-associated starfish, Astrolirus patricki sp. nov. (Asteroidea: Brisingida: Brisingidae), from the northwestern Pacific seamounts 【<a href="https://doi.org/10.7717/peerj.9071">DOI 链接</a>】</p></blockquote><hr><p>未完待续。。。</p><h2 id="文献资料"><a class="header-anchor" href="#文献资料"></a>文献资料</h2><p>Weighted gene co-expression network analysis reveals potential genes involved in early metamorphosis process in sea cucumber <em>Apostichopus japonicus</em></p><p>加权基因共表达网络分析揭示了参与海参早期变态过程的潜在基因</p><p>Sea cucumbers, one main class of Echinoderms, have a very fast and drastic metamorphosis process during their development. However, the molecular basis under this process remains largely unknown. Here we systematically examined the gene expression profiles of Japanese common sea cucumber (<em>Apostichopus japonicus</em>) for the first time by RNA sequencing across 16 developmental time points from fertilized egg to juvenile stage. Based on the weighted gene co-expression network analysis (WGCNA), we identified 21 modules. Among them, MEdarkmagenta was highly expressed and correlated with the early metamorphosis process from late auricularia to doliolaria larva. Furthermore, gene enrichment and differentially expressed gene analysis identified several genes in the module that may play key roles in the metamorphosis process. Our results not only provide a molecular basis for experimentally studying the development and morphological complexity of sea cucumber, but also lay a foundation for improving its emergence rate.</p><p>海参是棘皮动物的主要种类之一，在其发育过程中有一个非常迅速和剧烈的变态过程。然而，这一过程的分子基础在很大程度上仍然未知。本研究首次对日本普通海参（Apostichopus japonicus）受精卵至幼期 16 个发育时间点的基因表达谱进行了系统分析。基于加权基因共表达网络分析（WGCNA），我们鉴定出 21 个模块。其中，MEdarkmagenta 表达量高，且与耳状幼虫至海参形幼虫的早期变态过程相关。此外，基因富集和差异表达基因分析确定了模块中几个可能在变态过程中起关键作用的基因。本研究结果不仅为实验研究海参的发育和形态复杂性提供了分子基础，而且为提高海参的出苗率奠定了基础。</p><div class="tag link"><a class="link-card" title="DOI 链接" href="https://doi.org/10.1016/j.bbrc.2017.11.154"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">DOI 链接</p><p class="url">https://doi.org/10.1016/j.bbrc.2017.11.154</p></div></a></div><hr><p>Echinoderm systems for gene regulatory studies in evolution and development</p><p>在进化和发育中用于基因调控研究的棘皮系统</p><p>One of the main challenges in Evolutionary Developmental Biology is to understand to which extent developmental changes are driven by regulatory alterations in the genomic sequence. In the recent years, the focus of comparative developmental studies has moved towards a systems biology approach providing a better understanding of the evolution of gene interactions that form the so called Gene Regulatory Networks (GRN). Echinoderms provide a powerful system to reveal regulatory mechanisms and within the past decade, due to the latest technological innovations, a great number of studies have provided valuable information for comparative GRN analyses. In this review we describe recent advances in evolution of GRNs arising from echinoderm systems, focusing on the properties of conserved regulatory kernels, circuit cooption events and GRN topological rearrangements.</p><p>进化发育生物学的主要挑战之一是理解发育变化在多大程度上是由基因组序列的调节改变驱动的。近年来，比较发育研究的重点已经转向系统生物学的方法，以更好地理解形成所谓的基因调控网络（GRN）的基因相互作用的进化。棘皮动物提供了一个强大的系统来揭示调节机制，在过去的十年中，由于最新的技术创新，大量的研究为 GRN 的比较分析提供了有价值的信息。本文综述了棘皮系统中 GRN 的进化研究进展，主要包括保守调控核的性质、回路合作事件和 GRN 拓扑重排。</p><!-- 1-s2.0-S0959437X16300661-main.pdf --><hr><p>New discoveries of Cambrian pelmatozoan echinoderm ossicles from North China</p><p>来自华北地区的寒武纪棘皮动物有柄亚目听骨的新发现</p><p>A variety of echinoderm ossicles have been discovered in the middle to upper Cambrian rocks of the North China Craton. Material was collected from two localities: Shuangqiao (SQ)section (Paibian) in Hebei Province and Linyi (LY) (Guzhangian?–Paibian?) in Shandong Province. Six types of ossicles can be recognized, including rounded thecal plates, and columnals with a narrow lumen and ridged articulating facets. The combination of characters suggests an unknown stalked echinoderm, probably an eocrinoid, with relatively advanced columnal morphology.</p><!-- 1-s2.0-S1871174X15000438-main.pdf --><hr><p>The earliest scientific descriptions of Chinese fossil echinoderms in a late nineteenth-century publication by Lajos Lóczy (Ludwig von Lóczy)</p><p>对中国棘皮动物化石的最早科学描述是在19世纪后期</p><!-- 1-s2.0-S1871174X15000682-main.pdf --><hr><p>Fossil Echinoderm Studies in China and other countries: Historical and new perspectives</p><p>中国和其他国家的化石棘皮动物研究:历史和新视角</p><!-- 1-s2.0-S1871174X15000888-main.pdf --><hr><p>The onset of the Ordovician evolutionary radiation of benthic animals in the Baltic Region: Explosive diversity of attachment structures of stalked echinoderms, substrate revolution and the role of cyanobacterial communities</p><p>奥陶纪底栖动物进化辐射的开始波罗的海地区:有柄棘皮动物附着结构的爆炸性多样性，底物革命和蓝藻群落的作用</p><p>The study of the Ordovician holdfasts of the Baltic Paleobasin revealed an explosive increase in the morphological diversity of echinoderms of the Baltic Paleobasin, up to 12 major morphological types in the Volkhov Regional Stage (Dapingian), reflecting an explosive growth in the taxonomic and morphological diversity of stalked echinoderms in general, but primarily crinoids. A sudden increase in the size and diversity of holdfasts at that time suggests a considerable increase in calcite production by stalked echinoderms and their adaptation to a wide distribution of a new type of substrate — hardgrounds and firm coarse-grained bioclastic substrates. The possibility of wide distribution of such substrates was due to a considerable increase, of at least an order of magnitude, in the carbonate productivity of benthic communities, whereas the rapid distribution of a new type of substrate and an explosive increase in the diversity and abundance of their inhabitants in the Baltic Basin was related to the appearance of positive feedbacks between the living and non-living components of this ecosystem. The existence of this positive feedback was due to cyanobacterial communities, the development of a biofilm on the substrate, and mineralization of an extracellular polymer substance, which led to the formation of hardgrounds and consolidation of the surface of the bioclastic substrates. The appearance in the Middle Ordovician of positive feedback between the expansion of the bioclastic substrates and an increase in carbonate production by their inhabitants, resulted in the Ordovician substrate revolution and explosive diversification of Ordovician benthic animals. Cyanobacterial films episodically appearing on the substrate, were an essential factor in the formation of this feedback.</p><p>研究显示奥陶纪的波罗的海古盆地显示了波罗的海古盆地棘皮动物形态多样性的爆炸性增长，在沃尔霍夫区域阶段(大坪阶)，有 12 种主要的形态类型，反映了有柄棘皮动物的分类和形态多样性的爆炸性增长，但主要是海百合。</p><!-- 1-s2.0-S1871174X18300489-main.pdf --><hr><p>Evolution of Caribbean echinoderms during the Cenozoic: moving towards a complete picture using all of the fossils</p><p>加勒比地区新生代棘皮动物的演化:利用所有的化石走向完整的画面</p><!-- 1-s2.0-S003101820000208X-main.pdf --><hr><p>Echinoderm development and evolution in the post-genomic era</p><p>后基因组时代的棘皮动物的发展和进化</p><p>The highly recognizable animals within the phylum Echinodermata encompass an enormous disparity of adult and larval body plans. The extensive knowledge of sea urchin development has culminated in the description of the exquisitely detailed gene regulatory network (GRN) that governs the specification of various embryonic<br>territories. This information provides a unique opportunity for comparative studies in other echinoderm taxa to understand the evolution and developmental mechanisms underlying body plan change. This review focuses on recent work that has utilized new genomic resources and systems-level experiments to address questions of<br>evolutionary developmental biology. In particular, we synthesize the results of several recent studies from various echinoderm classes that have explored the development and evolution of the larval skeleton, which is a major feature that distinguishes the two predominant larval subtypes within the Phylum. We specifically<br>examine the ways in which GRNs can evolve, either through cis regulatory and/or protein-level changes in transcription factors. We also examine recent work comparing evolution across shorter time scales that occur within and between species of sea urchin, and highlight the kinds of questions that can be addressed by these comparisons. The advent of new genomic and transcriptomic datasets in additional species from all classes of echinoderm will continue to empower the use of these taxa for evolutionary developmental studies.</p><p>棘皮动物门内的高度可识别的动物包括一个巨大的差异的成虫和幼虫的身体计划。关于海胆发育的广泛知识已经达到了顶峰，详细的基因调控网络(GRN)的描述，管理各种胚胎领土的规格。这一信息为其他棘皮类的比较研究提供了独特的机会，以了解体平面变化的进化和发育机制。本文综述了近年来利用新的基因组资源和系统水平的实验来解决进化发育生物学的问题。特别是，我们综合了最近几项来自不同种类的棘皮动物的研究结果，这些研究探索了幼虫骨骼的发展和进化，这是区分该门中两种主要的幼虫亚型的主要特征。我们特别研究了grn可以通过顺式调控和/或转录因子的蛋白水平变化进化的方式。我们还研究了最近的研究，比较了海胆物种内部和物种之间在较短时间内发生的进化，并强调了通过这些比较可以解决的问题。新的基因组和转录组数据集的出现，将继续授权使用这些类群的进化发展研究</p><!-- 1-s2.0-S0012160616305747-main.pdf --><hr><p>The Cambrian Substrate Revolution and the early evolution of attachment in suspension-feeding echinoderms</p><p>寒武纪基质革命与悬浮取食棘皮动物附着的早期进化</p><p>The Cambrian, characterized by the global appearance of diverse biomineralized metazoans in the fossil record for the first time, represents a pivotal point in the history of life. This period also documents a major change in the nature of the sea floor: Neoproterozoic-type substrates stabilized by microbial mats were replaced by unconsolidated soft substrates with a well-developed mixed layer. The effect of this transition on the ecology and evolution of benthic metazoans is termed the Cambrian Substrate Revolution (CSR), and this is thought to have<br>impacted greatly on early suspension-feeding echinoderms in particular. According to this paradigm, most echinoderms rested directly on non-bioturbated soft substrates as sediment attachers and stickers during the Cambrian Epoch 2. As the substrates became increasingly disturbed by burrowing, forming a progressively<br>thickening mixed layer, echinoderms developed new strategies for attaching to firm and hard substrates. To test this model, we evaluated the mode of attachment of 83 Cambrian suspension-feeding echinoderm species; attachment mode was inferred based on direct evidence in fossil specimens and interpretations of functional<br>morphology. These data were analyzed quantitatively to explore trends in attachment throughout the <a href="http://Cambrian.In">Cambrian.In</a> contrast to previous studies, the majority of Cambrian clades (eocrinoids, helicoplacoids, helicocystoids,isorophid edrioasteroids, and solutes) are now interpreted as hard (shelly) substrate attachers. Only early<br>edrioasteroids attached directly to firm substrates stabilized by microbially induced sedimentary structures.Contrary to the predictions of the CSR paradigm, our study demonstrates that Cambrian echinoderms were morphologically pre-adapted to the substrate changes that occurred during the Cambrian, allowing them to fully<br>exploit the appearance of hardgrounds in the Furongian. We find no support for the claim that the CSR explains the peak in echinoderm diversity during Cambrian Epochs 2–3, or that it caused the extinction of helicoplacoids.</p><p>寒武纪首次在化石记录中以生物矿化的后生动物在全球范围内的出现为特征，代表了生命历史的一个关键点。这一时期也记录了海底性质的一个重大变化:由微生物垫稳定的新元古代类型的基岩被松散的软基岩所取代，后者具有发育良好的混合层。这种转变对底栖后生动物的生态和进化的影响被称为寒武纪底栖动物的进化(CSR)，这被认为对早期悬浮取食的棘皮动物有很大的影响。根据这一范式，在寒武纪第2期，大多数棘皮动物直接依附在非生物扰动的软基质上作为沉积物附着剂和贴纸。由于挖洞对基质的干扰越来越大，形成了一个逐渐增厚的混合层，棘皮动物开发了附着在坚硬基质上的新策略。为了验证该模型，我们对寒武系83种悬浮取食的棘皮动物的附着模式进行了评估;根据化石标本的直接证据和功能形态解释推断附着模式。对这些数据进行了定量分析，以探讨整个寒武纪的附着趋势。与以前的研究相比，寒武纪的大多数支系(类蠕形纲、类螺旋形纲、类螺旋形纲、类等蛾类流星体和溶质)现在被解释为坚硬的(壳类)基质附着体。只有早期的涡旋小行星直接附着在由微生物引起的沉积构造稳定的坚实基质上。与CSR模式的预测相反，我们的研究表明，寒武纪的棘皮动物在形态上预先适应了寒武纪发生的基质变化，使它们能够充分利用弗隆纪的硬地。我们没有发现支持CSR解释寒武纪棘皮动物多样性高峰的说法，或者它导致螺旋形类动物的灭绝。</p><!-- 1-s2.0-S0012825217301265-main.pdf --><hr><p>Fossil echinoderms from the Carboniferous Limestone sea defence blocks at Barton-on-Sea, Hampshire, southern England</p><p>来自英国南部汉普郡巴顿-on- sea石炭纪石灰岩海防御区块的棘皮动物化石</p><!-- 1-s2.0-S0016787803800317-main.pdf --><hr><p>Diversity patterns and biostratigraphy of Cenozoic echinoderms from Florida</p><p>佛罗里达新生代棘皮动物多样性模式与生物地层学</p><!-- 1-s2.0-S0031018200002091-main.pdf --><hr><p>Palaeogeographical and palaeoecological aspects of the Cambro^Ordovician radiation of echinoderms in Gondwanan Africa and peri-Gondwanan Europe</p><p>非洲冈瓦南地区和欧洲冈瓦南周边地区寒武系和奥陶系棘皮动物辐射的古地理和古生态特征</p><!-- 1-s2.0-S0031018203003031-main.pdf --><hr><p>⭐Evolutionary palaeoecology of early epifaunal echinoderms:Response to increasing bioturbation levels during the Cambrian radiation</p><p>早期深层棘皮动物的进化古生态学:寒武纪辐射期间生物扰动水平增加的响应</p><!-- 1-s2.0-S0031018205006942-main.pdf --><hr><p>⭐ Changes in the Early Palaeozoic geography as a possible factor of echinoderm higher taxa formation: Delayed larval development to cross the Iapetus Ocean</p><p>早期古生代的地理变化可能是棘皮动物高级类群形成的因素:穿越伊阿佩托斯洋的幼虫发育延迟</p><!-- 1-s2.0-S0031018206003609-main.pdf --><hr><p>⭐⭐ Climate changes in the Early to Middle Miocene of the Central Paratethys and the origin of its echinoderm fauna</p><p>中新世早期至中新世中期的气候变化中央副穴居动物及其棘皮动物群的起源</p><!-- 1-s2.0-S0031018207002003-main.pdf --><hr><p>⭐⭐ Settling strategy of stalked echinoderms from the Kaili Biota (middle Cambrian), Guizhou Province, South China</p><p>贵州凯里生物区中寒武世有柄棘皮动物的定居策略</p><!-- 1-s2.0-S0031018207004567-main.pdf --><hr><p>⭐ The absence of echinoderms from the Lower Cambrian Chengjiang fauna of China: Palaeoecological and palaeogeographical implications</p><p>中国下寒武统澄江动物群中棘皮动物的缺失:古生态学和古地理意义</p><!-- 1-s2.0-S0031018210000027-main.pdf --><hr><p>⭐ Palaeoecological aspects of the diversification of echinoderms in the Lower Ordovician of central Anti-Atlas, Morocco</p><p>摩洛哥中央反阿特拉斯下奥陶统棘皮动物多样性的古生态学方面</p><!-- 1-s2.0-S0031018216001395-main.pdf --><hr><p>The mechanically adaptive connective tissue of echinoderms: Its potential for<br>bio-innovation in applied technology and ecology</p><p>棘皮动物的机械适应性结缔组织:在应用技术和生态学方面的生物创新潜力</p><!-- 1-s2.0-S0141113611000894-main.pdf --><hr><p>⭐⭐ Complete mitochondrial genome of the sea cucumber Apostichopus japonicus (Echinodermata: Holothuroidea): The first representative from the subclass Aspidochirotacea with the echinoderm ground pattern</p><p>海参(Apostichopus japonicus)线粒体全基因组:棘皮海参亚纲中第一个具有棘皮基部图案的海参亚纲代表</p><!-- 1-s2.0-S0378111909001358-main.pdf --><hr><p>⭐⭐ Phylogenomic Resolution of the Hemichordate and Echinoderm Clade</p><p>半棘皮类和棘皮类的系统基因组解析</p><!-- 1-s2.0-S0960982214012925-main.pdf --><hr><p>⭐ Evolution of mitochondrial gene orders in echinoderms</p><p>棘皮动物线粒体基因顺序的进化</p><!-- 1-s2.0-S1055790307004186-main.pdf --><hr><p>⭐ Do echinoderm genomes measure up?</p><p>棘皮动物的基因组符合标准吗?</p><!-- 1-s2.0-S1874778715000148-main.pdf --><hr><p>⭐⭐ Evolution: Mapping Out Early Echinoderms</p><p>进化:绘制早期棘皮动物图谱</p><!-- 10.1016@j.cub.2020.05.013.pdf --><hr><p>⭐⭐ Global Diversity of Brittle Stars (Echinodermata: Ophiuroidea)</p><p>海蛇尾全球的多样性</p><hr><p>⭐⭐⭐ Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms</p><p>棘皮动物的体平面从双侧对称到五侧对称的基因组洞见</p><p>Echinoderms are an exceptional group of bilaterians that develop pentameral adult symmetry from a bilaterally symmetric larva. However, the genetic basis in evolution and development of this unique transformation remains to be clarified. Here we report newly sequenced genomes, developmental transcriptomes, and proteomes of diverse echinoderms including the green sea urchin (L. variegatus), a sea cucumber (A. japonicus), and with particular emphasis on a sister group of the earliest-diverged echinoderms, the feather star (A. japonica). We learned that the last common ancestor of echinoderms retained a well-organized Hox cluster reminiscent of the hemichordate, and had gene sets involved in endoskeleton<br>development. Further, unlike in other animal groups, the most conserved developmental stages were not at the body plan establishing phase, and genes normally involved in bilaterality appear to function in pentameric axis development. These results enhance our understanding of the divergence of protostomes and deuterostomes almost 500 Mya.</p><p>棘皮动物是一种特殊的双侧动物，从两侧对称的幼虫发展成五辐对称的成体。然而，这一独特转化的遗传基础在进化和发展仍有待澄清。本文报道了包括绿海胆(L. variegatus)、海参(a . japonicus)在内的多种棘皮动物的基因组、发育转录组和蛋白质组的最新测序结果，并重点报道了最早分化的棘皮动物的一个兄弟类群——羽星(a . japonica)。我们了解到，棘皮动物的最后一个共同祖先保留了一个组织良好的Hox簇，让人联想到半棘虫，并有参与内骨骼发育的基因集。此外，与其他动物不同的是，最保守的发育阶段并不是在身体计划建立阶段，通常参与双向性的基因似乎在五聚体轴的发育中发挥作用。这些结果加深了我们对近500米亚原口动物和后口动物差异的认识。</p><!-- s42003-020-1091-1.pdf --><hr><p>Echinoderm Phylogeny: Morphology and Molecules Approach Accord</p><p>棘皮动物的发展史: 形态学和分子方法一致</p><!-- smith1992.pdf --><hr><p>Echinoderms (Other Than Echinoids)</p><p>棘皮类动物(海胆类除外)</p><!-- smith2005.pdf -->]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 主要参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;寒武</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>基因工程有关资料</title>
    <link href="https://halo123.top/2021/05/27/Biology/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B/"/>
    <id>https://halo123.top/2021/05/27/Biology/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B/</id>
    <published>2021-05-27T14:40:48.000Z</published>
    <updated>2021-06-22T08:46:27.765Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果访问有问题尝试这个地址：<a href="http://81.70.151.52/2021/05/27/Biology/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B/">HALO</a> 或 <a href="https://halo123.cn.utools.club">HALO</a></p></blockquote><blockquote><p>选择、填空、名词解释、简答题、论述题</p></blockquote><h2 id="自测"><a class="header-anchor" href="#自测"></a>自测</h2><h3 id="作业题"><a class="header-anchor" href="#作业题"></a>作业题</h3><ol><li><a href="#Q1">用基因工程的定义原理来阐述重组新冠病毒疫苗</a> <a id="T1"></a></li><li>根据你的设想设计一款转基因产品，简述它的设计思路及其应用<!-- (#Q2)  -->  <a id="T2"></a></li><li><a href="#Q3">基因工程中常用工具酶种类有哪些，他们的主要作用是什么</a> <a id="T3"></a></li><li><a href="#Q4">什么是星星活性，引起星活性的因素有哪些，哪些措施可以抑制星活性</a> <a id="T4"></a></li><li><a href="#Q5">切口移位标记探针的主要步骤有哪些</a> <a id="T5"></a></li><li><a href="#Q6">20 μL 的酶切反应体系和 20 μL 的连接反应体系组成成分各是什么？酶切和连接的最佳反应温度又各是多少？</a> <a id="T6"></a></li><li><a href="#Q7">DNA 分子平末端的连接方式有哪些？</a> <a id="T7"></a></li><li><a href="#Q8">理想载体至少必备的条件有哪些</a> <a id="T8"></a></li><li><a href="#Q9">目前的主要载体种类有哪些</a> <a id="T9"></a></li><li><a href="#Q10">简述蓝白斑筛选法原理</a> <a id="T10"></a></li><li><a href="#Q11">简述 λ 噬菌体的三种选择标记</a> <a id="T11"></a></li><li><a href="#Q12">简述 YAC 载体的工作原理、应用、以及其缺点</a> <a id="T12"></a></li><li><a href="#Q13">简述碱裂解法和煮沸法抽提质粒 DNA 的原理</a> <a id="T13"></a></li><li><a href="#Q14">简述电泳的基本原理</a> <a id="T14"></a></li><li><a href="#Q15">琼脂糖凝胶电泳过程中影响 DNA 迁移率的因素有哪些？</a> <a id="T15"></a></li><li><a href="#Q16">简述 PCR 的基本原理</a> <a id="T16"></a></li><li><a href="#Q17">PCR 反应体系包含哪些成分</a> <a id="T17"></a></li><li><a href="#Q18">引物设计需遵循的原则有哪些</a> <a id="T18"></a></li><li><a href="#Q19">分子杂交的概念</a> <a id="T19"></a></li><li><a href="#Q20">Southern 杂交的原理</a> <a id="T20"></a></li><li><a href="#Q21">Northern 印迹与 Southern 印迹有哪些不同？</a> <a id="T21"></a></li><li><a href="#Q22">基因芯片的概念及应用</a> <a id="T22"></a></li><li><a href="#Q23">最常用的三种外源基因导入植物细胞的方法及原理</a> <a id="T23"></a></li><li><a href="#Q24">农杆菌 Ti 质粒的基因结构及各个结构的功能</a> <a id="T24"></a></li><li><a href="#Q25">简述农杆菌 Ti 质粒上的 T-DNA 导入植物基因组的过程</a> <a id="T25"></a></li><li><a href="#Q26">报告基因的概念</a> <a id="T26"></a></li><li><a href="#Q27">转植酸酶玉米，为什么要转植酸酶基因？植酸酶基因来自哪里？该转基因玉米的操作流程是怎么样的？</a> <a id="T27"></a></li><li><a href="#Q28">叙述 Tet-on 型四环素诱导系统的原理</a> <a id="T28"></a></li><li><a href="#Q29">化学降解法测序原理</a> <a id="T29"></a></li><li><a href="#Q30">Sanger 双脱氧链终止法测序原理</a> <a id="T30"></a></li><li><a href="#Q31">第二代和第三代测序技术分别有哪些技术？</a> <a id="T31"></a></li><li><a href="#Q32">目前测序技术有哪些方面的应用</a> <a id="T32"></a></li><li><a href="#Q33">基因组文库和 cDNA 文库的定义、各自构建的流程、以及两者的特点</a> <a id="T33"></a></li><li><a href="#Q34">酵母双杂交的原理以及应用</a> <a id="T34"></a></li><li><a href="#Q35">动物基因工程的概念</a> <a id="T35"></a></li><li><a href="#Q36">转基因动物的制备方法主要有哪些？</a> <a id="T36"></a></li><li><a href="#Q37">简述 CRISPR/Cas9 基因定向打靶技术的原理</a> <a id="T37"></a></li><li><a href="#Q38">详述将基因打靶技术联合应用胚胎干细胞法制备转基因动物的流程</a> <a id="T38"></a></li><li><a href="#Q39">详述转基因动物技术的应用</a> <a id="T39"></a></li><li><a href="#Q40">酵母基因工程的优势有哪些方面？</a> <a id="T40"></a></li><li><a href="#Q41">详述酵母基因工程的应用进展</a> <a id="T41"></a></li><li><a href="#Q42">什么是基因治疗</a> <a id="T42"></a></li><li><a href="#Q43">目前基因药物的分类及作用原理</a> <a id="T43"></a></li><li><a href="#Q44">详述基因治疗在肿瘤治疗上的主要方向及重大进展</a> <a id="T44"></a></li></ol><h3 id="有关名词"><a class="header-anchor" href="#有关名词"></a>有关名词</h3><ul><li><a href="#Noun%E5%9F%BA%E5%9B%A0%E8%8A%AF%E7%89%87">基因芯片</a> <a id="Back基因芯片"></a></li><li><a href="#Noun%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B">基因工程</a> <a id="Back基因工程"></a></li><li><a href="#Noun%E6%98%9F%E6%98%9F%E6%B4%BB%E6%80%A7">星星活性</a> <a id="Back星星活性"></a></li><li><a href="#Noun%E6%8A%A5%E5%91%8A%E5%9F%BA%E5%9B%A0">报告基因</a> <a id="Back报告基因"></a></li><li><a href="#Noun%E5%9F%BA%E5%9B%A0%E7%BB%84DNA%E6%96%87%E5%BA%93">基因组 DNA 文库</a> <a id="Back基因组DNA文库"></a></li><li><a href="#NouncDNA%E6%96%87%E5%BA%93">cDNA 文库</a><a id="BackcDNA文库"></a></li><li><a href="#Noun%E5%9F%BA%E5%9B%A0%E6%B2%BB%E7%96%97">基因治疗</a><a id="Back基因治疗"></a></li><li><a href="#Noun%E5%8A%A8%E7%89%A9%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B">动物基因工程</a><a id="Back动物基因工程"></a></li><li><a href="#Noun%E5%90%8C%E8%A3%82%E9%85%B6">同裂酶</a> <a id="Back同裂酶"></a></li><li><a href="#Noun%E5%90%8C%E5%B0%BE%E9%85%B6">同尾酶</a> <a id="Back同尾酶"></a></li><li><a href="#NounDNA%E8%BF%9E%E6%8E%A5%E9%85%B6">DNA 连接酶</a> <a id="BackDNA连接酶"></a></li><li><a href="#Noun%E8%BD%BD%E4%BD%93">载体</a> <a id="Back载体"></a></li><li><a href="#Noun%E7%A9%BF%E6%A2%AD%E8%BD%BD%E4%BD%93">穿梭载体</a> <a id="Back穿梭载体"></a></li><li><a href="#Noun%E8%B4%A8%E7%B2%92">质粒</a> <a id="Back质粒"></a></li><li><a href="#Noun%E4%BA%BA%E5%B7%A5%E6%9F%93%E8%89%B2%E4%BD%93%E8%BD%BD%E4%BD%93">人工染色体载体</a> <a id="Back人工染色体载体"></a></li><li><a href="#Noun%E9%BB%8F%E7%B2%92%E8%BD%BD%E4%BD%93">黏粒载体</a> <a id="Back黏粒载体"></a></li><li><a href="#Noun%E5%88%86%E5%AD%90%E6%9D%82%E4%BA%A4">分子杂交</a><a id="Back分子杂交"></a></li><li><a href="#Noun%E5%8F%8D%E5%90%91PCR">反向 PCR</a><a id="Back反向PCR"></a></li></ul><h3 id="其他"><a class="header-anchor" href="#其他"></a>其他</h3><p>限制性核酸内切酶主要是从 <psw>原核生物</psw> 中分离纯化出来，识别双链 DNA 分子的某种 <psw>特定的核苷酸序列</psw> ,并且使每一条链中 <psw>特定部位</psw> 的两个核苷酸之间的 <psw>磷酸二酯键</psw> 断开。形成两种末端 <psw>粘性末端</psw> 和  <psw>平末端</psw> 。</p><hr><p>下面哪项不具有限制酶识别序列的特征（ <psw>D</psw> ）</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4lnoo6zefc00.png" alt="image"></p><hr><p>以下 <a href="#Noun%E7%B2%98%E6%80%A7%E6%9C%AB%E7%AB%AF">粘性末端</a> 属于 5’ 粘性末端还是 3’ 粘性末端 <a id="Back粘性末端"></a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.656b2rolnjw0.png" alt="image"></p><psw>5' 粘性末端</psw> <p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4e3q765d9240.png" alt="image"></p><psw>3' 粘性末端</psw> <hr><p>以下酶关系属于 <a href="#Noun%E5%90%8C%E8%A3%82%E9%85%B6">同裂酶</a> 还是 <a href="#Noun%E5%90%8C%E5%B0%BE%E9%85%B6">同尾酶</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1frg3nx3y63k.png" alt="image"></p><psw>同裂酶</psw> <p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.2i916fh1bdy0.png" alt="image"></p><psw>同尾酶</psw> <hr><p>现有一长度为 1000 个碱基对（bp）的 DNA 分子，用限制性内切酶 <em>Eco</em>RⅠ 单独酶切后得到的 DNA 分子仍为 1000 pb，用限制性内切酶 <em>Kpn</em> Ⅰ 单独酶切后得到 400 pb 和 600 pb 两种长度的 DNA 分子，用 <em>Eco</em>R Ⅰ 和 <em>Kpn</em> Ⅰ 同时酶切后得到 200 pb 和 600 pb 的两种长度的 DNA 分子。该 DNA 分子的酶切图谱正确的是（ <psw>D</psw> ）</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.6iqvwczro240.png" alt="image"></p><hr><p>按照化学降解法测序显影的结果，读出碱基序列</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.49hf6zaqbya0.png" alt="image"></p><psw>TAGTCGCAGT</psw> <hr><p>按照 Sanger 双脱氧链终止法测序显影的结果，读出<font color="#e03e3e">模板</font>碱基序列</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.18ufjmcafxcw.png" alt="image"></p><psw>5'-ACGCATTGT-3'</psw> <!-- 3'-TGTTACGCA-5'5'-ACAATGCGT-3' --><hr><h2 id="作业题-v2"><a class="header-anchor" href="#作业题-v2"></a>作业题</h2><h3 id="用基因工程的定义原理来阐述重组新冠病毒疫苗-a-id-Q1-href-T1-↩-a"><a class="header-anchor" href="#用基因工程的定义原理来阐述重组新冠病毒疫苗-a-id-Q1-href-T1-↩-a"></a>用基因工程的定义原理来阐述重组新冠病毒疫苗 <a id="Q1" href="#T1">↩</a></h3><p>略</p><blockquote><p>重组新型冠状病毒疫苗（腺病毒载体，Ad5-nCov），将一段人工构建的保护性抗原基因整合到作为载体的病毒的基因组中，使重组后的基因片段在病毒进入宿主后被表达并产生抗体。</p></blockquote><h3 id="根据你的设想设计一款转基因产品，简述它的设计思路及其应用-a-id-Q2-href-T2-↩-a"><a class="header-anchor" href="#根据你的设想设计一款转基因产品，简述它的设计思路及其应用-a-id-Q2-href-T2-↩-a"></a>根据你的设想设计一款转基因产品，简述它的设计思路及其应用 <a id="Q2" href="#T2">↩</a></h3><p>略</p><h3 id="基因工程中常用工具酶种类有哪些，他们的主要作用是什么-a-id-Q3-href-T3-↩-a"><a class="header-anchor" href="#基因工程中常用工具酶种类有哪些，他们的主要作用是什么-a-id-Q3-href-T3-↩-a"></a>基因工程中常用工具酶种类有哪些，他们的主要作用是什么 <a id="Q3" href="#T3">↩</a></h3><ol><li><font color="#ea66a6">限制性内切酶</font>：主要用于 DNA 分子的特异切割</li><li><font color="#ea66a6">DNA 甲基化酶</font>：用于 DNA 分子的甲基化</li><li><font color="#ea66a6">核酸酶</font>：用于 DNA 和 RNA 的非特异性切割</li><li><font color="#ea66a6">核酸连接酶</font>：用于 DNA 和 RNA 的连接</li><li><font color="#ea66a6">核酸聚合酶</font>：用于 DNA 和 RNA 的合成</li><li><font color="#ea66a6">核酸末端修饰酶</font>：用于 DNA 和 RNA 的末端修饰</li><li><font color="#ea66a6">其它酶类</font>：用于生物细胞的破壁，转化，核酸纯化，检测等。</li></ol><h3 id="什么是星星活性，引起星活性的因素有哪些，哪些措施可以抑制星活性-a-id-Q4-href-T4-↩-a"><a class="header-anchor" href="#什么是星星活性，引起星活性的因素有哪些，哪些措施可以抑制星活性-a-id-Q4-href-T4-↩-a"></a>什么是星星活性，引起星活性的因素有哪些，哪些措施可以抑制星活性 <a id="Q4" href="#T4">↩</a></h3><p><a id="Noun星星活性"></a><font color="#d9730d">星星活性</font>：</p><div class="tabs" id="星星活性"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#星星活性-1">课本 P28</button></li><li class="tab"><button type="button" data-href="#星星活性-2">PPT</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="星星活性-1"><p>在极端非标准条件下，限制酶能切割与识别序列相似的序列，这个改变的特殊性称星星活性（star activity）。<a  href="#Back星星活性">↩</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="星星活性-2"><p>当酶切条件改变时，酶的专一性可能会降低，以至于同一种酶可识别和切割多个的位点。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><p><font color="#d9730d">引起星星活性的因素</font>：</p><ol><li>甘油浓度高（&gt; 5%）</li><li>酶过量（&gt; 100 U/μL）</li><li>离子强度低（&lt; 25 mmol/L）</li><li>pH 过高（&gt; 8.0）</li><li>加了有机溶剂如 DMSO（二甲基亚砜）、乙醇、乙二醇、二甲基乙酰胺和二甲基甲酰胺</li><li>用其他 2 价阳离子如 Mn<sup>2+</sup>、Cu<sup>2+</sup>、Co<sup>2+</sup> 或 Zn<sup>2+</sup> 代替了 Mg<sup>2+</sup></li></ol><blockquote><p>但不同的酶对上述条件的敏感性不一样，如 <em>Pst</em> Ⅰ 比 <em>Eco</em> R Ⅰ对高 pH 更敏感，但后者对甘油浓度更敏感。</p></blockquote><hr><p><font color="#d9730d">抑制星星活性的措施</font>：</p><ol><li>减少甘油浓度；</li><li>减少酶的用量（可避免过分酶切）；</li><li>提高离子强度到 100 ～ 150 mmol/L（如果不会抑制酶的活性的话）；</li><li>降低反应 pH 至 pH 7.0 ；</li><li>保证反应体系中无有机溶剂或乙醇；</li><li>保证使用 Mg<sup>2+</sup>作为 2 价阳离子。</li></ol><h3 id="切口移位标记探针的主要步骤有哪些-a-id-Q5-href-T5-↩-a"><a class="header-anchor" href="#切口移位标记探针的主要步骤有哪些-a-id-Q5-href-T5-↩-a"></a>切口移位标记探针的主要步骤有哪些 <a id="Q5" href="#T5">↩</a></h3><blockquote><p>P33</p></blockquote><p>利用大肠杆菌 DNA 聚合酶Ⅰ的<font color="#e03e3e"> 5’ → 3’ 外切核酸酶活性</font>，可用切口平移法（nick translation）标记 DNA。</p><ol><li>首先在镁离子存在下用低限量的 <a href="https://baike.baidu.com/item/DNase%20I/5203958?fr=aladdin">DNaseⅠ</a> 处理双链 DNA 模板，产生少量切口</li><li>在切口处，利用大肠杆菌 DNA 聚合酶Ⅰ的 5’ → 3’ 外切核酸酶活性使切口沿 5’ → 3’ 方向平移，同时产生切口也可作为大肠杆菌 DNA 聚合酶Ⅰ催化 DNA 合成的引物</li><li>合成过程中，dNTP 前体不断掺入到正在 DNA 链上。如果提供标记的 dNTP，那么所有的反应产物便被标记，可用作杂交探针。</li></ol><h3 id="20-μL-的酶切反应体系和-20-μL-的连接反应体系组成成分各是什么？酶切和连接的最佳反应温度又各是多少？-a-id-Q6-href-T6-↩-a"><a class="header-anchor" href="#20-μL-的酶切反应体系和-20-μL-的连接反应体系组成成分各是什么？酶切和连接的最佳反应温度又各是多少？-a-id-Q6-href-T6-↩-a"></a>20 μL 的酶切反应体系和 20 μL 的连接反应体系组成成分各是什么？酶切和连接的最佳反应温度又各是多少？ <a id="Q6" href="#T6">↩</a></h3><p><font color="#d9730d">20 μL 的酶切反应体系</font>：</p><table><thead><tr><th>总体积</th><th>20 μL</th></tr></thead><tbody><tr><td>DNA</td><td>1 μL（1 μg）</td></tr><tr><td>buffer（10x）</td><td>2 μL</td></tr><tr><td>ddH<sub>2</sub>O</td><td>16 μL</td></tr><tr><td>限制性内切酶</td><td>1 μL</td></tr></tbody></table><p><font color="#d9730d">反应温度</font>：不同的限制性内切酶的最适反应温度不同。大多数 37℃，少数要求 40℃ ～ 65℃</p><hr><p><font color="#d9730d">20 μL 的连接反应体系</font>，以 T4 DNA 连接酶的反应为例：</p><table><thead><tr><th>总体积</th><th>20 μL</th></tr></thead><tbody><tr><td>10× T4 DNA Ligase Buffer</td><td>2 μL</td></tr><tr><td>DNA 片段</td><td>约 0.3 pmol</td></tr><tr><td>载体 DNA</td><td>约 0.03 pmol</td></tr><tr><td>T4 DNA Ligase</td><td>1 μL</td></tr><tr><td>ddH<sub>2</sub>O</td><td>up to 20 μL</td></tr></tbody></table><p><font color="#d9730d">反应温度</font>：16 ℃</p><blockquote><p>DNA 片段的摩尔数应控制在载体 DNA 摩尔数的 3 ～ 10 倍</p></blockquote><h3 id="DNA-分子平末端的连接方式有哪些？-a-id-Q7-href-T7-↩-a"><a class="header-anchor" href="#DNA-分子平末端的连接方式有哪些？-a-id-Q7-href-T7-↩-a"></a>DNA 分子平末端的连接方式有哪些？ <a id="Q7" href="#T7">↩</a></h3><ul><li>直接用 T4 DNA 连接酶连接；</li><li>先用末端核苷酸转移酶，给平末端 DNA 分子加上同聚物尾巴之后再用 DNA 连接酶进行连接；</li><li>DNA 接头连接法：它是一类由人工合成的一头具有某种限制性内切酶粘末端，另一头为平末端的特殊的双链寡核苷酸片段。当它的平末端与平末端的外源 DNA 片段连接之后，便会使后者成为具黏性末端的新的 DNA 分子，而易于连接重组。</li></ul><h3 id="理想载体至少必备的条件有哪些-a-id-Q8-href-T8-↩-a"><a class="header-anchor" href="#理想载体至少必备的条件有哪些-a-id-Q8-href-T8-↩-a"></a>理想载体至少必备的条件有哪些 <a id="Q8" href="#T8">↩</a></h3><ol><li><font color="#d9730d">质粒拷贝数较高</font>。质粒拷贝数是指生长在标准的培养基条件下，每个细菌细胞中所含有的质粒 DNA 分子的数目。根据宿主细胞所含的拷贝数多少，可将质粒分成<ul><li>严谨型：低拷贝数的质粒，每个宿主细胞中仅含有 1 ～ 2 份的拷贝</li><li>松弛型：高拷贝数的质粒，每个宿主细胞中可高达 10 ～ 200 份拷贝</li></ul></li><li><font color="#d9730d">分子量较小</font>。低分子量的质粒如下优点：<ul><li>外源 DNA 容量较大</li><li>容易转化，当质粒大于 15 kb 时，将成为转化效率的制约因素</li><li>遗传工程操作时容易拿捏，容易分离，不易断裂</li></ul></li><li><font color="#d9730d">带有可供标记基因</font>。选择标记是指带有一种或数种抗生素抗性基因，使寄主获得同样的抗生素抗性性状（resistance）。抗生素选择基因有：氨苄青霉素（Amp），氯霉素（Cm），四环素（Tet）和卡那霉素（Kan）四种，而且希望各抗性基因内有若干单一的限制酶切点。</li><li><font color="#d9730d">带有尽可能多的单一限制性酶切位点</font>。单一的限制性酶切位点可供外源 DNA 定点插入，目前常用载体上的多克隆位点（multiple cloning sites, MCS）即具有该功能。</li><li><font color="#d9730d">具有复制起始点（origin, ori）</font>。这是质粒自我增殖所必不可少的基本条件，也是决定质粒拷贝数的重要元件，可使繁殖后的细胞维持一定数量的质粒拷贝数。</li></ol><h3 id="目前的主要载体种类有哪些-a-id-Q9-href-T9-↩-a"><a class="header-anchor" href="#目前的主要载体种类有哪些-a-id-Q9-href-T9-↩-a"></a>目前的主要载体种类有哪些 <a id="Q9" href="#T9">↩</a></h3><div class="tabs" id="载体种类"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#载体种类-1">按功能分类</button></li><li class="tab"><button type="button" data-href="#载体种类-2">按来源分类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="载体种类-1"><ul><li><font color="#ea66a6">克隆载体</font>（cloning vector）：主要是对目的基因克隆，建立 DNA 文库和 cDNA 文库，其上有复制子即可；</li><li><font color="#ea66a6">表达载体</font>（expression vector）：能使目的基因在宿主细胞中表达的一类载体。这类载体既有复制子，更要有强启动子；</li><li><a id="Noun穿梭载体"></a><font color="#ea66a6">穿梭载体</font>（shuttle vector）：这类载体可以在原核细胞中复制，也可在真核细胞中扩增和表达。（2 种复制子和 2 种标记基因）<a  href="#Back穿梭载体">↩</a></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="载体种类-2"><ul><li><font color="#ea66a6">质粒载体</font></li><li><font color="#ea66a6">病毒载体</font>（细菌、植物、动物）</li><li><font color="#ea66a6">人工染色体载体</font></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="简述蓝白斑筛选法原理-a-id-Q10-href-T10-↩-a"><a class="header-anchor" href="#简述蓝白斑筛选法原理-a-id-Q10-href-T10-↩-a"></a>简述蓝白斑筛选法原理 <a id="Q10" href="#T10">↩</a></h3><blockquote><p>P44</p></blockquote><ul><li>由 α-互补而产生的 <em>LacZ</em> <sup>+</sup> 细菌在诱导剂 IPTG（异丙基硫代半乳糖苷）的作用下，在底物 X-gal 存在时产生蓝色菌落。</li><li>而当外源 DNA 插入到质粒的多克隆位点（MCS）后，α-互补被插入失活，使得带有重组质粒的 <em>LacZ</em> <sup>-</sup> 细菌形成白色菌落。</li></ul><p>β-半乳糖苷酶可以拆分成两个部分，N 端和 C 端。β-半乳糖苷酶缺陷型<font color="#faa755">菌株</font>的基因组中含有表达 β-半乳糖苷酶 C 端的基因，而 N 端（一个 146 个氨基酸的短肽，即 α 肽链）的基因被安放到了表达的<font color="#faa755">载体</font>中。N 端基因经过改造，中间插入<font color="#faa755">多克隆位点</font>。这段经过改造的 N 端基因被称为 <em>lacZ</em> 基因</p><p><em>lacZ</em> 基因是乳糖 <em>lac</em> 操纵子中编码 β-半乳糖苷酶的基因，乳糖及其衍生物可诱导其表达。</p><p>α-互补是指 β-半乳糖苷酶的两个无活性片段（N 端片段和 C 端片段）组合成为功能完整的酶的过程，指 <em>lacZ</em> 基因上缺失近操作基因区段的突变体与带有完整的近操作基因区段的 β-半乳糖苷酶基因的突变体之间实现互补。大肠杆菌 β-半乳糖苷酶可以和其底物 X-gal 相互作用并且释放出一种蓝色物质，当该酶的 α-片段和 ω-片段分开时就失去了这种显色的功能。通常将编码该酶 α-片段的 <em>LacZ</em> ’ 基因插入到载体的多克隆位点的侧翼序列中，而在一些人工构建的大肠杆菌株系中却只能编码产生该酶的 ω 片段。这样一来，含有功能性完整的 <em>LacZ</em> ’ 基因的载体导入到这类寄主细胞中时，载体编码的 α-片段就能和寄主编码的 ω-片段发生互补并具有了对底物 X-gal 的作用功能（发生显色反应），这种现象被成为是 α-互补。</p><p>缺陷株基因组无法单独编码有活性的 β-半乳糖苷酶，但当菌体中含有带 <em>lacZ</em> 的质粒后，质粒 <em>lacZ</em> 基因编码的 α 肽链（酶的 N 端）和菌株基因组表达的 β-半乳糖苷酶的 C 端互补，具有与完整 β-半乳糖苷酶相同的作用，具有分解 X-gal 生成蓝色物质的能力。操作中，添加 IPTG 以激活 <em>lacZ</em> 中的 β-半乳糖苷酶的启动子，在含有 X-gal 的固体平板培养基中菌落就会呈现蓝色。但是当 MCS 位点上插入 DNA 片段时，<em>lacZ</em> 基因就失活了，没法完成 α-互补，β-半乳糖苷酶失活，无法分解 X-gal，因此菌落就是白色的。</p><h3 id="简述-λ-噬菌体的三种选择标记-a-id-Q11-href-T11-↩-a"><a class="header-anchor" href="#简述-λ-噬菌体的三种选择标记-a-id-Q11-href-T11-↩-a"></a>简述 λ 噬菌体的三种选择标记 <a id="Q11" href="#T11">↩</a></h3><blockquote><p>P54</p></blockquote><div class="tabs" id="噬菌体的三种选择标记"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#噬菌体的三种选择标记-1">β-半乳糖苷酶失活型载体</button></li><li class="tab"><button type="button" data-href="#噬菌体的三种选择标记-2">cⅠ基因失活</button></li><li class="tab"><button type="button" data-href="#噬菌体的三种选择标记-3">Spi 筛选</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="噬菌体的三种选择标记-1"><p>在 λ 基因组中引入 <em>LacZ</em> ’ 序列（其上含有一个 <em>Eco</em>RⅠ克隆位点）。感染  <em>LacZ</em> ’ 突变的大肠杆菌，经 IPTG 的诱导，利用 X-gal 的显色反应作选择标记</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="噬菌体的三种选择标记-2"><p><em>c</em>Ⅰ基因的表达促进 λ 噬菌体进入溶原状态，插入导致载体不能合成阻遏物，λ 载体 DNA 不能进入溶源期，受体菌裂解，形成清晰的噬菌斑。没有外源 DNA 插入的 λ 载体感染受体菌形成混浊噬菌斑。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="噬菌体的三种选择标记-3"><ul><li>野生型 λ 噬菌体不能在携带有 P2 原噬菌体的溶源菌中生长， λ 的这种表型称为Spi<sup>+</sup>（对 P2 的干扰敏感）。</li><li>当 λ 基因组中缺少参与重组的 <em>red</em> 和 <em>gam</em> 基因时， λ 突变体便可以在 P2 溶原菌中生长，其表型称为 Spi<sup>-</sup>。</li><li>基因 <em>red</em> 和 <em>gam</em> 位于非必需区域内，外源 DNA 片段能置换基因 <em>red</em> 和 <em>gam</em> 形成重组体，其重组体能在 <em>recA</em> <sup>+</sup> 的 P2 溶原菌中繁殖，并且显示出 Spi<sup>-</sup> 的表型。</li><li>因此只要选用 <em>recA</em> <sup>+</sup> 的 P2 溶原菌作为宿主菌，就可以对重组体进行筛选。能浸染宿主菌产生噬菌斑的即是重组分子。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="简述-YAC-载体的工作原理、应用、以及其缺点-a-id-Q12-href-T12-↩-a"><a class="header-anchor" href="#简述-YAC-载体的工作原理、应用、以及其缺点-a-id-Q12-href-T12-↩-a"></a>简述 YAC 载体的工作原理、应用、以及其缺点 <a id="Q12" href="#T12">↩</a></h3><blockquote><p>P81</p></blockquote><p><font color="#d9730d">工作原理</font>：对于 <em>Bam</em>HⅠ 切割后形成的微型酵母染色体，当用 <em>Eco</em>RⅠ 或 <em>Sma</em> Ⅰ 切割抑制基因 <em>sup</em> 4 内部的位点后形成染色体的两条臂，与外源大片段 DNA 在该切点相连就形成一个大型人工酵母染色体，转化到酵母菌后可像染色体一样复制，并随细胞分裂分配到子细胞中去，达到克隆大片段 DNA 的目的。外源 DNA 片段的装载导致抑制基因 <em>sup</em> 4 插入失活，从而使重组菌形成红色菌落；而载体自身连接转入到酵母细胞后所形成的菌落为白色。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.13el4mhlggbk.png" alt="YAC载体的工作原理"></p><hr><p><font color="#d9730d">YAC 的主要用途</font>：</p><ol><li>YAC 克隆重叠群是物理图谱的主要框架<ul><li>可容纳大片段（250 ～ 400 kb）的外源 DNA，在构建基因组文库时需要较少的克隆</li><li>在人类、植物、昆虫、鸟类、两栖类等复杂的生物基因组分析和 DNA 测序中发挥着重要作用。相比于早期 DNA 载体，YAC 是容纳大片段外源 DNA 的首选载体，成为人类基因组计划及图位克隆分离基因的重要工具，并促进了发展人类人工染色体（HAC）的研究</li></ul></li><li>基因功能研究中，基因嵌入及转基因技术都采用 YAC 克隆系统。通过 YAC 嵌入的基因不仅片段长，而且嵌入的基因更适于体内表达，并有利于基因保持其固有的空间构象和功能的发挥</li></ol><hr><p><font color="#d9730d">YAC 的缺点</font>：</p><ol><li>插入片段大，稳定性较差，不易操作</li><li>插入的大片段常发生缺失，使文库不完整</li><li>YAC 与酵母天然染色体分子结构相似，分离时难与天然染色体分开</li><li>文库中的嵌合现象严重</li><li>因插入片段大，往往发生序列重排，造成序列错乱</li></ol><h3 id="简述碱裂解法和煮沸法抽提质粒-DNA-的原理。-a-id-Q13-href-T13-↩-a"><a class="header-anchor" href="#简述碱裂解法和煮沸法抽提质粒-DNA-的原理。-a-id-Q13-href-T13-↩-a"></a>简述碱裂解法和煮沸法抽提质粒 DNA 的原理。 <a id="Q13" href="#T13">↩</a></h3><p>染色体 DNA 比质粒 DNA 分子大得多，且染色体 DNA 为线状分子，而质粒 DNA 为共价闭合环状分子；</p><div class="tabs" id="抽提质粒dna"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#抽提质粒dna-1">碱裂解法原理</button></li><li class="tab"><button type="button" data-href="#抽提质粒dna-2">煮沸法原理</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="抽提质粒dna-1"><p>当用碱处理 DNA 溶液时，线状染色体 DNA 容易发生变性，共价闭环的质粒 DNA 再回到中性 pH 时即恢复其天然构象；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="抽提质粒dna-2"><p>当加热处理 DNA 溶液时，线状染色体 DNA 容易发生变性，共价闭环的质粒 DNA 在冷却时即恢复其天然构象；</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>变性染色体 DNA 片段与变性蛋白质和细胞碎片结合形成沉淀，而复性的超螺旋质粒 DNA 分子则以溶解状态存在液相中，从而可通过离心将两者分开。</p><h3 id="简述电泳的基本原理。-a-id-Q14-href-T14-↩-a"><a class="header-anchor" href="#简述电泳的基本原理。-a-id-Q14-href-T14-↩-a"></a>简述电泳的基本原理。 <a id="Q14" href="#T14">↩</a></h3><p><font color="#d9730d">带电粒子可以用电泳技术进行分离、分析和鉴定的基本原理</font>：在一定 pH 条件下，每一种分子都具有特定的电荷（种类和数量）、大小和形状，在一定时间内它们在相同电场中泳动速度不同，各自集中到特定的位置上而形成紧密的泳动带。</p><h3 id="琼脂糖凝胶电泳过程中影响-DNA-迁移率的因素有哪些-a-id-Q15-href-T15-↩-a"><a class="header-anchor" href="#琼脂糖凝胶电泳过程中影响-DNA-迁移率的因素有哪些-a-id-Q15-href-T15-↩-a"></a>琼脂糖凝胶电泳过程中影响 DNA 迁移率的因素有哪些 <a id="Q15" href="#T15">↩</a></h3><p><font color="#d9730d">影响 DNA 迁移率的因素</font>：</p><p>DNA 分子的大小、构象，凝胶浓度，电压，电泳缓冲液的组成等。</p><ul><li>DNA 带负电荷，迁移率与分子量对数成反比，DNA 片段越长，泳动速度越慢</li><li>DNA 分子构象影响迁移率：共价闭环 DNA &gt; 线状 DNA &gt; 开环 DNA</li><li>泳动速度与凝胶浓度成反比</li><li>在低电压时，泳动速度与电场强度成正比</li><li>电泳缓冲液的组成及其离子强度会影响 DNA 的电泳迁移率</li></ul><h3 id="简述-PCR-的基本原理-a-id-Q16-href-T16-↩-a"><a class="header-anchor" href="#简述-PCR-的基本原理-a-id-Q16-href-T16-↩-a"></a>简述 PCR 的基本原理 <a id="Q16" href="#T16">↩</a></h3><ul><li>由一对引物介导，通过温度的调节，使双链 DNA 变性为单链 DNA、单链 DNA 与引物复性（退火）成为引物-DNA 单链复合物、以及在 dNTPs 存在下 DNA 聚合酶使引物延伸而成为双链 DNA（引物的延伸）</li><li>这种热变性-复性-延伸的过程，就是一个 PCR 循环</li><li>一般通过 20 ～ 30 个循环之后，就可获得大量的要扩增的 DNA 片段。</li></ul><h3 id="PCR-反应体系包含哪些成分-a-id-Q17-href-T17-↩-a"><a class="header-anchor" href="#PCR-反应体系包含哪些成分-a-id-Q17-href-T17-↩-a"></a>PCR 反应体系包含哪些成分 <a id="Q17" href="#T17">↩</a></h3><p><font color="#d9730d">PCR 反应体系包含</font>：</p><ul><li>模板 DNA</li><li>Taq 酶（Taq DNA polymerase）</li><li>dNTP</li><li>引物（Primers）（上游、下游）</li><li>缓冲液体系（buffer）</li><li>Mg<sup>2+</sup></li><li>ddH<sub>2</sub>O</li></ul><h3 id="引物设计需遵循的原则有哪些-a-id-Q18-href-T18-↩-a"><a class="header-anchor" href="#引物设计需遵循的原则有哪些-a-id-Q18-href-T18-↩-a"></a>引物设计需遵循的原则有哪些 <a id="Q18" href="#T18">↩</a></h3><ol><li>引物长度以 18 ～ 30 个碱基为宜，过长过短都会降低特异性</li><li>G＋C 的含量一般为 40% ～ 60％，提高引物与模板的结合力</li><li>Tm（解链温度）要合适，正反两引物间相差不大于 5℃</li><li>四种碱基随机分布，避免连续相同碱基排列</li><li>引物自身不应存在互补序列，以防形成发夹结构</li><li>两个引物之间不应有多于 4 个的互补，尤其避免 3’ 端的碱基互补，以免形成引物二聚体</li><li>引物 5’ 末端碱基可不与模板 DNA 紧密匹配，可添加与模板无关的序列（如限制性核酸内切酶），便于 PCR 产物的定向克隆。5’ 端是可修饰的。</li><li>引物 3’ 末端碱基一般应与模板 DNA 严格配对，并且 3’ 末端为 G 或 C 时引发效率较高，但不要 GC 连排。引物的延伸是在 3’ 端开始，3’ 端不能进行任何修饰</li><li>引物的碱基顺序不能与非扩增区有同源性，即引物要有特异性</li></ol><h3 id="分子杂交的概念-a-id-Q19-href-T19-↩-a"><a class="header-anchor" href="#分子杂交的概念-a-id-Q19-href-T19-↩-a"></a>分子杂交的概念 <a id="Q19" href="#T19">↩</a></h3><p><font color="#ea66a6">分子杂交</font>：是一类核酸和蛋白质分析方法，用于检测混合样品中特定核酸分子或蛋白质分子是否存在，以及其分子量的大小。</p><p>根据其检测对象不同，可分为：</p><table><thead><tr><th>分子杂交</th><th>检测对象</th><th>探针</th></tr></thead><tbody><tr><td>Southern 杂交</td><td>DNA</td><td>核酸</td></tr><tr><td>Northern 杂交</td><td>RNA</td><td>核酸</td></tr><tr><td>Western 杂交</td><td>蛋白质</td><td>抗体</td></tr></tbody></table><p>以及由此而简化的斑点杂交、菌落杂交和原位杂交等。</p><h3 id="Southern-杂交的原理-a-id-Q20-href-T20-↩-a"><a class="header-anchor" href="#Southern-杂交的原理-a-id-Q20-href-T20-↩-a"></a>Southern 杂交的原理 <a id="Q20" href="#T20">↩</a></h3><p>通过毛细管作用、电转移、真空转膜等方法，使在凝胶电泳中已分离的 DNA 片段转移并结合到适当的滤膜上，然后通过同已标记的探针进行杂交，以检测被转移 DNA 片段，称为 DNA 印迹杂交技术。</p><h3 id="Northern-印迹与-Southern-印迹有哪些不同-a-id-Q21-href-T21-↩-a"><a class="header-anchor" href="#Northern-印迹与-Southern-印迹有哪些不同-a-id-Q21-href-T21-↩-a"></a>Northern 印迹与 Southern 印迹有哪些不同 <a id="Q21" href="#T21">↩</a></h3><ol><li>转移的对象不同，Northern 印迹是将 RNA 变性及电泳分离后，将其转移到固相支持物上的过程。</li><li>虽然 RNA 电泳前不需像 DNA 那样进行酶切，但也需要变性。不过变性方法是不同的，它不能用碱变性，因为碱变性会导致 RNA 的降解，RNA 变性（解二级结构）一般使用甲醛</li></ol><h3 id="基因芯片的概念及应用-a-id-Q22-href-T22-↩-a"><a class="header-anchor" href="#基因芯片的概念及应用-a-id-Q22-href-T22-↩-a"></a>基因芯片的概念及应用 <a id="Q22" href="#T22">↩</a></h3><p><a id="Noun基因芯片"></a><font color="#ea66a6">基因芯片</font>：是一种高通量的斑点杂交技术，通过将大量的 DNA 分子固定于支持物上，并与标记的样品杂交，然后通过自动化仪器检测杂交信号来判断样品中靶分子的信息，诸如基因组 DNA 突变谱和 mRNA 表达谱的检测等。<a  href="#Back基因芯片">↩</a></p><p><font color="#d9730d">基因芯片的应用</font>：</p><div class="tabs" id="基因芯片的应用"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#基因芯片的应用-1">科研方面的应用</button></li><li class="tab"><button type="button" data-href="#基因芯片的应用-2">临床相关应用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="基因芯片的应用-1"><ul><li>表达谱分析</li><li>SNP 分析（包括最新的 CSVI/CNV 分析，GWAS）</li><li>CGH 分析</li><li>ChIP-chip 分析</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="基因芯片的应用-2"><ul><li>传染性疾病的检测（有无和耐药性检测）</li><li>遗传性疾病的检测</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="最常用的三种外源基因导入植物细胞的方法及原理-a-id-Q23-href-T23-↩-a"><a class="header-anchor" href="#最常用的三种外源基因导入植物细胞的方法及原理-a-id-Q23-href-T23-↩-a"></a>最常用的三种外源基因导入植物细胞的方法及原理 <a id="Q23" href="#T23">↩</a></h3><div class="tabs" id="外源基因导入植物细胞"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#外源基因导入植物细胞-1">原生质体介导法</button></li><li class="tab"><button type="button" data-href="#外源基因导入植物细胞-2">基因枪法</button></li><li class="tab"><button type="button" data-href="#外源基因导入植物细胞-3">根癌农杆菌介导法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="外源基因导入植物细胞-1"><p>以原生质体为受体，借助于特定的化学或物理手段将外源 DNA 直接导入植物细胞的方法。有 PEG 介导的基因转化、脂质体介导的基因转化、电激法介导的基因转化、显微注射法介导的基因转化、激光微束介导的基因转化等。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="外源基因导入植物细胞-2"><p>将外源 DNA 包被在微小的金粒或钨粒表面，然后在高压的作用下将微粒高速射入受体细胞或组织。微粒上的外源 DNA 进入细胞后，整合到植物染色体上并得到表达，从而实现外源基因的转化。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="外源基因导入植物细胞-3"><p>根癌农杆菌感染植物，其中 Ti 质粒中的一部分 DNA 片段进入寄主细胞并插入基因组中。T-DNA 中基因利用植物的酶系统进行转录和翻译</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="农杆菌-Ti-质粒的基因结构及各个结构的功能-a-id-Q24-href-T24-↩-a"><a class="header-anchor" href="#农杆菌-Ti-质粒的基因结构及各个结构的功能-a-id-Q24-href-T24-↩-a"></a>农杆菌 Ti 质粒的基因结构及各个结构的功能 <a id="Q24" href="#T24">↩</a></h3><ul><li><font color="#ea66a6">T-DNA 区</font>：转移到植物基因组的一段 DNA</li><li><font color="#ea66a6">Vir 区（毒性区）</font>：激活 T-DNA 转移，使植物致瘤</li><li><font color="#ea66a6">Ori 区</font>：质粒复制起点</li><li><font color="#ea66a6">Con 区</font>：调控 Ti 质粒在根癌农杆菌间的转移</li></ul><h3 id="简述农杆菌-Ti-质粒上的-T-DNA-导入植物基因组的过程-a-id-Q25-href-T25-↩-a"><a class="header-anchor" href="#简述农杆菌-Ti-质粒上的-T-DNA-导入植物基因组的过程-a-id-Q25-href-T25-↩-a"></a>简述农杆菌 Ti 质粒上的 T-DNA 导入植物基因组的过程 <a id="Q25" href="#T25">↩</a></h3><blockquote><p>P269</p></blockquote><p>农杆菌 Ti 质粒上的 T-DNA 导入植物基因组整个过程大致可分为<font color="#d9730d">以下 6 个步骤</font>：</p><ol><li>农杆菌对受体的识别</li><li>农杆菌附着到植物受体细胞</li><li>诱导启动毒性区基因表达</li><li>类似接合孔复合体的合成和装配</li><li>T-DNA 的加工和转运</li><li>T-DNA 的整合</li></ol><h3 id="报告基因的概念-a-id-Q26-href-T26-↩-a"><a class="header-anchor" href="#报告基因的概念-a-id-Q26-href-T26-↩-a"></a>报告基因的概念 <a id="Q26" href="#T26">↩</a></h3><p><font color="#ea66a6">报告基因</font>是指一类在细胞、组织、器官或个体处于特定情况下会表达并使得他们产生易于检测、且实验材料原本不会产生的性状的基因。</p><p>作为报告基因，在遗传选择和筛选检测方面须具有以下条件：</p><ol><li>已被克隆和全序列已测定；</li><li>表达产物在受体细胞中本不存在，即无背景，在被转染的细胞中无相似的内源性表达产物，且不损坏受体细胞。</li><li>其表达产物能进行定量测定</li></ol><h3 id="转植酸酶玉米，为什么要转植酸酶基因？植酸酶基因来自哪里？该转基因玉米的操作流程是怎么样的？-a-id-Q27-href-T27-↩-a"><a class="header-anchor" href="#转植酸酶玉米，为什么要转植酸酶基因？植酸酶基因来自哪里？该转基因玉米的操作流程是怎么样的？-a-id-Q27-href-T27-↩-a"></a>转植酸酶玉米，为什么要转植酸酶基因？植酸酶基因来自哪里？该转基因玉米的操作流程是怎么样的？ <a id="Q27" href="#T27">↩</a></h3><p>植酸酶是催化植酸及其盐类水解为肌醇与磷酸（盐）的一类酶的总称，具有特殊的空间结构，能够依次分离植酸分子中的磷，将植酸（盐）降解为肌醇和无机磷，同时释放出植酸（盐）结合的其他营养物质。</p><p>猪和禽类等单胃动物因缺乏分解植酸的酶而难以利用植酸，造成有效磷利用率低和环境污染等问题，因此通过转基因技术提高玉米中植酸酶含量，改善玉米饲料的品质，对节约成本、提高饲料利用率及保护环境等有重要的意义。</p><p>植酸酶广泛存在于自然界中，植物、部分动物组织和微生物都存在着植酸酶，主要来源有黑曲霉。</p><p>转基因玉米的操作流程：</p><ol><li>获得植酸酶基因，克隆到载体上扩增</li><li>构建植物基因转化受体系统</li><li>目的基因导入受体细胞，例如通过基因枪法、花粉管通道法将外源植酸酶基因导入受体</li><li>培养转化细胞</li><li>筛选、培植、鉴定。进行转基因植株检测，有 PCR、RT-PCR、Western 植酸酶活性等检测</li></ol><h3 id="叙述-Tet-on-型四环素诱导系统的原理。-a-id-Q28-href-T28-↩-a"><a class="header-anchor" href="#叙述-Tet-on-型四环素诱导系统的原理。-a-id-Q28-href-T28-↩-a"></a>叙述 Tet-on 型四环素诱导系统的原理。 <a id="Q28" href="#T28">↩</a></h3><p>Tet（四环素）诱导调控表达系统的基本原理是由诱导药物如 Tet 改变调控蛋白质的构象，从而控制目标蛋白质的表达最初的 Tet 诱导调控基因表达系统是以大肠杆菌 Tn10 转座子上 Tet 抗性操纵子为基础而建立的。Tet 阻遏蛋白（Tet repressor protein, TetR）与 Tet 操纵基因（Tet operator, TetO）DNA 序列有特异的亲和能力，当细胞内无 Tet 存在时，TetR 会与 TetO 结合，从而阻断下游的抗性基因表达。当有 Tet 存在时，药物使 TetR 的构象发生改变，导致 TetR 与 TetO 分离，从而引起抗性基因的抑制解除，抗性蛋白表达使细菌产生耐药性。利用 TetR 和 TetO 特异结合的特性，研究人员发展了多种类型的 Tet 调控系统，但根据其表达特点可以归为两大类：抑制型系统 Tet-off 和激活性系统 Tet-on。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Tet%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.svg" alt="Tet系统的基本结构示意图"></p><p>Tet 系统的基本结构示意图。Tet 系统由调控蛋白（tTA, rtTA, tTS, rtTS）的表达框和目的基因表达框组成。调控蛋白由一个强启动子驱动；而在目的基因的表达框中，启动子位于 Tet 应答元件（Tet-responsive element, TRE）的下游，调控蛋白可以通过 TRE 对下游启动子进行调控。</p><p>（一）Tet-off 系统</p><p>Gossen 等最早建立了 Tet-off 基因调控表达系统，该系统由调节表达载体和反应表达载体组成。调节表达载体包含一个由人巨细胞病毒早期启动子（P<sub>hCMV</sub>）启动的 Tet 转录活化因子（tetracycline transcriptional activator, tTA），tTA 由 TetR 与单纯疱疹病毒（HSV）VP16 蛋白质 C 端的一段转录激活区融合而成。反应表达载体由 Tet 应答元件（Tet-responsive element, TRE）、最小 CMV 启动子（minimal CMV promoter, P<sub>minCMV</sub>）及目的基因组成。目的基因位于 TRE 和 P<sub>minCMV</sub> 的下游；TRE 为 7 次重复的 TetO 序列。P<sub>minCMV</sub> 缺失增强子，因此在 tTA 未结合到 TRE 时，目的基因不表达；相反，当 tTA 结合到 TRE 时，VP16 会使 P<sub>minCMV</sub> 活化从而使基因表达。当细胞内无 Tet 或其衍生物强力霉素（doxcycline, Dox）的存在时，tTA 可与 TRE 结合，打开基因表达；而当Tet 或 Dox 存在时，它们可使 tTA 中的 TetR 改变构象，则 tTA 将从 TRE 上脱落下来，使 TRE 中的 P<sub>minCMV</sub> 处于非激活状态，从而使基因表达处于关闭状态。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Tet-off%E7%A4%BA%E6%84%8F%E5%9B%BE.svg" alt="Tet-off示意图"></p><p>Tet-off 示意图。tTA 是由 TetR 和病毒转录激活域 VP16 融合而成的蛋白。当不存在 Dox 时，tTA 和 TRE 结合，启动 P<sub>minCMV</sub> 的下游基因表达；当存在 Dox 时，Dox 使 tTA 的构象发生改变， tTA 会从 TRE 上脱落，从而导致 TRE-P<sub>minCMV</sub>  下游基因表达关闭。</p><p>（二）Tet-on 调控系统</p><p>Tet-on 调控系统与 Tet-off 调控系统的区别在于其调节蛋白质为反义 Tet 转录活化因子（reverse tetracycline transcriptional activator, rtTA）。rtTA 是由反义 TetR（reverse TetR, rTetR）与 VP16 的转录活化区域融合而成。rTetR 由 TetR 中的 4 个氨基酸发生突变而衍生而来的（E71 → K71, D95 → N95, L101 → S101, G102 → D102）。rTetR 的表型与 TetR 相反，在无 Dox 时其不能结合 TRE，导致基因表达关闭；而在有 Dox 存在时其会结合在 TRE 上，导致基因表达开放</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Tet-on%E7%A4%BA%E6%84%8F%E5%9B%BE.svg" alt="Tet-on示意图"></p><p>Tet-on 示意图。rtTA 是由 rTetR 和 VP16 融合而成的蛋白，它的表型与 tTA 相反。当 Dox 不存在时，rtTA 不能结合 TRE， TRE-P<sub>minCMV</sub>  下游基因表达关闭；当存在 Dox 时，rtTA 构象改变，rtTA 结合 TRE，则 TRE-P<sub>minCMV</sub>  下游基因表达开启。</p><blockquote><p>陈皓,夏海滨.四环素诱导调控表达系统的研究与应用[J].生命的化学,2011,31(02):285-291.</p></blockquote><h3 id="化学降解法测序原理-a-id-Q29-href-T29-↩-a"><a class="header-anchor" href="#化学降解法测序原理-a-id-Q29-href-T29-↩-a"></a>化学降解法测序原理 <a id="Q29" href="#T29">↩</a></h3><p>将一个 DNA 片段的 5’ 端磷酸基作放射性标记，再分别采用不同的化学方法修饰和裂解特定碱基，打断磷酸二脂键，从而产生一系列长度不一而 5’ 端被标记的 DNA 片段，这些以特定碱基结尾的片段群通过凝胶电泳分离，再经放射线自显影，确定各片段末端碱基，从而得出目的 DNA 的碱基序列。</p><h3 id="Sanger-双脱氧链终止法测序原理-a-id-Q30-href-T30-↩-a"><a class="header-anchor" href="#Sanger-双脱氧链终止法测序原理-a-id-Q30-href-T30-↩-a"></a>Sanger 双脱氧链终止法测序原理 <a id="Q30" href="#T30">↩</a></h3><blockquote><p>P167</p></blockquote><p>双脱氧链终止测序方法巧妙地使用了双脱氧核苷酸（2’,3’-ddNTP，N 指 A，T，G 或 C）在同一扩增（-OH），它与正常情况下合成 DNA 的脱氧核苷酸（2’-dNTP）的主要不同点在于 3’ 位置的羟基缺失。当它与正常核苷酸混合于同一个扩增反应体系中，在 DNA 聚合酶的作用下，虽然它也能够像 2’-脱氧核苷酸一样参与 DNA 合成，以其 5’ 位置的磷酸基团与上位脱氧核苷酸的 3’ 位置的羟基结合；但是，由于它自身 3’ 位置的羟基缺失，至使下位核苷酸的 5’ 磷酸基无法与之结合，使得正在合成的 DNA 链的合成反应终止于此双脱氧核苷酸。</p><p>基于双脱氧核苷酸的这种特性，Sanger 于 1977 年建立了以双脱氧终止反应为基础的 DNA 序列测定的方法。该方法以待测单链或双链 DNA 为模板，使用能与 DNA 模板结合的一段寡核苷酸为引物，在 DNA 聚合酶的催化作用下合成新的 DNA 链。正常情况下的 DNA 聚合酶催化反应在其反应体系中包含 4 种脱氧核苷酸（dATP、dCTP、dGTP 和 dTTP）,合成与模板 DNA 互补的新链。当向这个反应体系中加入一种双脱氧核苷酸（ddATP、ddCTP、ddGTP 和 ddTTP）后，在 DNA 合成过程中，ddNTP 将与相应的 dNTP 竞争掺入到新合成的 DNA 互补链中。</p><ul><li>如果 dNTP 掺入其中，DNA 互补链则将继续延伸下去；</li><li>而如果 ddNTP 掺入其中，DNA互补链的合成则到此终止。</li></ul><p>按照这一反应方式，可得到 4 种分别以 ddATP、ddCTP、ddGTP 和 ddTTP 结尾的不同长度 DNA 片段群。</p><p>由于反应时新生 DNA 片段的长度取决于模板 DNA 中与该双脱氧核苷酸相对应的互补碱基的位置，即双脱氧核苷酸掺入的位置，而双脱氧核苷酸的掺入是随机的，故各个新生 DNA 片段的长度互不相同。不同长度 DNA 片段在凝胶中的移动速率不同，而聚丙烯酰胺凝胶电泳分辨率极高，能分辨出小至 1 个碱基长度差的 DNA 片段，从而将混合产物中不同长度 DNA 片段分离开，再通过放射自显影曝光，根据片段尾部的双脱氧核苷酸读出该 DNA 的碱基排列顺序。</p><h3 id="第二代和第三代测序技术分别有哪些技术？-a-id-Q31-href-T31-↩-a"><a class="header-anchor" href="#第二代和第三代测序技术分别有哪些技术？-a-id-Q31-href-T31-↩-a"></a>第二代和第三代测序技术分别有哪些技术？ <a id="Q31" href="#T31">↩</a></h3><div class="tabs" id="第二代和第三代测序技术"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#第二代和第三代测序技术-1">第二代测序技术</button></li><li class="tab"><button type="button" data-href="#第二代和第三代测序技术-2">第三代测序技术</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="第二代和第三代测序技术-1"><ol><li>罗氏 454 公司的 GS FLX 测序平台</li><li>Illumina 公司的 Solexa Genome Analyzer 测序平台</li><li>ABI 公司的 SOLiD 测序平台</li><li>Life Techologies 公司的离子肼测序</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="第二代和第三代测序技术-2"><ol><li>Helicos 公司的 Heliscope 单分子测序仪</li><li>Pacific Biosciences 公司的 SMRT 技术</li><li>Oxford Nanopore Technologies 公司正在研究的纳米孔单分子技术</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="目前测序技术有哪些方面的应用？-a-id-Q32-href-T32-↩-a"><a class="header-anchor" href="#目前测序技术有哪些方面的应用？-a-id-Q32-href-T32-↩-a"></a>目前测序技术有哪些方面的应用？ <a id="Q32" href="#T32">↩</a></h3><ol><li>用于科研，建立基因序列数据库</li><li>用于临床，如肿瘤基因的检测、生育健康、病原微生物的检测、测序分析等</li><li>用于生物资源的保存</li><li>用于亲缘分析</li></ol><blockquote><p>仅作参考</p></blockquote><h3 id="基因组文库和-cDNA-文库的定义、各自构建的流程、以及两者的特点-a-id-Q33-href-T33-↩-a"><a class="header-anchor" href="#基因组文库和-cDNA-文库的定义、各自构建的流程、以及两者的特点-a-id-Q33-href-T33-↩-a"></a>基因组文库和 cDNA 文库的定义、各自构建的流程、以及两者的特点 <a id="Q33" href="#T33">↩</a></h3><blockquote><p><font color="#ea66a6">基因文库</font>（Gene library）：由某一生物的全部或部分基因的不同 DNA 片段的克隆所构成的群体, 称之为基因文库。一个完全的基因文库，应该能够保证从中筛选到目的基因。</p></blockquote><p><a id="Noun基因组DNA文库"></a><font color="#ea66a6">基因组 DNA 文库</font>：指将某生物体的全部基因组 DNA 用限制性内切酶或机械力量切割成一定长度范围的 DNA 片段，与合适的载体体外重组并转化相应的宿主细胞获得的所有阳性菌落。 包含基因的全部信息，如编码区，非编码区，内含子和外显子、启动子及调控序列。<a  href="#Back基因组DNA文库">↩</a></p><p><a id="NouncDNA文库"></a> <font color="#ea66a6">cDNA 文库</font>：是指将某种生物体基因组转录的全部 mRNA 经反转录产生的 cDNA 片段分别与克隆载体重组，储存于某种受体菌中，该群体就称该生物基因组的 cDNA 文库。<a  href="#BackcDNA文库">↩</a></p><p>基因组 DNA 文库的构建程序：</p><ol><li>载体的制备；</li><li>高纯度大分子量基因组 DNA（HMW DNA）的提取；</li><li>HMW DNA 的部分酶切与脉冲电泳分级分离（PFGE size selection）；</li><li>载体与外源片段的连接与转化或侵染宿主细胞；</li><li>重组克隆的挑取</li><li>文库的保存。</li></ol><p>cDNA 文库的构建主要分为四步：</p><ol><li>细胞总 RNA 的提取和 mRNA 分离</li><li>第一链 cDNA 合成；</li><li>第二链 cDNA 合成；</li><li>双链 cDNA 克隆进质粒或噬菌体载体并导入宿主中繁殖</li></ol><div class="tabs" id="基因组文库优点"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#基因组文库优点-1">基因组 DNA 文库的优点（相对于 cDNA 文库）</button></li><li class="tab"><button type="button" data-href="#基因组文库优点-2">cDNA 文库的主要优点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="基因组文库优点-1"><ol><li>cDNA 克隆只能反映 mRNA 的分子结构，没有包括基因组的间隔序列，并且受细胞来源或发育时期的影响。</li><li>cDNA 文库中，不同克隆的分布状态总是反映 mRNA 的分布状态，即：<ul><li>高丰度 mRNA 的 cDNA 克隆，所占比例较高，分离基因容易；</li><li>低丰度 mRNA 的 cDNA 克隆，所占比例较低，分离基因困难；</li></ul></li><li>从 cDNA 克隆中，不能克隆到基因组 DNA 中的非转录区段序列，不能用于研究基因编码区外侧调控序列的结构与功能。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="基因组文库优点-2"><ul><li>cDNA 文库以 mRNA 为材料，特别适用于某些 RNA 病毒等的基因组结构研究及有关基因的克隆分离。</li><li>cDNA 文库的筛选比较简单易行。</li><li>每一个 cDNA 文库都含有 mRNA 序列，这样在目的基因的选择中出现假阳性的概率就会比较低，因此阳性杂交信号一般都是有意义的，由此选择出来的阳性克隆将会含有目的基因。</li><li>cDNA 克隆还可用于真核细胞 mRNA 的结构和功能研究。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="酵母双杂交的原理以及应用-a-id-Q34-href-T34-↩-a"><a class="header-anchor" href="#酵母双杂交的原理以及应用-a-id-Q34-href-T34-↩-a"></a>酵母双杂交的原理以及应用 <a id="Q34" href="#T34">↩</a></h3><blockquote><p>《基因工程》P226</p></blockquote><p>双杂交系统的基本原理来自对酵母转录激活因子（transcriptional activator）GAL4 的认识。许多真核生物转录激活因子有两个功能域：</p><ul><li>一是 DNA 结合结构域（DNA binding domain，BD），可与 DNA 序列的特定位点即上游激活序列（upstream activating sequence，UAS）结合；</li><li>二是转录激活结构域（activation domain，AD），协助 RNA 聚合酶Ⅱ复合体激活 UAS 下游基因的转录。</li></ul><p>这两个结构域的功能是独立的。正常情况下它们都是同一种蛋白质的组成部分，缺一不可，但如果利用 DNA 重组技术把它们彼此分开并放置在同一宿主中表达，也不能激活相关基因的转录，其原因是由于它们彼此之间在空间上存在一定距离，不会直接发生相互作用。如果能将它们空间上的距离拉近，就可以形成有功能的转录激活因子，从而启动下游基因的转录。</p><p>酵母双杂交理论就是建立在此原理上，利用融合蛋白的策略，将蛋白 X 与 BD 融合，蛋白 Y 与 AD 融合，将它们导入酵母细胞中共表达，如果 X 与 Y 相互作用，则会导致 BD 和 AD 在空间上接近，形成一个有功能的转录激活因子，激活下游报告基因的表达。</p><ul><li>X 为已知蛋白，把要筛选的“探针 X”与 BD 构建融合蛋白 BD-X（通常称为诱饵，bait），并以含有 BD-X 融合蛋白基因和报告基因的细胞为构建文库的受体菌；</li><li>而将所要筛选的对象 Y 与 AD 构建成融合蛋白 AD-Y 的 cDNA 文库（即将目的 cDNA 与 AD 基因构建融合基因文库)，通常称 AD-Y 为猎物（prey），当 Y 基因产物能与 X 基因产物发生作用时，就可启动报告基因的表达。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E9%85%B5%E6%AF%8D%E5%8F%8C%E6%9D%82%E4%BA%A4%E7%B3%BB%E7%BB%9F.172tnzbgq85c.svg" alt="酵母双杂交系统"></p><p>A. GAL4 的 BD 和蛋白质 X 形成的融合蛋白同 GAL1 的 UAS 序列结合，但由于没有 AD 的结合所以不能激活报告基因的转录；<br>B. GAL4 的 AD 与蛋白质 Y 形成的融合蛋白没有 BD 结合时，也不能激活报告基因的转录；<br>C. BD-X 和 AD-Y 的相互作用重建了 GAL4 的功能，使 AD 激活启动子从而引发报告基因的转录。</p><hr><blockquote><p>PPT</p></blockquote><p>酵母双杂交系统筛选：用于分离与某一已知蛋白发生相互作用的蛋白质基因</p><p>GAL4 蛋白：酵母半乳糖苷酶基因 gal 的转录激活因子，该蛋白结合在 gal 基因上游激活区 （UAS） 可启动 gal 基因的转录<br>GAL4 蛋白可分为两个区域：</p><ul><li>DNA-BD：DNA 结合域，N-末端 1 ～ 147 aa（氨基酸）</li><li>AD：转录激活域，C-末端 768 ～ 881 aa</li></ul><p>这两个结合域将它们分开时仍分别具有功能，但不能激活转录，只有当被分开的两者通过适当的途径在空间上较为接近时，才能重新呈现完整的转录因子活性，并可激活上游激活序列（upstream activating sequence, UAS）的下游启动子，使启动子下游基因得到转录。</p><p>酵母双杂交系统筛选原理：</p><ul><li>将编码 DNA-BD 的基因与已知蛋白质 Bait protein 的基因构建在同一个表达载体上，在酵母中表达两者的融合蛋白 BD-Bait protein。</li><li>将编码 AD 的基因和 cDNA 文库的基因构建在 AD-LIBRARY 表达载体上。</li><li>同时将上述两种载体转化改造后的酵母，如两种载体所表达的融合蛋白不相互作用时，这种改造后的酵母细胞的基因组中既不能产生 GAL4，又不能合成 LEU、TRP、HIS、LacZ，因此，酵母在缺乏这些营养的培养基上无法正常生长。当上述两种载体所表达的融合蛋白能够相互作用时，功能重建的反式作用因子能够激活酵母基因组中的报告基因 HIS、LacZ 等，从而通过功能互补和显色反应筛选到阳性菌落。</li></ul><hr><blockquote><p>《分子生物学》P221</p></blockquote><p>酵母双杂交系统巧妙地利用真核生物转录调控因子的组件式结构特征，因为这些蛋白质往往由两个或两个以上相互独立的结构域构成其中 DNA 结合结构域（binding domain,BD）和转录激活结构域（AD）是转录激活因子发挥功能所必需的。</p><p>单独的 BD 能与特定基因的启动区结合，但不能激活基因的转录，而由不同转录调控因子的 BD 和 AD 所形成的杂合蛋白却能行使激活转录的功能。</p><p>实验中，首先运用基因重组技术把编码已知蛋白的 DNA 序列连接到带有酵母转录调控因子（常为 GAL1、GAL4 或 GCN1）BD 结构域基因片段的表达载体上。导入酵母细胞中使之表达带有 DNA 结合结构域的杂合蛋白，与报告基因上游的启动调控区相结合，准备作为“诱饵”捕获与已知蛋白相互作用的基因产物。此时，若将已知的编码转录激活结构域 AD 的基因片段分别与待筛选的 cDNA 文库中不同插入片段相连接，获得“猎物”载体，转化含有“诱饵”的酵母细胞，只要酵母细胞中表达的“诱饵”蛋白与“猎物”载体中表达的某个蛋白质发生相互作用，不同转录调控因子的 AD 和 BD 结构域就会被牵引靠拢，激活报告基因表达。分离有报告基因活性的酵母细胞，得到所需要的“猎物”载体，就能得到与已知蛋白质相互作用的新基因。</p><hr><p>酵母双杂交技术的应用:</p><ul><li>发现新蛋白质及蛋白质的新功能</li><li>建立基因组蛋白质连锁图谱</li><li>研究人类 DNA 文库，筛选药物作用位点</li><li>在细胞体内研究抗原和抗体的相互作用</li></ul><p>参考文献：</p><ul><li>王婷,葛怀娜,郭宏.酵母双杂交技术应用进展[J].生物技术进展,2015,5(05):392-396.</li><li>郑立双,李向楠,孙城涛,刘红羽,刘勋,贺明,吕文发.酵母双杂交技术及应用的研究进展[J].中国畜牧兽医,2013,40(09):105-108.</li></ul><h3 id="动物基因工程的概念-a-id-Q35-href-T35-↩-a"><a class="header-anchor" href="#动物基因工程的概念-a-id-Q35-href-T35-↩-a"></a>动物基因工程的概念 <a id="Q35" href="#T35">↩</a></h3><p><a id="Noun动物基因工程"></a><font color="#ea66a6">动物基因工程</font>是利用 DNA 重组技术对动物所进行的工程操作。从遗传学角度分为遗传性和非遗传性两种形式。</p><ul><li>外源基因能够通过配子进行垂直传递并稳定遗传的称为遗传性动物基因工程。</li><li>转基因仅在当代表现，不能够遗传给子代的被称为非遗传性动物基因工程。<a  href="#Back动物基因工程">↩</a></li></ul><h3 id="转基因动物的制备方法主要有哪些？-a-id-Q36-href-T36-↩-a"><a class="header-anchor" href="#转基因动物的制备方法主要有哪些？-a-id-Q36-href-T36-↩-a"></a>转基因动物的制备方法主要有哪些？ <a id="Q36" href="#T36">↩</a></h3><p>目前，研究制备转基因动物的主要方法有:</p><ol><li>显微注射法</li><li>胚胎干细胞法</li><li>反转录病毒感染法</li><li>精子载体导入法</li><li>体细胞核移植法</li></ol><h3 id="简述-CRISPR-Cas9-基因定向打靶技术的原理-a-id-Q37-href-T37-↩-a"><a class="header-anchor" href="#简述-CRISPR-Cas9-基因定向打靶技术的原理-a-id-Q37-href-T37-↩-a"></a>简述 CRISPR/Cas9 基因定向打靶技术的原理 <a id="Q37" href="#T37">↩</a></h3><blockquote><p>PPT</p></blockquote><p>CRISPR/Cas 系统概述</p><p>CRISPR/Cas 系统是很多细菌和大部分古细菌的天然免疫系统，通过对入侵的病毒和核酸进行特异性的识别，利用 Cas 蛋白进行切割，从而达到对自身的免疫。</p><p>CRISPR 结构：CRISPR 是一种特殊的 DNA 重复序列家族，广泛分布于细菌和古细菌基因组中。CRISPR 位点通常由短的高度保守的重复序列（repeats）组成，重复序列的长度通常为 21 ～ 48 bp，重复序列之间被 26 ～ 72 bp 间隔序列（spacer）隔开。CIRSPR 通过这些间隔序列（spacer）与靶基因进行识别。</p><p>Cas 家族：Cas（CRISPR associated）存在于 CRISPR 位点附近，是一种双链 DNA 核酸酶，能在 guide RNA 引导下对靶位点进行切割。它与 fokⅠ 酶功能类似，但是它并不需要形成二聚体才能发挥作用。</p><p>CRISPR/Cas9 系统作用机制</p><ul><li>CRISPR 基因座的表达（包括转录和转录后的成熟加工）</li><li>当该噬菌体再次入侵细菌时，CRISPR 簇首先转录为长的 crRNA 前体，然后逐步加工成小的成熟的 crRNA。</li><li>CRISPR/Cas 系统活性的发挥或外源遗传物质的干扰</li><li>crRNA 结合相关的 Cas 蛋白后，形成 crRNA-Cas 蛋白复合体，通过碱基互补配对精确地与目标 DNA 相结合，随后 Cas 蛋白对目标 DNA 进行断裂和降解。</li><li>Cas9 是一种核酸内切酶，其具有：RuvC 和 HNH 两个内切酶活性中心</li><li>Jinek 等发现 Cas9 在细菌和试管里对双链 DNA 具有强烈的切割能力，但是这种切割能力需要的 crRNA 和 tracrRNA 介导。</li><li>Jinek 等创造性的把 crRNA 和部分 tracrRNA 融合成一条嵌合的 RNA 链,使其同时具有 crRNA 和 tracrRNA 的特性，随后的切割实验表明，这条嵌合的 RNA 同样可以引导 Cas9 切割目标 DNA。现在普遍使用的都是 crRNA 和全长 tracrRNA 融合体，简称 sgRNA (single guide RNA)</li></ul><hr><blockquote><p>文献资料</p></blockquote><p>该系统原来是细菌及古菌适应性免疫系统的一部分，其功能是抵御病毒及外源 DNA 的入侵。 CRISPR/Cas 系统由 CRISPR 序列和 Cas 基因家族组成。其中，CRISPR 序列由一系列间隔序列及高度保守的正向重复序列相间排列形成，Cas 基因簇位于 CRISPR 序列的 5′ 端，编码的蛋白质可特异性切割外源 DNA。</p><p>CRISPR 是一种特殊的 DNA 重复序列家族，广泛分布于细菌和古细菌基因组中。CRISPR 位点通常由短的高度保守的重复序列（repeats）组成，重复序列的长度通常为 21 ～ 48 bp，重复序列之间被 26 ～ 72 bp 间隔序列（spacer）隔开。CRISPR 通过这些间隔序列与靶基因进行识别。</p><p>Cas（CRISPR associated）存在于 CRISPR 位点附近，是一种双链 DNA 核酸酶，能在 guide RNA 引导下对靶位点进行切割。它与 fok I 酶功能类似，但是它并不需要形成二聚体才能发挥作用。</p><p>CRISPR/Cas 系统分为 I 型、Ⅱ 型和 Ⅲ 型，以 Ⅱ 型的应用最为广泛。有外源 DNA 入侵时，CRISPR 序列转录并被加工形成约 40 nt（核苷酸数） 的成熟 crRNA（CRISPR RNAs）。成熟的 crRNA 与 tracrRNA（trans-activating CRISPR RNA）通过碱基互补配对形成双链 RNA，激活并引导 Cas9 切割外源 DNA 中的原型间隔序列（protospacer）。Cas9 蛋白具有两个核酸酶结构域：RuvC-like 结构域和 HNH 结构域，其中，HNH 结构域切割原型间隔序列中与 crRNA 互补配对的 DNA 链，RuvC-like 结构域切割另一条非互补链。研究表明，Cas9 对靶序列的编辑依赖于原型间隔序列下游的短序列 PAM （protospacer-adjacent motifs），PAM 通常为 5′-NGC-3′，极少情况下为 5′-NAG-3′，Cas9 切割的位点位于 PAM 上游第三个碱基。</p><p>根据 CRISPR/Cas9 系统的特点，研究者将 crRNA::tracrRNA 双分子结构融合成具有发夹结构的 sgRNA（single guide RNA），sgRNA 分子 5′ 端 20 nt 的引导序列可完全与 DNA 靶序列互补，从而引导 Cas9 对靶 DNA 进行编辑。只要改变 sgRNA 中的 20 nt 引导序列，基因组上任意 5′-(N)<sub>20</sub>-NGG-3′ 序列都可以被 CRISPR/Cas9 系统编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/CRISPRCas9.49zxlie890s0.png" alt="CRISPRCas9"></p><p>a ～ c 是 CRISPR/Cas9 系统的天然机制，d 是在基因编辑中 crRNA::tracrRNA 双分子结构融合成具有发夹结构的 sgRNA。</p><p>引用自 Antara Barman <a href="https://sci-hub.se/10.1007/s00294-019-01040-3"> doi：10.1007/s00294-019-01040-3 </a></p><blockquote><p>Lander E S. The heroes of CRISPR[J]. Cell, 2016, 164(1-2): 18-28.</p></blockquote><h3 id="详述将基因打靶技术联合应用胚胎干细胞法制备转基因动物的流程-a-id-Q38-href-T38-↩-a"><a class="header-anchor" href="#详述将基因打靶技术联合应用胚胎干细胞法制备转基因动物的流程-a-id-Q38-href-T38-↩-a"></a>详述将基因打靶技术联合应用胚胎干细胞法制备转基因动物的流程 <a id="Q38" href="#T38">↩</a></h3><ol><li>制备基因打靶载体，把目的基因和调控序列等与内源靶序列都重组到带标记基因的载体上</li><li>把打靶载体导入胚胎干细胞内，利用点击、脂质体包埋等方法对胚胎干细胞进行转染</li><li>对同源重组子的筛选，用选择性培养基筛选打靶击中的重组阳性细胞</li><li>收集囊胚期胚胎，在显微操作系统下向囊胚腔内注入转基因胚胎干细胞，经过短暂培养后，将质量好的囊胚移植到受体子宫内进行妊娠观察</li><li>筛选所得的转基因动物品系</li></ol><h3 id="详述转基因动物技术的应用-a-id-Q39-href-T39-↩-a"><a class="header-anchor" href="#详述转基因动物技术的应用-a-id-Q39-href-T39-↩-a"></a>详述转基因动物技术的应用 <a id="Q39" href="#T39">↩</a></h3><div class="tabs" id="转基因动物技术的应用"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#转基因动物技术的应用-1">在生命科学基础研究中的应用</button></li><li class="tab"><button type="button" data-href="#转基因动物技术的应用-2">在农牧业生产上的应用</button></li><li class="tab"><button type="button" data-href="#转基因动物技术的应用-3">在医药研究领域中的应用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="转基因动物技术的应用-1"><ul><li>研究基因的结构与功能</li><li>研究基因的组织特异性表达</li><li>研究发育相关基因的表达与调控</li><li>克隆在发育中起重要作用的基因</li><li>基因多级调节系统的研究</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="转基因动物技术的应用-2"><ul><li>优良动物品种育种</li><li>快速生长与肉质改良</li><li>增强抗病性</li><li>增强抗逆性</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="转基因动物技术的应用-3"><ul><li>研究病毒性疾病</li><li>研究建立人类疾病的转基因动物模型</li><li>转基因动物与基因治疗</li><li>生产天然活性药物蛋白</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="酵母基因工程的优势有哪些方面？-a-id-Q40-href-T40-↩-a"><a class="header-anchor" href="#酵母基因工程的优势有哪些方面？-a-id-Q40-href-T40-↩-a"></a>酵母基因工程的优势有哪些方面？ <a id="Q40" href="#T40">↩</a></h3><p>酵母菌表达外源基因的优势:</p><ol><li>酵母菌是最简单的真核模式生物</li><li>完成全基因组测序，基因表达调控机理比较清楚，遗传操作简便</li><li>具有原核细菌无法比拟的真核蛋白翻译后加工系统</li><li>大规模发酵历史悠久、技术成熟、工艺简单、成本低廉</li><li>能将外源基因表达产物分泌至培养基中</li><li>采用高表达的启动子，如 MOX、AOX、LAC4 等</li><li>不含有特异性的病毒、不产内毒素，美国 FDA 认定为安全的基因工程受体系统</li></ol><h3 id="详述酵母基因工程的应用进展-a-id-Q41-href-T41-↩-a"><a class="header-anchor" href="#详述酵母基因工程的应用进展-a-id-Q41-href-T41-↩-a"></a>详述酵母基因工程的应用进展 <a id="Q41" href="#T41">↩</a></h3><p>利用酵母基因工程成功地生产了人类、动物、植物或微生物来源的异源蛋白，在医药生物技术上发挥了重要作用。例如：</p><ul><li>生物反应器。人血清白蛋白、溶菌酶、乙肝疫苗等。</li><li>人类蛋白质间的互作。如利用酵母表达系统开展分泌蛋白和受体基因的快速筛选。</li><li>筛选新药。利用酵母展示技术筛选细胞凋亡的抑制剂、HIV-1 整合抑制新药等。</li><li>利用酵母表达膜蛋白。</li></ul><p>近年来，酵母基因工程菌已经实现了工业化生产，酵母产生的蛋白已经用在食品、饲料、洗涤、纺织和造纸等行业。尤其在酶制剂领域，国内有近 10 家企业的酶制剂年产量达到万吨，年总产值约 10 亿，并且以每年 10% 左右的速度增长。例如：</p><ul><li>利用重组酿酒酵母提高酿酒工艺</li><li>利用重组酿酒酵母环境能源危机。通过转基因技术使酿酒酵母能利用纤维素和半纤维素等可再生物质来生产廉价的酒精，缓解能源紧张。</li><li>利用毕赤酵母生产饲料用植酸酶。</li><li>利用酿酒酵母生产谷胱甘肽</li></ul><h3 id="什么是基因治疗-a-id-Q42-href-T42-↩-a"><a class="header-anchor" href="#什么是基因治疗-a-id-Q42-href-T42-↩-a"></a>什么是基因治疗 <a id="Q42" href="#T42">↩</a></h3><p><a id="Noun基因治疗"></a><font color="#ea66a6">基因治疗</font>的概念:</p><ul><li>经典概念（狭义概念）：针对患者的基因缺陷，导入特定基因补偿其缺陷或赋予机体新的功能以抗衡缺陷。</li><li>广义概念：将目的基因放进特定载体中导入靶细胞或组织，通过替换或补偿引起疾病的基因，调节异常表达的基因来治疗或缓解疾病，均称之为基因治疗。<a  href="#Back基因治疗">↩</a></li></ul><h3 id="目前基因药物的分类及作用原理-a-id-Q43-href-T43-↩-a"><a class="header-anchor" href="#目前基因药物的分类及作用原理-a-id-Q43-href-T43-↩-a"></a>目前基因药物的分类及作用原理 <a id="Q43" href="#T43">↩</a></h3><p>基因工程药物包括蛋白质类药物和核酸类药物两类：</p><ul><li>蛋白质类药物主要有重组细胞因子、重组多肽类激素、重组溶栓药物、基因工程抗体和基因工程疫苗等。</li><li>核酸类药物主要有 DNA 药物，反义核酸药和 RNA 干扰药物等。主要针对的疾病有肿瘤、感染性疾病、人免疫缺陷病毒相关疾病、自身免疫性疾病、器官移植、心血管疾病、神经障碍性疾病等。</li></ul><p>基因工程药物的作用机理分为以下三类：</p><ul><li>蛋白或多肽药物：通过蛋白自身的生理生化特性而抵抗疾病，胰岛素、生长素等激素，各类生长因子。</li><li>基因工程疫苗、基因工程抗体：基于抗原抗体反应的原理来抵抗疾病；乙肝疫苗，新冠肺炎疫苗，霍乱菌疫苗等。</li><li>反义核酸、核酶和 RNAi，基于中断基因表达来抵抗疾病。福米韦生，第一代反义核酸药物，治疗艾滋病（AIDS）病人并发的巨细胞病毒（CMV）性视网膜炎。通过对人类巨细胞病毒（CMV） mRNA 的反义抑制发挥特异而强大的抗病毒作用。</li></ul><h3 id="详述基因治疗在肿瘤治疗上的主要方向及重大进展-a-id-Q44-href-T44-↩-a"><a class="header-anchor" href="#详述基因治疗在肿瘤治疗上的主要方向及重大进展-a-id-Q44-href-T44-↩-a"></a>详述基因治疗在肿瘤治疗上的主要方向及重大进展 <a id="Q44" href="#T44">↩</a></h3><p>主要方向有：</p><ul><li>自杀基因治疗：通过转入自杀基因引起肿瘤细胞表型的改变，从而引起药物对肿瘤细胞直接或间接杀伤作用</li><li>免疫基因治疗：是把产生抗病毒或者肿瘤免疫力对应的抗原决定族基因导入机体细胞，以达到治疗目的。</li><li>小分子干扰 RNA 治疗：通过转入外源的小分子 RNA 干扰沉默肿瘤细胞中突变基因的表达</li><li>增强药物化疗效果：通过外源基因的引入增强药物化疗效果</li><li>利用基因编辑技术：CRISPR 技术有望进一步改进肿瘤免疫疗法，人工改造的具有嵌合抗原受体的 T 细胞，重新恢复对肿瘤细胞的免疫抑制作用。</li></ul><blockquote><p>仅供参考</p></blockquote><p>参考文献：</p><ul><li>钟里科.肿瘤免疫治疗的研究进展[J].临床医药文献电子杂志,2017,4(43):8356-8357.</li><li>孟圆,马晓磊.外源基因治疗肿瘤研究进展[J].济宁医学院学报,2017,40(06):457-461.</li><li>马云青,常兴.基因编辑与基因治疗[J].生命的化学,2019,39(01):21-27.</li></ul><hr><p>基因编辑技术同样在肿瘤治疗领域可能得到有效应用。肿瘤的发生涉及许多基因，包括原癌基因、抑癌基因等。</p><p>例如，人子宫颈癌的发生和 HPV （human papilloma virus）感染密切相关。HPV 是 DNA 病毒。HPV 病毒 DNA 在超过 95% 的子宫颈癌患者中被发现。HPV 主要致癌基因为 <em>E6</em>、<em>E7</em>。E6 和 E7 会选择性地表达于 HPV 相关的肿瘤细胞中，使抑癌基因 <em>p53</em> 和 <em>pRb</em> 失活，细胞周期紊乱，端粒酶活化，从而使肿瘤细胞永生。其中 E6 诱导 p53 降解，从而抑制 p53 相关的信号通路，导致癌化。E7 通过与 pRb 蛋白作用使细胞周期调节紊乱。因此，E6 和 E7 基因成为子宫颈癌的基因治疗靶点。目前，体内外实验已证明，CRISPR/Cas9 技术可以靶向 E6 和 E7 编码基因的启动子区域和基因编码区域进行基因敲除，阻止肿瘤细胞增殖。</p><p>CRISPR 技术也有望进一步改进肿瘤免疫疗法。肿瘤免疫疗法采取另外一种思路来对抗肿瘤，治疗靶点不再是肿瘤，而是免疫系统。该疗法主要采用具有抗肿瘤功能的单克隆抗体或者供体 T 细胞。肿瘤细胞会发生大量的遗传学改变和表观遗传学修饰，从而产生肿瘤细胞特异性的抗原，正常情况下，宿主免疫系统会识别这些特异性的抗原，并且清除肿瘤。但肿瘤也会进化出相应的免疫逃逸机制。其中一种重要的免疫逃逸机制是免疫抑制信号通路——免疫检查点，正常情况下，免疫检查点会介导免疫耐受，减轻组织损伤；但病理情况下，肿瘤细胞会通过免疫检查点抑制免疫系统的活化逃避免疫系统的监视。其中重要的免疫检查点是细胞毒 T 淋巴细胞相关抗原-4（处 cytotoxic T-lymphocyte-associated antigen-4, CTLA-4）和程序性死亡分子 PD-1（programmed death-1, PD-1）</p><p>为了重新恢复对肿瘤细胞的免疫抑制作用，采用人工改造的具有嵌合抗原受体的 T 细胞 [chimeric antigen receptor (CAR) T cells]。嵌合抗原受体在 T 细胞外部具有针对肿瘤细胞特异性抗原的结合结构域，在 T 细胞内部具有 T 细胞激活结构域和 T 细胞肿瘤细胞杀伤功能促进结构域。但是绝大数的 CART 来源于病人自身T细胞，时间成本和费用成本都很高，相对常规的抗体封闭免疫检查点的方法并不具有优势。通用的 CART 细胞会降低成本，但会与受体彼此间产生免疫排斥。ZFN 技术和 TALEN 技术已经实现了 T 细胞中内源性 TCR 基因敲除以及 CART 细胞中主要组织相容性抗原的敲除，从而解决免疫排斥问题。除此之外，为进一步加强 CART 的功能，有学者利用基因编辑技术将 CTLA-4 或 PD-1 基因敲除。</p><h2 id="第一章-基因工程概论"><a class="header-anchor" href="#第一章-基因工程概论"></a>第一章 基因工程概论</h2><h3 id="基因工程的诞生"><a class="header-anchor" href="#基因工程的诞生"></a>基因工程的诞生</h3><ul><li><a id="Noun基因工程"></a><font color="#ea66a6">基因工程</font>：又称 DNA 重组技术，是指以分子遗传学为理论基础，以分子生物学和微生物学的现代方法为手段，将不同来源一种或多种基因按预先设计的蓝图，在体外构建杂种 DNA 分子，然后导入活细胞，使之按照人们的意愿遗传并表达出新的性状，从而创造出人们所需求的新的生物类型。<a  href="#Back基因工程">↩</a></li><li>基因工程要素：包括外源 DNA；工具酶；载体分子和受体细胞等。</li></ul><h4 id="基因工程诞生的理论基础"><a class="header-anchor" href="#基因工程诞生的理论基础"></a>基因工程诞生的理论基础</h4><ul><li>孟德尔提出遗传因子分离定律和自由组合定律</li><li>摩尔根并提出一条染色体决定一个性状</li><li>1944年，Avery 利用肺炎双球菌转化实验证明了 DNA 是遗传物质，DNA 可从一种生物个体转移到另一种生物个体。</li></ul><blockquote><p>1944年，美国洛克菲勒研究所的 Oswald Avery 等公开发表了改进的肺炎双球菌实验结果。</p><ul><li>S型菌细胞提取物及其纯化的DNA都可使R型菌转变成S型菌；</li><li>经 DNase 处理的 S 型菌细胞提取物失去了转化作用。</li><li>经胰蛋白酶处理的 S 型菌细胞提取物仍有转化作用。</li></ul><p>实验证实了DNA是遗传物质，而且证明了DNA可以将一个细菌的性状转给另一个细菌，他的工作被称为是现代生物科学的革命性开端。</p></blockquote><ul><li>DNA 双螺旋结构，1953 年 James D. Watson 和 Francis H. C. Crick 揭示了 DNA 分子的双螺旋结构和半保留复制机制。解决了基因的自我复制和传递问题</li><li>中心法则和遗传密码，以 Nireberg 等为代表的一批科学家经过艰苦的努力，确定了遗传信息以密码方式传递，每三个核苷酸组成一个密码子，代表一个氨基酸，到 1966 年，全部破译了 64 个密码子，并提出了遗传信息传递的“中心法则”。1963 年尼伦伯格和马太破译编码氨基酸的遗传密码，1966 年霍拉纳用实验加以证明。</li></ul><p>综上：</p><ul><li>DNA 是遗传物质的证明</li><li>DNA 双螺旋结构和中心法则的确立</li><li>遗传密码的破译（遗传密码的通用性）</li></ul><h4 id="基因工程诞生的技术突破"><a class="header-anchor" href="#基因工程诞生的技术突破"></a>基因工程诞生的技术突破</h4><ul><li>基因的剪刀——限制性内切酶</li><li>基因的针线——DNA连接酶</li><li>基因的运输工具——运载体</li></ul><table><thead><tr><th>工具</th><th>作用</th></tr></thead><tbody><tr><td>限制性内切酶</td><td>在特定的切点上切割 DNA 分子</td></tr><tr><td>DNA连接酶</td><td>把两条 DNA 末端间的缝隙“缝合”起来</td></tr><tr><td>运载体</td><td>将外源基因送入受体细胞</td></tr></tbody></table><p>限制性内切酶：</p><ul><li>1968 年，Werner Arber 发现限制酶</li><li>1970 年，H.O. Smith 等分离并纯化了限制性核酸内切酶<em>Hind</em> Ⅱ</li><li>1972 年，Boyer 等相继发现了EcoR Ⅰ 一类重要的限制性内切酶。</li></ul><p>DNA 连接酶：</p><ul><li>1967 年，世界上有五个实验室几乎同时发现 DNA 连接酶</li><li>特别是 1970 年 Khorana 等发现的 T4 DNA 连接酶具有更高的连接活性。</li></ul><blockquote><p>DNA连接酶连接形成磷酸二酯键</p></blockquote><p>载体的发现与应用:</p><ul><li>1972 年前后使用小分子量的细菌质粒和 λ 噬菌体作载体。在细菌细胞里大量扩增。</li><li>1973 年，Stanford 大学的 Cohen 等成功地利用体外重组实现了细菌间性状的转移。这一年被定为基因工程诞生的元年。</li></ul><p>感受态体系：</p><ul><li>1970 年 M. Mandel 和 A. Higa 发现经过氯化钙处理的大肠杆菌容易吸收噬菌体 DNA。</li><li>1972 年 S. Cohen 发现这种处理过的细菌同样能吸收质粒 DNA。</li></ul><p>琼脂糖凝胶电泳：1960s 发明了琼脂糖凝胶电泳，可将不同长度的 DNA 分离开。</p><p>DNA 测序技术：1975 年 F. Sanger、A. Maxam 和 W. Gilbert 发明了 DNA 快速测序技术。</p><h4 id="基因工程的支撑技术"><a class="header-anchor" href="#基因工程的支撑技术"></a>基因工程的支撑技术</h4><ul><li>核酸凝胶电泳技术</li><li>核酸分子杂交技术</li><li>细菌转化转染技术</li><li>DNA 序列分析技术</li><li>寡核苷酸合成技术</li><li>基因定点突变技术</li><li>聚合酶链反应（PCR）技术</li></ul><h4 id="基因工程的诞生-v2"><a class="header-anchor" href="#基因工程的诞生-v2"></a>基因工程的诞生</h4><p>Berg 的开创性实验，1972 年斯坦福大学的 Paul Berg 小组完成了首次体外重组实验：用<em>EcoR</em> Ⅰ 内切酶消化猿猴病毒 SV40 的 DNA 和 λ 噬菌体的 DNA，再用 T4 DNA 连接酶将其连接起来。</p><p>Boyer-Cohen 实验，1973 年斯坦福大学 S. Cohen 小组将含有新霉素抗性基因的大肠杆菌 R6-3 质粒与含有四环素抗性基因的质粒 pSC101 连接成重组质粒，转化获得具有双重抗药性的大肠杆菌。后来又把非洲爪蟾核糖体基因片断同 pSC101 质粒重组，转化大肠杆菌，并在菌体内成功转录出相应的 mRNA。这是第一次成功的基因克隆实验。</p><p>此实验说明：</p><ol><li>PSC101 可以做为载体，将外源 DNA 导入寄主细胞</li><li>真核生物的基因可以转录到原核生物</li><li>质粒-大肠杆菌是成功的基因克隆体系</li></ol><h4 id="基因工程的特征"><a class="header-anchor" href="#基因工程的特征"></a>基因工程的特征</h4><ul><li>跨物种性：将一外源基因转到另一种不同的生物细胞内进行繁殖。</li><li>无性扩增：外源 DNA 在寄主细胞内可大量扩增和表达。</li></ul><h3 id="基因工程的研究内容"><a class="header-anchor" href="#基因工程的研究内容"></a>基因工程的研究内容</h3><table><thead><tr><th>基因工程的别名</th><th>基因拼接技术或 DNA 重组技术</th></tr></thead><tbody><tr><td>操作环境</td><td>生物体外</td></tr><tr><td>操作对象</td><td>基因</td></tr><tr><td>操作水平</td><td>DNA 分子水平</td></tr><tr><td>基本过程</td><td>剪切 → 拼接 → 导入 → 表达</td></tr><tr><td>结果</td><td>人类需要的基因产物</td></tr></tbody></table><h3 id="基因工程的基本流程"><a class="header-anchor" href="#基因工程的基本流程"></a>基因工程的基本流程</h3><ol><li>目的基因的获取，从复杂的生物基因组中，经过酶切消化或 PCR 扩增等步骤，分离出带有目的基因的 DNA 片断。（切）</li><li>重组体的制备，将目的基因的 DNA 片断插入到能自我复制并带有选择性标记（抗菌素抗性）的载体分子上。（接）</li><li>重组体的转化，将重组体（载体）转入适当的受体细胞中。（转）</li><li>重组子的培养，对转入重组子的受体细胞进行培养，以扩增 DNA 重组子或使其整合到受体细胞的基因组中。（增）</li><li>克隆的鉴定，挑选转化成功的细胞克隆（含有目的基因）。（检）</li><li>目的基因的表达，使导入寄主细胞的目的基因表达出我们所需要的基因产物。</li></ol><h3 id="基因工程的应用"><a class="header-anchor" href="#基因工程的应用"></a>基因工程的应用</h3><h4 id="基因工程在农业生产中的应用"><a class="header-anchor" href="#基因工程在农业生产中的应用"></a>基因工程在农业生产中的应用</h4><ol><li>提高植物的光合作用效率:<ul><li>提高 CO<sub>2</sub> 的固定率，利用蓝藻基因，改变与光合作用有关的酶的结构和组成（如二磷酸核酮糖羧化酶）。</li><li>提高光能吸收率和转化率，改变光能交换系统的分子的基因结构。</li></ul></li><li>提高豆科植物的固氮效率，使非固氮植物转变为固氮植物或能与根瘤菌共生固氮。</li><li>转基因植物，是农业生物技术的主要内容。将克隆到的特殊基因导入受体植物，使之增加一些优质性状（高产、稳定、优质、抗虫、抗病等）。例如：延熟（耐贮存）番茄、高产量的番茄、抗环斑病毒的转基因番木瓜等</li><li>转基因动物，将外源基因导入动物细胞，并在基因组内稳定整合，遗传给后代。如使动物成为生物反应器生产有用的活性蛋白等。</li></ol><h4 id="基因工程在工业中的应用"><a class="header-anchor" href="#基因工程在工业中的应用"></a>基因工程在工业中的应用</h4><ol><li>纤维素的开发利用，克隆各种参与纤维素降解的酶的基因，导入酿酒酵母，就可能利用廉价的纤维素来生产葡萄糖，发酵成酒。</li><li>酿酒工业，用外源基因改造酿酒酵母，产生优质的啤酒。或用酿酒酵母生产蛋白质等。</li></ol><h4 id="基因工程在医药上的应用"><a class="header-anchor" href="#基因工程在医药上的应用"></a>基因工程在医药上的应用</h4><ol><li>用转基因植物或动物生产药物</li><li>用微生物生产药物，大肠杆菌或酵母菌生产激素（如胰岛素）、干扰素等</li><li>设计高效特异的生物制剂，应用定点突变技术设计蛋白质或酶的结构，制造出高效高特异性的生物制剂</li><li>研制疫苗，制造新型疫苗（如HIV、癌症、乙肝、丙肝等）</li><li>基因诊断</li><li>法医鉴定</li><li>基因治疗，将正常的外源基因导入靶细胞中以弥补靶细胞所缺失或突变的基因、或抑制异常表达的基因。（仍在探索阶段）</li></ol><h4 id="基因工程在环境保护中的应用"><a class="header-anchor" href="#基因工程在环境保护中的应用"></a>基因工程在环境保护中的应用</h4><ol><li>检测水污染，用重组细菌或转基因鱼等检测水污染</li><li>生物降解，用带有重组质粒的“超级菌”分解油（烷烃类）、有机农药污染。</li></ol><h3 id="基因工程的商业化发展"><a class="header-anchor" href="#基因工程的商业化发展"></a>基因工程的商业化发展</h3><p>商业投资支持现代生物技术研究，生物技术的发展在某种程度上是由商品经济的发展所推动的。</p><p>基因工程商业化特点：</p><ol><li>技术密集型<ul><li>产品来源于实验室</li><li>科学家往往就是公司的领导人</li></ul></li><li>市场扩张迅速</li><li>投入巨大</li><li>风险太高</li><li>产品不断增加</li><li>研究专一、产品专一</li><li>医学生物技术产业进展最快</li></ol><h2 id="第二章-基因操作的工具酶"><a class="header-anchor" href="#第二章-基因操作的工具酶"></a>第二章 基因操作的工具酶</h2><table><thead><tr><th>工具酶</th><th>功能</th></tr></thead><tbody><tr><td>限制性内切酶</td><td>主要用于 DNA 分子的特异切割</td></tr><tr><td>DNA 甲基化酶</td><td>用于 DNA 分子的甲基化</td></tr><tr><td>核酸酶</td><td>用于 DNA 和 RNA 的非特异性切割</td></tr><tr><td>核酸连接酶</td><td>用于 DNA 和 RNA 的连接</td></tr><tr><td>核酸聚合酶</td><td>用于 DNA 和 RNA 的合成</td></tr><tr><td>核酸末端修饰酶</td><td>用于 DNA 和 RNA 的末端修饰</td></tr><tr><td>其它酶类</td><td>用于生物细胞的破壁，转化，核酸纯化，检测等。</td></tr></tbody></table><h3 id="限制性核酸内切酶"><a class="header-anchor" href="#限制性核酸内切酶"></a>限制性核酸内切酶</h3><h4 id="细菌的限制与修饰系统"><a class="header-anchor" href="#细菌的限制与修饰系统"></a>细菌的限制与修饰系统</h4><p>任何物种都有排除异物，保护自身的防御机制</p><ul><li>人的免疫系统（immunity system）</li><li>细菌的限制与修饰系统（restriction and modification system)：限制性内切酶（restriction endonuclease)、甲基化修饰酶 (modification enzyme）</li></ul><p>细菌的限制系统，限制（Restriction）侵入细菌体内的外源 DNA（非甲基化），能被限制性内切酶识别和降解，从而保护自身的 DNA 不被降解。</p><p>细菌的修饰系统，细菌自身的 DNA 可被甲基化酶修饰，从而防止限制性内切酶的识别和水解。</p><blockquote><p>Dam 甲基化酶 在 GAATTC 序列的腺嘌呤 N6 位引入甲基。</p></blockquote><p>限制与修饰作用：由于甲基化酶具有种属专一性，即只修饰寄主本身的 DNA，因而避免了限制酶对寄主 DNA 的破坏；对于外源 DNA，甲基化酶不能识别，而由限制酶将其水解。</p><p>R-M 系统是细菌安内御外的积极措施。</p><ul><li>限制：细菌为防御外来 DNA 入侵而将其降解的现象。（一般由限制酶来降解外源 DNA)</li><li>修饰：细菌为防止自身 DNA 被降解而修饰自身 DNA。（一般由甲基化酶进行修饰）</li></ul><blockquote><p>个别噬菌体在被降解之前已经发生了修饰，则可免予被降解。</p></blockquote><p>限制与修饰系统的意义:</p><ol><li>是许多细菌所具有的类似免疫的防卫机制。</li><li>是病毒具有一定寄主范围，感染具有种属专一性的原因。</li><li>既保证物种的遗传稳定性，又利于生物进化。</li></ol><h4 id="限制性内切酶的发现"><a class="header-anchor" href="#限制性内切酶的发现"></a>限制性内切酶的发现</h4><p>限制性核酸内切酶（restriction endonuelease）：是一类能识别双链 DNA 中特定核苷酸序列，并使每条链的一个磷酸二酯键断开的内脱氧核糖核酸酶（endo-deoxyribonuclease）。</p><ul><li>1968 年，Werner Arber 发现限制酶</li><li>1968 年，Meselson and Yuan 从 <em>E. coli</em> 菌株 Ｋ 和 Ｂ 中发现了Ⅰ型限制酶；</li><li>1970 年，Smith 等人首先从流感嗜血杆菌 d 株中分离出 <em>Hin</em>d Ⅱ和 <em>Hin</em>d Ⅲ</li></ul><h4 id="限制性内切酶的命名"><a class="header-anchor" href="#限制性内切酶的命名"></a>限制性内切酶的命名</h4><p>限制酶由三部分构成，即菌种名、菌株号、分离顺序。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.2ujx9a7hofw0.png" alt="制性内切酶的命名"></p><ul><li>第 1 个字母取自产生该酶的细菌属名，大写</li><li>第 2，3 二个字母取自它来源细菌的种名的头 2 个字母，斜体小写</li><li>第 4 个字母代表菌株号，大小写都可以，可有可无</li><li>最后用大写罗马数字，代表同一菌株中不同限制酶的编号</li></ul><blockquote><p><em>Eco</em>R Ⅰ、<em>Hin</em>dⅢ、<em>Acc</em>65 Ⅰ、<em>Pst</em> Ⅰ</p></blockquote><h4 id="限制性内切酶的分类"><a class="header-anchor" href="#限制性内切酶的分类"></a>限制性内切酶的分类</h4><p>根据限制性内切酶的<font color="#e03e3e">识别位点</font>和<font color="#e03e3e">切割位点</font>以及所需要的辅助因子，可将目前已鉴定出的限制性内切酶一般将限制酶分为 3 种不同类型。</p><ul><li>Ⅰ 型：切割位点不确定，不适用于基因工程。</li><li><font color="#e03e3e">Ⅱ 型：基因工程的工具酶。</font></li><li>Ⅲ型：切割位点不在识别位点，对分子克隆操作亦无实用意义。</li></ul><h4 id="各种限制与修饰系统的比较"><a class="header-anchor" href="#各种限制与修饰系统的比较"></a>各种限制与修饰系统的比较</h4><table><thead><tr><th></th><th>Ⅰ</th><th>Ⅱ</th><th>Ⅲ</th></tr></thead><tbody><tr><td>酶分子</td><td>三亚基多功能酶</td><td>内切酶与甲基化酶分子不在一起</td><td>二亚基双功能酶</td></tr><tr><td>识别位点</td><td>二分非对称</td><td>4 ～ 6 bp，大多数为回文对称结构</td><td>5 ～ 7 bp 非对称</td></tr><tr><td>切割位点</td><td>无特异性，至少在识别位点外 1000 bp</td><td>在识别位点中或靠近识别位点</td><td>在识别位点下游 24 ～ 26 bp</td></tr><tr><td>识别未甲基化的序列进行切割</td><td>能</td><td>能</td><td>能</td></tr><tr><td>限制作用是否需用 ATP</td><td>是</td><td>否</td><td>是</td></tr></tbody></table><h4 id="Ⅱ-型限制性内切酶"><a class="header-anchor" href="#Ⅱ-型限制性内切酶"></a>Ⅱ 型限制性内切酶</h4><p>首先由 H.O. Smith 和 K.W. Wilcox 在 1970 年从流感嗜血杆菌 Rd 菌株中分离出来。分离的第一个酶是 <em>Hin</em>d Ⅱ</p><p>作用原理：识别双链 DNA 上未甲基化修饰的一小段明确的序列（多数是回文序列），然后在识别位点之内的特定位置切割。</p><p>Ⅱ 型限制性内切酶的特性：一般识别和切割 4 和 6 个核苷酸顺序，少数为 5、7 个核苷酸，也有识别 8 个核苷酸的，但无 4 个以下的。</p><h4 id="限制酶切割的位置"><a class="header-anchor" href="#限制酶切割的位置"></a>限制酶切割的位置</h4><p>切割的位点：</p><ul><li>一般在识别序列内部，如 G↓GATCC、AT↓CGAT、GTC↓GAC、CCGC↓GG、AGCGC↓T 等。</li><li>少数在识别序列的两侧，如 ↓GATC、CATG↓、↓CCAGG 等</li></ul><p>限制酶切后产生两个末端，末端结构是 5’-P 和 3’-OH</p><h4 id="限制酶产生的末端"><a class="header-anchor" href="#限制酶产生的末端"></a>限制酶产生的末端</h4><p><a id="Noun粘性末端"></a> <font color="#ea66a6">粘性末端</font>：在识别序列 2 条链对应位上<font color="#e03e3e">错位切割</font>，有 5’ 端突出的粘性末端和 3’ 端突出的粘性末端。 <a  href="#Back粘性末端">↩</a><br><font color="#ea66a6">齐平末端</font>：在识别序列内的<font color="#e03e3e">对称轴上切割</font>，其切割产物具平头末端（可任意连接，但连接效率低）。</p><p>粘性末端的意义：粘性末端突出的单链部分可以与相同的酶或<font color="#faa755">同尾酶</font>切割得到的粘性末端的单链部分互补配对。</p><ul><li>在回文对称轴上同时切割 DNA 的两条链，则产生平末端</li><li>若在对称轴 5’ 侧切割底物， DNA 双链交错断开产生 5’ 突出粘性末端</li><li>若在对称轴 3’ 侧切割底物，则产生 3’ 突出粘性末端</li></ul><h4 id="关于限制酶的几个概念"><a class="header-anchor" href="#关于限制酶的几个概念"></a>关于限制酶的几个概念</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5lccfdjh1xs0.png" alt="识别位点以及切割位点"></p><blockquote><p>限制酶识别序列同 DNA 的来源无关，也就是说不具有种的特异性，对不同的 DNA 普遍适用。原则上任何不同来源的 DNA，经过适当限制酶消化成片段后，都可以通过其黏性末端或平末端连接起来，组合成新的重组分子或是新的基因。这种特性是重组 DNA 技术的重要基础之一。</p></blockquote><p><a id="Noun同裂酶"></a><font color="#ea66a6">同裂酶</font>：识别序列相同而来源不同的一类限制酶。亦称异源同工酶。它们的切割位点可能不同。<a  href="#Back同裂酶">↩</a></p><p>同裂酶应用：一些同裂酶间对于切割位点上的甲基化碱基的敏感度有所不同，利用这样细微的差异可以进行 DNA 甲基化作用的研究。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.2haypleyeh40.png" alt="完全同裂酶和不完全同裂酶"></p><p><a id="Noun同尾酶"></a><font color="#ea66a6">同尾酶</font>：这一类的限制酶来源各异，识别的靶序列也不相同，但产生相同的粘性末端。<a  href="#Back同尾酶">↩</a></p><blockquote><p>同尾酶的粘性末端结合形成的新位点不能再被原来的酶识别</p></blockquote><p>酶的星号活性（星星活性）：当酶切条件改变时，酶的专一性可能会降低，以至于同一种酶可识别和切割多个的位点。详见 <a href="#Q4">星星活性</a></p><p>双酶切方法：同步双酶切、分步双酶切</p><p>Ⅱ 型核酸内切酶的多酶联合酶解，对盐浓度要求不同的酶，可采取下列方法：</p><ul><li>使用较贵的酶的盐浓度，加大便宜酶的用量，同时酶解</li><li>低盐酶先切，然后补加盐，高盐酶再切</li><li>一种酶先切，然后更换缓冲液，另一种酶再切</li></ul><p>Ⅲ 类限制性内切酶，能完全肯定的识别位点和切割位点，但切割位点也是在识别位点的一侧的一定距离，通常距特异性位点 24 bp ～ 26 bp。<font color="#faa755">在基因工程操作中用途不大</font></p><p>常用限制性核酸内切酶的特性</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/342.3rtcekyhykw0.svg" alt="常用限制性核酸内切酶的特性"></p><h4 id="限制性内切酶的活性单位"><a class="header-anchor" href="#限制性内切酶的活性单位"></a>限制性内切酶的活性单位</h4><p>20 μL 中，含 1 μg 底物 DNA，于最适反应条件和温度下，保温 1 小时，能使 1 μg DNA 完全降解所需的酶蛋白量即为<font color="#ea66a6">一个酶单位</font>，用 U 表示。</p><h4 id="限制性内切酶的反应条件"><a class="header-anchor" href="#限制性内切酶的反应条件"></a>限制性内切酶的反应条件</h4><p><font color="#d9730d">20 μL 的酶切反应体系</font>：</p><table><thead><tr><th>总体积</th><th>20 μL</th></tr></thead><tbody><tr><td>DNA</td><td>1 μL（1 μg）</td></tr><tr><td>buffer（10x）</td><td>2 μL</td></tr><tr><td>ddH<sub>2</sub>O</td><td>16 μL</td></tr><tr><td>限制性内切酶</td><td>1 μL</td></tr></tbody></table><ol><li>确定酶切 DNA 的量</li><li>计算完全酶切所需的酶量。</li><li>10X 反应液的体积应为终体积的 1/10</li><li>依次加入计算好的 DNA 量、10X 反应液、酶。</li></ol><h4 id="影响限制性内切酶活性的因素"><a class="header-anchor" href="#影响限制性内切酶活性的因素"></a>影响限制性内切酶活性的因素</h4><ol><li>DNA 的纯度，DNA 中的杂质如蛋白质、酚、氯仿、乙醇、SDS、EDTA 等都会影响酶的活性。一般采取以下措施：纯化 DNA、加大酶的用量、延长酶催化反应的保温时间、扩大反应体积（&gt;20 μl）</li><li>DNA 的甲基化程度，大肠杆菌一般有两种甲基化酶修饰质粒：dam 甲基化酶（修饰 GATC 中的 A）；dcm 甲基化酶（修饰 CCA/TGG 的 C）。基因工程中必须使用甲基化酶失活突变的菌株。</li><li>温度，不同的限制性内切酶的最适反应温度不同。大多数是 37℃，少数要求 40 ～ 65℃。</li><li>DNA 的分子结构，DNA 分子的不同构型对限制性内切酶的活性也有很大的影响。某些限制性核酸内切酶切割超螺旋的质粒 DNA 所需要的酶量要比消化线性的 DNA 量高出很多倍。</li><li>缓冲液，是影响限制酶活性的重要因素。商品化的限制酶一般都带有专用缓冲液。化学组成：<ul><li>MgCl<sub>2</sub>、NaCl/KCl：提供 Mg<sup>2+</sup> 和离子强度</li><li>Tris-HCl：维持 pH</li><li>二硫苏糖醇（DTT）：保持酶中 -SH 的还原态，保持酶稳定性</li><li>牛血清白蛋白 BSA 等：有助于酶的稳定</li></ul></li></ol><h4 id="限制性内切酶的应用"><a class="header-anchor" href="#限制性内切酶的应用"></a>限制性内切酶的应用</h4><ul><li>重组 DNA 前的切割</li><li>构建新质粒</li><li>构建物理图谱</li><li>DNA 分子杂交</li><li>用限制性内切酶消化受体 DNA</li><li>制备 DNA 探针</li><li>亚克隆以用作序列分析</li><li>基因定位，DNA 同源性研究</li></ul><h3 id="DNA-连接酶"><a class="header-anchor" href="#DNA-连接酶"></a>DNA 连接酶</h3><p><a id="NounDNA连接酶"></a><font color="#ea66a6">DNA 连接酶</font>：能够催化双链分子中相邻的<font color="#e03e3e"> 3’-OH </font>和<font color="#e03e3e"> 5’-P </font>末端之间形成<font color="#e03e3e">磷酸二酯键</font>，使 DNA 分子连接起来的酶。  <a  href="#BackDNA连接酶">↩</a></p><h4 id="DNA-连接酶种类"><a class="header-anchor" href="#DNA-连接酶种类"></a>DNA 连接酶种类</h4><ul><li>T4 DNA 连接酶，从 T4 噬菌体感染的大肠杆菌提取，T4 DNA ligase 能量 ATP</li><li>大肠杆菌 DNA 连接酶，E. coli DNA ligase 能量 NAD<sup>﹢</sup></li></ul><h4 id="DNA-连接酶的连接范围："><a class="header-anchor" href="#DNA-连接酶的连接范围："></a>DNA 连接酶的连接范围：</h4><ol><li>粘性末端 DNA 连接</li><li>缺口的填补</li><li>平末端 DNA 连接</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/46236.78umjzpo9yo0.svg" alt="T4DNA连接酶的连接范围"></p><p>E. coli DNA连接酶或 T4 DNA 连接酶可把黏性末端之间的缝隙“缝合”起来，恢复被限制酶切开的两个核苷酸之间的磷酸二酯键，T4 DNA连接酶还可把平末端之间的缝隙“缝合”起来，但效率较低</p><h4 id="DNA-连接酶的连接条件"><a class="header-anchor" href="#DNA-连接酶的连接条件"></a>DNA 连接酶的连接条件</h4><ol><li>双链 DNA 分子</li><li>具有 3’-OH 和 5’-P</li><li>缺口处不缺核苷酸</li><li>需要能量</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.6x5leewaxwk0.png" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1jfon0qwgakg.png" alt="image"></p><h4 id="T4-DNA-连接酶的反应条件"><a class="header-anchor" href="#T4-DNA-连接酶的反应条件"></a>T4 DNA 连接酶的反应条件</h4><table><thead><tr><th>总体积</th><th>20 μL</th></tr></thead><tbody><tr><td>10× T4 DNA Ligase Buffer</td><td>2 μL</td></tr><tr><td>DNA 片段</td><td>约 0.3 pmol</td></tr><tr><td>载体 DNA</td><td>约 0.03 pmol</td></tr><tr><td>T4 DNA Ligase</td><td>1 μL</td></tr><tr><td>ddH<sub>2</sub>O</td><td>up to 20 μL</td></tr></tbody></table><p><font color="#d9730d">反应温度</font>：16 ℃，连接过夜</p><blockquote><p>DNA 片段的摩尔数应控制在载体 DNA 摩尔数的 3 ～ 10 倍。</p></blockquote><h4 id="体外-DNA-片段的连接方法"><a class="header-anchor" href="#体外-DNA-片段的连接方法"></a>体外 DNA 片段的连接方法</h4><p>由于待连接的 DNA 片段具不同形式的末端，因此须采用不同的连接方法。</p><ol><li>具互补黏性末端片段之间的连接</li><li>具平末端 DNA 片段之间的连接</li><li>DNA 片段末端修饰后进行连接</li></ol><p>平头双链DNA片段的连接操作。从分子动力学的角度讲，由限制性核酸内切酶创造的粘性末端的连接属于分子内部的连接，而平头末端的连接则属于分子间的连接，因此后者反应速度要慢得多，提高平头末端连接效率的方法包括：</p><ul><li>加大连接酶用量（10 倍大于粘性末端的连接）</li><li>加大平头末端底物的浓度，增加分子间碰撞机会</li><li>加入10% PEG8000，促进大分子之间的有效作用</li><li>加入单价阳离子（NaCl），最终浓度 150 ～ 200 mM</li></ul><p>平头双链 DNA 片段修饰后进行连接:</p><ol><li>DNA 片段末端同聚物加尾后进行连接。给平末端 DNA 片段 3’-OH 加上同聚物。</li><li>DNA 片段加连杆或衔接头后连接</li></ol><p>DNA 接头（adapter）连接法：于 1978 年由康乃尔大学吴瑞教授发明的。它是一类由人工合成的一头具有某种限制性内切酶粘末端，另一头为平末端的特殊的双链寡核苷酸片段。当它的平末端与平末端的外源 DNA 片段连接之后，便会使后者成为具黏性末端的新的 DNA 分子，而易于连接重组。</p><p>小结：平末端 DNA 片段的连接</p><ol><li>直接用 T4 DNA 连接酶连接；</li><li>先用末端核苷酸转移酶，给平末端 DNA 分子加上同聚物尾巴之后再用 DNA 连接酶进行连接；</li><li>DNA 接头连接法。</li></ol><h3 id="DNA-聚合酶"><a class="header-anchor" href="#DNA-聚合酶"></a>DNA 聚合酶</h3><h4 id="常用的-DNA-聚合酶"><a class="header-anchor" href="#常用的-DNA-聚合酶"></a>常用的 DNA 聚合酶</h4><ol><li>大肠杆菌 DNA 聚合酶 Ⅰ</li><li>T7 DNA聚合酶</li><li>Taq DNA聚合酶</li><li>Pfu DNA聚合酶</li><li>末端转移酶</li><li>反转录酶</li></ol><h4 id="DNA-聚合酶的特点"><a class="header-anchor" href="#DNA-聚合酶的特点"></a>DNA 聚合酶的特点</h4><ol><li><font color="#d9730d">共同特点</font>，在 DNA 模板指导下，以 4 种脱氧核糖核苷酸（dNTP）为底物，在引物 3’-OH 末端聚合 DNA 链（DNA合成）的一类酶。</li><li>主要区别：<ul><li>持续合成能力和外切酶活性不同。</li><li>T7 DNA 聚合酶可以连续添加数千个 dNTPs 而不从模板上掉下来。</li><li>其它几种 DNA 聚合酶只能连续添加 10 多个 dNTPs 就会从模板上解离下来。</li></ul></li></ol><p>DNA 聚合酶的特性比较:</p><table><thead><tr><th>DNA 聚合酶</th><th>3’→5’ 外切酶活性</th><th>5’→3’ 外切酶活性</th><th>聚合速率</th><th>持续能力</th></tr></thead><tbody><tr><td>大肠杆菌DNA聚合酶</td><td>低</td><td><font color="#e03e3e">有</font></td><td>中</td><td>低</td></tr><tr><td>Klenow fragment</td><td>低</td><td>无</td><td>中</td><td>低</td></tr><tr><td>T4 DNA聚合酶</td><td>高</td><td>无</td><td>中</td><td>低</td></tr><tr><td>T7 DNA聚合酶</td><td>高</td><td>无</td><td>快</td><td>高</td></tr><tr><td>逆转录酶</td><td>无</td><td>无</td><td>低</td><td>中</td></tr><tr><td>Taq DNA聚合酶</td><td>无</td><td><font color="#e03e3e">有</font></td><td>快</td><td>高</td></tr></tbody></table><p>DNA聚合酶的活性：</p><ol><li>5’→3’ 聚合酶活性</li><li>5’→3’ 外切酶活性</li><li>3’→5’ 外切酶活性</li></ol><h4 id="大肠杆菌-DNA-聚合酶Ⅰ"><a class="header-anchor" href="#大肠杆菌-DNA-聚合酶Ⅰ"></a>大肠杆菌 DNA 聚合酶Ⅰ</h4><p>功能：</p><ol><li>5’→3’ 聚合酶活性</li><li>5’→3’ 外切酶活性</li><li>3’→5’ 外切酶活性</li></ol><p>聚合反应的条件：</p><ol><li>底物为四种脱氧核苷 5’ 三磷酸（dNTPs）。</li><li>引物为 3’ 端具有游离的 -OH 基团。</li><li>模板为单链 DNA 或具有切口的双链 DNA。</li></ol><p>主要用途：通过 5’→3’ 聚合酶活性和 5’→3’ 外切酶活性使 DNA 切口平移，制备核酸分子杂交用的带放射性标记的 DNA 探针。</p><p>制备 DNA 分子杂交探针（缺口平移 Nick translation）</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4a9s2h02kys0.png" alt="image"></p><ol><li>DNase Ⅰ 处理双链的 DNA 分子</li><li>带有 3’-OH 末端的单链缺口</li><li>polⅠ从 5’-P 移去一个核苷酸</li><li>polⅠ将 <sup>32</sup>P 标记的核苷酸参入取代被移去的核苷酸</li><li>重复 3、4 的步骤，缺口沿 5’-3’ 方向移动，形成 <sup>32</sup>P 标记的核苷酸合成的 DNA 链</li></ol><p>核酸探针（probe）:能够同某种被研究的核酸序列特异性结合的、带有标记的寡聚核苷酸。</p><ul><li>标记：已知序列的核酸片段</li><li>显示位置：与互补的待测序列杂交</li></ul><h4 id="T7-DNA-聚合酶的特点及用途"><a class="header-anchor" href="#T7-DNA-聚合酶的特点及用途"></a>T7 DNA 聚合酶的特点及用途</h4><ol><li>持续合成能力强，一旦与模板结合就会不间断地合成互补链。</li><li>3’→ 5’ 外切酶活性高，单链和双链都能降解。</li><li>不受 DNA 二级结构的影响，其它 DNA 聚合酶受 DNA 二级结构的阻碍</li></ol><p>用途：用于测序</p><h4 id="Taq-DNA-聚合酶"><a class="header-anchor" href="#Taq-DNA-聚合酶"></a>Taq DNA 聚合酶</h4><p>由嗜热的水生菌 <em>Thermus aquaticus</em> 分离纯化，主要用于 DNA 测序、聚合酶链式反应（PCR）体外扩增 DNA。</p><p>因为没有 3’→5’ 外切酶活性，所以有一定的错配率，约 1000 bp 有 2 ～ 3 bp 错配。</p><h4 id="Pfu-DNA-聚合酶"><a class="header-anchor" href="#Pfu-DNA-聚合酶"></a>Pfu DNA 聚合酶</h4><p>Pfu 聚合酶有着出色的热稳定性，以及特有的“校正作用”。与 Taq DNA 聚合酶不同，Pfu DNA 聚合酶具有 3’-5’ 外切酶的即时校正活性，可以即时的识别并切除错配核苷酸。</p><p>商业化的 Pfu 聚合酶试剂，其出错率是 100 万到 130 万个碱基对出现一个错配，因此，Pfu 聚合酶正逐渐取代 Taq 聚合酶，成为使用最广的 PCR 工具。</p><h4 id="末端转移酶"><a class="header-anchor" href="#末端转移酶"></a>末端转移酶</h4><p>末端转移酶（terminal transferase），（不依赖模板的 DNA 聚合酶）</p><p>用途：</p><ul><li>克隆 DNA 片段时加上互补同聚物末端，便于与载体连接。</li><li>末端标记</li></ul><p>末端转移酶催化 DNA 片段在其 3′ 羟基末端加接脱氧核糖核苷酸。合成时不需 DNA 模板，但是底物要有一定长度，至少是 3 个碱基以上的寡核苷酸片段。反应底物可以是带有 3′ 羟基的单链 DNA，也可以是 3′ 端延伸的双链 DNA，反应时 4 种 dNTP 的任何一种都可以作为合成的前体物。</p><p>TdT 的基本特性：不需要模板的 DNA 聚合酶，随机掺入 dNTPs。</p><h4 id="反转录酶：AMV"><a class="header-anchor" href="#反转录酶：AMV"></a>反转录酶：AMV</h4><p>来源，商品反转录酶有两种：</p><ul><li>来自禽类成髓细胞瘤病毒（AMV）</li><li>来自 Moloney 鼠白血病毒（M-MLV）反转录酶</li></ul><p>结构和活性：</p><table><thead><tr><th>酶类别</th><th>肽链</th><th>5’-3’ 聚合活性</th><th>RNase H</th></tr></thead><tbody><tr><td>AMV</td><td>α（62 KDa) 、 β（94 KDa)</td><td>+</td><td>+++</td></tr><tr><td>M-MLV</td><td>84 KDa</td><td>+</td><td>+</td></tr></tbody></table><p>α 链：有反转录活性和 RNaseH 活性</p><p>RNaseH：α 链经过蛋白酶水解后产生的一条多肽。以 5’→3’ 或 3’→5’ 方向特异地水解 RNA-DNA 杂交双链中的 RNA 链。</p><p>β 链：RNA-DNA 杂交双链中 5’→3’ DNA 外切酶活性</p><h4 id="DNA-连接酶与-DNA-聚合酶的异同"><a class="header-anchor" href="#DNA-连接酶与-DNA-聚合酶的异同"></a>DNA 连接酶与 DNA 聚合酶的异同</h4><table><thead><tr><th></th><th>DNA聚合酶</th><th>DNA连接酶</th></tr></thead><tbody><tr><td>区别1</td><td>只能将单个核苷酸连接到已有的核酸片段上，形成磷酸二酯键</td><td>在两个DNA片段之间形成磷酸二酯键</td></tr><tr><td>区别2</td><td>以一条DNA链为模板，将单个核苷酸通过磷酸二酯键连接成一条互补的DNA链</td><td>将DNA双链上的两个切口同时连接起来，不需要模板</td></tr><tr><td>相同点</td><td>形成磷酸二酯键</td><td>形成磷酸二酯键</td></tr></tbody></table><h3 id="修饰酶类"><a class="header-anchor" href="#修饰酶类"></a>修饰酶类</h3><p>在基因克隆技术中，除了限制酶、连接酶、聚合酶这些主要的工具酶外，还经常使用某些酶的相关功能对DNA或RNA进行分子修饰，以便使基因工程操作更加巧妙、简便和高效。把这类酶统称为修饰酶。</p><p>其他基因工程常用酶：</p><ul><li>核酸酶 SⅠ</li><li>碱性磷酸酶</li><li>核糖核酸酶 A</li><li>核糖核酸酶 H</li><li>蛋白酶 K</li><li>溶菌酶</li></ul><h4 id="核酸酶SⅠ"><a class="header-anchor" href="#核酸酶SⅠ"></a>核酸酶SⅠ</h4><p>是一种单链特异的核酸酶，在最适的酶催反应条件下，降解单链 DNA 或 RNA，产生带磷酸的单核苷酸或寡核苷酸。对双链 DNA、双链 RNA 和 DNA-RNA 杂交体相对不敏感。通常水解单链 DNA 的速率要比水解双链 DNA 快 75000 倍。</p><p>S1 核酸酶的单链水解功能也可以作用对双链 DNA 中的一个切口发生作用，并从单链部位切断核酸分子。</p><p>S1 单链核酸酶的用途：使 S1 核酸酶在分析核酸杂交分子（RNA-DNA）的结构、给 RNA 分子定位、测定真核基因中间隔子序列的位置、去除 DNA 片段中突出的单链尾，以及打开在双链 cDNA 合成期间形成的发夹环起作用</p><h4 id="碱性磷酸酶"><a class="header-anchor" href="#碱性磷酸酶"></a>碱性磷酸酶</h4><p>其活性是催化核酸脱掉磷酸基团，从而使 DNA（或RNA）片段的 5′ 磷酸末端转换成 3′ 羟基末端，即所谓的核酸分子的脱磷酸作用。主要作用是防止 DNA 片段自连。</p><h4 id="核糖核酸酶-A"><a class="header-anchor" href="#核糖核酸酶-A"></a>核糖核酸酶 A</h4><p>核糖核酸酶 A（RNase A）对核糖核酸有水解作用，但对脱氧核糖核酸则不起作用。广泛用来去除 DNA 制品中的污染 RNA。</p><h4 id="核糖核酸酶-H"><a class="header-anchor" href="#核糖核酸酶-H"></a>核糖核酸酶 H</h4><p>核糖核酸酶 H（Rnase H）：它能够特异性地水解杂交到 DNA 链上的 RNA 磷酸二酯键，故能分解 RNA/DNA 杂交体系中的 RNA 链。主要用于在 cDNA 克隆合成第二链之前去除 RNA。</p><h4 id="蛋白酶-K"><a class="header-anchor" href="#蛋白酶-K"></a>蛋白酶 K</h4><p>是一种强力蛋白溶解酶，是 DNA 提取的关键试剂。该酶 在较广的 pH 范围（4 ～ 12.5）内及高温（50 ～ 70°C）均有活性，在 DNA 提取中，主要作用是酶解与核酸结合的组蛋白，使 DNA 游离在溶液中，随后用不同方法进行抽提，除去杂质，收集 DNA。</p><h4 id="溶菌酶"><a class="header-anchor" href="#溶菌酶"></a>溶菌酶</h4><p>是一类水解细菌细胞壁中肽聚糖的酶，破碎细菌细胞壁，主要用于提取质粒和原核生物 DNA。</p><h2 id="第三章-基因工程载体"><a class="header-anchor" href="#第三章-基因工程载体"></a>第三章 基因工程载体</h2><p><a id="Noun载体"></a><font color="#ea66a6">载体</font>（Vectors）：在基因工程操作中，把能携带外源 DNA 或基因进入宿主细胞的 DNA 分子叫载体。<a  href="#Back载体">↩</a></p><p>理想基因工程对载体的要求：</p><ol><li>在宿主细胞内能独立复制。</li><li>有选择性标记，用于筛选。</li><li>具备合适的酶切位点，外源 DNA 插入其中不影响载体的复制。</li><li>分子量小，拷贝数多。</li><li>容易从宿主细胞中分离纯化。</li></ol><p>载体的功能：</p><ul><li>运送外源基因高效转入受体细胞</li><li>为外源基因提供复制能力或整合能力</li><li>为外源基因的扩增或表达提供必要的条件</li></ul><p><a href="#Q8">载体的种类</a></p><h3 id="质粒载体"><a class="header-anchor" href="#质粒载体"></a>质粒载体</h3><p><a id="Noun质粒"></a> <font color="#ea66a6">质粒</font>（plasmid）：是独立于染色体以外的能自主复制的双链闭合环状 DNA 分子。存在于细菌、霉菌、蓝藻、酵母等细胞中。<a  href="#Back质粒">↩</a></p><h4 id="质粒的一般特性"><a class="header-anchor" href="#质粒的一般特性"></a>质粒的一般特性</h4><ol><li>分子小：1 ～ 200 kb</li><li>编码基因少：2 ～ 3 个中等大小的蛋白质。如抗菌素抗性、代谢特征等</li><li>环形状：双链环状 DNA。（酵母的“杀伤质粒”是 RNA）</li><li>质粒的三种空间构型：<ul><li>共价闭合环状 DNA（cccDNA)，呈超螺旋（SC）（super coil）</li><li>开环 DNA（open circular，ocDNA），一条链上有一至数个缺口。</li><li>线形 DNA（linear，lDNA）</li></ul></li><li>质粒空间构型与电泳速率</li></ol><h4 id="质粒-DNA-的生物学特性"><a class="header-anchor" href="#质粒-DNA-的生物学特性"></a>质粒 DNA 的生物学特性</h4><ol><li>不相容性（不亲和性）：有相同复制起始区的不同质粒不能共存于同一宿主细胞中。该不相容性的分子基础主要是由于它们在复制功能之间的相互干扰造成的。</li><li>复制类型：<ul><li>严谨型质粒的复制受到宿主细胞蛋白质合成的严格控制</li><li>松弛型质粒的复制不受宿主细胞蛋白质合成的严格控制。</li></ul></li><li>质粒转移性，在大肠杆菌中的质粒，可以分为：<ul><li>接合型质粒，能自我转移，如 F 质粒（F 因子）</li><li>非接合型质粒，不能自我转移，如：R 质粒（抗性质粒）</li></ul></li></ol><p>大肠杆菌接合（conjunction）：F 因子携带基因编码的蛋白质能使两个细菌间形成纤毛状细管连接的接合（conjugation），通过这细管遗传物质可在两个细菌间传递。</p><p>组建理想质粒载体必须具备的条件，见 <a href="#Q8">理想载体至少必备的条件有哪些</a></p><p>抗菌素选择原理：不带有抗菌素抗性基因的受体菌不能在含有抗菌素的培养基（选择培养基）中生长。当带有抗菌素抗性基因的载体进入受体菌后，受体菌才能生长。</p><p>TODO 蓝白斑试验、乳糖操纵子调节机制</p><h4 id="质粒载体的改造"><a class="header-anchor" href="#质粒载体的改造"></a>质粒载体的改造</h4><ol><li>去掉不必要的 DNA 区段。</li><li>减少限制酶的识别位点，一种酶只保留一个。（单一的限制性酶切位点）。</li><li>加入易于捡出的选择性标记基因。</li><li>对质粒进行安全性改造，要求质粒不能随便转移。</li><li>改造或增加基因表达的调控序列。</li></ol><h4 id="常用的质粒载体"><a class="header-anchor" href="#常用的质粒载体"></a>常用的质粒载体</h4><p>pBR322，松弛型复制，拷贝数 50 ～ 100 / cell，用于基因克隆</p><p>pUC18/19，拷贝数 500 ～ 700/cell，装有多克隆位点（MCS），正选择颜色标记 <em>lacZ</em>’，用于基因克隆和测序</p><p>重组子的检测：pUC18 质粒结构中具有来自大肠杆菌 <em>lac</em> 操纵子的 <em>lacZ</em>’ 基因，所编码的 α-肽链可参与 α-互补作用。因此，在应用 pUC18 质粒为载体的重组实验中，可用 X-gal 显色法一步实现对重组子克隆的鉴定。</p><h3 id="噬菌体载体"><a class="header-anchor" href="#噬菌体载体"></a>噬菌体载体</h3><p>噬菌体是一类细菌病毒（Bacteriophage）</p><p>噬菌体的结构：蛋白质外壳内包裹着 DNA（双链、单链、线性、环状等）。</p><p>λ DNA 分子的特点：</p><ol><li>长度为 48502 bp;</li><li>双链线性 DNA;</li><li>λ 噬菌体包装 DNA 的大小为原 λ DNA 长度的 78 ～ 105%（38 ～ 54 kb）</li><li>两端有 cos 位点，可以环化。</li></ol><p>cos 位点（cohensive-end site）：λ DNA 两端各有 12 bp 的粘性末端，粘性末端形成的双链区域称为 cos 位点。</p><p>噬菌体的生活周期：</p><ol><li>溶菌周期（裂解循环），烈性噬菌体（virulent phage)</li><li>溶原周期，温和噬菌体（temperate phage）感染细菌后，将自己的 DNA 整合到细菌的染色体 DNA 中。形成这一过程称为<font color="#ea66a6">溶源化</font></li></ol><p>烈性噬菌体溶菌生长的基本过程：</p><ol><li>吸附，吸附到位于感染细胞表面的特殊接受器上。</li><li>注入，噬菌体 DNA 穿过细胞壁注入寄主细胞。</li><li>转变，被感染的细胞成为制造噬菌体颗粒的场所。</li><li>合成，大量合成噬菌体特有的核酸和蛋白质。</li><li>组装，包装了 DNA 头部和尾部组装成噬菌体的颗粒。</li><li>释放，合成的子代噬菌体颗粒从寄主细胞内释放出来。</li></ol><p>向溶原和裂解方向的转变由感染复数和细胞的营养状态决定的，感染复数越高和营养状态越差，向溶原方向的频率就越高。</p><h4 id="λ-噬菌体的基因组结构"><a class="header-anchor" href="#λ-噬菌体的基因组结构"></a>λ 噬菌体的基因组结构</h4><p>λ 噬菌体基因组至少可编码 30 个基因，根据功能不同分为 3 个区：</p><ol><li><em>Nul</em> 基因到 <em>J</em> 基因：其产物用于噬菌体 DNA 的包装和噬菌体颗粒的形成。</li><li><em>J</em> 基因到 <em>gam</em> 基因：编码基因调节、溶原状态的发生和维持以及遗传重组所需基因，其中许多基因是非必需，在构建载体是可以去掉，用外源 DNA 替代。</li><li><em>gam</em> 基因至 <em>Rz</em> 基因：包含噬菌体复制和裂解宿主所需的基因。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/452345345.3mu8l6boxvg0.svg" alt="452345345"></p><h4 id="噬菌体载体改造"><a class="header-anchor" href="#噬菌体载体改造"></a>噬菌体载体改造</h4><p>λ-DNA 载体的构建（一）：删除重复的酶切位点</p><ol><li>野生型的 λ-DNA 链上有 5 个 <em>Eco</em>RⅠ 位点和 7 个 <em>Hin</em>dⅢ位点，不利于重组操作，必须删除至 1 ～ 2 个</li><li>为了便于各种来源的 DNA 片段的克隆，还需要增加一些单一的酶切位点</li><li>除了简单的切割外，还需要采用定点突变技术去除或增添酶位点</li></ol><p>λ-DNA 载体的构建（二）：加装选择标记，与质粒不同，野生型 λ-DNA 上缺少合适的选择标记，因此加装选择标记是 λ-DNA 克隆载体构建的重要内容</p><p>λ-DNA 克隆载体上的选择标记主要有下列两类：</p><ul><li>免疫功能类标记</li><li>颜色反应类标记</li></ul><p>详见 <a href="#Q11">简述 λ 噬菌体的三种选择标记</a></p><p>λ 噬菌体载体的两种类型：</p><ol><li>置换型（replacement），可被外源 DNA 置换 λ 噬菌体非必需区的载体。两侧有一对限制性酶切位点的载体。插入外源 DNA 片段一般为 6 kb，最大 11 kb</li><li>插入型（insertion），含一个限制性位点可供插入外源 DNA 的载体，这类 λ 噬菌体载体称插入型载体。非必需区已经去除。插入外源 DNA 片段大小为 9 ～ 23 kb</li></ol><p>克隆原理及步骤，结合 λ 包装过程</p><ol><li>通过裂解过程增殖载体、回收、纯化</li><li>酶切、载体与外源 DNA</li><li>连接</li><li>体外包装</li><li>感染/铺平板</li><li>筛选</li></ol><p>λ-DNA 重组分子的体外包装：</p><p>λ-DNA 重组分子需在体外人工包装成有感染力的噬菌体重组颗粒，方可高效导入受体细胞。</p><p>用于体外包装的蛋白质可直接从感染了 λ 噬菌体的大肠杆菌中提取，现已商品化。这些包装蛋白通常分为相互互补的两部分：一部分缺少 E 组份，另一部分则缺少 D 组份。包装时，当且仅当这两部分包装蛋白与重组 λ-DNA 分子混合后，包装才能有效进行，任何一种蛋白包装液被重组 λ-DNA 污染后，均不能被包装成有感染力的噬菌体颗粒，这也是基于安全而设计的。</p><p>λ-DNA 载体的优点：比一般的质粒载体的容量大的多。用在真核生物基因组文库的建立。</p><h2 id="第四章-人工染色体载体"><a class="header-anchor" href="#第四章-人工染色体载体"></a>第四章 人工染色体载体</h2><p>常规载体在工作时都是在不影响质粒或噬菌体复制功能的基础上装载外源 DNA 片段的，同时保持质粒或噬菌体的基本特性。但这些载体体所装载的容量有限。<font color="#faa755">利用染色体的复制元件来驱动外源DNA片段的载体称为人工染色体载体</font>，其装载外源 DNA 片段的容量可以与染色体的大小媲美。</p><p><a id="Noun人工染色体载体"></a><font color="#ea66a6">人工染色体载体</font>：利用染色体的复制元件来驱动外源 DNA 片段复制的载体称为人工染色体载体。<a  href="#Back人工染色体载体">↩</a></p><p>模拟染色体的复制方式，因此都能装载大片段的 DNA 片段。</p><p>目前常用的人工染色体载体包括：</p><ul><li>黏粒载体（cosmid）</li><li>酵母人工染色体载体（YAC）</li><li>细菌人工染色体载体（BAC）</li></ul><h3 id="黏粒载体"><a class="header-anchor" href="#黏粒载体"></a>黏粒载体</h3><p><a id="Noun黏粒载体"></a><font color="#ea66a6">黏粒载体</font>（Cosmid）又叫柯斯质粒载体，这是一种由人工构建的含有 λ 噬菌体 DNA 的 cos 位点和质粒复制子的特殊类型的杂和质粒载体，具有质粒和噬菌体的双重特征，被称为 cosmid，指带有粘性末端位点的质粒。<a  href="#Back黏粒载体">↩</a></p><p>柯斯质粒在结构组成上具有 λ 噬菌体的特性，也具有质粒载体的特性和高容量的克隆能力，一般可插入 30 ～ 45 kb 的外源基因，是构建<font color="#faa755">真核生物基因文库</font>的主要载体。</p><h4 id="黏粒载体构成"><a class="header-anchor" href="#黏粒载体构成"></a>黏粒载体构成</h4><ul><li>λ 噬菌体 DNA：cos位点</li><li>质粒：复制子、抗药性基因、多克隆位点</li></ul><h4 id="黏粒载体特点"><a class="header-anchor" href="#黏粒载体特点"></a>黏粒载体特点</h4><ol><li>含有噬菌体 DNA 的粘性末端 cos 位点，可像 λ 噬菌体 DNA 一样被噬菌体包装蛋白包装，能并高效导入受体细胞</li><li>具质粒复制起始位点，可像质粒一样在细菌中复制</li><li>带有抗药性基因，如 <em>Amp</em> <sup>r</sup>、<em>Tet</em> <sup>r</sup>，易筛选</li><li>具一个或多个限制酶酶切位点，插入外源 DNA</li><li>分子量较小（5 ～ 7 kb），但能容纳较大的 DNA 片段</li></ol><h4 id="与-λ-噬菌体-DNA-的差异"><a class="header-anchor" href="#与-λ-噬菌体-DNA-的差异"></a>与 λ 噬菌体 DNA 的差异</h4><ol><li>缺少噬菌体复制起点，进入细菌后不能像噬菌体一样复制；</li><li>除 cos 位点外，λ 基因组的其余部分都被切割掉，具有高容量的克隆能力，最大可插入 30 ～ 45 kb 的片段；</li><li>柯斯质粒进入细胞后，质粒的复制子进行复制。</li></ol><h4 id="克隆原理及步骤"><a class="header-anchor" href="#克隆原理及步骤"></a>克隆原理及步骤</h4><ol><li>分离外源 DNA 片段 30 ～ 45 kb</li><li>外源 DNA 与黏粒载体相连</li><li>体外包装：在 λ 的 A 蛋白的末端酶功能作用下切割 cos 位点，且 cos 方向相同，并将包装到成熟的 λ 噬菌体颗粒中去</li><li>感染 E.coli：线状的重组 DNA 被注入细胞，通过 cos 位点的环化形成黏粒载体，像质粒一样复制</li></ol><h3 id="酵母人工染色体"><a class="header-anchor" href="#酵母人工染色体"></a>酵母人工染色体</h3><p>YAC 是酵母人工染色体（Yeast artificial chromosome）的缩写，是目前能容纳最大外源 DNA 片段（100 万碱基以上）的载体</p><p>把酵母染色体与基因复制和表达有关的主要部件都组装在质粒上，令质粒行使酵母的转录和复制功能</p><p>YAC 只以<font color="#faa755">单抄本方式繁殖</font>，所以不适用于以生产为目的的基因工程。要用于在酵母中构建大片段 DNA 文库特别用来构建高等真核生物的基因组文库，人类基因组研究和巨大基因如 DMD 基因达 Mbp（10<sup>6</sup> bp）数量级基因的克隆，并不用作常规的基因克隆。</p><h4 id="YAC-的基本序列元件"><a class="header-anchor" href="#YAC-的基本序列元件"></a>YAC 的基本序列元件</h4><p>YAC 载体为满足自主复制、染色体在子代细胞间的分离及保持染色体稳定的需要，必须含有以下元件：</p><ul><li>酵母染色体 DNA 自主复制顺序（ARS）：染色体自主复制起点, 如 ARS1 酵母复制起始子</li><li>酵母染色体的着丝粒顺序（CEN）：保证酵母细胞分裂时染色体的分配</li><li>酵母染色体的端粒重复顺序（TEL）：（两端各一个）维持染色体结构的稳定性，确保染色体完整性，维持染色体成为线状，保护染色体末端免受核酸酶侵袭</li><li>选择标记：用于重组克隆的筛选。在细菌和酵母菌中选择的标记基因，含有 Amp 大肠杆菌筛选标记；TRP1 色氨酸生物合成基因, URA3 尿嘧啶生物合成基因</li><li>克隆位点</li></ul><blockquote><p>YAC 载体的选择标记主要采用营养缺陷型基因：如色氨酸合成酶基因 trp 1和尿嘧啶合成酶基因 ura3 等</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.16c51ugy0qqk.png" alt="image"></p><p>YAC 载体应含有下列元件：</p><ul><li>酵母染色体的端粒序列（<em>TEL</em>）</li><li>酵母染色体的复制子（<em>APS1</em>）</li><li>酵母染色体的着丝粒序列（<em>CEN4</em>）</li><li>酵母系统的选择标记（<em>URA3</em>）</li><li>大肠杆菌的复制子标记（<em>ori</em>）</li></ul><p>YAC 载体的装载量为：250 ～ 400 kb</p><p>YAC 载体的工作原理、主要用途以及其缺点，见 <a href="#Q12">简述 YAC 载体的工作原理、应用以及其缺点</a></p><h3 id="细菌人工染色体载体"><a class="header-anchor" href="#细菌人工染色体载体"></a>细菌人工染色体载体</h3><p>细菌人造染色体通常是在大肠杆菌性因子 F 质粒的基础上构建的，其装载量范围在 120 ～ 300 kb 之间。</p><ul><li>基于细菌性因子（F 因子）的复制点和氯霉素抗性标记基因，在 F 质粒（pMBO131）基础上构建了高容量的第一代 BAC 人工染色体（300 kb）</li><li>BAC 载体在重组缺陷型（REC-）宿主菌只有 1 个拷贝，有利于保持 DNA 大分子，尤其是重复序列多的 DNA 大分子，在细胞内稳定复制而不发生重组</li><li>F 因子（100 kb）又称致育因子，在细菌细胞内能自我复制，能整合到宿主染色体中。因其低拷贝特性使其重排和嵌合程度低。且 F 因子呈闭环结构，可以用常规技术从大肠杆菌中分离</li></ul><h4 id="细菌人工染色体的结构"><a class="header-anchor" href="#细菌人工染色体的结构"></a>细菌人工染色体的结构</h4><ol><li>F 因子的 parA，parB，parC 基因以保证单拷贝的 BAC 质粒在大肠杆菌分裂时均匀分配到子代细胞</li><li>起始 oriS 基因，严密控制，决定低拷贝和起始</li><li>解旋酶基因 repC，易于 DNA 复制和决定复制方向</li><li>选择标志基因 Cm<sup>r</sup> 氯霉素抗性基因</li><li>lacZ 基因，颜色鉴别重组子，外源基因插入其中</li><li>loxP 和 cosN 位点，易于克隆 DNA 回收和操作</li><li>在多克隆位点两侧，还有 T7 及 SP6 启动子位点，用于制备 RNA 分子，进一步分析克隆的基因表达，作为染色体步行的探针，以及序列测定克隆的片段</li></ol><h4 id="BAC-载体与质粒载体的异同点"><a class="header-anchor" href="#BAC-载体与质粒载体的异同点"></a>BAC 载体与质粒载体的异同点</h4><p>BAC 载体的工作原理与常规的质粒载体相似。</p><p>不同的是：</p><ul><li>BAC 载体装载的是大片段 DNA，一般在 100 Kb ～ 300 Kb 。</li><li>BAC 载体的拷贝数小，制备难度大。</li></ul><h4 id="BAC-基因组文库的构建"><a class="header-anchor" href="#BAC-基因组文库的构建"></a>BAC 基因组文库的构建</h4><ol><li>BAC 载体的制备：BAC DNA的分离、BAC DNA经酶切（<em>Hin</em>d Ⅲ）线性化、去磷酸化反应</li><li>高分子量基因组 DNA 的制备：大分子量 <em>Hin</em>dⅢ 酶切片段的制备、脉冲电泳选择酶切片段</li><li>BAC 克隆</li><li>电转化</li><li>BAC 克隆鉴定</li></ol><h4 id="BAC-载体用途"><a class="header-anchor" href="#BAC-载体用途"></a>BAC 载体用途</h4><p>各种类型的 pBACs 在大肠杆菌受体菌只能维持单一拷贝 pBACs 主要适用于：</p><ul><li>克隆大型基因簇（gene cluster）结构</li><li>构建动植物基因文库</li></ul><h3 id="载体的种类和特征"><a class="header-anchor" href="#载体的种类和特征"></a>载体的种类和特征</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E8%BD%BD%E4%BD%93%E7%9A%84%E7%A7%8D%E7%B1%BB%E5%92%8C%E7%89%B9%E5%BE%81.4g287gqvj8o0.svg" alt="载体的种类和特征"></p><h3 id="四种常用载体的比较"><a class="header-anchor" href="#四种常用载体的比较"></a>四种常用载体的比较</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%9B%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%BD%BD%E4%BD%93%E7%9A%84%E6%AF%94%E8%BE%83.60n91opoces0.svg" alt="四种常用载体的比较"></p><h2 id="第五章-核酸提取及电泳技术"><a class="header-anchor" href="#第五章-核酸提取及电泳技术"></a>第五章 核酸提取及电泳技术</h2><h3 id="DNA-提取方法"><a class="header-anchor" href="#DNA-提取方法"></a>DNA 提取方法</h3><p>DNA 提取的几种方法:</p><ul><li>质粒 DNA 的提取：碱裂解法、煮沸法</li><li>基因组 DNA 的提取：CTAB 法、SDS 法、苯酚抽提法</li></ul><h4 id="质粒-DNA-的提取"><a class="header-anchor" href="#质粒-DNA-的提取"></a>质粒 DNA 的提取</h4><p>碱裂解法和煮沸法抽提质粒 DNA 原理，见 <a href="#Q13">碱裂解法和煮沸法抽提质粒 DNA 的原理</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E7%A2%B1%E8%A3%82%E8%A7%A3%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.3c7sygnede60.svg" alt="碱裂解法流程图"></p><h4 id="基因组-DNA-的提取-——-CTAB-法"><a class="header-anchor" href="#基因组-DNA-的提取-——-CTAB-法"></a>基因组 DNA 的提取 —— CTAB 法</h4><p>CTAB 法原理（植物 DNA 提取经典方法）</p><p>CTAB（hexadecyltrimethylammonium bromide，十六烷基三甲基溴化铵），<font color="#faa755">是一种阳离子去污剂，可溶解细胞膜，并与核酸形成复合物</font>。</p><p>该复合物在高盐溶液中（&gt; 0.7 mol/L NaCl）是可溶的，通过有机溶剂抽提，去除蛋白、多糖、酚类等杂质后加入乙醇沉淀即可使核酸分离出来。</p><blockquote><p>注：CTAB 溶液在低于 15℃ 时会形成沉淀析出，因此在将其加入冰冷的植物材料之前必须预热至 60℃ ，且离心时温度不要低于 15℃。</p></blockquote><p>CTAB 提取缓冲液的经典配方：</p><table><thead><tr><th>组份</th><th>Tris-HCl（pH 8.0）</th><th>EDTA （pH8.0）</th><th>NaCl</th><th>CTAB</th><th>β-巯基乙醇</th></tr></thead><tbody><tr><td>终浓度</td><td>100 mM</td><td>20 mM</td><td>1.4M</td><td>2%(W/V)</td><td>0.1%（V/V）使用前加入</td></tr></tbody></table><ul><li>Tris-HCl（pH 8.0）提供一个缓冲环境，防止核酸被破坏；</li><li>EDTA 螯合 Mg<sup>2+</sup> 或 Mn<sup>2+</sup> 离子，抑制 DNase 活性；</li><li>NaCl 提供一个高盐环境，使 DNA 充分溶解，存在于液相中；</li><li>CTAB 溶解细胞膜，并结合核酸，使核酸便于分离；</li><li>β-巯基乙醇是抗氧化剂，有效地防止酚氧化成醌，避免褐变，使酚容易去除</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/CTAB%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.o9hn9jum3f4.svg" alt="CTAB法流程图"></p><h4 id="基因组-DNA-的提取-——-SDS-法"><a class="header-anchor" href="#基因组-DNA-的提取-——-SDS-法"></a>基因组 DNA 的提取 —— SDS 法</h4><p>SDS 法原理：</p><ul><li>SDS 是一种离子型表面活性剂，在高温（55 ～ 65℃）条件下能溶解细胞膜和核膜蛋白，裂解细胞膜和核膜，使染色体离析，蛋白变性，释放出核酸；</li><li>上清液中的 DNA 用酚/氯仿抽提，反复抽提后用乙醇沉淀水相中的 DNA。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/SDS%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.3l3m5mnu21i0.svg" alt="SDS法流程图"></p><h4 id="DNA-提取的基本步骤"><a class="header-anchor" href="#DNA-提取的基本步骤"></a>DNA 提取的基本步骤</h4><ol><li>材料准备</li><li>破碎细胞或包膜－内容物释放</li><li>核酸分离、纯化</li><li>沉淀或吸附核酸，并去除杂质</li><li>核酸溶解在适量缓冲液或水中</li></ol><p>材料准备：</p><p>基因组 DNA 的提取</p><ul><li>最好使用新鲜材料，低温保存的样品材料不要反复冻融</li><li>提取血液基因组 DNA 时，要选择有核细胞（白细胞）</li><li>组培细胞培养时间不能过长，否则会造成 DNA 降解</li><li>含病毒的液体材料 DNA 含量较少，提取前先富集</li></ul><p>质粒 DNA 的提取</p><ul><li>使用处于对数期的新鲜菌体（老化菌体导致开环质粒增加）</li><li>培养时应加入筛选压力，否则菌体易污染，质粒易丢失</li><li>尽量选择高拷贝的质粒，如为低拷贝或大质粒，则应加大菌体用量</li><li>菌株不要频繁转接（质粒丢失）</li></ul><p>细胞裂解：</p><p>基因组 DNA 的提取</p><ul><li>材料应适量，过多会影响裂解，导致DNA量少，纯度低</li><li>针对不同材料，选择适当的裂解预处理方式：植物材料（液氮研磨）、动物组织（匀浆或液氮研磨）、组培细胞（蛋白酶 K）、细菌（溶菌酶破壁）、酵母（破壁酶或玻璃珠）</li><li>高温温浴时，定时轻柔振荡</li></ul><p>质粒 DNA 的提取</p><ul><li>菌体量适当</li><li>培养基去除干净，同时保证菌体在悬浮液中充分悬浮</li><li>变性的时间不要过长（5分钟），否则质粒易被打断</li><li>复性时间也不宜过长，否则会有基因组 DNA 的污染</li><li>G<sup>+</sup>菌、酵母质粒的提取，应先用酶法或机械法处理破壁</li></ul><p>基因组 DNA 的提取和质粒 DNA 的提取的核酸分离、纯化：</p><ul><li>采用有机（酚/氯仿）抽提时应充分混匀，但动作要轻柔</li><li>酚/氯仿抽提去除蛋白质</li><li>在待沉淀溶液中加入 1/2 体积的 5 M NaCl，高盐可溶解多糖，去除多糖</li><li>70％ 的乙醇洗涤去除盐离子</li></ul><h4 id="DNA-的定量和纯度测定"><a class="header-anchor" href="#DNA-的定量和纯度测定"></a>DNA 的定量和纯度测定</h4><ul><li>紫外分光光度计测定</li><li>琼脂糖凝胶电泳估算</li></ul><p>紫外分光光度计测定</p><ul><li>DNA/RNA 在 260 nm 处有最大的吸收峰</li><li>蛋白质在 280 nm 处有最大的吸收峰</li><li>盐和小分子则集中在 230 nm 处</li></ul><p>测浓度：对标准样品来说，浓度为 1 μg/ml 时，DNA 钠盐的 OD<sub>260</sub> = 0.02，当 OD<sub>260</sub> = 1 时，dsDNA 浓度约为 50 μg/ml。DNA（mg/ml）= 50 ×  OD<sub>260</sub> 读数 × 稀释倍数 / 1000</p><p>测纯度：DNA/RNA 纯品的 OD<sub>260</sub> / OD<sub>280</sub> 为 1.8 左右，故根据 OD<sub>260</sub> / OD<sub>280</sub> 的值可以估计 DNA 的纯度。</p><ul><li>若比值大于 1.9 说明含有 RNA</li><li>比值小于 1.6 说明有残余蛋白质、酚类等存在。</li></ul><p>琼脂糖凝胶电泳估算：EB 能嵌入 DNA 平面结构，在 300 nm 的紫外光照下能发色红光。荧光强度与 DNA 含量及大小成正比。通过与已知 Marker 条带的亮度对比来估计目的 DNA 的含量。</p><h3 id="电泳技术"><a class="header-anchor" href="#电泳技术"></a>电泳技术</h3><p>电泳的概念：带电物质在电场中向相反电极移动的现象称为电泳（electrophoresis）。</p><p>电泳现象早在十九世纪初就已发现（1808 年俄国物理学家 Reŭss 进行了世界上第一次电泳实验）。但电泳技术的广泛应用，则是在 1937 年用滤纸作为支持介质成功地进行纸电泳以后，特别是近几十年以来，电泳技术发展很快，各种类型的电泳技术相继诞生，在生物化学、医学、免疫学等领域得到了广泛应用。</p><p>琼脂糖凝胶电泳：琼脂糖凝胶孔径相对较大，其分辨率较低，一般用于核酸的分离分析。</p><p>聚丙烯酰胺凝胶电泳：其分辨率较高，可用于核酸和蛋白质的分离、纯化及检测。</p><h4 id="电泳的基本原理"><a class="header-anchor" href="#电泳的基本原理"></a>电泳的基本原理</h4><p>在一定 pH 条件下，每一种分子都具有特定的电荷（种类和数量）、大小和形状，在一定时间内它们在相同电场中泳动速度不同，各自集中到特定的位置上而形成紧密的泳动带。这就是带电粒子可以用电泳技术进行分离、分析和鉴定的基本原理。</p><h4 id="琼脂糖凝胶电泳"><a class="header-anchor" href="#琼脂糖凝胶电泳"></a>琼脂糖凝胶电泳</h4><p>琼脂糖凝胶电泳是用琼脂或琼脂糖作支持介质的一种电泳方法。</p><p>琼脂糖凝胶约可区分相差 100 bp 的 DNA 片段，其分辨率虽比聚丙烯酰胺凝胶低，但它制备容易，分离范围广，尤其适于分离大片段 DNA。普通琼脂糖凝胶分离 DNA 的范围为 0.2 ～ 20 kb。</p><p>安全的核酸染料：溴化乙啶（EB）是一种最常用的物美价廉的核酸染料，有致癌性。因此，近年来数种较为安全的核酸染料在逐步取代 EB 的应用，如 SYBRGreen、GeneFinder 和 GoldView 核酸荧光染料，GeneFinder 和 Glod View 染色后的条带可以在紫外灯下观察、照相，在可见光（400 ～ 500 nm 的蓝绿光）透射仪下观察条带呈绿色。</p><p>琼脂糖凝胶中 RNA 的检测：RNA 分析前需要变性，加入甲醛变性剂，使 RNA 分子内的氢键打开，除去二级结构。</p><p>影响 DNA 迁移率的因素：</p><ul><li>DNA 分子的大小、构象，凝胶浓度，电压，电泳缓冲液的组成等</li><li>DNA 带负电荷，迁移率与分子量对数成反比，DNA 片段越长，泳动速度越慢</li><li>DNA 分子构象影响迁移率：共价闭环 DNA &gt; 线状 DNA &gt; 开环 DNA</li><li>泳动速度与凝胶浓度成反比</li><li>在低电压时，泳动速度与电场强度成正比</li><li>电泳缓冲液的组成及其离子强度影响 DNA 的电泳迁移率。</li></ul><h4 id="聚丙烯酰胺凝胶电泳"><a class="header-anchor" href="#聚丙烯酰胺凝胶电泳"></a>聚丙烯酰胺凝胶电泳</h4><p>聚丙烯酰胺凝胶电泳（polyacrylamide gel electropho-resis，PAGE）是以聚丙烯酰胺凝胶作为支持介质的一种电泳方法。是由丙烯酰胺单体（简称Acr）和交联剂 N,N-甲叉双丙烯酰胺（简称 Bis）在催化剂作用下合成的。Acr 和 Bis 两种都有神经毒性，需带 PE 手套。</p><p>凝胶孔径大小，主要受凝胶浓度的影响。凝胶浓度越大，孔径越小。凝胶浓度过大，胶硬而脆，易折断；浓度过小，凝胶稀软，不易操作，也易断裂。</p><p>聚丙烯酰胺凝胶电泳可很好分辨 100 ～ 1000 bp，其分辨率可达 1 bp。</p><p>聚丙烯酰胺凝胶电泳:</p><ul><li>非变性：检测 DNA（PAGE）</li><li>变性：检测蛋白质（SDS-PAGE）</li></ul><h3 id="PCR-技术及其应用"><a class="header-anchor" href="#PCR-技术及其应用"></a>PCR 技术及其应用</h3><p>体外扩增特异 DNA 片段的技术，能快速、特异地扩增目的 DNA 片段。能通过试管内的数小时反应将特定的 DNA 片段扩增数百万倍。迅速获取大量的单一核酸片段，为分子生物学研究提供了强大的工具。</p><h4 id="PCR-的原理"><a class="header-anchor" href="#PCR-的原理"></a>PCR 的原理</h4><ul><li>由一对引物介导，通过温度的调节，使双链 DNA 变性为单链 DNA、单链 DNA 与引物复性（退火）成为引物-DNA 单链复合物、以及在 dNTPs 存在下 DNA 聚合酶使引物延伸而成为双链 DNA（引物的延伸）；</li><li>这种热变性-复性-延伸的过程，就是一个 PCR 循环；</li><li>一般通过 20 ～ 30 个循环之后，就可获得大量的要扩增的 DNA 片段。</li></ul><h4 id="PCR-反应体系"><a class="header-anchor" href="#PCR-反应体系"></a>PCR 反应体系</h4><p><font color="#d9730d">PCR 反应体系包含</font>：</p><ul><li>模板 DNA</li><li>Taq 酶（Taq DNA polymerase）</li><li>dNTP</li><li>引物（Primers）（上游、下游）</li><li>缓冲液体系（buffer）</li><li>Mg<sup>2+</sup></li><li>ddH<sub>2</sub>O</li></ul><ol><li>模板变性 (Denaturation)，双链 DNA 模板在 95℃ 变性为单链 DNA。</li><li>引物退火 (Annealing)，引物与单链 DNA 互补并退火。</li><li>延伸反应 (Extention) ，耐热的 DNA 聚合酶催化子链的合成。</li></ol><h4 id="PCR-反应条件的设定"><a class="header-anchor" href="#PCR-反应条件的设定"></a>PCR 反应条件的设定</h4><p>待扩增片段：1000 bp<br>引物 Tm ＝ 37 ～ 72℃</p><p>DNA 模板变性: 94℃, 5分钟;<br>PCR 循环 (30 次):94℃, 30秒; 50℃, 30秒; 72℃, 1分钟;<br>最终延伸:72℃, 7 ～ 10分钟</p><h4 id="引物（寡核苷酸引物）"><a class="header-anchor" href="#引物（寡核苷酸引物）"></a>引物（寡核苷酸引物）</h4><p>引物：引物是 PCR 特异性反应的关键，PCR 产物的特异性取决于引物与模板 DNA 互补的程度。理论上，只要知道任何一段模板 DNA 序列，就能按其设计互补的寡核苷酸链做引物，利用 PCR 就可将模板 DNA 在体外大量扩增。</p><p>引物是与待扩增DNA片断两翼互补的一段特异的寡核苷酸片断。</p><p>引物的作用：决定 PCR 扩增产物的特异性与长度，决定 PCR 反应的成败。</p><p>引物设计的原则，见 <a href="#Q18">引物设计需遵循的原则有哪些</a></p><h4 id="PCR-的类型"><a class="header-anchor" href="#PCR-的类型"></a>PCR 的类型</h4><ul><li>标准 PCR</li><li>长 PCR (Long PCR)：PCR 产物 &gt; 5 kb</li><li>巢式 PCR (Nested PCR)</li><li>反向 PCR (Inverse PCR)</li><li>菌落 PCR (Colony PCR)</li><li>逆 (反) 转录 PCR (RT-PCR)</li><li>实时定量 PCR (Real Time Quantitative PCR, qRT-PCR)</li></ul><p><a id="Noun反向PCR"></a><font color="#ea66a6">反向 PCR</font> (reverse PCR) ：用反向的互补引物来扩增两引物以外的 DNA 片段，对某个已知 DNA 片段两侧的未知序列进行扩增。可对未知序列扩增后进行分析，如探索邻接已知 DNA 片段的序列；用于仅知部分序列的全长 cDNA 的克隆, 建立基因组步移文库。<a  href="#Back反向PCR">↩</a></p><p><font color="#ea66a6">实时荧光 PCR 技术</font>：通过荧光染料或荧光标记的特异性的探针，对 PCR 产物进行标记跟踪，实时在线监控反应过程；结合相应的软件可以对结果进行分析，计算待测样品的初始模板量。</p><h4 id="PCR-的应用领域"><a class="header-anchor" href="#PCR-的应用领域"></a>PCR 的应用领域</h4><ul><li>生物学基础研究：目的基因扩增和鉴定；DNA序列测定；定点突变；基因表达分析</li><li>医学临床应用：遗传疾病基因诊断；致病病原体检测；癌基因检测；器官移植组织配型</li><li>法医学物证鉴定：个体识别；亲子鉴定</li><li>其他：动、植物检疫（转基因动植物检测）；生物物种鉴定，系统进化研究；分子考古学（恐龙 DNA 分析）等</li></ul><h2 id="第六章-基因工程的常规技术之分子杂交"><a class="header-anchor" href="#第六章-基因工程的常规技术之分子杂交"></a>第六章 基因工程的常规技术之分子杂交</h2><p><a id="Noun分子杂交"></a><font color="#ea66a6">分子杂交</font>：是一类核酸和蛋白质分析方法，用于检测混合样品中特定核酸分子或蛋白质分子是否存在，以及其分子量的大小。<a  href="#Back分子杂交">↩</a></p><p>根据其检测对象不同，可分为：</p><table><thead><tr><th>分子杂交</th><th>检测对象</th><th>探针</th></tr></thead><tbody><tr><td>Southern 杂交</td><td>DNA</td><td>核酸</td></tr><tr><td>Northern 杂交</td><td>RNA</td><td>核酸</td></tr><tr><td>Western 杂交</td><td>蛋白质</td><td>抗体</td></tr></tbody></table><p>以及由此而简化的斑点杂交、菌落杂交和原位杂交等。</p><h3 id="核酸分子杂交的基本原理"><a class="header-anchor" href="#核酸分子杂交的基本原理"></a>核酸分子杂交的基本原理</h3><p>带有互补核苷酸序列的单链 DNA 或 RNA，当它们混合在一起时，其相应的同源区段将会退火形成双链的结构，形成杂种核酸分子。</p><p>当用一个标记的核酸分子与核酸样品杂交,便可查明该样品中是否存在与该标记核酸分子具有同源性的核酸分子。<br>这个标记的核酸分子称为探针（probe），可以是 DNA，RNA 或合成的寡核苷酸。</p><p>用合适方法（如放射自显影或免疫组织化学等技术）把标记物检测出来，就可确定靶核苷酸序列的拷贝数及表达丰度等。</p><h3 id="分子杂交基本过程"><a class="header-anchor" href="#分子杂交基本过程"></a>分子杂交基本过程</h3><ol><li>核酸印迹（Nucleic acid blotting)：将核酸样品（DNA、RNA或蛋白质）在凝胶上分离，然后将样品通过影印的方式转移到固相支持物如滤膜上。</li><li>核酸杂交（Hybridization)：将印迹有核酸样品的滤膜同带有放射性标记或其它标记的 DNA 或 RNA 探针（Probe）或抗体进行杂交。</li><li>结果检测（Detection Results)：通过放射自显影或显色反应，判断样品中是否有与探针同源的核酸分子或与抗体反应的蛋白质分子。</li></ol><h3 id="Southern-杂交"><a class="header-anchor" href="#Southern-杂交"></a>Southern 杂交</h3><p>Southern 杂交原理：通过毛细管作用、电转移、真空转膜等方法，使在凝胶电泳中已分离的 DNA 片段转移并结合到适当的滤膜上，然后通过同已标记的探针进行杂交，以检测被转移 DNA 片段，称为 DNA 印迹杂交技术。</p><blockquote><p>在 1975 年，由英国的 E.Southern 首先设计发明的，因此又称为 Southern 杂交（Southern blotting)。</p></blockquote><p>Southern 杂交特点：</p><ul><li>作用对象：DNA 分子</li><li>DNA 片段需经凝胶电泳分离</li><li>固相支持物：可选用的滤膜种类较多</li><li>灵敏度高</li></ul><p>Southern 杂交过程：</p><ol><li>DNA 的片段化（限制性酶切）及其电泳分离</li><li>凝胶电泳后的变性处理，在 0.4 mol/L NaOH 碱性条件下变性，使双链 DNA 分子变成单链。再在 1.5 mol/L NaCl、1 mol/L Tris（pH 7.4）条件下中和使 DNA 仍保持单链状态。</li><li>转移并固定到滤膜上，通过毛细管渗吸或电转移或真空转移的方式，将凝胶上的 DNA 转移到硝酸纤维素滤膜或尼龙膜上。最后通过 80℃ 处理或紫外线照射将 DNA 固定在滤膜上。 转膜方法：毛细管虹吸印迹法、电转印法、真空转移法</li><li>探针的制备及杂交<ul><li>预杂交：将结合了 DNA 分子的滤膜先与特定的预杂液进行预杂交，也就是将滤膜的空白处用鱼精 DNA 或小牛血清蛋白封闭起来，防止在杂交过程中滤膜本身对探针的吸附。</li><li>标记与目的序列同源的核苷酸片段作为探针</li><li>杂交：在一定的溶液条件和温度下，将标记的核酸探针与滤膜混合，如果滤膜上的 DNA 分子存在与探针同源的序列，那么探针将与该分子形成杂合双链，从而吸在滤膜上。</li><li>洗膜：经过一定的洗涤程序将游离的探针分子除去。</li></ul></li><li>检测与分析<ul><li>通过放射自显影或生化检测，就可判断滤膜上是否存在与探针同源的 DNA 分子及其分子量。</li><li>Southern 杂交主要用来判断某一生物样品中是否存在某一基因（DNA 水平）。</li><li>Southern 杂交也可检测目的基因的拷贝数。</li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Southern%E6%9D%82%E4%BA%A4.405raphh4d20.svg" alt="Southern杂交"></p><p>常用的固相支持物：</p><ol><li>硝酸纤维素膜：优点是吸附能力强，杂交信号本底低。缺点是 DNA 分子结合不牢固，脆性大易破裂</li><li>尼龙膜：优点是结合单链，双链 DNA 的能力比硝酸纤维素膜强；缺点：杂交信号本底高</li><li>化学活化膜：优点：DNA与膜共价结合；对不同大小的DNA片段有同等结合能力；缺点：结合能力较上述两种膜低</li></ol><h3 id="Northern-杂交"><a class="header-anchor" href="#Northern-杂交"></a>Northern 杂交</h3><p>Northern 杂交原理：根据毛细管作用的原理，使在凝胶电泳中已分离的 RNA 转移并结合到适当的滤膜上，然后通过同已标记的探针进行杂交，以检测被转移 RNA 片段，称为 RNA 印迹杂交技术。</p><blockquote><p>在 1979 年，由 J. C. Alwine 等人设计，也称为 Northern 杂交（Northern blotting)。</p></blockquote><p>Northern 杂交特点：</p><ul><li>作用对象：RNA 分子</li><li>需经凝胶电泳分离</li><li>固相支持物：尼龙膜为主，结合牢固程度高</li><li>主要用于基因是否表达以及基因表达强弱的检测（RNA 水平）</li></ul><h3 id="Northern-印迹与-Southern-印迹的不同"><a class="header-anchor" href="#Northern-印迹与-Southern-印迹的不同"></a>Northern 印迹与 Southern 印迹的不同</h3><ol><li>转移的对象不同，Northern 印迹是将 RNA 变性及电泳分离后，将其转移到固相支持物上的过程。</li><li>虽然 RNA 电泳前不需像 DNA 那样进行酶切，但也需要变性。不过变性方法是不同的，它不能用碱变性，因为碱变性会导致 RNA 的降解</li></ol><h3 id="Western-杂交"><a class="header-anchor" href="#Western-杂交"></a>Western 杂交</h3><p>Western 杂交原理：在电场的作用下将电泳分离的蛋白质从凝胶转移至一种固相支持体，然后用这种蛋白质的特异抗体来检测。</p><p>Western 杂交的总体过程也与 Southern 杂交相似，只不过在印迹转移过程中转移的是蛋白质而不是 DNA，这种将蛋白质样品从 SDS-PAGE 凝胶通过电转移方式转移到滤膜的方法，称为 Western blotting<br>其后的杂交过程不是真实意义的分子杂交，而是通过抗体（探针）以免疫反应形式检测滤膜上是否存在被抗体识别的蛋白质，并判断其分子量。所用的探针不是 DNA 或 RNA，而是针对某一蛋白质制备的特异性抗体。</p><p>Western 杂交特点：</p><ul><li>Western 杂交主要用来检测细胞或组织样品中是否存在能被某抗体识别的蛋白质，从而判断在翻译水平上某基因是否表达。（<font color="#faa755">翻译水平</font>）</li><li>这种检测方法与其它免疫学方法的不同是，一方面可以避免非特异性的免疫反应，而且更关键的是可以检测出目标蛋白质的分子量，从而直观的在滤膜上显示出目标蛋白。</li></ul><p>Western Blot 流程</p><ol><li>蛋白样品的制备</li><li>SDS-PAGE 电泳</li><li>转膜</li><li>封闭</li><li>一抗杂交</li><li>二抗杂交</li><li>底物显色</li></ol><h3 id="斑点杂交"><a class="header-anchor" href="#斑点杂交"></a>斑点杂交</h3><p>斑点杂交原理：在 Southern 杂交的基础上发展起来的用于快速检测特异核酸分子的杂交技术。将核酸样品直接点到适当的滤膜上，然后进行杂交检测。</p><p>斑点杂交优点：</p><ol><li>快速简便，不需电泳分离</li><li>一次的检测量大</li><li>更适用于定量检测</li></ol><h3 id="菌落或噬菌斑杂交"><a class="header-anchor" href="#菌落或噬菌斑杂交"></a>菌落或噬菌斑杂交</h3><p>菌落或噬菌斑杂交原理：</p><ul><li>将菌落或噬菌斑直接转移到滤膜上，使溶菌变性的 DNA 同滤膜原位结合，然后进行杂交检测。</li><li>杂后根据杂交信号及其相对应的菌落或噬菌斑的位置，杂交便可从大量菌落或噬菌斑中筛选出含有目标序列（阳性克隆子）（与探针同源）的菌落或噬菌斑。</li></ul><h3 id="核酸杂交分类表"><a class="header-anchor" href="#核酸杂交分类表"></a>核酸杂交分类表</h3><table><thead><tr><th>杂交方法</th><th>适用范围</th></tr></thead><tbody><tr><td>Southern 印迹</td><td>检测经凝胶电泳分开的 DNA 分子，需转印到膜上</td></tr><tr><td>Northern 印迹</td><td>检测经凝胶电泳分开的 RNA 分子，需转印到膜上</td></tr><tr><td>斑点印迹杂交</td><td>检测未经分离的、固定在膜上的 DNA 或 RNA 分子</td></tr><tr><td>菌落或噬菌斑杂交</td><td>检测固定在膜上的、经裂解后从细菌或噬菌体中释放出的 DNA 分子</td></tr></tbody></table><h3 id="探针"><a class="header-anchor" href="#探针"></a>探针</h3><p>在一个核酸样品中查找是否存在某一特定序列的分子可用分子杂交来检测，但首先要有一段与目标核酸分子的序列同源的核酸片段。</p><p>将该片段标记后与样品核酸进行分子杂交，通过检测标记核酸的存在从而判断样品中特定核酸片段的存在。</p><p>用作检测的核酸片段即为探针（probe）。</p><h4 id="核酸探针的来源"><a class="header-anchor" href="#核酸探针的来源"></a>核酸探针的来源</h4><ul><li>基因组 DNA 探针</li><li>cDNA 探针</li><li>RNA 探针</li><li>寡核苷酸探针：人工合成、15 ～ 30 nt</li></ul><h4 id="探针的标记"><a class="header-anchor" href="#探针的标记"></a>探针的标记</h4><ol><li>均匀标记：间接标记不是标记探针分子本身，而是复制一段新的探针分子，在复制过程中掺入标记的核苷酸（如 [α-<sup>32</sup>P] dATP），从而使整个新分子被均匀地标记。</li><li>末端标记：直接将探针分子的某个原子替换为放射性同位素原子，或直接在探针分子上加入标记的原子或复合物，这种直接标记一般是在探针分子的末端进行标记，亦称末端标记。</li></ol><h4 id="常用的探针标记物"><a class="header-anchor" href="#常用的探针标记物"></a>常用的探针标记物</h4><table><thead><tr><th>标记物种类</th><th>主要标记物</th><th>特点</th></tr></thead><tbody><tr><td>放射性同位素标记物</td><td><sup>32</sup>P、<sup>35</sup>S、<sup>3</sup>H</td><td>灵敏度极高；不影响各种酶促反应；不影响碱基配对的特异性和稳定性；特异性高，假阳性少；污染环境；半衰期短；</td></tr><tr><td>非放射性标记物</td><td>生物素、地高辛、荧光素</td><td>安全；稳定性好；灵敏度和特异性较低；</td></tr></tbody></table><h4 id="核酸分子杂交信号的检测"><a class="header-anchor" href="#核酸分子杂交信号的检测"></a>核酸分子杂交信号的检测</h4><ol><li>放射性同位素标记探针：放射自显影</li><li>非放射性同位素标记探针：酶联免疫反应 + 显色反应</li></ol><blockquote><p>地高辛原理：地高辛 + 抗地高辛抗体（带有荧光素或酶的标记）</p></blockquote><h4 id="常用的探针标记法"><a class="header-anchor" href="#常用的探针标记法"></a>常用的探针标记法</h4><ol><li>切口移位（平移）法</li><li>PCR 标记法</li><li>末端标记法</li></ol><h2 id="第六章-基因工程的常规技术之基因芯片"><a class="header-anchor" href="#第六章-基因工程的常规技术之基因芯片"></a>第六章 基因工程的常规技术之基因芯片</h2><p><font color="#ea66a6">生物芯片</font>：是将大量生物识别分子按预先设置的排列固定于一种载体（如硅片、玻片及高聚物载体等）表面，根据分子间的特异性相互作用的原理，如核酸杂交反应，抗原抗体反应等来检测各种生物分子存在的量的一种技术，以实现对细胞、蛋白质、核酸以及其它生物组分的准确、快速、大信息量的检测。</p><p>生物芯片包括：DNA 芯片、蛋白质芯片</p><p><font color="#ea66a6">DNA 芯片</font>：是最重要的一种生物芯片，又称基因芯片，是一种<font color="#faa755">高通量的斑点杂交技术</font>，通过将大量的 DNA 分子固定于支持物上，并与标记的样品杂交，然后通过自动化仪器检测杂交信号来判断样品中靶分子的信息，诸如基因组 DNA 突变谱和 mRNA 表达谱的检测等。</p><h3 id="基因芯片主要技术流程"><a class="header-anchor" href="#基因芯片主要技术流程"></a>基因芯片主要技术流程</h3><ul><li>芯片制备</li><li>样品荧光标记</li><li>芯片杂交</li><li>芯片洗涤和扫描</li><li>扫描图像分析</li></ul><h4 id="芯片的制备"><a class="header-anchor" href="#芯片的制备"></a>芯片的制备</h4><p>（一）支持物的预处理</p><ul><li>实性材料：硅芯片、玻片和瓷片。需进行预处理，使其表面衍生出羟基、氨基活性基团。</li><li>膜性材料：聚丙烯膜、尼龙膜、硝酸纤维膜。通常包被氨基硅烷或多聚赖氨酸</li></ul><p>（二）探针的制备</p><ol><li>原位合成法</li><li>接触点样法</li><li>喷墨法</li></ol><p>探针的固化：打印探针后，需要将其固定在支持物表面，同时也要封闭支持物上未打印区域以防止核酸样品的非特异性固定</p><h4 id="样品的准备"><a class="header-anchor" href="#样品的准备"></a>样品的准备</h4><ul><li>样品的分离纯化：DNA，mRNA</li><li>扩增：PCR，RT-PCR，固相 PCR</li><li>标记等过程：荧光标记（常用 Cy3、Cy5），生物素、放射性标记</li></ul><h4 id="分子杂交"><a class="header-anchor" href="#分子杂交"></a>分子杂交</h4><p>样品与 DNA 芯片上的探针阵列进行杂交。与经典分子杂交的区别：</p><ul><li>杂交时间短，30 分钟内完成</li><li>可同时平行检测许多基因序列</li></ul><h4 id="检测分析"><a class="header-anchor" href="#检测分析"></a>检测分析</h4><ol><li>激光激发使含荧光标记的 DNA 片段发射荧光</li><li>激光扫描仪或激光共聚焦显微镜采集各杂交点的信号</li><li>软件进行进行图象分析和数据处理</li></ol><h3 id="DNA-芯片的应用"><a class="header-anchor" href="#DNA-芯片的应用"></a>DNA 芯片的应用</h3><ol><li>科研方面的应用<ul><li>表达谱分析</li><li>SNP 分析（包括最新的 CSV/CNV分析，GWAS）</li><li>CGH 分析</li><li>Chip-ChIP 分析</li></ul></li><li>临床相关应用<ul><li>传染性疾病的检测（有无和耐药性检测）</li><li>遗传性疾病的检测</li></ul></li></ol><p>表达谱芯片</p><ul><li>肿瘤相关基因（正常与肿瘤组织表达差异）</li><li>药物筛选（培养细胞药物刺激前后表达差异）</li><li>发育（同一组织不同发育时期基因表达差异）</li><li>组织发生（不同组织或器官的基因表达差异）</li></ul><h3 id="DNA-芯片未来展望"><a class="header-anchor" href="#DNA-芯片未来展望"></a>DNA 芯片未来展望</h3><ul><li>作为一门技术本身已经非常成熟。</li><li>今日的 DNA 芯片在表达谱分析，SNP 分析以及 Chip-ChIP 分析方面的地位将会逐渐被下一代测序技术所取代，但以其灵活性和高效性，在临床应用方面将长久的发挥作用。</li><li>DNA 芯片发展过程中所积累起来设备，技术以及数据分析软件将为其它类型的高密度芯片技术的发展提供重要参考。</li><li>开发其它可能的应用：记住核心 addressable-decoder.</li><li>……</li></ul><h2 id="第六章-基因工程的常规技术之-DNA-序列分析"><a class="header-anchor" href="#第六章-基因工程的常规技术之-DNA-序列分析"></a>第六章 基因工程的常规技术之 DNA 序列分析</h2><p>1977 年，Maxam 和 Gilbert 报道了<font color="#faa755">化学降解法</font>测定 DNA 的序列。</p><p>1977 年，Sanger 在引入双脱氧核苷三磷酸（ddNTP）后，形成了双脱氧链终止法，使得 DNA 序列测定的效率和准确性大大提高。</p><p>1980 年，Frederik Sanger 和 Walter Gilbert 因“在测定核酸碱基序列上的突出贡献”而分享了当年的诺贝尔化学奖。</p><h3 id="第一代-DNA-测序技术"><a class="header-anchor" href="#第一代-DNA-测序技术"></a>第一代 DNA 测序技术</h3><p>第一代 DNA 测序技术：传统的化学降解法、双脱氧链终止法以及在它们的基础上发展来的各种 DNA 测序技术。</p><p>第一代 DNA 测序技术包括：化学降解法、双脱氧链终止法、荧光自动测序技术和杂交测序技术。</p><h4 id="化学降解法"><a class="header-anchor" href="#化学降解法"></a>化学降解法</h4><p>将一个 DNA 片段的 5’ 端磷酸基作放射性标记，再分别采用不同的化学方法修饰和裂解特定碱基，打断磷酸二脂键，从而产生一系列长度不一而5’ 端被标记的 DNA 片段，这些以特定碱基结尾的片段群通过凝胶电泳分离，再经放射线自显影，确定各片段末端碱基，从而得出目的 DNA 的碱基序列。</p><p>碱基特异性化学切割反应：</p><ul><li>硫酸二甲酯（DMS）：使 DNA 分子中鸟嘌呤（<font color="#faa755">G</font>）上的 N<sub>7</sub> 原子甲基化。</li><li>哌啶甲酸：在酸性条件使 DNA 链脱嘌呤（<font color="#faa755">G</font> &amp; <font color="#faa755">A</font>）。</li><li>肼：在碱性条件使 DNA 分子中胸腺嘧啶和胞嘧啶（<font color="#faa755">T</font> &amp; <font color="#faa755">C</font>）的嘧啶环断裂；但<font color="#faa755">高盐条件</font>下，只 <font color="#faa755">C</font> 断裂，而不与 T 反应。</li></ul><p>在不同的酸、碱、高盐和低盐条件下，三种化学试剂按不同组合可以特异地切割核苷酸序列中特定的碱基。</p><p>将标记 DNA 分为 G、GorA、CorT 和 C 4 个反应体系</p><p>测定 DNA 长度大约为 250 bp。</p><table><thead><tr><th>反应体系</th><th>碱基修饰试剂</th><th>碱基修饰反应</th><th>断裂点</th></tr></thead><tbody><tr><td>G</td><td>硫酸二甲酯</td><td>鸟嘌呤甲基化</td><td>G</td></tr><tr><td>G + A</td><td>哌啶甲酸</td><td>脱嘌呤作用</td><td>G 和 A</td></tr><tr><td>C+T</td><td>肼</td><td>嘧啶开环</td><td>C 和 T</td></tr><tr><td>C</td><td>肼（加盐）</td><td>胞嘧啶开环</td><td>C</td></tr></tbody></table><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5ibn2nkvrwo0.png" alt="化学裂解法测定 DNA 的核苷酸序列"></p><p>化学降解法刚问世时，准确性较好，也容易为普通研究人员所掌握，因此用得较多。但化学降解法操作过程较麻烦，且用到放射性物质，逐渐被简便快速的 Sanger 法所代替。</p><h4 id="双脱氧链终止法（Sanger法）"><a class="header-anchor" href="#双脱氧链终止法（Sanger法）"></a>双脱氧链终止法（Sanger法）</h4><p>1977年，英国人 Fred Sanger 发现，如果在 DNA 复制过程中掺入 ddNTP，就会产生一系列末端终止的 DNA 链，并能通过电泳按长度分辨。不同末端终止 DNA 链的长度是由掺入到新合成链上随机位置的 ddNTP 决定的。</p><p>Sanger 双脱氧链终止法：</p><ul><li>与 PCR 反应类似。</li><li>反应体系中包含：模板 DNA, Taq 酶, dNTPs, ddNTPs 和测序引物；</li><li>反应过程：变性－复性－延伸－终止</li></ul><p>Sanger 法是在反应体系中加入 2’,3’-ddNTP，由于其没有 3’-OH 而不能与下一个核苷酸相连，于是 DNA 链的合成便终止。</p><p>Sanger 法：</p><ul><li>在 PCR 时加入标记的复制终止剂，比如 ddA，ddT，ddC，ddG（相应于 4 种碱基）</li><li>ddNTP 的两个作用：可以当作正常碱基参与复制、一旦链入 DNA 中，其后就不能再继续连接</li><li>电泳</li><li>谁终止，碱基就是谁</li></ul><p>Sanger 双脱氧链终止法</p><ul><li>一个样品需要 4 个合成反应（每个反应分别加 4 种 dNTP 和一种 ddNTP)</li><li>反应结束后，分 4 个泳道进行聚丙烯酰胺凝胶电泳分离</li><li>各自泳道按照分离片段大小进行读数</li></ul><h4 id="DNA-测序自动化和大规模测序"><a class="header-anchor" href="#DNA-测序自动化和大规模测序"></a>DNA 测序自动化和大规模测序</h4><p>特点:</p><ul><li>原理同 sanger 法</li><li>标记物为荧光染料（与双脱氧核苷三磷酸共价相连)</li><li>激光扫描自动测序</li><li>结果清晰、准确、分辨率高</li><li>测序速度快</li></ul><p>毛细管电泳基本原理：与链终止法测序原理相同，只是用不同的荧光色彩标记 ddNTP，如 dd<font color="#e03e3e">A</font>TP 标记<font color="#e03e3e">红色</font>荧光, dd<font color="#32cd32">T</font>TP 标记<font color="#32cd32">绿色</font>荧光，dd<font color="#33a3dc">C</font>TP 标记<font color="#33a3dc">蓝色</font>荧光, dd<font color="#faa755">G</font>TP 标记<font color="#faa755">黄色</font>荧光，由于每种 ddNTP 带有各自特定的荧光颜色，而简化为由 1 个泳道同时判读4种碱基。</p><p>DNA 自动测序步骤：</p><ol><li>4 种带有不同荧光染料标记的终止物 ddNTPs</li><li>Sanger 测序反应</li><li>反应产物毛细管电泳分离</li><li>激光激发、荧光信号采集、计算机分析与 DNA 自动排序</li></ol><h4 id="DNA-自动测序与手工测序的不同点"><a class="header-anchor" href="#DNA-自动测序与手工测序的不同点"></a>DNA 自动测序与手工测序的不同点</h4><ol><li>标记物不同：手工测序采用放射性核素标记，而自动测序采用 4 种荧光染料分别标记 ddNTP 或标记引物</li><li>加样方式不同：手工测序，一个样品的 4 个测序反应物分别在不同泳道进行，而自动测序可在一个泳道内电泳</li><li>检测手段不同：手工测序采用放射自显影，从 4 种寡聚核苷酸的梯子形图谱中读出 DNA 序列，而自动测序则采用激光扫描器同步扫描，计算机进行阅读和编辑</li></ol><h3 id="第二代-DNA-测序技术"><a class="header-anchor" href="#第二代-DNA-测序技术"></a>第二代 DNA 测序技术</h3><p>第一代测序技术在分子生物学研究中发挥过重要的作用，如人类基因组计划（human genome project，HGP）主要基于第一代 DNA 测序技术。目前基于荧光标记和 Sanger 的双脱氧链终止法原理的荧光自动测序仪仍被广泛地应用。</p><p>随着人类基因组计划的完成，人们进入了后基因组时代，即功能基因组时代，第一代测序技术由于成本高、速度慢等原因已经不能满足深度测序和重复测序等大规模基因组测序的需求，这促使了第二代测序技术（高通量测序技术）。</p><p>第二代测序技术，主要包括：</p><ol><li>罗氏 454 公司的 GS FLX 测序平台、</li><li>Illumina 公司的 Solexa Genome Analyzer 测序平台</li><li>ABI 公司的 SOLiD 测序平台</li><li>Life Techologies 公司的离子肼测序</li></ol><p>第二代测序技术最显著的特征是高通量，一次能对几十万到几百万条DNA分子进行序列测序，使得对一个物种的转录组测序或基因组深度测序变得方便易行。</p><h4 id="第二代-DNA-测序技术原理"><a class="header-anchor" href="#第二代-DNA-测序技术原理"></a>第二代 DNA 测序技术原理</h4><p>第二代测序技术将片段化的基因组 DNA 两侧连上接头，随后用不同的方法产生几百万个<font color="#faa755">空间固定的 PCR 克隆阵列</font>。每个克隆由单个文库片段的多个拷贝组成。然后进行<font color="#faa755">引物杂交</font>和<font color="#faa755">酶延伸反应</font>。由于所有的克隆都在同一平面上，这些反应就能够大规模平行进行，每个延伸反应所掺入的<font color="#faa755">荧光标记</font>的成像检测也能同时进行，从而获得测序数据。DNA 序列延伸和成像检测不断重复，最后经过<font color="#faa755">计算机分析</font>就可以获得完整的 DNA 序列信息。</p><h4 id="454-测序流程"><a class="header-anchor" href="#454-测序流程"></a>454 测序流程</h4><ol><li>DNA 文库制备：将待测 DNA 打断成 300 ～ 800 bp 长的小片段，末端修复后在片段两端加上不同的接头，变性处理回收单链 DNA。</li><li>体外 DNA 扩增: 454 系统采用的是乳化 PCR 的方法进行扩增。</li><li>富集固定：将含有 DNA 片段的磁珠富集起来，并将这些磁珠置于一种 PTP 平板中的特制小孔中，每个孔只能容纳一个磁珠。</li><li>测序：采用焦磷酸测序法，每个含有磁珠的小孔都可以测出其中一个片段的序列。</li></ol><h4 id="第二代-DNA-测序的局限性"><a class="header-anchor" href="#第二代-DNA-测序的局限性"></a>第二代 DNA 测序的局限性</h4><p>第二代测序技术并不完美：</p><ul><li>一是由于其在测序前要仍旧通过 PCR 手段对待测片段进行扩增，因此增加了测序的错误率</li><li>二是其测序结果比较短，更适合重测序，而不太适用于没有基因组序列的全新测序。</li></ul><h3 id="第三代测序技术（单分子测序，直接测序）"><a class="header-anchor" href="#第三代测序技术（单分子测序，直接测序）"></a>第三代测序技术（单分子测序，直接测序）</h3><p>第三代测序技术主要有：</p><ol><li>Helicos公司的Heliscope 单分子测序仪</li><li>Pacific Biosciences 公司的 SMRT 技术</li><li>Oxford Nanopore Technologies 公司正在研究的纳米孔单分子技术</li></ol><h4 id="纳米孔单分子技术"><a class="header-anchor" href="#纳米孔单分子技术"></a>纳米孔单分子技术</h4><ol><li>使用外切酶从 ssDNA 的末端逐个切割形成单碱基</li><li>被切下来的单个碱基会落入纳米孔，并和纳米孔内的环糊精相互作用，短暂地影响流过纳米孔的电流强度，这种电流强度的变化幅度就成为每种碱基的特征。</li><li>利用不同碱基产生的电信号进行测序。</li></ol><h4 id="第三代测序技术特点"><a class="header-anchor" href="#第三代测序技术特点"></a>第三代测序技术特点</h4><ol><li>不再基于所用测序技术使用的边合成边测序的思想，减少合成过程中出现的差错；</li><li>测序步长达到 30 kb 以上。</li></ol><h2 id="第七章-DNA-文库的构建和目的基因的筛选"><a class="header-anchor" href="#第七章-DNA-文库的构建和目的基因的筛选"></a>第七章 DNA 文库的构建和目的基因的筛选</h2><p>基因文库（Gene library）：由某一生物的全部或部分基因的不同 DNA 片段的克隆所构成的群体, 称之为基因文库。一个完全的基因文库，应该能够保证从中筛选到目的基因。即 Genomic Library or Gene Bank</p><p>按照外源 DNA 的片段：</p><ul><li>基因组 DNA 文库</li><li>cDNA 文库</li><li>宏基因组文库</li></ul><p>基因组 DNA 文库：指将某生物体的全部基因组 DNA 用限制性内切酶或机械力量切割成一定长度范围的 DNA 片段，与合适的载体体外重组并转化相应的宿主细胞获得的所有阳性菌落。包含基因的全部信息，如编码区，非编码区，内含子和外显子、启动子及调控序列</p><p>cDNA文库（complementary，DNA 互补DNA）：由某一生物的特定器官或特定发育时期（时空特异性）细胞内的 mRNA 经反转录形成的 cDNA，它们所构成的重组 DNA 克隆群体，则称之为 cDNA 基因文库。</p><blockquote><p>反映了基因表达谱，对研究基因表达，调控及基因互作非常有用。</p></blockquote><h3 id="DNA-文库构建的基本程序"><a class="header-anchor" href="#DNA-文库构建的基本程序"></a>DNA 文库构建的基本程序</h3><ol><li>提取研究对象基因组 DNA，制备合适大小的 DNA 片段，或提取组织或器官的 mRNA 并反转录成 cDNA；</li><li>酶切的 DNA 片段或 cDNA 与经特殊处理的载体连接形成重组 DNA；</li><li>重组 DNA 转化宿主细胞或体外包装后侵染受体菌；</li><li>阳性重组菌落或噬菌斑的选择。</li></ol><p>高纯度大分子量基因组 DNA （High molecular weight DNA, HMW DNA）的提取</p><h3 id="文库的代表性和随机性"><a class="header-anchor" href="#文库的代表性和随机性"></a>文库的代表性和随机性</h3><p>文库中所有克隆所携带的 DNA 片段重新组合起来可以覆盖整个基因组，即可以从该文库中分离任何一段 DNA 。</p><ul><li>采用酶切或随机切割的方法来消化染色体 DNA ，以保证克隆的随机性，保证每段 DNA 在文库中出现的频率均等；</li><li>增加文库总容量。</li></ul><p>1976年 L.Clark，J.Carbon 提出了一个完全的基因文库所需克隆的计算公式$$n= \frac{\ln_{}{(1-p)}}{\ln_{}{(1-f)}}$$ $n$ : 一个完全基因文库所应包含的重组体克隆数<br>$p$ : 所期望的目的基因在基因文库中出现的几率<br>$f$ : 插入片段的平均大小与基因组 DNA 大小的比值</p><h3 id="基因组-DNA-文库的构建"><a class="header-anchor" href="#基因组-DNA-文库的构建"></a>基因组 DNA 文库的构建</h3><p>定义：指将某生物体的全部基因组 DNA 用限制性内切酶或机械力量切割成一定长度范围的 DNA 片段，与合适的载体体外重组并转化相应的宿主细胞获得的所有阳性菌落。</p><p>基因组 DNA 文库的构建程序：</p><ol><li>载体的制备；</li><li>高纯度大分子量基因组 DNA （High molecular weight DNA, HMW DNA）的提取；</li><li>HMW DNA 的部分酶切与脉冲电泳分级分离（PFGE size selection）；</li><li>载体与外源片段的连接与转化或侵染宿主细胞；</li><li>重组克隆的挑取</li><li>文库的保存。</li></ol><p>用于构建基因文库的载体：</p><ul><li>Plasmid，&lt;10kb，亚基因组文库</li><li>Phage，0 ～ 23 kb，cDNA文库</li><li>Cosmid， ～ 45 kb，小基因组物种的基因组文库</li><li>BAC， ～ 100kb，大基因组物种的基因组文库，物理图谱构建，基因组测序</li><li>YAC， ～ 300kb ～ 1.2 Mb，大基因组物种的基因组文库，物理图谱构建，基因组测序</li></ul><p>噬菌体改建的载体，利用了噬菌体的包装效率高和杂交筛选背景低的优点；经改造的人工染色体，其主要优点在于可容纳超过   100 kb 以上的外源片段。</p><p>粘粒克隆所需的克隆子数是 λ phage 的一半，如 λ 需 700000 时，cosmid 需 350000 个。YAC 可用于克隆 500 kb 以上，甚至几 Mb 的 DNA 片段，克隆子数就更少了。</p><h3 id="亚基因组文库的构建"><a class="header-anchor" href="#亚基因组文库的构建"></a>亚基因组文库的构建</h3><p>用基因组 DNA 的特定部分所构建的基因文库质粒 DNA，线粒体 DNA，特定限制性片段</p><p>在有杂交探针的情况下，可通过 Southern 杂交，先找出目标基因所在的限制性片段的大小，然后用相应大小的限制性 DNA 片段构建出基因文库，这样可减少筛选的压力。</p><p>例如，将基因组 DNA 用多种限制性内切酶切割，通过 Southern 杂交，发现目标基因在 8.3 kb <em>Spe</em>Ⅰ 片段上，则将<em>Spe</em>Ⅰ 切割的基因组 DNA 中的 ～ 8.3 kb 片段回收，用于构建 DNA 文库</p><h3 id="基因组-DNA-文库克隆子的保存"><a class="header-anchor" href="#基因组-DNA-文库克隆子的保存"></a>基因组 DNA 文库克隆子的保存</h3><ol><li>影印滤膜保存法</li><li>文库在液体培养基中扩增保存</li><li>保存单个克隆子</li></ol><h4 id="文库在液体培养基中扩增保存"><a class="header-anchor" href="#文库在液体培养基中扩增保存"></a>文库在液体培养基中扩增保存</h4><p>方法：从琼脂平板上挑取已长出的克隆子转入含适当的抗生素培养基中，混合的细菌生长数代后，其培养物于 -70℃ 储存（加终浓度为 25% 的甘油）。<br>缺点：因文库菌落生长的不均匀性而导致文库中某些特定的序列过多或过少。</p><h4 id="保存单个克隆子"><a class="header-anchor" href="#保存单个克隆子"></a>保存单个克隆子</h4><p>方法：从平板上挑选单个克隆子接种于合适的含抗生素的培养基中，菌体生长到一定浓度后，加入终浓度为 25% 的甘油，于 -70℃ 下保存。<br>缺点：需保存的克隆子数过多，工作量大。</p><h3 id="cDNA-文库的构建"><a class="header-anchor" href="#cDNA-文库的构建"></a>cDNA 文库的构建</h3><p>定义：是指将某种生物体基因组转录的全部 mRNA 经反转录产生的 cDNA 片段分别与克隆载体重组，储存于某种受体菌中，该群体就称该生物基因组的 cDNA 文库。</p><p>cDNA 文库的构建主要分四步：</p><ol><li>细胞总 RNA 的提取和 mRNA 分离；</li><li>第一链 cDNA 合成；</li><li>第二链 cDNA 合成；</li><li>双链 cDNA 克隆进质粒或噬菌体载体并导入宿主中繁殖。</li></ol><h4 id="mRNA-的分离"><a class="header-anchor" href="#mRNA-的分离"></a>mRNA 的分离</h4><p>从总 RNA 中富集 mRNA 是构建 cDNA 文库和其它应用所必需进行的步骤。通过降低 rRNA 和 tRNA 含量，可大大提高筛选到目标基因的可能性。</p><p>目前纯化 mRNA 的方法都是在固体支持物表面共价结合固定一段由脱氧胸腺嘧啶核苷组成的寡聚核苷酸 [oligo(dT)] 链，由它与 mRNA 的 Poly(A) 尾巴杂交，从而吸附固定住 mRNA，进而将 mRNA 从其它组分中分离出来的。</p><p>（1）mRNA 的含量：取决于细胞类型和细胞的生理状态。</p><p>（2）mRNA 完整性的检测：</p><ol><li>mRNA 分子的大小：哺乳动物 mRNA 长度为 500 ～ 8000 bp，大部分 mRNA 位于 1.5 ～ 2.0 kb 之间。</li><li>总 mRNA 指导合成 cDNA 第一链长分子的能力。</li><li>指导合成高分子量蛋白质的能力，指导合成目的多肽的能力。</li></ol><p>（3）mRNA 在细胞中的丰度</p><ul><li>高丰度 mRNA：目的 mRNA 在细胞中的含量占细胞质总 mRNA 量的 50 ～ 90%，如珠蛋白，免疫球蛋白，卵清蛋白，该类 mRNA 在合成和克隆 cDNA 之前不需进一步纯化特定 mRNA。</li><li>低丰度 mRNA：目的 mRNA 在细胞中的含量占细胞质总 mRNA 量的 0.5% 以下。</li></ul><p>（4）对 mRNA 进行分级分离</p><ul><li>通过琼脂糖凝胶电泳分离大小不同的 mRNA 分子，该方法的分离效果最好，但从凝胶中回收的得率较低。</li><li>蔗糖梯度离心：加入破坏 RNA 二级结构的变性剂如氢氧化甲基汞等，再进行蔗糖梯度离心以分离不同分子量的 mRNA。</li></ul><p>cDNA 的分级分离：mRNA 通过反转录形成 cDNA，在插入到克隆载体前，通过琼脂糖凝胶电泳，将不同大小的 cDNA 分子分离开来。优点：</p><ul><li>避免了分离过程中 mRNA 被污染的 RNA 酶降解</li><li>增加了获得全长 cDNA 克隆的概率</li><li>获得更准确的分级分离效果（分子量）</li></ul><h4 id="第一链-cDNA-的合成"><a class="header-anchor" href="#第一链-cDNA-的合成"></a>第一链 cDNA 的合成</h4><p>oligo(dT) 引导的 DNA 合成法：利用真核 mRNA 分子所具有的 poly(A) 尾巴的特性，加入 12 ～ 20 个脱氧胸腺嘧啶核苷组成的 oligo(dT) 短片段，由反转录酶合成 cDNA 的第一链。</p><h4 id="第二链-cDNA-的合成"><a class="header-anchor" href="#第二链-cDNA-的合成"></a>第二链 cDNA 的合成</h4><p>cDNA 第二链的合成就是将上一步形成的 mRNA-cDNA 杂合双链变成互补双链 cDNA 的过程。</p><p>cDNA 第二链的合成的方法大致 4 种：</p><ol><li>自身引导合成法</li><li>置换合成法</li><li>引导合成法</li><li>引物－衔接头合成法。</li></ol><p>（一）自身引导合成法</p><p>获得的单链 cDNA 3’ 端会形成发夹结构的能力，以此作为第二链合成的引物，在大肠杆菌聚合酶ⅠKlenow 或反转录酶的作用下，合成 cDNA 的第二链。再利用 S1 核酸酶将连接处（仅该位点处为单链结构）切断形成平端结构可以进行连接。</p><p>缺点：在以 S1 核酸酶切割 cDNA 的发夹状结构时，会导致对应于 mRNA 5’ 端的地方的序列出现缺失和重排。S1 核酸酶的纯度不够时，会偶尔破坏合成的双链 cDNA 分子。</p><p>（2）置换合成法</p><p>以第一链合成产物 cDNA:mRNA 杂交体作为切口平移的模板，RNA 酶 H 在杂交体的 mRNA 链上造成切口和缺口，产生一系列 RNA 引物，在大肠杆菌 DNA 聚合酶Ⅰ的作用下合成 cDNA 的第二链。</p><p>优点：</p><ol><li>合成 cDNA 的效率高</li><li>直接利用第一链的反应产物，不需纯化</li><li>避免使用 S1 核酸酶来切割双链 cDNA</li></ol><p>（3）引导合成法</p><p>首先是制备带有 Poly(dT) 的载体片段Ⅰ和一端带有 Poly(dG) 的片段Ⅱ，并用片段Ⅰ来代替 Oligo(dT) 进行 cDNA 第一链的合成，在第一链 cDNA 合成后直接采用末端转移酶（TdT）在第一链 cDNA 的 3’-端加上一段 Poly(dC) 的尾巴，同时进行酶切创造出另一端的粘端，与片段Ⅱ一起形成环化体，这种环化了的杂合双链在 RNA 酶 H、大肠杆菌 DNA 聚合酶Ⅰ和 DNA 连接酶的作用下合成与载体联系在一起的双链 cDNA 。</p><p>（4）引物-衔接头法：引导合成法改进而来</p><p>第一链合成后直接采用末端转移酶（TdT）在第一链 cDNA 的 3’-端加上一段 Poly(dC) 的尾巴，然后用一段带接头序列的 Poly(dG) 短核苷酸链作引物合成互补的 cDNA 链，接头序列可以是适用于 PCR 扩增的特异序列或用于方便克隆的酶切位点的序列。这一方法目前已经发展成 PCR 法构建 cDNA 文库的常用方法。</p><h4 id="双链-cDNA-克隆进质粒或噬菌体载体并导入宿主中繁殖"><a class="header-anchor" href="#双链-cDNA-克隆进质粒或噬菌体载体并导入宿主中繁殖"></a>双链 cDNA 克隆进质粒或噬菌体载体并导入宿主中繁殖</h4><p>cDNA 末端的处理：</p><ul><li>由于大片段的平末端连接效率非常低，因此为了避免用平末端与载体连接，对双链 cDNA 的末端进行加工是十分必要的</li><li>方法：添加特异性核酸接头以形成适合于克隆的黏性末端</li><li>末端转移酶，可以向 cDNA 末端加上与克隆载体末端互补的尾部</li></ul><p>双链 cDNA 的克隆，双链平头的 cDNA 通常可以使用下列三种方法克隆入载体中：</p><ol><li>平头末端直接与载体连接，但连接效率低</li><li>平头两端分别接同聚物尾，最好是 AT 同聚物尾，这样重组分子可通过加热局部变性和 S1 核酸酶处理回收插入片段</li><li>加装人工接头引入酶切口，以便插入片段回收</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.62eygxp7d440.png" alt="image"></p><h3 id="基因组-DNA-文库与-cDNA-文库的比较"><a class="header-anchor" href="#基因组-DNA-文库与-cDNA-文库的比较"></a>基因组 DNA 文库与 cDNA 文库的比较</h3><p>相对于 cDNA 文库，基因组文库的优点：</p><ul><li>cDNA 克隆只能反映 mRNA 的分子结构，没有包括基因组的间隔序列，并且受细胞来源或发育时期的影响。</li><li>cDNA 文库中，不同克隆的分布状态总是反映 mRNA 的分布状态，即：高丰度 mRNA 的 cDNA 克隆，所占比例较高，分离基因容易；低丰度 mRNA 的 cDNA 克隆，所占比例较低，分离基因困难；</li><li>从 cDNA 克隆中，不能克隆到基因组 DNA 中的非转录区段序列，不能用于研究基因编码区外侧调控序列的结构与功能。</li></ul><p>cDNA 文库的主要优点：</p><ul><li>cDNA 文库以 mRNA 为材料，特别适用于某些 RNA 病毒等的基因组结构研究及有关基因的克隆分离。</li><li>cDNA 文库的筛选比较简单易行。</li><li>每一个 cDNA 文库都含有 mRNA 序列，这样在目的基因的选择中出现假阳性的概率就会比较低，因此阳性杂交信号一般都是有意义的，由此选择出来的阳性克隆将会含有目的基因。</li><li>cDNA 克隆还可用于真核细胞 mRNA 的结构和功能研究。</li></ul><h3 id="基因克隆的筛选策略"><a class="header-anchor" href="#基因克隆的筛选策略"></a>基因克隆的筛选策略</h3><ul><li>表型筛选法</li><li>杂交筛选和 PCR 筛选</li><li>免疫筛选</li><li>酵母双杂交系统筛选</li></ul><h4 id="酵母双杂交系统"><a class="header-anchor" href="#酵母双杂交系统"></a>酵母双杂交系统</h4><p>酵母双杂交系统筛选：用于分离与某一已知蛋白发生相互作用的蛋白质基因</p><p>GAL4 蛋白：酵母半乳糖苷酶基因 gal 的转录激活因子，该蛋白结合在 gal 基因上游激活区 （UAS） 可启动 gal 基因的转录<br>GAL4 蛋白可分为两个区域：</p><ul><li>DNA-BD：DNA 结合域，N-末端 1 ～ 147 aa（氨基酸）</li><li>AD：转录激活域，C-末端 768 ～ 881 aa</li></ul><p>这两个结合域将它们分开时仍分别具有功能，但不能激活转录，只有当被分开的两者通过适当的途径在空间上较为接近时，才能重新呈现完整的转录因子活性，并可激活上游激活序列（upstream activating sequence, UAS）的下游启动子，使启动子下游基因得到转录。</p><h4 id="酵母双杂交系统筛选原理"><a class="header-anchor" href="#酵母双杂交系统筛选原理"></a>酵母双杂交系统筛选原理</h4><ol><li>将编码 DNA-BD 的基因与已知蛋白质 Bait protein 的基因构建在同一个表达载体上，在酵母中表达两者的融合蛋白 BD-Bait protein。</li><li>将编码 AD 的基因和 cDNA 文库的基因构建在 AD-LIBRARY 表达载体上。</li><li>同时将上述两种载体转化改造后的酵母，如两种载体所表达的融合蛋白不相互作用时，这种改造后的酵母细胞的基因组中既不能产生 GAL4，又不能合成 LEU、TRP、HIS、LacZ，因此，酵母在缺乏这些营养的培养基上无法正常生长。当上述两种载体所表达的融合蛋白能够相互作用时，功能重建的反式作用因子能够激活酵母基因组中的报告基因 HIS、LacZ 等，从而通过功能互补和显色反应筛选到阳性菌落。</li></ol><h4 id="酵母双杂交系统的优点"><a class="header-anchor" href="#酵母双杂交系统的优点"></a>酵母双杂交系统的优点</h4><ol><li>作用信号是在融合基因表达后，在细胞内重建转录因子的作用而给出的，省去了纯化蛋白质的繁琐步骤。</li><li>检测在活细胞内进行，可以在一定程度上代表细胞内的真实情况。</li><li>检测的结果可以是基因表达产物的积累效应，因而可检测存在于蛋白质之间的微弱的或暂时的相互作用。</li><li>酵母双杂交系统可采用不同组织、器官、细胞类型和分化时期材料构建 cDNA 文库，能分析细胞质、细胞核及膜结合蛋白等多种不同亚细胞部位及功能的蛋白。</li></ol><h4 id="酵母双杂交系统局限性和存在的问题"><a class="header-anchor" href="#酵母双杂交系统局限性和存在的问题"></a>酵母双杂交系统局限性和存在的问题</h4><ol><li>双杂交系统分析蛋白间的相互作用定位于细胞核内，而许多蛋白间的相互作用依赖于翻译后加工如糖基化、二硫键形成等，这些反应在核内无法进行这限制了某些细胞外蛋白和细胞膜受体蛋白等的研究。</li><li>酵母双杂交系统的一个重要的问题是&quot;假阳性&quot;。由于某些蛋白本身具有激活转录功能或在酵母中表达时发挥转录激活作用，使 DNA 结合结构域杂交蛋白在无特异激活结构域的情况下可激活转录。另外某些蛋白表面含有对多种蛋白质的低亲和力区域，能与其他蛋白形成稳定的复合物，从而引起报告基因的表达，产生&quot;假阳性&quot;结果。</li></ol><h2 id="第八章-植物基因工程"><a class="header-anchor" href="#第八章-植物基因工程"></a>第八章 植物基因工程</h2><h3 id="植物基因工程概念"><a class="header-anchor" href="#植物基因工程概念"></a>植物基因工程概念</h3><p>植物基因工程是以植物为受体，采用基因克隆、遗传转化以及细胞、组织培养技术将外源基因转移并整合到受体植物的基因组中，并使其在后代植株中得以正确表达和稳定遗传，从而使受体获得新性状的技术体系。</p><h3 id="转基因植物快速发展的因素"><a class="header-anchor" href="#转基因植物快速发展的因素"></a>转基因植物快速发展的因素</h3><ul><li>植物单个细胞具有发育成完整个体的“细胞全能性”；</li><li>植物是人类食物和能量的主要来源</li><li>许多高等植物具有自花授粉或自交能力，易于得到纯合的转基因个体</li><li>具有丰富的突变体资源，为植物基因的分离提供良好的条件。</li></ul><h3 id="植物转基因的基本技术路线"><a class="header-anchor" href="#植物转基因的基本技术路线"></a>植物转基因的基本技术路线</h3><ul><li>获得目的基因，克隆到载体上扩增</li><li>受体细胞培养：如植物愈伤组织等</li><li>目的基因导入受体细胞</li><li>培养转化细胞</li><li>筛选、培植、鉴定</li></ul><h3 id="转基因的受体系统"><a class="header-anchor" href="#转基因的受体系统"></a>转基因的受体系统</h3><ul><li>组织受体系统（如：受伤的细胞容易受到病毒或质粒的感染，并形成愈伤组织，可诱导分化出完整植株）</li><li>原生质体系统（便于体外细胞和遗传操作）</li><li>生殖细胞受体系统（单倍体培养诱导愈伤组织、转化；利用花粉和卵细胞的受精过程转化）</li><li>叶绿体转化系统（能直接表达原核基因）</li></ul><h3 id="外源基因导入植物受体的方法"><a class="header-anchor" href="#外源基因导入植物受体的方法"></a>外源基因导入植物受体的方法</h3><ul><li>根癌农杆菌介导法</li><li>基因枪法</li><li>原生质体介导法</li></ul><h4 id="根癌农杆菌介导法"><a class="header-anchor" href="#根癌农杆菌介导法"></a>根癌农杆菌介导法</h4><p>一种土壤细菌感染植物伤口造成植物的肿瘤（冠瘿）</p><p>植物受伤处的分泌物（糖、氨基酸和酚类物质等）诱导农杆菌的附着，农杆菌中的 T-DNA 插入植物基因组，T-DNA 利用植物的酶系统进行转录和翻译，其表达产物致使植物致瘤。</p><p>Ti 质粒：</p><ul><li>T-DNA 区，转移到植物基因组的一段 DNA</li><li>毒性区（vir区）：激活 T-DNA 转移，使植物致瘤</li><li>Ori区：质粒复制起点</li><li>Con区：调控 Ti 质粒在根癌农杆菌间的转移</li></ul><p>Ti 质粒分为：农杆碱型、胭脂碱型、章鱼碱型</p><p>T-DNA 的转化需要 Vir 区基因的表达和左右边界（LB、RB）的存在</p><p>土壤农杆菌-植物 DNA 转移体系步骤：</p><ol><li>农杆菌对受体的识别；</li><li>农杆菌附着到植物受体细胞；</li><li>Ti 质粒毒性区基因被激活表达；</li><li>类似接合孔复合体的合成和装配；</li><li>T-DNA 的切割、加工和转运；</li><li>T-DNA 整合到植物染色体上</li></ol><p>T-DNA 整合到植物染色体上：</p><ol><li>首先在植物靶 DNA 上出现一个缺刻（nick）</li><li>随着 DNA 解链，宿主细胞的 5’-3’ 外切酶活性使缺刻扩大成裂口（gap）</li><li>T-DNA 侵入裂口，末端与靶 DNA 单链上的少数核苷酸配对形成异源二倍体；</li><li>T-DNA 悬挂在外侧的末端被切割除去，T-DNA 与靶 DNA 末端相连；</li><li>以整合后的 T-DNA 链为模板合成 T-DNA 的第二条链，完成整合过程。</li></ol><p>Ti 质粒的改造</p><p>改造原因：</p><ul><li>Ti 质粒无单一的限制性内切酶位点，不能通过体外 DNA 重组技术直接向野生型 Ti 质粒导入外源基因；</li><li>Ti 质粒的分子量太大，给 DNA 的重组以及基因转化等操作带来困难，Ti 质粒上还存在一些对于 T-DNA 转移不起任何作用的基因。</li><li>野生的 Ti 质粒带有致瘤基因，感染植物后，引起冠瘿瘤，阻碍细胞的分化和植株的再生；</li><li>Ti 质粒本身无合适的选择基因；</li><li>Ti 质粒不能在大肠杆菌中复制，即使得到重组质粒，也只能在农杆菌中进行扩增。</li></ul><p>Ti 质粒衍生的克隆转化载体必须具备以下的结构特点：</p><ul><li>具有选择标记基因</li><li>DNA 复制起始位点</li><li>T-DNA 右边缘序列</li><li>单克隆位点</li><li>vir 区域，利用双元载体系统和共整合载体系统解决。</li></ul><p>共整合载体系统（一元载体系统）</p><ol><li>Ti 质粒进行卸甲处理</li><li>将目的基因构建于中间载体上</li><li>在卸甲载体 T-DNA 区插入一段与中间载体同源的质粒序列。</li><li>然后将中间载体转移到含有卸甲载体的根癌农杆菌中，中间载体通过同源重组整合到卸甲载体的 T-DNA 区，并与卸甲 Ti 质粒一起复制。</li><li>根据中间载体上所携带的抗性基因进行抗性筛选，获得遗传重组根癌农杆菌菌株。</li><li>使用这种菌株去侵染植物组织细胞，就可以获得含有目的基因的转基因植物。</li></ol><p>双元载体系统：Vir 基因不必与 T-DNA 位于同一质粒上，只需处于同一细菌中</p><p>叶盘转化法</p><h4 id="基因枪法"><a class="header-anchor" href="#基因枪法"></a>基因枪法</h4><p>基因枪法原理：借助高速运动的金属微粒（金粒或钨粒）将质粒 DNA 引入植物细胞内。首先将质粒 DNA 附着在金属微粒子上，然后借助高压驱动，将附有 DNA 的微粒射入靶细胞内。</p><p>决定基因枪使用成功的因素：</p><ol><li>第一因素是动力系统。根据动力系统，基因枪分为三大类：<ul><li>第一类是以火药爆炸力作为动力加速微弹；</li><li>第二类是以电弧放电蒸发浪作为动力；</li><li>第三类是以高压气体作为动力。</li></ul></li><li>第二因素是微弹的制备过程。用的微载体有两类：一是钨粉，另一个是金粉，直径一般为 0.6 ～ 4 μm。常用的将 DNA 包被到微载体上所用的沉淀试剂有亚精胺、氯化钙、乙醇、聚乙二醇、异丙醇等。</li><li>第三个因素是受体材料的选择。</li></ol><h4 id="原生质体介导法"><a class="header-anchor" href="#原生质体介导法"></a>原生质体介导法</h4><p>（一）PEG 介导原生质体转化</p><p>原理：在 PEG 和 Ca<sup>2+</sup> 的存在下，原生质体的细胞膜会发生一系列结构上的瞬时变化，使得 DNA 通过细胞膜进入细胞内，进<br>而与植物基因组 DNA 整合。</p><p>机制：推测在二价阳离子存在条件下，PEG 使 DNA 沉淀在细胞膜上，细胞通过内吞作用，将质粒 DNA 吞进细胞。</p><p>转化过程：原生质体的制备 → 转化 → 培养 → 筛选抗性愈伤组织 → 再生</p><p>转化受体及特点：受体原生质体，已成功转化水稻、小麦等，技术性强，程序复杂，转化频率较低，转基因植株变异频率高。</p><p>（二）脂质体介导法</p><p>脂质体：是一种人工膜。在水中磷脂分子亲水头部插入水中，疏水尾部伸向空气，搅动后形成双层脂分子的球形脂质体，直径 25 ～ 1000 nm不等。</p><p>用脂质体包裹一些 DNA 就成了一种人工模拟的原生质体，与植物原生质体共保温后脂质体与原生质体膜结构之间发生相互作用，而后通过细胞的内吞作用而将外源 DNA 导入植物的原生质体。</p><p>（三）电激法</p><p>在高压电场的瞬时作用下，细胞膜可以出现可逆的微小孔洞，外源 DNA 可以通过这些孔洞进入细胞内。可用于真核、原核细胞的转染</p><p>优点：简单、重复性好、转移效率高<br>缺点：对细胞有损伤</p><p>转化受体及特点：受体原生质体或部分消解的愈伤组织，已成功转化水稻、玉米、小麦、烟草、马铃薯等，转化频率较高</p><p>（四）显微注射法</p><p>DNA 损失少</p><p>无需选择标记基因整合效率高</p><p>（五）激光微束介导法</p><p>利用激光微束（0.3 ～ 0.5 uM）射击靶细胞，引起可逆性穿孔，从而直接导入外源 DNA。首先在动物与人的细胞中获得成功，80 年代后期用于植物。<br>技术原理：激光照射系统产生高能量激光脉冲，照射经高渗处理的材料，产生穿孔后，外源 DNA 向靶细胞渗入。然后培养靶组织，产生转化植株。<br>优点：可瞄准靶细胞定位导入外源 DNA，与其他方法比较对靶细胞损伤小、恢复快。单、双子叶植物均可，受体细胞可以是花粉、单细胞或组织、器官。<br>缺点：需要相应昂贵的设备，穿刺处理速度较慢。</p><h3 id="植物转基因方法比较"><a class="header-anchor" href="#植物转基因方法比较"></a>植物转基因方法比较</h3><p>根癌农杆菌介导法优点：可以在原生质体、细胞团、组织器官或整株等多级水平上进行，方法成熟可靠，简便易行，周期短，转化率高<br>根癌农杆菌介导法缺点：转化<font color="#faa755">双子叶植物为主</font>。大多数单子叶植物和裸子植物对农杆菌的侵入不敏感，限制了该法在禾谷类作物中的应用。</p><p>DNA 直接转化法优点：无宿主限制，适用于各种单、双子叶植物，操作简单<br>DNA 直接转化法缺点：转化效率低，需要专门设备（电激仪、显微操作仪或基因枪），多数需要原生质体与愈伤组织，周期太长</p><h3 id="高等植物的基因表达系统"><a class="header-anchor" href="#高等植物的基因表达系统"></a>高等植物的基因表达系统</h3><ul><li>外源基因的四环素诱导系统</li><li>外源基因的乙醇诱导系统</li><li>外源基因的地塞米松诱导系统</li><li>外源基因的类固醇诱导系统</li></ul><h4 id="外源基因的四环素诱导系统"><a class="header-anchor" href="#外源基因的四环素诱导系统"></a>外源基因的四环素诱导系统</h4><p>四环素<br>四环素阻碍蛋白基因（Tet repressor，Tet R）<br>四环素操纵基因（Tet resistance operon，TetO）<br>四环素诱导型目的基因（报道基因）</p><h3 id="转基因植物的筛选与检测"><a class="header-anchor" href="#转基因植物的筛选与检测"></a>转基因植物的筛选与检测</h3><p>选择性基因：</p><ul><li>新霉素抗性基因：卡那霉素、新霉素、G418</li><li>庆大霉素抗性基因：庆大霉素</li><li>潮霉素磷酸转移酶基因：潮霉素</li><li>膦丝菌素乙酰转移酶基因：膦丝菌素</li></ul><p><a id="Noun报告基因"></a><font color="#ea66a6">报告基因</font>是指一类在细胞、组织、器官或个体处于特定情况下会表达并使得他们产生易于检测、且实验材料原本不会产生的性状的基因。<a  href="#Back报告基因">↩</a></p><p>作为报告基因，在遗传选择和筛选检测方面须具有以下条件：</p><ol><li>已被克隆和全序列已测定；</li><li>表达产物在受体细胞中本不存在，即无背景，在被转染的细胞中无相似的内源性表达产物，且不损坏受体细胞。</li><li>其表达产物能进行定量测定。</li></ol><p>报告基因主要类型：</p><ol><li>氯霉素乙酰转移酶基因（<em>cat</em>）</li><li>β-D-葡萄糖酸苷酶基因（<em>gus</em>）</li><li>荧光素酶基因（<em>luc</em>）</li><li>绿色荧光蛋白基因（<em>gfp</em>）</li></ol><p>转基因植物的 GUS 检测原理：β-D-葡萄糖酸苷酶基因（Gus），催化 β-葡萄糖苷酯类物质水解。其中很多水解产物具有发色团或形成荧光物质。</p><p>例：组织化学法测定 Gus 活性，作用底物为 X-gluc，产物是一种不可溶的 5,5-二溴,4,4-二氯靛蓝；</p><p>转基因植物的 GFP 检测</p><p>转基因植物产品的检测，目前已采用的检测方法：</p><ul><li>核酸水平，DNA：PCR、Southern 杂交；RNA：RT-PCR、Nouthern 杂交</li><li>蛋白质水平，Western杂交</li></ul><h3 id="转基因植物的应用"><a class="header-anchor" href="#转基因植物的应用"></a>转基因植物的应用</h3><ul><li>抗除草剂的转基因植物（最早进入田间生产，目前载培面积最大），如 Monsanto 的抗除草剂草甘膦大豆</li><li>抗虫转基因植物，如Syngenta的Bt :176抗虫玉米</li><li>抗病转基因植物（抗病毒，抗真菌，抗细菌）</li><li>抗环境胁迫转基因作物（温度、 水分、化学物）</li><li>植物发育调节基因工程（控制果实成熟, 雄性不有，改良植物品质）</li><li>医药领域中的转基因植物（利用植物作为生物反应器，生产药用蛋白、食用疫苗等）</li></ul><h2 id="第九章-动物基因工程"><a class="header-anchor" href="#第九章-动物基因工程"></a>第九章 动物基因工程</h2><p>转基因动物（transgenic animal）：分为遗传性与非遗传性</p><ul><li>遗传性（转基因动物个体）：指用 DNA 重组技术将人们所需要的目的基因导入动物的受精卵或早期胚胎内，使外源目的基因随细胞的分裂而增殖并在体内表达，且能稳定地遗传给后代的动物。</li><li>非遗传性（动物细胞工程）：指用 DNA 重组技术将人们所需要的目的基因导入动物受体细胞，使外源目的基因随细胞的分裂而增殖并在体内表达，仅在当代表现，不遗传给子代。</li></ul><h3 id="哺乳动物细胞表达系统优缺点"><a class="header-anchor" href="#哺乳动物细胞表达系统优缺点"></a>哺乳动物细胞表达系统优缺点</h3><p>优点：表达的蛋白与天然蛋白在结构、糖基化、磷酸化、寡聚体类型和方式上几乎相同，且能正确组装成多亚基蛋白。如 EPO（促红细胞生成素）</p><blockquote><p>EPO（促红细胞生成素）用原核系统进行表达——缺少可用以进行糖基化的结构和机制，酵母、昆虫或植物表达的产品可以糖基化，但这类细胞的糖基化酶不同，因而表达产物的寡糖链末端多为甘露糖、N-羟基乙酰神经氨酸（GlcNAc）和半乳糖，易被肝细胞、巨噬细胞表面的受体识别而清除。因此此类产品可能对人有免疫原性。</p></blockquote><p>缺点：</p><ul><li>哺乳动物细胞的表达水平低；</li><li>获得高表达细胞株所需的时间长；</li><li>细胞大规模培养的成本高；</li><li>哺乳动物细胞生产的蛋白质类药物的成本较高；</li></ul><h3 id="哺乳动物的受体系统"><a class="header-anchor" href="#哺乳动物的受体系统"></a>哺乳动物的受体系统</h3><p>（一）正常的哺乳类动物细胞具有四大生物学特征：</p><ul><li>锚地依赖性：细胞必须附在固体上或固定的表面才能生长分裂</li><li>血清依赖性：细胞必须具有生长因子才能生长</li><li>接触抑制性：细胞与细胞接触后，生长便受到抑制</li><li>形态依赖性：细胞扁平状，并有长纤维网状结构</li></ul><blockquote><p>上述特征使得正常的哺乳动物细胞在体外培养中，一般只能存活 50 代且在培养皿上以平面的形式生长，即单层细胞生长。有时，正常细胞会改变某些特征而越过生理临界点，继续增殖并无限制分裂，这种状态称为细胞系形成，此时的细胞成为细胞系</p></blockquote><p>（二）高效表达外源基因受体细胞应具备下列条件：</p><ul><li>细胞系特征，丧失细胞接触抑制性和锚地依赖性特征，便于大规模培养</li><li>合适的标记，便于转化株的筛选和维持</li><li>遗传稳定性，外源基因多次传代后不至于丢失，易于长期保存</li><li>生长快且齐，分裂周期短，生长均一，便于控制</li><li>安全性能好，不合成分泌致病物质，不致癌</li></ul><p>（三）高等哺乳动物受体细胞的类型</p><p>根据受体细胞表达的重组蛋白的稳定性和糖基化类型不同，按照要表达的目的蛋白选择最佳的受体细胞，现今高等哺乳动物受体细胞类型主要由以下 5种：</p><ul><li>中国仓鼠卵巢细胞（CHO）</li><li>绿猴肾细胞（CV-1）</li><li>地鼠幼鼠肾细胞（BHK)</li><li>小鼠乳腺肿瘤细胞（C127）</li><li>西班牙犬肾细胞（MDCK细胞）</li></ul><p>（1）中国仓鼠卵巢细胞（CHO），迄今为止，用于医疗用品（药物、抗体、诊断试剂）大规模生产的高等哺乳动物受体细胞主要是中国仓鼠卵巢细胞（CHO）</p><ul><li>遗传背景清楚，生理代谢稳定</li><li>与人的亲缘关系接近，外源蛋白修饰准确</li><li>基因转移和载体表达系统完善</li><li>耐受剪切力，便于大规模培养</li><li>被美国 FDA 确认为安全的基因工程受体细胞（GRAS）</li></ul><p>（2）1981 年，Gluzman 用编码野生型 T 抗原但复制起点缺失的 SV40，转化允许 SV40 裂解性生长的非洲绿猴肾细胞 CV-1，获得了三个细胞系：COS1、COS3、COS7。这三个细胞系均含有 T 抗原，保留完全的允许 SV40 裂解性生长的能力（被广泛地用于瞬时表达系统）。</p><p>T 抗原作用：当表达产生的 T 抗原结合到 SV40 的复制点的 DNA 调控区，病毒 DNA 的复制即被启动。</p><p>（3）BHK-21：1961 年从地鼠幼鼠的肾脏分离而来成果：用它表达的重组凝血因子Ⅷ已获准投放市场。</p><p>（4）C127 细胞：来自 RⅢ 小鼠乳腺肿瘤细胞，特别适用于带有牛乳头瘤病毒（BPV）载体的转染：用 C127 细胞生产的重组人生长激素（hGH）已获准投放市场，用于治疗生长激素缺乏症。</p><p>（5）MDCK 细胞：1958 年从成年雌性的西班牙长耳狗的肾脏分离获得的，是贴壁生长的上皮样细胞：有报道用该细胞结合人巨细胞病毒早早期启动子可高效表达分泌蛋白，表达量占细胞分泌蛋白质总量的 15% ～ 20%。</p><h3 id="高等哺乳动物受体细胞的遗传标记"><a class="header-anchor" href="#高等哺乳动物受体细胞的遗传标记"></a>高等哺乳动物受体细胞的遗传标记</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%93%BA%E4%B9%B3%E5%8A%A8%E7%89%A9%E5%8F%97%E4%BD%93%E7%BB%86%E8%83%9E%E5%B8%B8%E8%A7%81%E7%9A%84%E9%81%97%E4%BC%A0%E9%80%89%E6%8B%A9%E6%A0%87%E8%AE%B0.71wq3gp97v40.svg" alt="哺乳动物受体细胞常见的遗传选择标记"></p><p>含有胸腺嘧啶核苷激酶（TK）编码基因缺陷的（<em>tk</em><sup>-</sup>）受体细胞，不能在含有次黄嘌呤、氨基喋呤、胸腺嘧啶核苷的培养基上（HAT 培养基）生长，载体上的标记基因 <em>tk</em> 能与之遗传互补</p><p>含有次黄嘌呤磷酸核糖转移酶（HPRT）编码基因缺陷的（<em>hprt</em><sup>-</sup>）受体细胞，不能在含有次黄嘌呤、氨基喋呤、胸腺嘧啶核苷的培养基上（HAT培养基）生长，载体上的标记基因 <em>hprt</em> 与之遗传互补</p><h3 id="哺乳动物细胞载体系统"><a class="header-anchor" href="#哺乳动物细胞载体系统"></a>哺乳动物细胞载体系统</h3><p>哺乳动物细胞表达载体应具备的条件：</p><ol><li>基本的元件：增强子、终止信号和 poly(A) 信号、多克隆位点、剪接信号、筛选标记等；</li><li>易于扩增至足够数量，能够在哺乳动物细胞内稳定存在、不丢失：哺乳动物细胞无天然质粒，需具有原核和真核复制起点；</li><li>能够在哺乳动物细胞内高效表达的强启动子：一般细胞不过量表达蛋白。</li></ol><h4 id="质粒型载体"><a class="header-anchor" href="#质粒型载体"></a>质粒型载体</h4><p>（一）通用型表达载体</p><p>通用型表达载体拥有真核细胞表达载体共同结构特征，可使携带的目的基因高效表达，而且一般无物种或细胞类型的特异性，是研究基因功能的有力工具。如 pEGFP-N1 等。</p><p>pEGFP-N1 表达载体的特点：</p><ol><li>从结构上看，载体中的 pUC <em>ori</em>，保证该载体在大肠杆菌中具有很强的复制能力；</li><li>含有高效且功能强大的启动子 PSV40 和 PCMV，可以使目的基因在细胞中稳定表达；</li><li>具有多克隆位点（MCS），便于目的基因的插入；</li><li>具有 SV40 <em>ori</em>，使该载体在任何表达 SV40 T 抗原的真核细胞内进行复制；</li><li>含新霉素抗性基因表达盒，由 SV40 早期启动子、卡那霉素抗性基因（<em>neo</em><sup>r</sup>/<em>kan</em><sup>r</sup>) 以及单纯疱疹病毒胸苷激酶基因 HSV-TK 的聚腺嘌呤信号组成，可以采用 G418 来筛选。</li><li>具有 EGFP 报告基因。EGFP 是一种优化的突变型 GFP，产生的荧光比普通 GFP 强 35 倍，大大增强了其报告基因的敏感度。EGFP 的 N 及 C 端均可融合，并不影响其发光。</li></ol><p>这些特殊的结构可以实现目的基因在靶细胞内的稳定表达和鉴定。</p><p>（二）组织特异性表达载体</p><p>组织特异性表达载体是利用某种组织特殊的启动子构建真核表达载体，驱动目的基因在特定组织中表达。常用的高等哺乳动物组织特异性表达载体有乳腺组织特异性表达载体、脂肪组织特异性表达载体、肌肉组织特异性表达载体、神经组织特异性表达载体、前列腺组织特异性表达载体等</p><p>pBC1 是山羊乳腺特异性质粒表达载体，具有以下特点:</p><ol><li>含有一个可以保证重组质粒在原核细胞内大量复制的复制原点（来自质粒 pBR322）;</li><li>具有选择性标记氨苄青霉素抗性基因（ampicillin）</li><li>具有山羊乳腺特异性表达的 β-酪蛋白基因启动子（Pβ-casein），目的基因插入到外显子 2 和 7 之间的 <em>Xho</em>Ⅰ 多克隆位点上，其后<br>为 β-酪蛋白基因的 3’ 调控区，保证转录的有效终止。</li><li>启动子上游有两个 β-肌球蛋白（β-globin）基因的绝缘子序列（β-globin insulator），能够防止随机整合外源基因插入位点的位置效应，保证目的基因的高效表达。</li><li>该载体还可以通过在 <em>Sal</em>Ⅰ 和 <em>Not</em>Ⅰ位点插入靶基因的两侧同源臂，制备成同源重组转基因结构，实现基因敲除（knock-out）与敲入（knock-in）。</li></ol><p>利用该转基因结构制备的转基因动物乳腺中外源基因的表达水平可达到 60 mg/L。</p><h4 id="病毒类载体"><a class="header-anchor" href="#病毒类载体"></a>病毒类载体</h4><ul><li>人腺病毒 DNA</li><li>猴空泡病毒 DNA（SV40）</li><li>人乳多瘤病毒 DNA（BKV）</li><li>人牛痘病毒 DNA</li></ul><p>腺病毒的基因组 DNA</p><p>腺病毒基因组 DNA 全长 36 kb，其包装上限为原基因组的 105%，DNA 两端各有一个反向重复序列（<em>ITR</em>）；<em>E</em>1 ～ <em>E</em>4为早期基因，与病毒基因组表达调控有关，其中 <em>E</em>3 编码晚期基因的调控因子，<em>L</em>1 ～ <em>L</em>5 为编码病毒包装蛋白的晚期的复制及晚期基因的基因；<em>IVa</em>2 和 <em>VA</em> 均为病毒 RNA 聚合酶的亚基编码基因。<em>E</em>3 区缺失只会影响病毒颗粒的成熟，不影响基因组的复制功能，因而在构建载体时往往除去这个 2.2 kb的片段，使得载体的装载量提高到 4 kb以上。</p><p>腺病毒 DNA 载体的特点：</p><ol><li>基因重排低，外源基因与病毒 DNA 重组后能稳定复制几个周期</li><li>安全性能好，不整合人的染色体 DNA，不会导致恶性肿瘤</li><li>宿主范围广，对受体细胞是否处于分裂期要求不严格</li><li>使用效果好，外源基因在载体上容易高效表达</li></ol><h4 id="定向打靶载体"><a class="header-anchor" href="#定向打靶载体"></a>定向打靶载体</h4><p>基因打靶（genetargeting）是一种定向改变生物活体遗传信息的操作技术。该技术是在胚胎干细胞（embryonic stem cell, ESC）与同源重<br>组（homologous recombination, HR）基础上建立起来的。基因打靶通过对生物活体遗传信息的定向修饰包括基因灭活、点突变引入、缺<br>失突变、外源基因定位引入、染色体组大片段删除等，并使修饰后的遗传信息在生物活体内遗传，表达突变的性状，从而研究基因功能、提供相关的疾病治疗和建立新药饰选评价模型等。2007 年度诺贝尔生理学或医学奖授予了美国犹他大学医学院的 Capecchi、英国卡迪夫大学医学院的 Evans 和北卡罗莱纳大学医学院的 Smithies 等三人以表彰他们在小鼠中的“基因打靶”技术的应用。</p><p>基因打靶技术主要四个步骤：</p><ol><li>基因打靶载体的构建。把目的基因和调控序列等与内源靶序列同源的序列都重组到带标记基因的载体上。</li><li>打靶载体的导入受体细胞内;</li><li>同源重组子的筛选，用选择性培养基筛选打靶击中的重组阳性细胞;</li><li>将重组阳性细胞转入动物胚胎，产生转基因动物，并进行检测。</li></ol><p>（1）敲降载体</p><p>敲降载体的作用是使受体细胞特定的靶基因 mRNA 发生降解，从而使靶基因的表达水平大幅降低。</p><p>敲降载体的构建是基于 RNAi 技术原理进行的。RNAi 的优点是作用特异性强，敲降靶基因效率高，相对基因敲除载体操作简单，筛选细胞周期短。<br>由于 RNAi 识是在转录后水平上降低基因表达，而不是从基因组中剔除掉基因，有时也会因背景不干净导致表型难以分析。</p><p>以荧光素酶报告基因为例说明其检测原理。首先构建一个真核表达载体，在荧光素酶或 GFP 报告基因的翻译终止密码子后插入目的基因片段。将构建后的载体和 shRNA 共转染 293 T 细胞，在 293 T 细胞内就会转录出荧光素酶基因和目的基因的融合 mRNA，如果 shRNA 在目的基因上无靶点，不会影响荧光素酶基因的翻译，在添加荧光素酶化学发光底物情况下，底物就会被分解并产生一定波长光，通过检测器可检测荧光;反之，若 shRNA 在目的基因上有靶点，融合 mRNA 被降解，荧光素酶基因不能翻译，就不会产生荧光。通过该系统可以快速、准确的验证 RNAi 干扰靶点。</p><p>（2）敲除载体</p><p>敲除载体是在 DNA 水平对受体细胞内靶基因实施编辑与修饰，对基因功能研究、转基因动物疾病模型建立和畜禽性状改良等方面有着广泛应用价值。</p><p>敲除载体主要作用是破坏靶细胞中特定基因表达结构，使其不能表达，具有位点特异性。为了实现此目的，可通过同源重组来实现，随着基因敲除技术的发展产生了基因敲除效率更高的锌指核酸酶、TALEN、CRISPR/Cas9 和 Cre-LoxP等技术。</p><p>CRISPR/Cas 系统概述</p><p>CRISPR/Cas 系统是很多细菌和大部分古细菌的天然免疫系统，通过对入侵的病毒和核酸进行特异性的识别，利用 Cas 蛋白进行切割，从而达到对自身的免疫。</p><p>CRISPR 结构：CRISPR 是一种特殊的 DNA 重复序列家族，广泛分布于细菌和古细菌基因组中。CRISPR 位点通常由短的高度保守的重复序列（repeats）组成，重复序列的长度通常为 21 ～ 48 bp，重复序列之间被 26 ～ 72 bp 间隔序列（spacer）隔开。CIRSPR 通过这些间隔序列（spacer）与靶基因进行识别。</p><p>Cas 家族：Cas（CRISPR associated）存在于 CRISPR 位点附近，是一种双链 DNA 核酸酶，能在 guide RNA 引导下对靶位点进行切割。它与 fokⅠ 酶功能类似，但是它并不需要形成二聚体才能发挥作用。</p><p>CRISPR/Cas9 系统作用机制</p><ul><li>CRISPR 基因座的表达（包括转录和转录后的成熟加工）</li><li>当该噬菌体再次入侵细菌时，CRISPR 簇首先转录为长的 crRNA 前体，然后逐步加工成小的成熟的 crRNA。</li><li>CRISPR/Cas 系统活性的发挥或外源遗传物质的干扰</li><li>crRNA 结合相关的 Cas 蛋白后，形成 crRNA-Cas 蛋白复合体，通过碱基互补配对精确地与目标 DNA 相结合，随后 Cas 蛋白对目标 DNA 进行断裂和降解。</li><li>Cas9 是一种核酸内切酶，其具有：RuvC 和 HNH 两个内切酶活性中心</li><li>Jinek 等发现 Cas9 在细菌和试管里对双链 DNA 具有强烈的切割能力,但是这种切割能力需要的 crRNA 和 tracrRNA 介导。</li><li>Jinek 等创造性的把 crRNA 和部分 tracrRNA 融合成一条嵌合的 RNA 链,使其同时具有 crRNA 和 tracrRNA 的特性，随后的切割实验表明，这条嵌合的 RNA 同样可以引导 Cas9 切割目标 DNA。现在普遍使用的都是 crRNA 和全长 tracrRNA 融合体,简称 sgRNA (single guide RNA)</li></ul><p>CRISPR/Cas9 脱靶效应</p><ul><li>2013 年，研究者们发表多篇文章介绍 CRISPR/Cas9 系统，但 CRISPR/Cas9 目前仍存在一个很严重且无法避免的问题，即潜在的脱靶效应不可消除。</li><li>Cas9 蛋白不具特异性</li><li>CRISPR/Cas9 与靶位点识别的特异性主要依赖于 gRNA 与靠近 PAM（5’-NGG-3’）处 10 ～ 12 bp 碱基的配对，而其余远离 PAM 处 8 ～ 10 bp 碱基的错配对靶位点的识别影响不大。</li></ul><p>降低脱靶效应：添加同源臂（homology arm,HR）</p><h3 id="制备转基因动物的方法"><a class="header-anchor" href="#制备转基因动物的方法"></a>制备转基因动物的方法</h3><p>转基因动物研究的核心技术是成功地把目的基因转入动物早期胚胎细胞中。目前，研究制备转基因动物的主要方法有:</p><ol><li>显微注射法</li><li>胚胎干细胞法</li><li>反转录病毒感染法</li><li>精子载体导入法</li><li>体细胞核移植法</li></ol><h4 id="显微注射法"><a class="header-anchor" href="#显微注射法"></a>显微注射法</h4><p>受精卵能够分化出各种细胞、组织，形成一个完整的个体，所以把受精卵的分化潜能称为全能性。随着分化发育的进程，转基因会分布到各种组织细胞中去，包括生殖细胞，因此，转基因是可以遗传的。</p><p>受精卵显微注射制备转基因动物的优点：</p><ol><li>转移率高</li><li>实验周期相对较短</li><li>导入过程直观</li><li>外源基因的大小不受限制</li><li>没有化学试剂等对细胞的毒性作用</li></ol><p>受精卵显微注射制备转基因动物的缺点：</p><ol><li>设备昂贵；</li><li>技术难度高；</li><li>胚胎受到机械损伤大而存活率降低；</li><li>只能敲入外源基因，不能敲除或定点修饰基因；</li><li>外源基因整合至基因组的效率很低，对经济大动物（猴、牛、羊）的整合效率更低；</li><li>外源基因随机整合，或影响内源基因本身的表达；</li><li>对经济大动物，由于需要大量的供体和受体，耗时长、费用昂贵，受到很大的限制。</li></ol><h4 id="胚胎干细胞法"><a class="header-anchor" href="#胚胎干细胞法"></a>胚胎干细胞法</h4><p>胚胎干细胞（embryonic stem cell，ES）是从早期胚胎内细胞团（ICM）分离出来的，能在体外培养的一种高度未分化的多能干细胞。</p><ul><li>它是一种含正常二倍体染色体的具有发育全能性的细胞。</li><li>可以在体外进行人工培养，扩增，并能以克隆的形式保存。</li></ul><p>ESC 法是将外源 DNA 定向整合到内源基因组中表达。将转染的胚胎干细胞注射入受体囊胚腔，可参与嵌合体的形成，将来出生的动物的生殖系统就有可能整合上外源基因，通过杂交繁育得到纯合目的基因的个体，即为转基因动物。</p><p>胚胎干细胞法制备转基因动物的优点：</p><ol><li>不受细胞代次影响</li><li>只需将外源基因导入干细胞</li><li>可以通过筛选细胞提高转基因效率</li></ol><p>胚胎干细胞法制备转基因动物的缺点：</p><ol><li>大动物胚胎干细胞建系困难；</li><li>第一代动物为嵌合体；</li><li>转基因周期时间长，效率较低。</li></ol><h4 id="反转录病毒感染法"><a class="header-anchor" href="#反转录病毒感染法"></a>反转录病毒感染法</h4><p>利用反转录病毒的高效率感染和在宿主细胞DNA上的高度整合特性，可以大大提高基因转移的效率。因此可以利用反转录病毒作为目的基因的载体，通过感染实现基因转移，产生嵌合体动物，再经过杂交，筛选即可获得转基因动物。</p><p>逆转录病毒感染法优点：在各种转基因方法中，逆转录病毒感染法的转基因效率是最高的，且为单拷贝随机整合。</p><p>逆转录病毒感染法缺点：逆转录病毒载体在设计时虽然缺失了病毒的复制功能序列，但是复制大量载体DNA所需的辅助病毒基因组内有可能与目的基因一起整合到同一细胞核中，就可能大量复制病毒，造成严重的污染，故不安全。此外，逆转录病毒载体容量有限，只能转移小片段 DNA（≤ 10 kb），而且逆转录病毒长末端重复的甲基化状态常使转基因的表达缺失。</p><h4 id="精子载体法"><a class="header-anchor" href="#精子载体法"></a>精子载体法</h4><p>精子吸附 DNA 的方法</p><p>精子吸附 DNA 就使目的基因进入精细胞，再通过受精作用把目的基因传给子代动物，获得转基因动物。外源目的基因进入精细胞可通过与精子共育法、电穿孔导入法和脂质体转染法。</p><p>受精技术</p><p>精子在吸附外源性 DNA 后，即可以利用其进行受精，受精的方法及途径随着精子的处理方式及卵来源不同而有所不同：</p><ul><li>人工授精</li><li>壶腹部手术授精</li><li>体外授精</li></ul><p>精子载体法制备转基因动物的优点：</p><ol><li>简便易行；</li><li>耗费低；</li><li>转染率高；</li><li>适应性广。</li></ol><p>精子载体法制备转基因动物的缺点：</p><ol><li>不够稳定；</li><li>随机整合率高。</li></ol><h4 id="体细胞核移植法"><a class="header-anchor" href="#体细胞核移植法"></a>体细胞核移植法</h4><p>体细胞核移植法制备转基因动物的优点：</p><ol><li>适用于大多数物种</li><li>试验周期短</li><li>可在细胞水平检测外源基因是否整合</li><li>细胞核供体容易获得、操作从容</li></ol><p>体细胞核移植法制备转基因动物的缺点</p><ol><li>操作程序相对复杂;</li><li>可能出现生理缺陷;</li><li>克隆效率较低。</li></ol><h3 id="转基因动物的应用"><a class="header-anchor" href="#转基因动物的应用"></a>转基因动物的应用</h3><h4 id="转基因动物在生命科学基础研究中的应用"><a class="header-anchor" href="#转基因动物在生命科学基础研究中的应用"></a>转基因动物在生命科学基础研究中的应用</h4><ul><li>研究基因的结构与功能</li><li>研究基因的组织特异性表达</li><li>研究发育相关基因的表达与调控</li><li>克隆在发育中起重要作用的基因</li><li>基因多级调节系统的研究</li></ul><h4 id="在农牧业生产上的应用"><a class="header-anchor" href="#在农牧业生产上的应用"></a>在农牧业生产上的应用</h4><ul><li>优良动物品种育种</li><li>快速生长与肉质改良</li><li>增强抗病性</li><li>增强抗逆性</li></ul><h4 id="转基因动物在医药研究领域中的应用"><a class="header-anchor" href="#转基因动物在医药研究领域中的应用"></a>转基因动物在医药研究领域中的应用</h4><ul><li>研究病毒性疾病</li><li>研究建立人类疾病的转基因动物模型</li><li>转基因动物与基因治疗</li><li>生产天然活性药物蛋白</li></ul><h4 id="在异种器官移植中的应用"><a class="header-anchor" href="#在异种器官移植中的应用"></a>在异种器官移植中的应用</h4><p>建立异种抗原缺失或者表达水平低下的转基因动物（猪）</p><h3 id="转基因动物研究及其产品的安全性评价"><a class="header-anchor" href="#转基因动物研究及其产品的安全性评价"></a>转基因动物研究及其产品的安全性评价</h3><h4 id="供体动物和受体动物"><a class="header-anchor" href="#供体动物和受体动物"></a>供体动物和受体动物</h4><ol><li>提供配子或胚胎干细胞的动物（供体）以及受体的动物需要有详细的履历，包括受体、供体的背景资料、生物学特性、生态环境、健康状<br>况及其他系谱资料等。</li><li>动物的健康状况应由兽医专家进行评估，包括与物种及繁衍有关疾病问题的特定检查。</li><li>为控制某些偶发性病原菌的传播，供体和受体动物应满足同样的建立生产群所要求的偶发性病原菌检查标准。而作为异种移植供体使用的转基因动物，对其供体和受体动物来源地区的传染病监测更为严格</li><li>对工作人员的健康状况也要做系统检查，甚至要终生监测</li></ol><h4 id="基因操作的安全性"><a class="header-anchor" href="#基因操作的安全性"></a>基因操作的安全性</h4><p>为确保终产物具有预期性，必须对用来生产转基因动物的重组 DNA 构件加以很好的鉴定，转基因构件的组装、克隆、纯化及最后的鉴定均应有质<br>量监控。主要包括:</p><ol><li>转基因及其表达系统（功能的异源获得）</li><li>通过同源重组实现基因的定位整合（功能的同源丧失）</li><li>转基因及其表达产物的安全性鉴定</li></ol><h4 id="转基因动物释放的安全性评价"><a class="header-anchor" href="#转基因动物释放的安全性评价"></a>转基因动物释放的安全性评价</h4><p>（一）遗传稳定性</p><p>外源 DNA 插入到宿主动物的基因组中往往牵涉到多拷贝的 DNA 同时整合到染色体的同一位点上，也可能整合位点多于一个，以及整合过程中或整合后，全部或有些基因发生重排或缺失。在传代过程中可能发生染色体交换、易位等引起转基因在基因组中的位置或基因结构的变化，进而引起编码的蛋白发生变化以及新基因的灭活或基因沉默等。因此，转基因动物释放前，其稳定性应该通过诸如 Southern 等方法来检测几代转基因动物的稳定性。</p><p>（二）表达稳定性</p><ul><li>转基因表达的稳定性会发生改变，这种改变取决于宿主动物的遗传背景与转基因之间互作的程度，以及转基因由于父系或母系遗传所表现出的印记作用。有结果表明，随着传递代数增加，转基因表达水平会降低。</li><li>因此，在一个世代中或经过若于代后, 转基因的稳定性应从表达量确定，应确定一个可接受的表达量的范围作为标准。可能时，正常的或预期的转基因RNA转录水平还应包括转录物的大小、相对丰度、RNA 生成的组织和细胞系等角度进行验证。方法包括 Northern、RT-PCR 等技术。</li><li>对预期产物的量应从多个转基因动物系谱中检测。</li></ul><h4 id="生态环境安全问题"><a class="header-anchor" href="#生态环境安全问题"></a>生态环境安全问题</h4><ul><li>以抗病性改良为目标的生产性状改良型转基因动物，其抗病性实际上为病原提供了更强的选择压力，造成病原可能在选择压力下进化的问题，病原的进化不仅对转基因动物带来危害，同时也对非转基因群体带来极大的威胁。</li><li>转基因动物一旦发生逃逸有可能破获生态平衡。</li><li>转基因动物应严格隔离，繁育应仅限于特定机构中进行，同时要对转基因动物群体和个体进行监测。</li></ul><h4 id="几个转基因动物伦理学方面的问题"><a class="header-anchor" href="#几个转基因动物伦理学方面的问题"></a>几个转基因动物伦理学方面的问题</h4><ul><li>我们没有权利因为好奇或者其它奇怪的目的干涉生物的基因组</li><li>在制造转基因动物的过程中有较高的死亡率，为了获得一个成功的转基因动物牺牲那么多的动物是否值得</li><li>转基因的动物通常是怪物一样的东西，它们要么因为所转的基因寿命缩短，如果它们逃逸出去对于周围环境中的生物会造成威胁。</li><li>小鼠之类的动物与人类是如此不同，它们怎能成为精准的人类疾病模型</li></ul><h2 id="第十章-酵母基因工程"><a class="header-anchor" href="#第十章-酵母基因工程"></a>第十章 酵母基因工程</h2><h3 id="发展历程"><a class="header-anchor" href="#发展历程"></a>发展历程</h3><ol><li>1974 年，rlarck—walker 和 Miklos 发现在大多数酿酒酵母中存在质粒。</li><li>1978 年，Hmnen 将来自一株酿酒酵母的 leu 2 基因导入另一株酿酒酵母，弥补了后者的 Leu2 缺陷，标志着酵母重组技术的建立。</li><li>1981 年，Hinnen 等用酵母基因表达系统表达了人干扰素。</li><li>1983 年，中国首次用酵母菌表达了乙型肝炎病毒表面抗原基因。</li><li>1989 年，酵母双杂交系统被用来研究蛋白质间的互作。</li><li>1996年，在全世界科学家的通力合作下，完成了第一个真核生物——酿酒酵母全基因组的测序。</li></ol><h3 id="酵母菌作为表达外源基因受体菌的特征"><a class="header-anchor" href="#酵母菌作为表达外源基因受体菌的特征"></a>酵母菌作为表达外源基因受体菌的特征</h3><p>酵母菌的简介：酵母菌（Yeast）是一群以芽殖或裂殖等无性繁殖或以减数分裂实现有性繁殖。至少由80个属和600多个种组成。</p><p>酵母菌是最成熟的真核生物表达系统。</p><p>酵母菌表达外源基因的优势：</p><ol><li>酵母菌是最简单的真核模式生物</li><li>全基因组测序，基因表达调控机理比较清楚，遗传操作简便</li><li>具有原核细菌无法比拟的真核蛋白翻译后加工系统</li><li>大规模发酵历史悠久、技术成熟、工艺简单、成本低廉</li><li>能将外源基因表达产物分泌至培养基中</li><li>采用高表达的启动子，如 MOX、AOX、LAC4 等</li><li>不含有特异性的病毒、不产内毒素，美国 FDA 认定为安全的基因工程受体系统（Generally Recognized As Safe  GRAS）</li></ol><p>酵母菌表达外源基因的劣势：</p><ol><li>与原核相比，表达效率相对低，因为表达的外源蛋白会形成聚合体而影响产率</li><li>酵母常有密码子偏性，真核基因在其中表达时需要人工修正。</li></ol><h3 id="酵母菌的宿主系统"><a class="header-anchor" href="#酵母菌的宿主系统"></a>酵母菌的宿主系统</h3><h4 id="广泛用于外源基因表达的酵母宿主菌"><a class="header-anchor" href="#广泛用于外源基因表达的酵母宿主菌"></a>广泛用于外源基因表达的酵母宿主菌</h4><p>目前已广泛用于外源基因表达和研究的酵母菌包括：</p><ul><li>酿酒酵母，农业、食品，如啤酒、酒精</li><li>巴斯德毕赤酵母，人血清清蛋白、溶菌酶等</li><li>粟酒裂殖酵母，凝血因子、细胞周期调节蛋白等</li><li>多形汉逊酵母，乙型肝炎表面抗原、葡萄糖淀粉酶等</li><li>乳酸克鲁维酵母，牛凝乳酶、人血清清蛋白、人溶菌酶等</li></ul><p>其中酿酒酵母的遗传学和分子生物学研究最详尽，但巴斯德毕赤酵母表达外源基因最理想</p><h4 id="提高重组蛋白表达产率的突变宿主菌"><a class="header-anchor" href="#提高重组蛋白表达产率的突变宿主菌"></a>提高重组蛋白表达产率的突变宿主菌</h4><ol><li>开发高效的启动子提高和控制外源基因的转录水平</li><li>提供表达载体在细胞的稳定性</li><li>提高表达基因在细胞中的拷贝数</li></ol><h4 id="抑制超糖基化作用的突变宿主菌"><a class="header-anchor" href="#抑制超糖基化作用的突变宿主菌"></a>抑制超糖基化作用的突变宿主菌</h4><p>许多真核生物的蛋白质在其天门冬酰胺侧链上接有寡糖基团，它们常常影响蛋白质的生物活性。整个糖单位由糖基核心和外侧糖链两部分组成。</p><p>酵母菌普遍拥有蛋白质的糖基化系统，但野生型酿酒酵母对异源蛋白的糖基化反应很难控制，呈超糖基化倾向，因此超糖基化缺陷株非常重要。</p><h4 id="减少泛素依赖型蛋白降解作用的突变宿主菌"><a class="header-anchor" href="#减少泛素依赖型蛋白降解作用的突变宿主菌"></a>减少泛素依赖型蛋白降解作用的突变宿主菌</h4><p>真核生物如何识别和选择性降解蛋白质是细胞生命过程中的重要环节，对于维持蛋白质在细胞内含量的动态平衡起着关键性作用。需要清除的蛋白质，通过其赖氨酸残基侧链 ε-氨基连接多聚泛素链（降解标签），继而在蛋白酶体中被降解。</p><p>泛素-蛋白酶体系统与蛋白质质量控制、细胞周期、DNA 修复、转录及免疫应激等密切相关，也与许多种疾病的发生相关。</p><p>泛素降解途径衰减的酿酒酵母 <em>UBI</em> 4 缺陷型：</p><p>在酿酒酵母菌中，泛素主要由 <em>UBI</em> 4基因表达，<em>UBI</em> 4<sup>-</sup> 突变株能正常生长，但细胞内游离泛素分子的浓度比野生株要低得多，因此 <em>UBI</em> 4缺陷突变株是外源基因表达理想的受体。</p><h3 id="酵母菌的载体系统"><a class="header-anchor" href="#酵母菌的载体系统"></a>酵母菌的载体系统</h3><h4 id="酿酒酵母-穿梭质粒"><a class="header-anchor" href="#酿酒酵母-穿梭质粒"></a>酿酒酵母/穿梭质粒</h4><ul><li>靶基因克隆</li><li>TA 克隆</li><li>重组表达载体</li><li>导入酵母</li><li>诱导表达</li><li>蛋白纯化</li></ul><h4 id="毕赤酵母-整合质粒"><a class="header-anchor" href="#毕赤酵母-整合质粒"></a>毕赤酵母/整合质粒</h4><ul><li>靶基因克隆</li><li>TA 克隆</li><li>重组表达载体</li><li>重组质粒线性化</li><li>电转化导入酵母</li><li>诱导表达</li><li>蛋白纯化</li></ul><h3 id="酵母菌的转化系统"><a class="header-anchor" href="#酵母菌的转化系统"></a>酵母菌的转化系统</h3><h4 id="酵母菌的转化方法"><a class="header-anchor" href="#酵母菌的转化方法"></a>酵母菌的转化方法</h4><p>酵母菌原生质体转化法：早期酵母菌的转化都采用在等渗缓冲液中稳定的原生质体转化，在Ca<sup>2+</sup> 和 PEG 的存在下，转化细胞可达原生质体总数的 1 ～ 2%。但该程序操作周期长，而且转化效率受到原生质再生率的严重制约。</p><p>碱金属离子介导的酵母菌完整细胞的转化：酿酒酵母的完整细胞经碱金属离子（如 Li<sup>+</sup> 等）、PEG、热休克处理后，也可高效吸收质粒 DNA，而且具有下列特性：</p><ul><li>吸收线型 DNA 的能力明显大于环状 DNA，两者相差 80 倍</li><li>共转化现象极为罕见</li></ul><p>酵母菌电击转化法：酵母菌原生质体和完整细胞均可在电击条件下吸收质粒 DNA，但在此过程中应避免使用 PEG，它对受电击的细胞具有较很大的负作用。电击转化的优点是不依赖于受体细胞的遗传特征及培养条件适用范围广，而且转化率可高达 10<sup>5</sup> /μg DNA。</p><h4 id="用于转化子筛选的标记基因"><a class="header-anchor" href="#用于转化子筛选的标记基因"></a>用于转化子筛选的标记基因</h4><p>用于酵母菌转化子筛选的标记基因主要有营养缺陷型互补基因和显性基因两大类</p><p>营养缺陷型的互补基因主要有氨基酸和核苷酸生物合成基因，如：<em>LEU</em>、<em>TRP</em>、<em>HIS</em>、<em>LYS</em>、<em>URA</em>、<em>ADE</em></p><p>显性标记基因编码产物只要是毒性物质的抗性蛋白：</p><table><thead><tr><th>标记基因</th><th>编码产物</th><th>遗传表型</th></tr></thead><tbody><tr><td><em>aph</em></td><td>氨基糖苷转移酶</td><td>抗 G418</td></tr><tr><td><em>cat</em></td><td>氯霉素乙酰转移酶</td><td>抗氯霉素</td></tr><tr><td><em>dhfr</em></td><td>二氢叶酸还原酶</td><td>抗氨甲喋呤和磺胺</td></tr><tr><td><em>cup</em>1</td><td>铜离子螯合物</td><td>耐受铜离子</td></tr><tr><td><em>suc</em>2</td><td>蔗糖转化酶</td><td>耐受高浓度蔗糖</td></tr><tr><td><em>ilv</em>2</td><td>乙酰乳糖合成酶</td><td>抗硫酰脲除草剂</td></tr></tbody></table><h3 id="酵母菌的表达系统"><a class="header-anchor" href="#酵母菌的表达系统"></a>酵母菌的表达系统</h3><h4 id="酵母菌启动子的可控性"><a class="header-anchor" href="#酵母菌启动子的可控性"></a>酵母菌启动子的可控性</h4><p>超诱导型启动子</p><p>酿酒酵母的半乳糖利用酶系由 GAL1、GAL7和 GAL10 基因编码</p><p>半乳糖诱导时，GAL4 高效表达，GAL1、GAL1、GAL10 超高效表达</p><h4 id="外源基因在酵母菌中表达的限制因素"><a class="header-anchor" href="#外源基因在酵母菌中表达的限制因素"></a>外源基因在酵母菌中表达的限制因素</h4><ul><li>外源基因稳态 mRNA 的浓度</li><li>外源基因 mRNA 的翻译活性</li><li>酵母菌对密码子的偏爱性</li></ul><p>在酿酒酵母中，高丰度的蛋白质（如甘油醛-3-磷酸脱氢酶 GAPDH、磷酸甘油激酶 PKG、乙醇脱氢酶 ADH）中 96% 以上的氨基酸是由 25 个密码子编码的</p><h4 id="酵母菌表达系统的选择"><a class="header-anchor" href="#酵母菌表达系统的选择"></a>酵母菌表达系统的选择</h4><p>（一）酿酒酵母表达系统</p><p>酿酒酵母的基因表达系统最为成熟，包括转录活性较高的甘油醛-3-磷酸脱氢酶基因 <em>GAPDH</em>、磷酸甘油激酶基因 <em>PKG</em>、乙醇脱氢酶基因 <em>ADH</em> 所属的启动子，多种重组外源蛋白获得成功表达。</p><p>酿酒酵母表达系统的最大问题在于其超糖基化能力，往往使得有些重组蛋白（如人血清白蛋白等）与受体细胞紧密结合，而不能大量分泌。这一缺陷可用非酿酒酵母型的表达系统来弥补。</p><p>（二）乳酸克鲁维酵母表达系统</p><p>乳酸克鲁维酵母的双链环状质粒 pKD1 已被广泛用作重组异源蛋白生产的高效表达稳定性载体，即便在无选择压力的条件下，也能稳定遗传 40 代以上。</p><p>乳酸克鲁维酵母表达分泌型和非分泌型的重组蛋白，性能均优于酿酒酵母表达系统。</p><p>（三）巴斯德毕赤酵母表达系统</p><p>巴斯德毕赤酵母是一种<font color="#faa755">甲基营养菌</font>，能在低廉的甲醇培养基中生长，<font color="#faa755">甲醇</font>可高效诱导甲醇代谢途径中各酶编码基因的表达，因此生长迅速、乙醇氧化酶基因 <em>AOX</em>1 所属强启动子、表达的可诱导性是巴斯德毕赤酵母表达系统的三大优势。</p><p>由于巴斯德毕赤酵母没有合适的自主复制型载体，所以外源基因的表达序列一般整合入受体的染色体DNA上。在此情况下，外源基因的高效表达在很大程度上取决于整合拷贝数的多寡。目前已有百余种具有经济价值的重组蛋白在巴斯德毕赤酵母系统中获得成功表达。</p><p>（四）多形汉逊酵母表达系统</p><p>多形汉逊酵母也是一种<font color="#faa755">甲基营养菌</font>。其自主复制序列 <em>HARS</em> 已被克隆，并用于构建克隆表达载体，但与巴斯德毕赤酵母相似，这种载体在受体细胞有丝分裂时显示出不稳定性。所不同的是，<em>HARS</em> 质粒能高频自发地整合在受体的染色体 DNA 上，甚至可以连续整合 100 多个拷贝，因此重组多形汉逊酵母的构建也是采取整合的策略。</p><p>目前，包括乙型肝炎表面抗原在内的数种外源蛋白在该系统中获得成功表达。</p><h3 id="酵母基因工程的应用"><a class="header-anchor" href="#酵母基因工程的应用"></a>酵母基因工程的应用</h3><h4 id="利用重组酵母生产乙肝疫苗"><a class="header-anchor" href="#利用重组酵母生产乙肝疫苗"></a>利用重组酵母生产乙肝疫苗</h4><p>由乙型肝炎病毒（HBV）感染引起的急慢性乙型肝炎是一种严重的传染病，全球有 3 亿人成为 HBV 携带者，中国就有 1.2 亿，占 1/9；相当一部分人可能转化为肝硬化或肝癌患者。目前对乙型肝炎病毒还没有一种有效的治疗药物，因此高纯度乙型疫苗的生产对预防病毒感染具有重大的社会效益，而利用重组酵母大规模生产乙型疫苗为其广泛应用提供了可靠的保证。</p><p>（一）乙型肝炎病毒的结构与性质</p><p>乙型肝炎病毒的结构：乙肝病毒是一种蛋白包裹型的双链 DNA 病毒，具有感染力的病毒颗粒呈球面状，直径为 42 nm，基因组仅为 3.2 kb。病毒颗粒的主要结构蛋白是病毒的表面抗原多肽（HBsAg）或 S 多肽，它具有糖基化和非糖基化两种形式。颗粒内的蛋白成份包括核心抗原（ HBcAg ）、病毒 DNA 聚合酶、微量病毒蛋白。除此之外，被乙肝病毒感染的人的肝脏还能合成并释放大量的 22 nm 的空壳亚病毒颗粒，其免疫原性是未装配的各种包装蛋白组份的 1000 倍。包装蛋白共有三种转膜糖蛋白：S、M、L 多肽。</p><p>传统乙肝疫苗的制备</p><p>乙肝病毒在体外细胞培养基中并不能繁殖，因此第一代的乙肝疫苗是从病毒携带者的肝细胞质膜上提取出来的。虽然这种质膜来源的疫苗具有较高的免疫原性，但由于原材料的限制难以大规模产业化。</p><p>（二）产乙肝表面抗原的重组酿酒酵母</p><p>20 世纪 80 年代开始选择酿酒酵母表达重组 HBsAg，主要工作包括将 S 多肽的编码置于 <em>ADH</em>1 启动子控制下，转化子能表达出具有免疫活性的重组蛋白，它在细胞提取物中以球形脂蛋白颗粒的形式存在，平均颗粒直径为 22 nm，其结构和形态均与慢性乙肝病毒携带者血清中的病毒颗粒相同。</p><p>目前，由酿酒酵母生产的重组 HBsAg 颗粒已作为乙肝疫苗商品化重组产物的最终产量可达细胞总蛋白量的 1% ～ 2%。</p><p>进一步的研究表明，M 多肽和 L 多肽对 S 型疫苗具有显著的增效作用，由三者（或两者）构成的复合型乙肝疫苗还可以诱导那些对 S 抗原缺乏响应的人群的免疫反应。</p><p>（三）产乙肝表面抗原的重组巴斯德毕赤酵母</p><p>重组巴斯德毕赤酵母的性能：由于巴斯德毕赤酵母染色体 DNA 上还拥有第二个乙醇氧化酶基因 <em>AOX</em>2，所以整合型重组菌仍能在含有甲醇的培养基上生长。重组菌首先在含有甘油的培养基中培养，待甘油耗尽后，加入甲醇诱导 HBsAg 表达，最终 S 蛋白的产量可达细胞可溶性蛋白总量的 3%，在大规模的生产过程中，巴斯德毕赤酵母工程菌在一个 240 L 的发酵罐中培养，最终可获得 90 克 22 nm 的 HBsAg 颗粒，足够制成 900 万份乙肝疫苗。</p><h4 id="利用重组酿酒酵母提高酿酒工艺"><a class="header-anchor" href="#利用重组酿酒酵母提高酿酒工艺"></a>利用重组酿酒酵母提高酿酒工艺</h4><ol><li>将葡萄糖淀粉酶基因导入酿酒酵母；</li><li>将外源的蛋白水解酶基因导入酿酒酵母；</li><li>将 β-葡聚糖酶基因导入酵母；</li><li>将 ATP 硫酸化酶和腺苷酰硫酸激酶基因在酿酒酵母体内表达，促进 SO<sub>2</sub> 的生成，维持啤酒、葡萄酒等风味。</li></ol><h4 id="利用重组酿酒酵母环境能源危机"><a class="header-anchor" href="#利用重组酿酒酵母环境能源危机"></a>利用重组酿酒酵母环境能源危机</h4><p>通过转基因技术使酿酒酵母能利用纤维素和半纤维素等可再生物质来生产廉价的酒精，缓解能源紧张。</p><h4 id="酵母基因工程在生物医药中的应用"><a class="header-anchor" href="#酵母基因工程在生物医药中的应用"></a>酵母基因工程在生物医药中的应用</h4><ol><li>生物反应器。人血清白蛋白、溶菌酶、乙肝疫苗等。</li><li>人类蛋白质间的互作。如利用酵母表达系统开展分泌蛋白和受体基因的快速筛选。</li><li>筛选新药。利用酵母展示技术筛选细胞凋亡的抑制剂、HIV-1 整合抑制新要等。</li><li>利用酵母表达膜蛋白。</li></ol><h2 id="第十一章-基因治疗"><a class="header-anchor" href="#第十一章-基因治疗"></a>第十一章 基因治疗</h2><h3 id="基因药物"><a class="header-anchor" href="#基因药物"></a>基因药物</h3><p>基因工程药物包括蛋白质类药物和核酸类药物两类：</p><ul><li>蛋白质类药物主要有重组细胞因子、重组多肽类激素、重组溶栓药物、基因工程抗体和基因工程疫苗等。</li><li>核酸类药物主要有 DNA 药物，反义核酸药和 RNA 干扰药物等。主要针对的疾病有肿瘤、感染性疾病、人免疫缺陷病毒相关疾病、自身免疫性疾病、器官移植、心血管疾病、神经障碍性疾病等。</li></ul><p>基因工程药物的作用机理分为以下三类：</p><ol><li>蛋白或多肽药物：通过蛋白自身的生理生化特性而抵抗疾病，胰岛素、生长素等激素，各类生长因子。</li><li>基因工程疫苗、基因工程抗体：基于抗原抗体反应的原理来抵抗疾病；乙肝疫苗，新冠肺炎疫苗，霍乱菌疫苗等。</li><li>反义核酸、核酶和 RNAi，基于中断基因表达来抵抗疾病。福米韦生，第一代反义核酸药物，治疗艾滋病（AIDS）病人并发的巨细胞病毒（CMV）性视网膜炎。通过对人类巨细胞病毒（CMV）mRNA 的反义抑制发挥特异而强大的抗病毒作用。</li></ol><h3 id="基因诊断"><a class="header-anchor" href="#基因诊断"></a>基因诊断</h3><p>基因诊断常用技术方法如下：</p><ol><li>核酸分子杂交技术</li><li>聚合酶链反应 (PCR)</li><li>基因测序</li><li>生物芯片</li></ol><h3 id="临床治疗"><a class="header-anchor" href="#临床治疗"></a>临床治疗</h3><p>传统临床疾病治疗有以下四种主要方式：</p><ol><li>药物治疗</li><li>手术治疗</li><li>放射治疗</li><li>理疗</li></ol><p>新的生物治疗：基因治疗 (gene therapy)</p><h4 id="基因治疗的概念"><a class="header-anchor" href="#基因治疗的概念"></a>基因治疗的概念</h4><ul><li>经典概念（狭义概念）：针对患者的基因缺陷，导入特定基因补偿其缺陷或赋予机体新的功能以抗衡缺陷。</li><li>广义概念：将目的基因放进特定载体中导入靶细胞或组织，通过替换或补偿引起疾病的基因，调节异常表达的基因来治疗或缓解疾病，均称之为基因治疗。</li></ul><h4 id="基因治疗的总体策略"><a class="header-anchor" href="#基因治疗的总体策略"></a>基因治疗的总体策略</h4><ul><li>基因矫正</li><li>基因置换</li><li>基因增补</li><li>基因失活</li><li>自杀基因的应用</li><li>免疫基因治疗</li><li>耐药基因治疗</li></ul><p>基因矫正 (gene correction) 是指将致病基因的突变碱基加以纠正，而保留正常部分。</p><p>基因置换 (gene replacement)指用正常基因通过同源重组技术，原位替换致病基因，使细胞内的 DNA 完全恢复正常状态。</p><p><font color="#faa755">基因增补</font> (gene augmentation)是指不去除异常基因，将有功能的正常基因导入病变细胞或其它细胞后发生非定点整合，表达正常产物以补偿缺陷基因的功能，或使原有的功能得以加强。</p><p>基因失活 (gene inactivation) 是将特定的反义核酸（反义 RNA、反义 DNA）和核酶导入细胞，在转录和翻译水平阻断某些基因的表达，而实现治疗的目的。多用于抗肿瘤和抗病毒感染的治疗。</p><p>“自杀基因”的应用：HSV-TK</p><p>自杀基因又称前体药物酶转化基因，这种基因导入受体细胞后可产生一种酶，它可将原来无细胞毒性或低毒药物前体转化为细胞毒性物质，将细胞本身杀死，这种基因被称为“自杀基因”。</p><p>自杀基因导入肿瘤细胞后，可将肿瘤细胞杀死。但对正常细胞则无伤害作用。</p><p>免疫基因治疗：是把产生抗病毒或者肿瘤免疫力对应的抗原决定族基因导入机体细胞，以达到治疗目的。如细胞因子基因治疗 、免疫增强基因疗法、肿瘤DNA疫苗疗法等。</p><p>耐药基因治疗：在肿瘤治疗中，为提高机体耐受肿瘤化疗药物的能力，把产生抗药物毒性的基因导入人体细胞。如将多药耐药基因 MDR-1 导入骨髓造血干细胞，减少骨髓受抑制的程度，以加大化疗剂量，提高化疗效果。</p><h4 id="基因治疗的方式"><a class="header-anchor" href="#基因治疗的方式"></a>基因治疗的方式</h4><p>根据基因导入的方式分为两种：</p><ol><li>直接体内疗法（in vivo）是指将目的基因直接导入体内有关的组织器官，使其进入相应的细胞并进行表达。</li><li>间接体内疗法（ex vivo）是指在体外将目的基因导入靶细胞，经过筛选和增殖后将细胞回输给患者，使该基因在体内有效地表达相应产物，以达到治疗的目的。</li></ol><h4 id="基因治疗的基本程序"><a class="header-anchor" href="#基因治疗的基本程序"></a>基因治疗的基本程序</h4><ol><li>治疗性基因的获得</li><li>基因载体的选择，病毒载体、非病毒载体</li><li>靶细胞的选择，体细胞、生殖细胞</li><li>基因转移方法，化学法、物理法、病毒载体系统、膜融合法等</li><li>转导细胞的选择鉴定，利用载体中的标记基因</li><li>回输体内</li></ol><p>（一）治疗性基因的获得</p><p>外源基因</p><p>目的基因：</p><ul><li>与致病基因相对应的有功能的正常基因</li><li>与致病基因无关、有治疗作用的基因</li></ul><p>标记基因：新霉素磷酸转移酶（Neo）基因</p><p>外源基因的获得：人工合成、PCR 扩增</p><p>外源基因的选择原则：</p><ol><li>体内少量表达就可显著改善症状；</li><li>过高表达不会对机体造成危害；</li><li>在抗病毒和病原体的基因治疗中，所选择的靶基因应在病毒和病原体的生活史中起重要的作用，并且该序列是特异的；肿瘤病人多有免疫缺陷，可选用免疫因子基因转入人体；可采用反义技术封闭细胞内活化的癌基因或向细胞内转入野生型抑癌基因，抑制肿瘤生长，所针对的癌基因或抑癌基因应与该肿瘤的发生和发展有明确的相关性。</li></ol><p>（二）载体的选择与构建</p><p>基因治疗关键步骤之一，是将治疗基因高效转移入患者体内、并能调控其适度表达。</p><p>病毒载体：</p><ul><li>逆转录病毒（RV）</li><li>腺病毒（AV）</li><li>腺相关病毒（AAV）</li><li>单纯疱疹病毒（HSV）</li><li>痘苗病毒（VV）</li></ul><p>问题：</p><ol><li>靶细胞 DNA 合成必须活跃，因为病毒感染和整合作用均依赖靶细胞 DNA 的复制；</li><li>安全性问题。随机整合：诱发插入突变，激活癌基因；缺陷型逆转录病毒通过重组获得复制能力</li></ol><p>（三）靶细胞的选择</p><p>间接体内疗法中使用，分为生殖细胞和体细胞两大类，现阶段只限于应用体细胞</p><p>靶细胞选择的原则:</p><ol><li>易操作;</li><li>易培养;</li><li>易接受外源基因;</li><li>在体内能持久高效表达</li></ol><p>目前常用的靶细胞包括：成纤维细胞、淋巴细胞、上皮细胞、造血细胞、肝细胞、肌细胞等</p><p>生殖细胞基因治疗：</p><ol><li>生殖生物学问题复杂</li><li>伦理学问题</li><li>禁止应用人体</li></ol><p>体细胞基因治疗：研究重点</p><p>（四）基因转移方法</p><ul><li>化学方法——磷酸钙沉淀法、DEAE-葡聚糖法</li><li>物理方法——电穿孔法、粒子轰击法</li><li>病毒法——主要通过携带有外源基因的病毒载体感染靶细胞来实现基因的转移。</li><li>膜融合法——细胞融合法、脂质体介导法、原生质体融合法、微细胞核介导法等</li></ul><p>(五) 基因转染细胞的筛选与鉴定</p><p>抗性筛选方法：重组载体上插入有标记基因 Neo，导入受体细胞后可使其产生对 G418（氨基糖甙抗生素）药物的抗性。在加入 G418 的培养基中进行选择性培养时，转染 NeoR 基因的细胞能够存活，而未转染的细胞则死亡；</p><p>应用标记基因作为探针进行分子杂交法筛选</p><p>外源基因表达的鉴定：采用 Northern 印迹杂交；检测 mRNA 的表达；测定其表达产物即蛋白质的含量等方法。</p><p>（六）回输体内</p><p>方式：静脉注射、肌注、皮下注射、滴鼻等</p><ul><li>基因修饰的淋巴细胞以静脉注射的方式回输到血液中；</li><li>将皮肤成纤维细胞以细胞胶原悬液注射至患者皮下组织；</li><li>采用自体骨髓移植的方法输入造血细胞；</li><li>或以导管技术将血管内皮细胞定位输入血管等。</li></ul><h3 id="基因治疗的现状与展望"><a class="header-anchor" href="#基因治疗的现状与展望"></a>基因治疗的现状与展望</h3><p>基因治疗应满足的条件：</p><ol><li>优先单基因缺陷疾病</li><li>仅限体细胞的基因治疗</li><li>靶细胞易获取、培养、及回输体内。</li><li>治疗效果应胜过对病人的危害。</li><li>表达水平无需调控且无副作用。</li><li>需经动物实验验证安全可行。</li></ol><p>基因治疗的合理性:</p><ol><li>基因治疗的疾病一般是目前无法得到根治的、严重的遗传性疾病，而且这些疾病很容易造成患者死亡，因此，基因治疗方案比较容易得到患者或监护人的同意，同时也比较容易得到政府有关部门的批准。</li><li>尽管基因治疗困难重重，但是科学家认为，基因治疗的思路是正确的，因此一直在坚持不懈地研究着、实践着。</li><li>基因治疗蕴藏着丰厚的商业利润。因此在巨大商业利润的驱动下，国家或私人都投入了大量研究资金，这样就进一步刺激了基因治疗的发展。</li></ol><p>基因治疗的困难:</p><ol><li>难以获得真正有治疗作用的基因。</li><li>外源基因的表达难以在体内精确调控。</li><li>体细胞经体外培养后，其生物学特性会有改变。</li><li>过多的外源蛋白对机体带来可能的影响。</li><li>随机整合潜在的威胁。</li></ol><h2 id="第十二章-转基因生物安全性及安全监管"><a class="header-anchor" href="#第十二章-转基因生物安全性及安全监管"></a>第十二章 转基因生物安全性及安全监管</h2><h3 id="转基因安全评价原则"><a class="header-anchor" href="#转基因安全评价原则"></a>转基因安全评价原则</h3><p>实质等同性原则：即生物技术产生的食品及食品成分，如果与一种现有的食物成分、毒理性、过敏性、抗营养因子等在实质上是相当的，则可以认为是安全的。强调了转基因食品安全性的目的，不是要了解该食品的绝对安全性，而是评价它与非转基因食品的同类食品比较的相对安全性。</p><p>预先防范原则：采取对公众透明的方式，结合其他的评价原则，对转基因生物及其产品研究和试验进行风险性和危害性评价后采取先预防，防患于未然。</p><p>个案原则：针对不同目的基因、不同载体、不同受体、不同释放环境进行个案评价</p><p>逐步评估原则：转基因生物及其产品的研究开发包括实验室研究，中间试验，环境释放，生产性试验和商业化生产等环节，该原则就是要求在每个环节上对转基因生物及其产品进行风险评估。</p><p>风险效益平衡原则：对转基因生物及其产品的经济效益和它可能给环境和人类健康带来风险进行权衡，从而确定是否继续开发相关产品。</p><p>熟悉性原则：转基因生物及其产品的风险评价工作既可以在短期内完成，也可能需要长期监测。这主要取决于人们对转基因生物及其产品的有关性状，同其他生物或环境的相互作用，预定用途等背景知识的熟悉程度等。</p><h3 id="转基因安全评价内容"><a class="header-anchor" href="#转基因安全评价内容"></a>转基因安全评价内容</h3><p>分子水平评价：基因水平评价、转录水平评价、翻译水平评价<br>食用或饲用安全性评价：营养学评价、毒理性评价、致敏性评价、非预期效应评价<br>环境安全性评价：基因漂移评价、遗传稳定性评价、生存竞争力评价、生物多样性评价</p><!-- <a id="Noun限制性内切酶"></a><a  href="#Back限制性内切酶">↩</a> -->]]></content>
    
    
    <summary type="html">仅供参考</summary>
    
    
    
    <category term="生物技术复习资料" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E6%8A%80%E6%9C%AF%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    
    <category term="复习资料" scheme="https://halo123.top/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    
    <category term="基因工程" scheme="https://halo123.top/tags/%E5%9F%BA%E5%9B%A0%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>语摘</title>
    <link href="https://halo123.top/2021/05/27/Plan/%E8%AF%AD%E6%91%98/"/>
    <id>https://halo123.top/2021/05/27/Plan/%E8%AF%AD%E6%91%98/</id>
    <published>2021-05-27T08:28:48.000Z</published>
    <updated>2021-05-28T04:19:44.558Z</updated>
    
    <content type="html"><![CDATA[<h2 id="凯文·凯利给年轻人的建议"><a class="header-anchor" href="#凯文·凯利给年轻人的建议"></a>凯文·凯利给年轻人的建议</h2><div class="tag link"><a class="link-card" title="凯文·凯利《给年轻人的 99 条建议》" href="https://kk.org/thetechnium/99-additional-bits-of-unsolicited-advice/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">凯文·凯利《给年轻人的 99 条建议》</p><p class="url">https://kk.org/thetechnium/99-additional-bits-of-unsolicited-advice/</p></div></a></div><div class="tag link"><a class="link-card" title="阮一峰 科技爱好者周刊（第 157 期）" href="https://github.com/ruanyf/weekly/blob/master/docs/issue-157.md"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">阮一峰 科技爱好者周刊（第 157 期）</p><p class="url">https://github.com/ruanyf/weekly/blob/master/docs/issue-157.md</p></div></a></div><ul><li>That thing that made you weird as a kid could make you great as an adult — if you don′t lose it. 小时候，让你与其它同学格格不入的东西，长大后会帮助你成功，如果你不失去它的话。</li><li>If you have any doubt at all about being able to carry a load in one trip, do yourself a huge favor and make two trips.</li><li>What you get by achieving your goals is not as important as what you become by achieving your goals. At your funeral people will not recall what you did; they will only remember how you made them feel.</li><li>Recipe for success: under-promise and over-deliver.</li><li>It′s not an apology if it comes with an excuse. It is not a compliment if it comes with a request.</li><li>Jesus, Superman, and Mother Teresa never made art. Only imperfect beings can make art because art begins in what is broken.</li><li>If someone is trying to convince you it′s not a pyramid scheme, it′s a pyramid scheme.</li><li>Learn how to tie a bowline knot. Practice in the dark. With one hand. For the rest of your life you′ll use this knot more times than you would ever believe.</li><li>If something fails where you thought it would fail, that is not a failure.</li><li>Be governed not by the tyranny of the urgent but by the elevation of the important.</li><li>Leave a gate behind you the way you first found it.</li><li>The greatest rewards come from working on something that nobody has a name for. If you possibly can, work where there are no words for what you do.</li><li>A balcony or porch needs to be at least 6 feet (2m) deep or it won′t be used.</li><li>Don′t create things to make money; make money so you can create things. The reward for good work is more work.</li><li>In all things — except love — start with the exit strategy. Prepare for the ending. Almost anything is easier to get into than out of.</li><li>Train employees well enough they could get another job, but treat them well enough so they never want to.</li><li>Don′t aim to have others like you; aim to have them respect you.</li><li>The foundation of maturity: Just because it′s not your fault doesn′t mean it′s not your responsibility.</li><li>A multitude of bad ideas is necessary for one good idea.</li><li>Being wise means having more questions than answers.</li><li>Compliment people behind their back. It′ll come back to you.</li><li>Most overnight successes — in fact any significant successes — take at least 5 years. Budget your life accordingly.</li><li>You are only as young as the last time you changed your mind.</li><li>Assume anyone asking for your account information for any reason is guilty of scamming you, unless proven innocent. The way to prove innocence is to call them back, or login to your account using numbers or a website that you provide, not them. Don′t release any identifying information while they are contacting you via phone, message or email. You must control the channel.</li><li>Sustained outrage makes you stupid.</li><li>Be strict with yourself and forgiving of others. The reverse is hell for everyone.</li><li>Your best response to an insult is “You′re probably right.” Often they are.</li><li>The worst evils in history have always been committed by those who truly believed they were combating evil. Beware of combating evil.</li><li>If you can avoid seeking approval of others, your power is limitless.</li><li>When a child asks an endless string of “why?” questions, the smartest reply is, “I don′t know, what do you think?”</li><li>To be wealthy, accumulate all those things that money can′t buy.</li><li>Be the change you wish to see.</li><li>When brainstorming, improvising, jamming with others, you′ll go much further and deeper if you build upon each contribution with a playful “yes — and” example instead of a deflating “no — but” reply.</li><li>Work to become, not to acquire.</li><li>Don′t loan money to a friend unless you are ready to make it a gift.</li><li>On the way to a grand goal, celebrate the smallest victories as if each one were the final goal. No matter where it ends you are victorious.</li><li>Calm is contagious.</li><li>Even a foolish person can still be right about most things. Most conventional wisdom is true.</li><li>Always cut away from yourself.</li><li>Show me your calendar and I will tell you your priorities. Tell me who your friends are, and I′ll tell you where you′re going.</li><li>When hitchhiking, look like the person you want to pick you up.</li><li>Contemplating the weaknesses of others is easy; contemplating the weaknesses in yourself is hard, but it pays a much higher reward.</li><li>Worth repeating: measure twice, cut once.</li><li>Your passion in life should fit you exactly; but your purpose in life should exceed you. Work for something much larger than yourself.</li><li>If you can′t tell what you desperately need, it′s probably sleep.</li><li>When playing Monopoly, spend all you have to buy, barter, or trade for the Orange properties. Don′t bother with Utilities.</li><li>If you borrow something, try to return it in better shape than you received it. Clean it, sharpen it, fill it up.</li><li>Even in the tropics it gets colder at night than you think. Pack warmly.</li><li>To quiet a crowd or a drunk, just whisper.</li><li>Writing down one thing you are grateful for each day is the cheapest possible therapy ever.</li><li>When someone tells you something is wrong, they′re usually right. When someone tells you how to fix it, they′re usually wrong.</li><li>If you think you saw a mouse, you did. And, if there is one, there are more.</li><li>Money is overrated. Truly new things rarely need an abundance of money. If that was so, billionaires would have a monopoly on inventing new things, and they don′t. Instead almost all breakthroughs are made by those who lack money, because they are forced to rely on their passion, persistence and ingenuity to figure out new ways. Being poor is an advantage in innovation.</li><li>Ignore what others may be thinking of you, because they aren′t.</li><li>Avoid hitting the snooze button. That′s just training you to oversleep.</li><li>Always say less than necessary.</li><li>You are given the gift of life in order to discover what your gift <em>in</em> life is. You will complete your mission when you figure out what your mission is. This is not a paradox. This is the way.</li><li>Don′t treat people as bad as they are. Treat them as good as you are.</li><li>It is much easier to change how you think by changing your behavior, than it is to change your behavior by changing how you think. Act out the change you seek.</li><li>You can eat any dessert you want if you take only 3 bites.</li><li>Each time you reach out to people, bring them a blessing; then they′ll be happy to see you when you bring them a problem.</li><li>Bad things can happen fast, but almost all good things happen slowly.</li><li>Don′t worry how or where you begin. As long as you keep moving, your success will be far from where you start.</li><li>When you confront a stuck bolt or screw: righty tighty, lefty loosey.</li><li>If you meet a jerk, overlook them. If you meet jerks everywhere everyday, look deeper into yourself.</li><li>Dance with your hips.</li><li>We are not bodies that temporarily have souls. We are souls that temporarily have bodies.</li><li>You can reduce the annoyance of someone′s stupid belief by increasing your understanding of why they believe it.</li><li>If your goal does not have a schedule, it is a dream.</li><li>All the greatest gains in life — in wealth, relationships, or knowledge —come from the magic of compounding interest — amplifying small steady gains. All you need for abundance is to keep adding 1% more than you subtract on a regular basis.</li><li>The greatest breakthroughs are missed because they look like hard work.</li><li>People can′t remember more than 3 points from a speech.</li><li>I have never met a person I admired who did not read more books than I did.</li><li>The greatest teacher is called “doing”.</li><li>Finite games are played to win or lose. Infinite games are played to keep the game going. Seek out infinite games because they yield infinite rewards.</li><li>Everything is hard before it is easy. The day before something is a breakthrough, it′s a stupid idea.</li><li>A problem that can be solved with money is not really a problem.</li><li>When you are stuck, sleep on it. Let your subconscious work for you.</li><li>Your work will be endless, but your time is finite. You cannot limit the work so you must limit your time. Hours are the only thing you can manage.</li><li>To succeed, get other people to pay you; to become wealthy, help other people to succeed.</li><li>Children totally accept — and crave — family rules. “In our family we have a rule for X” is the only excuse a parent needs for setting a family policy. In fact, “I have a rule for X” is the only excuse you need for your own personal policies.</li><li>All guns are loaded.</li><li>Many backward steps are made by standing still.</li><li>This is the best time ever to make something. None of the greatest, coolest creations 20 years from now have been invented yet. You are not late.</li><li>No rain, no rainbow.</li><li>Every person you meet knows an amazing lot about something you know virtually nothing about. Your job is to discover what it is, and it won′t be obvious.</li><li>You don′t marry a person, you marry a family.</li><li>Always give credit, take blame.</li><li>Be frugal in all things, except in your passions splurge.</li><li>When making something, always get a few extras — extra material, extra parts, extra space, extra finishes. The extras serve as backups for mistakes, reduce stress, and fill your inventory for the future. They are the cheapest insurance.</li><li>Something does not need to be perfect to be wonderful. Especially weddings.</li><li>Don′t let your email inbox become your to-do list.</li><li>The best way to untangle a knotty tangle is not to “untie” the knots, but to keep pulling the loops apart wider and wider. Just make the mess as big, loose and open as possible. As you open up the knots they will unravel themselves. Works on cords, strings, hoses, yarns, or electronic cables.</li><li>Be a good ancestor. Do something a future generation will thank you for. A simple thing is to plant a tree.</li><li>To combat an adversary, become their friend.</li><li>Take one simple thing — almost anything — but take it extremely seriously, as if it was the only thing in the world, or maybe the entire world is in it — and by taking it seriously you′ll light up the sky.</li><li>History teaches us that in 100 years from now some of the assumptions you believed will turn out to be wrong. A good question to ask yourself today is “What might I be wrong about?”</li><li>Be nice to your children because they are going to choose your nursing home.</li><li>Advice like these are not laws. They are like hats. If one doesn′t fit, try another.</li></ul>]]></content>
    
    
    <summary type="html">记录</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>数据的表示和运算</title>
    <link href="https://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-26T11:56:05.000Z</published>
    <updated>2021-05-30T08:49:35.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数制与编码"><a class="header-anchor" href="#数制与编码"></a>数制与编码</h2><p>在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：</p><ol><li>二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示 0 和 1。</li><li>二进制位 1 和 0 正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li><li>二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li></ol><h3 id="进位计数法"><a class="header-anchor" href="#进位计数法"></a>进位计数法</h3><p>进位计数法是一种计数的方法。常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。</p><p>在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 10（0 ~ 9），每个数位计满 10 就向高位进位，即“逢十进一”。十进制数 101，其个位的 1 显然与百位的 1 所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。</p><p>一个 $r$ 进制数（$K_{n} K_{n-1} \cdots K_{0} K_{-1} \cdots K_{-m}$）的数值可表示为：$$K_{n} r^{n}+ K_{n-1} r^{n-1} + \cdots + K_{0} r^{0} + K_{-1} r^{-1} + \cdots + K_{-m} r^{-m} = \sum_{i=n}^{-m} K_{i} r^{i}$$式中，$r$ 是基数；$r^{i}$ 是第 $i$ 位的位权（整数位最低规定为第 0 位）；$K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。</p><ul><li>二进制。计算机中用得最多的是基数为 2 的计数制，即二进制。二进制只有 0 和 1 两种数字符号，计数“逢二进一”。它的任意数位的权为 $2^{i}$，$i$ 为所在位数。</li><li>八进制。八进制作为二进制的一种书写形式，其基数为 8，有 0 ~ 7 共 8 个不同的数字符号，计数“逢八进一”。因为 $r=8=2^{3}$，所以只要把二进制中的 3 位数码编为一组就是一位八进制数码，两者之间的转换极为方便。</li><li>十六进制。十六进制也是二进制的一种常用书写形式，其基数为 16，“逢十六进一”。 每个数位可取 0 ~ 9、A、B、C、D、E、F 中的任意一个，其中 A、B、C、D、E、F 分别表示 10 ~ 15。因为 $r=16=2^{4}$，因此 4 位二进制数码与 1 位十六进制数码相对应。</li></ul><h3 id="不同进制数之间的相互转换"><a class="header-anchor" href="#不同进制数之间的相互转换"></a>不同进制数之间的相互转换</h3><p>（1）二进制数转为八进制数和十六进制数</p><p>对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。</p><ul><li>其整数部分，从小数点开始往左数，将一串二进制数分为 3 位（八进制）一组或 4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；</li><li>对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为 3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。</li></ul><p>同样，由八进制数或十六进制数转换成二进制数， 只需将每位改为 3 位或 4 位二进制数即可（必要时去掉整数最高位或小数最低位的 0）。</p><p>八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较为方便。</p><p>（2）任意进制数转换为十进制数</p><p>将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。</p><p>（3）十进制数转换为任意进制数</p><p>一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分用除基取余法，对小数部分用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。</p><ul><li>除基取余法（整数部分的转换）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为 0 时结束。</li><li>乘基取整法（小数部分的转换）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为 1.0 （或满足精度要求）时结束。</li></ul><p>例如将十进制数 123.6875 转换成二进制数：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%95%B0.png" alt="十进制数转换为任意进制数"></p><p>因此整数部分 123 = (1111011)<sub>2</sub> ，小数部分 0.6885 = (0.1011)<sub>2</sub> ，所以 123.6875 = (1111011.1011)<sub>2</sub></p><blockquote><p>注意：在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如 0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示。</p></blockquote><h3 id="真值和机器数"><a class="header-anchor" href="#真值和机器数"></a>真值和机器数</h3><p>在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如 +15、-8 等。这种带“+”或“-”符号的数称为真值。真值是机器数所代表的实际值。</p><p>在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。如 0,101 （这里的逗号“,”实际上并不存在，仅为区分符号位与数值位）表示 +5。这种把符号“数字化”的数称为机器数。</p><h3 id="BCD-码"><a class="header-anchor" href="#BCD-码"></a>BCD 码</h3><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0 ~ 9 这 10 个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但 4 位二进制数可以组合出 16 种代码，因此必有 6 种状态为冗余状态。</p><p>下面列举几种常用的 BCD 码：</p><ol><li>8421 码（最常用）。它是一种有权码，设其各位的数值为 $b_{3}$，$b_{2}$，$b_{2}$，$b_{0}$，则权值从高到低依次为 8，4，2，1，它表示的十进制数为 $D= 8b_{3} +4b_{2} + 2b_{1}+ 1b_{0}$。如 8 → 1000；9 → 1001。若两个 8421 码相加之和小于等于 (1001)<sub>2</sub> 即 (9)<sub>10</sub>，则不需要修正；若相加之和大于等于 (1010)<sub>2</sub> 即 (10)<sub>10</sub>，则要加 6 修正（从 1010 到 1111 这 6 个为无效码，当运算结果落于这个区间时，需要将运算结果加上 6），并向高位进位，进位可以在首次相加或修正时产生。<br><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/8421%E7%A0%81%E4%BF%AE%E6%AD%A3.png" alt="8421码修正"></li><li>余 3 码。这是一种无权码，是在 8421 码的基础上加 (0011)<sub>2</sub> 形成的，因每个数都多余“3”，因此称为余 3 码。如 8 → 1011；9 → 1100。</li><li>2421 码。这也是一种有权码，权值由高到低分别为 2，4，2，1，特点是大于等于 5 的 4 位二进制数中最高位为 1，小于 5 的最高位为 0。如 5 → 1011 而非 0101。</li></ol><h3 id="字符与字符串"><a class="header-anchor" href="#字符与字符串"></a>字符与字符串</h3><p>由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。</p><p>（1）字符编码 ASCII 码</p><p>目前，国际上普遍采用的一种字符系统是 7 位二进制编码的 ASCII 码，它可表示 10 个十进制数码、52 个英文大写字母和小写字母（A ~ Z, a ~ z）及一定数量的专用符号（如 $、%、+、= 等），共 128 个字符。</p><p>在 ASCII 码中，编码值 0 ~ 31 为控制字符，用于通信控制或设备的功能控制；编码值 127 是 DEL 码；编码值 32 是空格 SP；编码值 32 ~ 126 共 95 个字符称为可印刷字符。</p><blockquote><p>提示: 0 ~ 9 的 ASCII 码值为 48 (011 0000) ~ 57 (011 1001)，即去掉高 3 位，只保留低 4 位，正好是二进制形式的 0 ~ 9。</p></blockquote><p>（2）汉字的表示和编码</p><p>在 1981 年的国家标准 GB 2312——1980 中，每个编码用两字节表示，收录了一级汉字 3755 个、二级汉字 3008 个、各种符号 682 个，共计 7445 个。</p><p>目前最新的汉字编码是 2000 年公布的国家标准 GB 18030，它收录了 27484 个汉字。编码标准采用 1 B、2 B 和 4 B。</p><p>汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码是国家标准局于 1981 年颁布的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p><p>国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 20 H。国标码两字节的最高位都是 0，ASCII 码的最高位也是 0。为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为“1”，这就是汉字内码。</p><p>区位码和国标码都是输入码，它们和汉字内码的关系（十六进制）如下:</p><ul><li>国标码 = (区位码)<sub>16</sub> + 2020H</li><li>汉字内码 = (国标码)<sub>16</sub> + 8080H</li></ul><h3 id="校验码"><a class="header-anchor" href="#校验码"></a>校验码</h3><p>校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p><p>通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。对于码距不小于 2 的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</p><h4 id="奇偶校验码"><a class="header-anchor" href="#奇偶校验码"></a>奇偶校验码</h4><p>在原编码上加一个校验位，它的码距等于 2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，增加的冗余位称为奇偶校验位。</p><p>奇偶校验实现的方法：由若干位有效信息（如 1 B）再加上一个二进制位（校验位）组成校验码。校验位的取值（0 或 1）将使整个校验码中“1”的个数为奇数或偶数，所以有两种可供选择的校验规律。</p><ul><li>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。</li><li>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。</li></ul><p>缺点：具有局限性，奇偶校验只能发现数据代码中奇数位的出错情况，但不能纠正错误，常用于对存储器数据的检查或传输数据的检查。</p><h4 id="海明校验码"><a class="header-anchor" href="#海明校验码"></a>海明校验码</h4><p>海明码是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。根据纠错理论得：$$L- 1=D+C \ (D \ge C)$$即编码最小码距 $L$ 越大，其检测错误的位数 $D$ 越大，纠正错误的位数 $C$ 也越大，且纠错能力恒小于等于检错能力。海明码就是根据这一理论提出的具有纠错能力的一种编码。</p><p>下面用一个例子来介绍求海明码的步骤。在 $n=4$、$k=3$ 时，求 1010 的海明码。</p><p>（1）确定海明码的位数</p><p>设 $n$ 为有效信息的位数，$k$ 为校验位的位数，则信息位 $n$ 和校验位 $k$ 应满足 $$n+k \le 2^{k}-1$$ 若要检测两位错，则需再增加 1 位校验位，即 $k+1$ 位。海明码位数为 $n+k=7 \le 2^{3}-1$ 成立，则 $n$、$k$ 有效。</p><p>设信息位为 $D_{4} D_{3} D_{2} D_{1}$（1010），共 4 位，校验位为 $P_{3} P_{2} P_{1}$，共 3 位，对应的海明码为 $H_{7} H_{6} H_{5} H_{4} H_{3} H_{2} H_{1}$。</p><p>（2）确定校验位的分布</p><p>规定校验位 $P_i$ 在海明位号为 $2^{i-1}$ 的位置上，其余各位为信息位，因此有：</p><ul><li>$P_1$ 的海明位号为 $2^{i-1} = 2^{0} = 1$，即 $H_1$ 为 $P_1$。</li><li>$P_2$ 的海明位号为 $2^{i-1} = 2^{1} = 2$，即 $H_2$ 为 $P_2$。</li><li>$P_3$ 的海明位号为 $2^{i-1} = 2^{2} = 4$，即 $H_4$ 为 $P_3$。</li></ul><p>将信息位按原来的顺序插入，则海明码各位的分布如下:<br>$$<br>\begin{matrix}<br>H_{7}  &amp; H_{6}  &amp; H_{5}  &amp; H_{4}  &amp; H_{3}  &amp; H_{2}  &amp; H_{1} \\<br>D_{4}  &amp; D_{3}  &amp; D_{2}  &amp; P_{3}  &amp; D_{1}  &amp; P_{2}  &amp; P_{1}<br>\end{matrix}<br>$$</p><p>（3）分组以形成校验关系</p><p>每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。另外，校验位不需要再被校验。分组形成的校验关系如下。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E4%BD%8D.png" alt="海明码校验位"></p><p>（4）校验位取值</p><p>校验位 $P_i$ 的值为第 $i$ 组（由该校验位校验的数据位）所有位求异或（如果两个值不相同，则异或结果为 1。如果两个值相同，异或结果为 0。）。由上分组有：</p><p>$$<br>\begin{align*}<br>P_{1}=D_{1} \oplus D_{2} \oplus D_{4} = 0 \oplus 1 \oplus 1 = 0 \\<br>P_{2}=D_{1} \oplus D_{3} \oplus D_{4} = 0 \oplus 0 \oplus 1 = 1 \\<br>P_{3}=D_{2} \oplus D_{3} \oplus D_{4} = 1 \oplus 0 \oplus 1 = 0<br>\end{align*}<br>$$</p><p>所以，1010 对应的海明码为 1010010</p><p>（5）海明码的校验原理</p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成 $k$ 个校验方程：</p><p>$$<br>\begin{align*}<br>S_{1}=P_{1} \oplus D_{1} \oplus D_{2} \oplus D_{4} \\<br>S_{2}=P_{2} \oplus D_{1} \oplus D_{3} \oplus D_{4} \\<br>S_{3}=P_{3} \oplus D_{2} \oplus D_{3} \oplus D_{4}<br>\end{align*}<br>$$</p><p>若 $S_{3}S_{2}S_{1} =000$，则说明无错；否则说明出错，且这个数就是错误的位号，如 $S_{3}S_{2}S_{1} = 001$，说明第 1 位出错，即 $H_{1}$ 出错，直接将该位取反就达到纠错的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E5%85%83%E7%B4%A0%E5%85%B3%E7%B3%BB.png" alt="海明码校验元素关系"></p><p>海明码的检错能力为 1 位，纠错能力为 2 位。通常使用时会在最头部加上“全校验位”，对整体进行偶校验：</p><ul><li>$S_{3}S_{2}S_{1} =000$ 且全体偶校验成功，无错误</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验失败，有 1 位错误，纠正即可</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验成功，有 2 位称为，需重传</li></ul><p>拓展：</p><div class="tag link"><a class="link-card" title="【3Blue1Brown】汉明码Pa■t1，如何克服噪■" href="https://www.bilibili.com/video/BV1WK411N7kz"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【3Blue1Brown】汉明码Pa■t1，如何克服噪■</p><p class="url">https://www.bilibili.com/video/BV1WK411N7kz</p></div></a></div><div class="tag link"><a class="link-card" title="【3Blue1Brown】汉明码part2，优雅的全貌" href="https://www.bilibili.com/video/BV1pV411y7E8"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【3Blue1Brown】汉明码part2，优雅的全貌</p><p class="url">https://www.bilibili.com/video/BV1pV411y7E8</p></div></a></div><h4 id="循环冗余校验码"><a class="header-anchor" href="#循环冗余校验码"></a>循环冗余校验码</h4><ul><li>CRC 码的基本思想</li><li>如何构造</li><li>如何检错纠错</li></ul><p>循环冗余校验（Cyclic Redundancy Check，CRC）码的基本思想是：在 $K$ 位信息码后再拼接 $R$ 位的校验码，整个编码的长度为 $N$ 位，因此，这种编码又称 $(N,K)$ 码。</p><ul><li>数据发送、接收方约定一个“除数”</li><li>$K$ 个信息位 + $R$ 个校验位作为“被除数”，添加校验位后需保证除法的余数为 0</li><li>收到数据后，进行除法检查余数是否为 0，若余数非 0 说明出错，则进行重传或纠错</li></ul><p>CRC 码基于线性编码理论，在发送端，将要传送的 $K$ 位二进制信息码左移 $R$ 位，将它与生成多项式 $G(x)$ 做模 2 除法，生成一个 $R$ 位校验码，并附在信息码后，构成一个新的二进制码（CRC 码），共 $K+R$ 位。在接收端，利用生成多项式对接收到的编码做模 2 除法，以检测和确定出错的位置，如无错则整除，其中生成多项式是接收端和发送端的一个约定。</p><p>任意一个二进制数码都可用一个系数仅为“ 0 ”或“ 1 ”的多项式与其对应。生成多项式 $G(x)$ 的最高幂次为 $R$，转换成对应的二进制数有 $R+1$ 位。例如，生成多项式 $x^{3} + x^{2} + 1$ 对应的二进制数为 1101，而二进制数 1011 对应的多项式为 $x^{3} + x^{2} + 1$ 。下面用一个例子来介绍 CRC 的编码和检测过程。</p><p>设生成多项式 $G(x) = x^{3} + x^{2} + 1$，信息码为 101001，求对应的 CRC 码</p><ul><li>生成多项式 $G(x) = 1x^{3} + 1x^{2} + 0x^{1} + 1x^{0}$，故对应的二进制码为 1101。</li><li>$R$ 等于生成多项式最高次幂，即为 3</li><li>$K$ 等于信息码长度，即为 6</li><li>校验码位数 $N = K+R=9$</li></ul><p>（1）位移</p><p>将原信息码左移 $R$ 位，低位补 0，得到 101001000</p><p>（2）相除</p><p>对位移后的信息码，用生成多项式进行模 2 除法，产生余数。</p><blockquote><p>模 2 减法：和模 2 加法的结果相同，都是做异或运算<br>模 2 除法：模 2 除法和算术除法类似，但每位除（减）的结果不影响其他位，即不借位。</p></blockquote><ol><li>用除数对被除数最高几位做模 2 减（异或），不借位。</li><li>除数右移一位，若余数最高位为 1，商为 1，并对余数做模 2 减。若余数最高位为 0，商为 0，除数继续右移一位。</li><li>循环直到余数位数小于除数时，该余数为最终余数。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="CRC码生成过程"></p><p>模 2 除法过程如图上所示，得到余数为 001，则报文 101001 编码后的报文（即 CRC 码）为 101001001</p><p>（3）检错和纠错</p><p>接收端收到的 CRC 码，用生成多项式 $G(x)$ 做模 2 除法，若余数为 0，则码字无错。</p><p>若接收端收的 CRC 码为 $C_{9} C_{8} C_{7} C_{6} C_{5} C_{4} C_{3} C_{2} C_{1} = 101001011$，将这个数据与 1101 进行模 2 除法，得到的余数为 010，则说明 $C_{2}$ 出错（不一定正确），将 $C_{2}$ 取反即可。</p><blockquote><p>注意：余数值与出错位置并不是二进制与十进制转换的关系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E4%BD%99%E6%95%B0%E4%B8%8E%E5%87%BA%E9%94%99%E4%BD%8D%E5%85%B3%E7%B3%BB.png" alt="CRC码余数与出错位关系"></p><p>$K$ 个信息位，$R$ 个校验位，若生成多项式选择得当，且 $2^{R} \ge K + R + 1$ ，则 CRC 码可纠正 1 位错。实际应用中一般只用来“检错”。</p><p>理论上可以证明循环冗余校验码的检错能力有以下特点：</p><ol><li>可检测出所有奇数个错误;</li><li>可检测出所有双比特的错误;</li><li>可检测出所有小于等于校验位长度的连续错误;</li></ol><h2 id="定点数的表示与运算"><a class="header-anchor" href="#定点数的表示与运算"></a>定点数的表示与运算</h2><h3 id="定点数的表示"><a class="header-anchor" href="#定点数的表示"></a>定点数的表示</h3><p>在计算机中参与运算的机器数有两大类：无符号（unsigned）数和有符号（signed）数。</p><ol><li><font color="#ea66a6">无符号数</font>。指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为 8 位，则数的表示范围为 0 ~ 2<sup>8</sup>-1，即 0 ~ 255。</li><li><font color="#ea66a6">有符号数</font>。在机器中，数的“正”“负”号是无法识别的，有符号数用“0”表示“正”号，用“1”表示“负”号，从而将符号也数值化，并通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。</li></ol><p>有符号数的机器表示有原码、补码、反码和移码。为了能正确区别真值和各种机器数，约定用 X 表示真值，用 [X]<sub>原</sub>表示原码，[X]<sub>补</sub>表示补码， [X]<sub>反</sub>表示反码，[X]<sub>移</sub>表示移码。</p><p>定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用“.”表示，而是约定它的位置。理论上，小数点位置固定在哪一位都可以，但在计算机中通常采用两种简单的约定：将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般常称前者为定点小数，后者为定点整数。</p><p>（1）定点整数</p><p>定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据 $X$ 的形式为 $ X = x_{0}x_{1}x_{2} \cdots x_{n}$ （其中 $x_{0}$ 为符号位，$x_{1} \sim  x_{n}$ 是数值的有效部分，也称<font color="#ea66a6">尾数</font>，$x_{n}$ 为最低有效位），则在计算机中的表示形式如图所示（设机器字长 $n+1$ 位)。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="定点整数的格式"></p><ul><li>当 $x_{0}=0$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其所能表示的最大正数，真值等于 $2^{n}-1$。</li><li>当 $x_{0}=1$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其（原码）所能表示的最小负数，真值等于 $- ( 2^{-n}-1 )$。</li></ul><p>（2）定点小数</p><p>定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据 $X$ 的形式为 $ X = x_{0}x_{1}x_{2} \cdots x_{n}$ （其中 $x_{0}$ 为符号位，$x_{1} \sim  x_{n}$ 是尾数，$x_{1}$ 为最高有效位），则在计算机中的表示形式如图所示（设机器字长 $n+1$ 位)。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="定点小数的格式"></p><ul><li>当 $x_{0}=0$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其所能表示的最大正数，真值等于 $1-2^{-n}$。</li><li>当 $x_{0}=1$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其（原码）所能表示的最小负数，真值等于 $- ( 1-2^{-n} )$。</li></ul><h3 id="原码、补码、反码、移码"><a class="header-anchor" href="#原码、补码、反码、移码"></a>原码、补码、反码、移码</h3><h4 id="原码"><a class="header-anchor" href="#原码"></a>原码</h4><p>原码是一种比较简单、直观的机器数表示法，<font color="#faa755">用机器数的最高位表示该数的符号，其余的各位表示数的绝对值</font>。原码的定义如下：</p><p>（1）纯整数的原码定义</p><p>$$[x]_{原} = \begin{cases}<br>0, x &amp; 2^{n} &gt; x \ge 0  \\<br>2^{n}-x = 2^{n}+\left | x \right |  &amp; 0 \ge x &gt; -2^{n}<br>\end{cases}$$</p><p>例如：</p><ul><li>若 $x_{1}=+1110$，字长为 8 位，则其原码表示为 $[x_{1}]_{原} = 00001110$，其中最高位是符号位。</li><li>若 $x_{2}=-1110$，字长为 8 位，则其原码表示为 $[x_{2}]_{原} = 2^{7}+1110= 10001110$，其中最高位是符号位。</li></ul><p>若字长为 $n+1$，则原码整数的表示范围为 $-(2^{n}-1) \le x \le 2^{n}-1$（关于原点对称）</p><blockquote><p>注意：真值零的原码表示有正零和负零两种形式，即 $[+0]_{原} = 00000$ 和 $[-0]_{原} = 10000$。</p></blockquote><p>（2）纯小数的原码定义</p><p>$$[x]_{原} = \begin{cases}<br>x &amp; 1 &gt; x \ge 0  \\<br>1-x = 1+\left | x \right |  &amp; 0 \ge x &gt; -1<br>\end{cases}$$</p><p>例如：</p><ul><li>若 $x_{1}=+0.1101$，字长为 8 位，则其原码表示为：$[x_{1}]_{原} = 01101000$，其中最高位是符号位。</li><li>若 $x_{2}=-0.1101$，字长为 8 位，则其原码表示为：$[x_{2}]_{原} = 1-(-0.1101) = 11101000$，其中最高位是符号位。</li></ul><p>更一般地：</p><ul><li>对于正小数 $ x= +0.x_{1}x_{2} \cdots x_{n}$，有 $ [x]_{原}= 0.x_{1}x_{2} \cdots x_{n}$</li><li>对于负小数 $ x= -0.x_{1}x_{2} \cdots x_{n}$，有 $  [x]_{原}= 1.x_{1}x_{2} \cdots x_{n}$。</li></ul><p>若字长为 $n+1$，则原码小数的表示范围为 $-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）</p><blockquote><p>同样真值零的原码表示有正零和负零两种形式</p></blockquote><h4 id="反码"><a class="header-anchor" href="#反码"></a>反码</h4><p>反码通常用来作为由原码求补码或由补码求原码的中间过渡。</p><ul><li>若符号位为 0，则反码与原码相同</li><li>若符号位为 1，则数值位全部取反</li></ul><p>若字长为 $n+1$，反码的整数和小数表示范围与原码整数和小数表示范围对应相同。</p><blockquote><p>注意：真值零的反码表示不唯一，$[+0]_{反}=0.0000$，$[-0]_{反}=1.1111$</p></blockquote><h4 id="补码"><a class="header-anchor" href="#补码"></a>补码</h4><ul><li>正数的补码 = 原码</li><li>负数的补码 = 反码末位 + 1（要考虑进位）</li></ul><blockquote><p>注意：补码的真值 0 只有一种表示形式 $[+0]_{补}=[-0]_{补}=00000000$，定点整数补码 $[x]_{补}=10000000$ 表示 $x=-2^{7}$，定点小数补码 $[x]_{补}=10000000$ 表示 $x=-1$</p></blockquote><ul><li>若机器字长为 $n+1$，补码整数的表示范围：$-2^{n} \le x \le 2^{n}-1$ （比原码多表示一个 $-2^{n}$）</li><li>若机器字长为 $n+1$，补码小数的表示范围：$-1 \le x \le 1-2^{-n}$ （比原码多表示一个 $-1$）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E4%B8%8D%E5%90%8C%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="不同机器数之间的转换"></p><h4 id="移码"><a class="header-anchor" href="#移码"></a>移码</h4><p>移码：补码的基础上将符号位取反。</p><blockquote><p>注意：移码只能用于表示整数</p></blockquote><p>移码的正值 0 和整数的表示范围与补码相同。</p><p>移码表示的整数很方便对比真值大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数制与编码&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#数制与编码&quot;&gt;&lt;/a&gt;数制与编码&lt;/h2&gt;
&lt;p&gt;在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二进制只有两种状态，使用有两个稳</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中文文案排版</title>
    <link href="https://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/"/>
    <id>https://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/</id>
    <published>2021-05-26T08:30:50.000Z</published>
    <updated>2021-05-26T08:34:29.754Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="转自 《中文文案排版指北》" href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">转自 《中文文案排版指北》</p><p class="url">https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md</p></div></a></div><h2 id="空格"><a class="header-anchor" href="#空格"></a>空格</h2><h3 id="中英文之间需要增加空格"><a class="header-anchor" href="#中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a class="header-anchor" href="#中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a class="header-anchor" href="#数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a class="header-anchor" href="#全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h3 id="用-text-spacing-来挽救？"><a class="header-anchor" href="#用-text-spacing-来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h3><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a class="header-anchor" href="#标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a class="header-anchor" href="#不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a class="header-anchor" href="#全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a class="header-anchor" href="#使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说&quot;喵&quot;了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a class="header-anchor" href="#数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a class="header-anchor" href="#遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a class="header-anchor" href="#名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a class="header-anchor" href="#专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a class="header-anchor" href="#不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a class="header-anchor" href="#争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a class="header-anchor" href="#链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a class="header-anchor" href="#简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;转自 《中文文案排版指北》&quot; href=&quot;https://github.com/sparanoid/chinese-copywriting-guidelines/blob/mast</summary>
      
    
    
    
    <category term="Tips" scheme="https://halo123.top/categories/Tips/"/>
    
    
    <category term="Tips" scheme="https://halo123.top/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理概述</title>
    <link href="https://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-26T04:55:05.000Z</published>
    <updated>2021-06-08T07:29:00.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统的组成"><a class="header-anchor" href="#计算机系统的组成"></a>计算机系统的组成</h2><p>硬件系统和软件系统共同构成了一个完整的计算机系统。</p><ul><li><font color="#ea66a6">硬件</font>是指有形的物理设备，是计算机系统中实际物理装置的总称。</li><li><font color="#ea66a6">软件</font>是指在硬件上运行的程序和相关的数据及文档。</li></ul><p>计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，其既可以用软件实现，又可以用硬件实现，则称为<font color="#faa755">软硬件在逻辑上是等效的</font>。</p><p>在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高。</p><h2 id="计算机硬件的基本组成"><a class="header-anchor" href="#计算机硬件的基本组成"></a>计算机硬件的基本组成</h2><h3 id="早期的冯·诺依曼机"><a class="header-anchor" href="#早期的冯·诺依曼机"></a>早期的冯·诺依曼机</h3><p>冯·诺依曼在研究 <a href="https://baike.baidu.com/item/EDVAC/8438215?fr=aladdin">EDVAC 机</a> 时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯·诺依曼机，其特点如下：</p><ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 5 大部件组成。</li><li>指令和数据以同等地位存储在存储器中，并可按地址寻访。</li><li>指令和数据均用二进制代码表示。</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序。</li><li>早期的冯·诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。</li></ol><blockquote><p>注意：“存储程序”的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p></blockquote><p>典型的冯·诺依曼机计算机结构如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%85%B8%E5%9E%8B%E7%9A%84%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="典型的冯诺依曼计算机结构"></p><h3 id="现代计算机的组织结构"><a class="header-anchor" href="#现代计算机的组织结构"></a>现代计算机的组织结构</h3><p>在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>而随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能够满足计算机发展的要求。现代计算机已发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率，其结构如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="以存储器为中心的计算机结构"></p><p>目前绝大多数现代计算机仍遵循冯·诺依曼的存储程序的设计思想。</p><h3 id="计算机的功能部件"><a class="header-anchor" href="#计算机的功能部件"></a>计算机的功能部件</h3><p>传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但功能部件是一致的，它们的功能部件包括如下几种：</p><p>（1）输入设备</p><p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。</p><p>（2）输出设备</p><p>输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称 I/O 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。</p><p>（3）存储器</p><p>存储器是计算机的存储部件，用来存放程序和数据。存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器）。</p><ul><li>CPU 能够直接访问的存储器是主存储器。</li><li>辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。</li></ul><p>主存储器由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是 1 B（8 bit）或是字节的偶数倍。</p><p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式（相联存储器是按内容访问的）。</p><p>主存储器的最基本组成如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="主存储器逻辑图"></p><ul><li>存储体存放二进制信息；</li><li><font color="#ea66a6">地址寄存器</font>（Memory Address Register，<font color="#ea66a6">MAR</font>）存放访存地址，经过地址译码后找到所选的存储单元；</li><li><font color="#ea66a6">数据寄存器</font>（Memory Data Register，<font color="#ea66a6">MDR</font>）用于暂存要从存储器中读或写的信息；</li><li>时序控制逻辑用于产生存储器操作所需的各种时序信号。</li></ul><p>MAR 用于寻址，其位数对应着存储单元的个数，如 MAR 为 10 位，则有 2<sup>10</sup> = 1024 个存储单元，记为 1 K。MAR 的长度与<font color="#ea66a6">程序计数器</font>（Program Counter，<font color="#ea66a6">PC</font>）的长度相等。</p><p>MDR 的位数和存储字长相等，一般为字节的二次幂的整数倍。</p><blockquote><p>注意：MAR 与 MDR 虽然是存储器的一部分，但在现代 CPU 中却是存在于 CPU 中的。另外，高速缓存（Cache）也存在于 CPU 中。</p></blockquote><p>（4）运算器</p><p>运算器是计算机的执行部件，用于进行算术运算和逻辑运算。</p><ul><li>算术运算是按算术运算规则进行的运算，如加、减、乘、除；</li><li>逻辑运算包括与、或、非、异或、比较、移位等运算。</li></ul><p>运算器的核心是算术逻辑单元（Arithmetic and Logical Unit，ALU）。</p><p>运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（Accumulator，ACC）、乘商寄存器（Multiple—Quotient Register，MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前 3 个寄存器是必须有的。</p><p>运算器内还有程序状态寄存器（Program Status Word，PSW），也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。</p><p>（5）控制器</p><p>控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（Program Counter，PC）、指令寄存器（Instruction Register，IR）和控制单元（CU）组成。</p><p>PC 用来存放当前欲执行指令的地址，可以自动加 1 以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。</p><p>IR 用来存放当前的指令，其内容来自主存的 MDR。</p><ul><li>指令中的操作码 OP(IR) 送至 CU，用以分析指令并发出各种微操作命令序列</li><li>指令中的地址码 Ad(IR) 送往 MAR，用以取操作数。</li></ul><p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器（Central Processing Unit，CPU）。CPU 和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O 设备等）统称为外部设备，简称外设。</p><p>下图所示为冯·诺依曼结构的模型机。CPU 包含 ALU、通用寄存器组 GPRs、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制 ALU 执行什么运算，可以控制主存是进行读操作还是写操作（读/写控制信号）。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9C%BA.png" alt="冯诺依曼结构的模型机"></p><p>CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线。</p><ul><li>MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；</li><li>控制线中有读/写信号线，指出数据是从 CPU 写入主存还是从主存读出到 CPU，根据是读操作还是写操作来控制将 MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到 MDR 中。</li></ul><h2 id="计算机软件的分类"><a class="header-anchor" href="#计算机软件的分类"></a>计算机软件的分类</h2><h3 id="系统软件和应用软件"><a class="header-anchor" href="#系统软件和应用软件"></a>系统软件和应用软件</h3><p>软件按其功能分类，可分为系统软件和应用软件。</p><ul><li>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等。</li><li>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。</li></ul><blockquote><p>注意：数据库管理系统（DBMS）和数据库系统（DBS）是有区别的。DBMS 是位于用户和操作系统之间的一层数据管理软件，是系统软件；而 DBS 是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。</p></blockquote><h3 id="三个级别的语言"><a class="header-anchor" href="#三个级别的语言"></a>三个级别的语言</h3><ol><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ol><h2 id="计算机的工作过程"><a class="header-anchor" href="#计算机的工作过程"></a>计算机的工作过程</h2><p>计算机的工作过程分为以下三个步骤：</p><ol><li>把程序和数据装入主存储器。</li><li>将源程序转换成可执行文件。</li><li>从可执行文件的首地址开始逐条执行指令。</li></ol><h3 id="从源程序到可执行文件"><a class="header-anchor" href="#从源程序到可执行文件"></a>从源程序到可执行文件</h3><p>在计算机中编写的 C 语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。</p><p>以 UNIX 系统中的 GCC 编译器程序为例，读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello，整个翻译过程可分为 4 个阶段完成，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="源程序转换为可执行文件的过程"></p><ol><li>预处理阶段：预处理器（cpp）对源程序中以字符 <code>#</code> 开头的命令进行处理，例如将 <code>#include</code> 命令后面的 .h 文件内容插入程序文件。输出结果是一个以 i 为扩展名的源文件 hello.i</li><li>编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s 汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</li><li>汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的 hello.o，它是一种二进制文件，因此在文本编辑器中打开它时会显示乱码。</li><li>链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将 hello.o 和标准库函数 <code>prinft</code> 所在的可重定位目标模块 prinft.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</li></ol><h3 id="指令执行过程的描述"><a class="header-anchor" href="#指令执行过程的描述"></a>指令执行过程的描述</h3><p>程序中第一条指令的地址置于 PC 中，根据 PC 取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址。用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。</p><p>下面以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的 ACC 中）为例进行说明，其信息流程如下：</p><p>1、取指令: PC → MAR → M → MDR → IR</p><p>根据 PC 取指令到 IR（指令寄存器）。将 PC 的内容送 MAR（地址寄存器），MAR 中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR（数据寄存器） 从数据线接收指令信息，并传送到 IR 中。</p><p>2、分析指令: OP(IR) → CU</p><p>指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR 中是取数指令，因此读控制信号被送到总线的控制线上。</p><p>3、执行指令：Ad(IR) → MAR → M → MDR → ACC</p><p>取数操作。将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。</p><p>此外，每取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即 (PC)+1 → PC。</p><blockquote><p>注意: (PC) 指程序计数器 PC 中存放的内容。PC → MAR 应理解为 (PC) → MAR，即程序计数器中的值经过数据通路送到 MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动）。但运算时括号不能省略，即 (PC)+1 → PC 不能写为 PC+1 → PC。</p></blockquote><h2 id="计算机系统的多级层次结构"><a class="header-anchor" href="#计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p>现代计算机是一个硬件与软件组成的综合体。由于面对的应用范围越来越广，因此必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者都从不同的角度并用不同的语言来对待同一个计算机系统，因此他们各自看到的计算机系统的属性及对计算机系统提出的要求也就不同。</p><p>计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p><p>关于计算机系统层次结构的分层方式，目前尚无统一的标准，这里采用如下图所示的层次结构。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的多级层次结构"></p><p>第 1 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。</p><p>第 2 级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统。</p><p>第 3 级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。</p><p>第 4 级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。</p><p>第 5 级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。</p><p>在高级语言层之上，还可以有应用层，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等。</p><p>通常把没有配备软件的纯硬件系统称为“裸机”。第 3 层至第 5 层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的。</p><p>层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能将由硬件来实现，因而软/硬件交界面的划分也不是绝对的。</p><p>这里主要讨论传统机器 M1 和微程序机器 M0 的组成原理及设计思想。</p><h2 id="计算机的性能指标"><a class="header-anchor" href="#计算机的性能指标"></a>计算机的性能指标</h2><h3 id="计算机的主要性能指标"><a class="header-anchor" href="#计算机的主要性能指标"></a>计算机的主要性能指标</h3><p>（1）机器字长</p><p>机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与 CPU 的寄存器位数、加法器有关。因此，机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8 位）的整数倍。</p><blockquote><p>注意：<a href="#%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E5%92%8C%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF%E7%9A%84%E5%85%B3%E7%B3%BB">机器字长、指令字长和存储字长的关系</a></p></blockquote><p>（2）数据通路带宽</p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。</p><blockquote><p>注意：各个子系统通过数据总线连接形成的数据传送路径称为数据通路。</p></blockquote><p>（3）主存容量</p><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 × 字长（如 512 K × 16位）来表示存储容量。其中，MAR 的位数反映存储单元的个数，MAR 的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）。</p><p>例如，MAR 为 16 位，表示 2<sup>16</sup> = 65536，即此存储体内有 65536 个存储单元（可称为 64 K 内存，1 K = 1024），若 MDR 为 32 位，表示存储容量为 64 K × 32 位。</p><p>（4）运算速度</p><ul><li><p>吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期。</p></li><li><p>响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括 CPU 时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O 操作、操作系统开销等的时间）。</p></li><li><p>CPU 时钟周期。通常为节拍脉冲或 T 周期，即主频的倒数，它是 CPU 中最小的时间单位，每个动作至少需要 1 个时钟周期。CPU时钟周期 = 1/主频，主频通常以 Hz（赫兹）为单位，1 Hz 表示每秒 1 次。</p></li><li><p>主频（CPU 时钟频率）。机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。例如，常用 CPU 的主频有 1.8 GHz、2.4 GHz、 2.8 GHz 等。</p></li><li><p>CPI（Clock cycle Per Instruction），即执行一条 指令所需的时钟周期数。</p></li><li><p>CPU 执行时间，指运行一个程序所花费的时间。</p><p>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 × CPI) / 主频。</p><p>上式表明，CPU 的性能（CPU 执行时间）取决于三个要素：主频（时钟频率）；每条指令执行所用的时钟周期数（CPI）；指令条数。</p><p>主频、CPI 和指令条数是相互制约的。例如，更改指令集可以减少程序所含指令的条数，但同时可能引起 CPU 结构的调整，从而可能会增加时钟周期的宽度（降低主频）。</p></li><li><p>MIPS（Million Instructions Per Second），即每秒执行多少百万条指令。</p><p>MIPS = 指令条数 / (执行时间 × 10<sup>6</sup>) = 主频 / CPI</p></li><li><p>MFLOPS（Mega Floating point Operations Per Second），即每秒执行多少百万次浮点运算。</p><p>MFLOPS = 浮点操作次数 / (执行时间 × 10<sup>6</sup>)</p></li><li><p>GFLOPS（Giga Floating point Operations Per Second），即每秒执行多少十亿次浮点运算。</p><p>GFLOPS = 浮点操作次数 / (执行时间 × 10<sup>9</sup>)</p></li><li><p>TFLOPS（Tera Floating point Operations Per Second），即每秒执行多少万亿次浮点运算。</p><p>TFLOPS = 浮点操作次数 / (执行时间 × 10<sup>12</sup>)</p></li></ul><blockquote><p>注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 1 Kb = 2<sup>10</sup> b；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 1 kb/s = 10 b/s。通常前者用大写的 K，后者用小写的 k，但其他前缀均为大写，表示的含义取决于所用的场景。</p></blockquote><h3 id="几个专业术语"><a class="header-anchor" href="#几个专业术语"></a>几个专业术语</h3><ul><li>系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</li><li>兼容。指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。</li><li>软件可移植性。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。</li><li>固件。将程序固定在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于只读存储器中）。</li></ul><h2 id="常见问题和易混淆知识点"><a class="header-anchor" href="#常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h2><h3 id="计算机由哪几部分组成？以哪部分为中心？"><a class="header-anchor" href="#计算机由哪几部分组成？以哪部分为中心？"></a>计算机由哪几部分组成？以哪部分为中心？</h3><p>计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。</p><p>而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已经发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。</p><h3 id="主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"><a class="header-anchor" href="#主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"></a>主频高的 CPU 一定比主频低的 CPU 快吗？为什么？</h3><p>衡量 CPU 运算速度的指标有很多，不能以单独的某个指标来判断 CPU 的好坏。CPU 的主频，即 CPU 内核工作的时钟频率。CPU 的主频表示 CPU 内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为 CPU 的运算速度还要看 CPU 的流水线的各方面的性能指标（架构、缓存、指令集、CPU 的位数、Cache 大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。</p><h3 id="不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"><a class="header-anchor" href="#不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"></a>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</h3><p>机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直按执行。</p><h3 id="什么是透明性？透明是指什么都能看见吗？"><a class="header-anchor" href="#什么是透明性？透明是指什么都能看见吗？"></a>什么是透明性？透明是指什么都能看见吗？</h3><p>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。</p><p>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</p><p>在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的。</p><h3 id="计算机体系结构和计算机组成的区别和联系是什么？"><a class="header-anchor" href="#计算机体系结构和计算机组成的区别和联系是什么？"></a>计算机体系结构和计算机组成的区别和联系是什么？</h3><p>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。</p><p>计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例<br>如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p><p>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370 结构就包含了多种价位和性能的机型。</p><h3 id="基准程序执行得越快说明机器的性能越好吗"><a class="header-anchor" href="#基准程序执行得越快说明机器的性能越好吗"></a>基准程序执行得越快说明机器的性能越好吗?</h3><p>一般情况下， 基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p><h3 id="机器字长、指令字长和存储字长的关系"><a class="header-anchor" href="#机器字长、指令字长和存储字长的关系"></a>机器字长、指令字长和存储字长的关系</h3><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li>存储字长：一个存储单元存储的二进制代码的长度。</li></ul><p>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意 64 位操作系统是指特别为 64 位架构的计算机而设计的操作系统，它能够利用 64 位处理器的优势。但 64 位机器既可以使用 64 位操作系统，又可以使用 32 位操作系统。而 32 位处理器是无法使用 64 位操作系统的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统的组成&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#计算机系统的组成&quot;&gt;&lt;/a&gt;计算机系统的组成&lt;/h2&gt;
&lt;p&gt;硬件系统和软件系统共同构成了一个完整的计算机系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#ea66a6</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 下 C\C++ 开发环境配置</title>
    <link href="https://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/"/>
    <id>https://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/</id>
    <published>2021-05-24T13:15:36.000Z</published>
    <updated>2021-05-28T13:52:06.180Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：</p><div class="tag link"><a class="link-card" title="哔哩哔哩视频" href="https://www.bilibili.com/video/BV13K411M78v"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">哔哩哔哩视频</p><p class="url">https://www.bilibili.com/video/BV13K411M78v</p></div></a></div><h2 id="开发环境搭建"><a class="header-anchor" href="#开发环境搭建"></a>开发环境搭建</h2><ul><li>MinGW-w64 编译器 <a href="http://www.mingw-w64.org/doku.php/download">官网下载链接</a></li><li>CMake工具 <a href="https://cmake.org/download/">官网下载链接</a></li></ul><p>将下载的压缩包解压，并将 解压后的文件夹的 bin 文件夹目录放到环境变量中。</p><p>VSCode 插件，在插件中搜索下载</p><ul><li>C\C++：智能提示、debug 和代码浏览</li><li>CMake：CMake 的语法支持</li><li>CMake Tools：CMake 的扩展支持</li></ul><hr><p>CMake Tools 安装遇到的坑</p><p>问题描述：</p><p>CMake Tools 版本为 1.7.3，报错代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad CMake executable . Is it installed or settings contain the correct path (cmake.cmakePath)? </span><br></pre></td></tr></table></figure><p>原因是 CMake Tools 没有找到正确的 CMake 安装路径</p><p>解决方法：在设置中指定 cmake.exe 的文件地址。具体方法是打开设置（快捷键 Ctrl + 逗号）搜索 cmake.cmakePath 可以看到 Name/path of the CMake executable to use. 默认为 cmake 将其设置自己安装 cmake.exe 文件地址，例如我的设置是 E:\Program\Develop\Cmake\bin\cmake.exe。</p><p>参考解决地址：<a href="https://github.com/microsoft/vscode-cmake-tools/issues/685">https://github.com/microsoft/vscode-cmake-tools/issues/685</a></p><h2 id="基于-g-命令"><a class="header-anchor" href="#基于-g-命令"></a>基于 g++ 命令</h2><h3 id="编译单文件"><a class="header-anchor" href="#编译单文件"></a>编译单文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里顺便写段实例代码，打开命令行 VSCode 默认快捷键为 Ctrl 加反引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;g++ .\main.cpp</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode&gt;.\a.exe</span><br><span class="line">Before swap:</span><br><span class="line">val1 &#x3D; 10   </span><br><span class="line">val2 &#x3D; 20   </span><br><span class="line">After swap: </span><br><span class="line">val1 &#x3D; 20   </span><br><span class="line">val2 &#x3D; 10  </span><br></pre></td></tr></table></figure><p>这里会默认生成 a.exe 可执行文件，通过命令行可以运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt; g++ -g .\main.cpp -o swap</span><br></pre></td></tr></table></figure><p>通过上一段命令可以生成名为 swap 的可调试的可执行文件</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/VSCode%E9%85%8D%E7%BD%AElaunch.json.png" alt="VSCode配置launch"></p><p>选择 g++.exe - Build and debug active file ，会在目录 .vscode 下自动生成 launch.json 文件夹，同时产生了与 cpp 同名的 .exe 文件用于断点调试</p><h3 id="编译多文件"><a class="header-anchor" href="#编译多文件"></a>编译多文件</h3><p>将上述代码拆分成多个文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many_main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many_swap.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 g++ 编译多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g .\many_main.cpp .\many_swap.cpp -o many_swap </span><br></pre></td></tr></table></figure><p>如果使用 VSCode 默认生成的 launch.json 进行调试会出错，这里需要进行配置，修改 <code>program</code> 属性为 g++ 生成的可调式的可执行文件名，并注释 <code>preLaunchTask</code>，这里因为自己使用 g++ 命令编程完成，不在需要 VSCode 进行编译</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\many_swap.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-Cmake"><a class="header-anchor" href="#基于-Cmake"></a>基于 Cmake</h2><p>在主目录中新建 CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(SWAP)</span><br><span class="line"></span><br><span class="line">add_executable(cmake_swap many_main.cpp many_swap.cpp)</span><br></pre></td></tr></table></figure><p>使用 Shift + Ctrl + P 调出配置搜索，搜索 CMake:Configure 选择 mingw</p><p>之后会自动生成 build 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;cd build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;cmake ..</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: E:&#x2F;Project&#x2F;CodeBase&#x2F;C&#x2F;VSCode&#x2F;build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;mingw32-make.exe</span><br></pre></td></tr></table></figure><p>就会在 build 文件夹中生成 cmake_swap.exe （根据 CMakeLists.txt 配置生成）</p><p>如果电脑中安装了 VS 可以会调用微软的 MSVC 编译器，第一次使用时用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br></pre></td></tr></table></figure><p>来代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><h2 id="修改-launch-json-和-tasks-json"><a class="header-anchor" href="#修改-launch-json-和-tasks-json"></a>修改 launch.json 和 tasks.json</h2><p>launch.json 需要关注的点为：</p><ul><li><code>program</code>：可执行文件的路径</li><li><code>preLaunchTask</code>：对应 tasks.json 的 <code>label</code> 属性的值</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\build\\cmake_swap.exe&quot;</span>,</span><br><span class="line">            <span class="comment">// 调试时需要添加的参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasks.json 用于调试之前的编译工作指令，需要关注的点为：</p><ul><li><code>args</code>：多文件需要指定文件名</li><li><code>label</code>：与 launch.json 的 <code>preLaunchTask</code> 对应</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\g++.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;detail&quot;</span>: <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 CMake 文件的自动配置 tasks.json 如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;mingw32-make.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;/p&gt;
&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;哔哩哔哩视频&quot; href=&quot;https://www.bilibili.com/video/BV13K411M78v&quot;&gt;&lt;div class=&quot;left&quot;&gt;</summary>
      
    
    
    
    <category term="C\C++" scheme="https://halo123.top/categories/C-C/"/>
    
    
    <category term="C" scheme="https://halo123.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://halo123.top/2021/05/23/Java/Java-I-IO/"/>
    <id>https://halo123.top/2021/05/23/Java/Java-I-IO/</id>
    <published>2021-05-23T08:31:54.000Z</published>
    <updated>2021-05-27T13:59:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：《Java 技术手册》</p><h2 id="File-类"><a class="header-anchor" href="#File-类"></a>File 类</h2><p>File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文件和文件夹。是以前 Java 处理文件 I/O 的基础。这个抽象既能表示文件，也能表示目录，不过有时使用起来有些麻烦，写出的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个文件对象，表示用户的家目录</span></span><br><span class="line">File homedir = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;user.home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象，表示配置文件</span></span><br><span class="line"><span class="comment">// （家目录中应该存在这个文件）</span></span><br><span class="line">File f = <span class="keyword">new</span> File(homedir, <span class="string">&quot;app.conf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在，是否真是文件，以及是否可读</span></span><br><span class="line"><span class="keyword">if</span> (f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead()) &#123;</span><br><span class="line">    <span class="comment">// 创建一个文件对象，表示新配置目录</span></span><br><span class="line">    File configdir = <span class="keyword">new</span> File(f, <span class="string">&quot;.configdir&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后创建这个目录</span></span><br><span class="line">    configdir.mkdir();</span><br><span class="line">    <span class="comment">// 最后，把配置文件移到新位置</span></span><br><span class="line">    f.renameTo(<span class="keyword">new</span> File(configdir, <span class="string">&quot;.config&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展现了 File 类使用灵活的一面，但也演示了这种抽象带来的一些问题。一般情况下，需要调用很多方法查询 File 对象才能判断这个对象到底表示的是什么，以及具有什么能力。</p><p>File 类中有相当多的方法，但根本没有直接提供一些基本功能（尤其是无法读取文件的内容），下述代码简要总结了 File 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限管理</span></span><br><span class="line"><span class="keyword">boolean</span> canX = f.canExecute();</span><br><span class="line"><span class="keyword">boolean</span> canR = f.canRead();</span><br><span class="line"><span class="keyword">boolean</span> canW = f.canWrite();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ok;</span><br><span class="line">ok = f.setReadOnly();</span><br><span class="line">ok = f.setExecutable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setReadable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setWritable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的方式表示文件名</span></span><br><span class="line">File absF = f.getAbsoluteFile();</span><br><span class="line">File canF = f.getCanonicalFile();</span><br><span class="line">String absName = f.getAbsolutePath();</span><br><span class="line">String canName = f.getCanonicalPath();</span><br><span class="line">String name = f.getName();</span><br><span class="line">String pName = getParent();</span><br><span class="line">URI fileURI = f.toURI(); <span class="comment">// 创建文件路径的URI形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件的元数据</span></span><br><span class="line"><span class="keyword">boolean</span> exists = f.exists();</span><br><span class="line"><span class="keyword">boolean</span> isAbs = f.isAbsolute();</span><br><span class="line"><span class="keyword">boolean</span> isDir = f.isDirectory();</span><br><span class="line"><span class="keyword">boolean</span> isFile = f.isFile();</span><br><span class="line"><span class="keyword">boolean</span> isHidden = f.isHidden();</span><br><span class="line"><span class="keyword">long</span> modTime = f.lastModified(); <span class="comment">// 距Epoch时间的毫秒数</span></span><br><span class="line"><span class="keyword">boolean</span> updateOK = f.setLastModified(updateTime); <span class="comment">// 毫秒</span></span><br><span class="line"><span class="keyword">long</span> fileLen = f.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件管理操作</span></span><br><span class="line"><span class="keyword">boolean</span> renamed = f.renameTo(destFile);</span><br><span class="line"><span class="keyword">boolean</span> deleted = f.delete();</span><br><span class="line"><span class="comment">// 创建文件不会覆盖现有文件</span></span><br><span class="line"><span class="keyword">boolean</span> createdOK = f.createNewFile();</span><br><span class="line"><span class="comment">// 处理临时文件</span></span><br><span class="line">File tmp = File.createTempFile(<span class="string">&quot;my-tmp&quot;</span>, <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">tmp.deleteOnExit();</span><br><span class="line"><span class="comment">// 处理目录</span></span><br><span class="line"><span class="keyword">boolean</span> createdDir = dir.mkdir();</span><br><span class="line">String[] fileNames = dir.list();</span><br><span class="line">File[] files = dir.listFiles();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：《Java 技术手册》&lt;/p&gt;
&lt;h2 id=&quot;File-类&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#File-类&quot;&gt;&lt;/a&gt;File 类&lt;/h2&gt;
&lt;p&gt;File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文</summary>
      
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-05-20T13:47:40.000Z</published>
    <updated>2021-05-28T04:23:12.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是泛型"><a class="header-anchor" href="#什么是泛型"></a>什么是泛型</h2><p>在讲解什么是泛型之前，我们先观察 Java 标准库提供的 <code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上 <code>ArrayList</code> 内部就是一个 <code>Object[]</code> 数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述 <code>ArrayList</code> 存储 String 类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>很容易出现 <code>ClassCastException</code>，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以为 String 单独编写一种 ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，存入的必须是 String，取出的也一定是 String，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringArrayList list = <span class="keyword">new</span> StringArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p>问题暂时解决。然而，新的问题是，如果要存储 Integer，还需要为 Integer 单独编写一种 ArrayList，实际上，还需要为其他所有 class 单独编写一种 ArrayList。这是不可能的，JDK 的 class 就有上千个，而且它还不知道其他人编写的 class。</p><p>为了解决新的问题，我们必须把 <code>ArrayList</code> 变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 可以是任何 class。这样一来，我们就实现了，编写一次模版，可以创建任意类型的 <code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如 <code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的 <code>ArrayList&lt;类型&gt;</code>。由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h3 id="向上转型"><a class="header-anchor" href="#向上转型"></a>向上转型</h3><p>在 Java 标准库中的 <code>ArrayList&lt;T&gt;</code> 实现了 <code>List&lt;T&gt;</code> 接口，它可以向上转型为 <code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即类型 <code>ArrayList&lt;T&gt;</code> 可以向上转型为 <code>List&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>要特别注意：不能把 <code>ArrayList&lt;Integer&gt;</code> 向上转型为 <code>ArrayList&lt;Number&gt;</code> 或 <code>List&lt;Number&gt;</code> 。</p><p>假设 <code>ArrayList&lt;Integer&gt;</code> 可以向上转型为 <code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> Float(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line">Integer n = integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure><p>我们把一个 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code> 类型后，这个 <code>ArrayList&lt;Number&gt;</code> 就可以接受 Float 类型，因为 Float 是 Number 的子类。但是，<code>ArrayList&lt;Number&gt;</code> 实际上和 <code>ArrayList&lt;Integer&gt;</code> 是同一个对象，也就是 <code>ArrayList&lt;Integer&gt;</code> 类型，它不可能接受 Float 类型， 所以在获取 Integer 的时候将产生  <code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code>。</p><p><code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;Number&gt;</code> 两者完全没有继承关系。</p><h2 id="使用泛型"><a class="header-anchor" href="#使用泛型"></a>使用泛型</h2><p>使用 ArrayList 时，如果不定义泛型类型时，泛型类型实际上就是 Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把 <code>&lt;T&gt;</code> 当作 Object 使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型 <code>&lt;String&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;String&gt;</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们定义泛型类型 <code>&lt;Number&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br><span class="line">Number first = list.get(<span class="number">0</span>);</span><br><span class="line">Number second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br></pre></td></tr></table></figure><p>编译器看到泛型类型 <code>List&lt;Number&gt;</code> 就可以自动推断出后面的 <code>ArrayList&lt;T&gt;</code> 的泛型类型必须是 <code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>除了 <code>ArrayList&lt;T&gt;</code> 使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code> 可以对任意数组进行排序，但待排序的元素必须实现 <code>Comparable&lt;T&gt;</code> 这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接对 String 数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(ss);</span><br><span class="line">System.out.println(Arrays.toString(ss));</span><br></pre></td></tr></table></figure><p>这是因为 String 本身已经实现了 <code>Comparable&lt;String&gt;</code> 接口。如果换成我们自定义的 Person 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将 Person 转型为 Comparable。我们修改代码，让 Person 实现 <code>Comparable&lt;T&gt;</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按 <code>name</code> 进行排序。也可以修改比较逻辑，例如，按 <code>score</code> 从高到低排序。</p><h2 id="编写泛型"><a class="header-anchor" href="#编写泛型"></a>编写泛型</h2><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如 <code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如 <code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是 <code>String</code>，最后，把特定类型 <code>String</code> 替换为 <code>T</code>，并申明 <code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练后即可直接从 <code>T</code> 开始编写。</p><h3 id="静态方法"><a class="header-anchor" href="#静态方法"></a>静态方法</h3><p>编写泛型类时，要特别注意，泛型类型 <code>&lt;T&gt;</code> 不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法 <code>create()</code> 的方法参数和返回类型上使用泛型类型 <code>T</code>。</p><p>可以在 <code>static</code> 修饰符后面加一个 <code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这个 <code>&lt;T&gt;</code> 和 <code>Pair&lt;T&gt;</code> 类型的 <code>&lt;T&gt;</code> 已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的 <code>create()</code> 静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h3 id="多个泛型类型"><a class="header-anchor" href="#多个泛型类型"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望 <code>Pair</code> 不总是存储两个类型一样的对象，就可以使用类型 <code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>Java 标准库的 <code>Map&lt;K, V&gt;</code> 就是使用两种泛型类型的例子。它对 Key 使用一种类型，对 Value 使用另一种类型。</p><h3 id="擦拭法"><a class="header-anchor" href="#擦拭法"></a>擦拭法</h3><p>泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java 语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。例如，我们编写了一个泛型类 <code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java 使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型 <code>&lt;T&gt;</code> 视为 Object；</li><li>编译器根据 <code>&lt;T&gt;</code> 实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java 的泛型是由编译器在编译时实行的，编译器内部永远把所有类型 <code>T</code> 视为 Object 处理，但是，在需要转型的时候，编译器会根据 <code>T</code> 的类型自动为我们实行安全地强制转型。</p><p>了解了 Java 泛型的实现方式——擦拭法，我们就知道了 Java 泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code> 不能是基本类型，例如 int，因为实际类型是 Object，Object 类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>局限二：无法取得带泛型的 Class。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>T</code> 是 Object，我们对 <code>Pair&lt;String&gt;</code> 和 <code>Pair&lt;Integer&gt;</code> 类型获取 Class 时，获取到的是同一个 Class，也就是 Pair 类的 Class。</p><p>换句话说，所有泛型实例，无论 <code>T</code> 的类型是什么，<code>getClass()</code> 返回同一个 <code>Class</code> 实例，因为编译后它们全部都是 <code>Pair&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在 <code>Pair&lt;String&gt;.class</code>，而是只有唯一的 <code>Pair.class</code>。</p><p>局限四：不能实例化 <code>T</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建 <code>new Pair&lt;String&gt;()</code> 和创建 <code>new Pair&lt;Integer&gt;()</code> 就全部成了 Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化 <code>T</code> 类型，我们必须借助额外的 <code>Class&lt;T&gt;</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助 <code>Class&lt;T&gt;</code> 参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code> 。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了 <code>Class&lt;String&gt;</code> 的实例，所以我们借助 <code>String.class</code> 就可以实例化 String 类型。</p><h3 id="不恰当的覆写方法"><a class="header-anchor" href="#不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的 <code>equals(T t)</code> 方法实际上会被擦拭成 <code>equals(Object t)</code>，而这个方法是继承自 Object 的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与 <code>Object.equals(Object)</code> 的冲突就可以成功编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">same</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承"><a class="header-anchor" href="#泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code>，子类的类型是 <code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类 <code>IntPair</code> 并没有泛型类型，所以，正常使用即可。</p><p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code> 的 <code>T</code> 类型，即给定一个变量 <code>Pair&lt;Integer&gt; p</code>，无法从 <code>p</code> 中获取到 <code>Integer</code> 类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型 <code>T</code>（对 <code>IntPair</code> 来说，也就是 <code>Integer</code> 类型）保存到子类的 class 文件中，不然编译器就不知道 <code>IntPair</code> 只能存取 Integer 这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code> 可以获取到父类的泛型类型 Integer。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Java 引入了泛型，所以，只用 Class 来标识类型已经不够了。实际上，Java 的类型系统结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                      ┌────┐</span><br><span class="line">                      │Type│</span><br><span class="line">                      └────┘</span><br><span class="line">                         ▲</span><br><span class="line">                         │</span><br><span class="line">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class="line">   │            │                  │               │</span><br><span class="line">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class="line">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class="line">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="extends-通配符"><a class="header-anchor" href="#extends-通配符"></a>extends 通配符</h2><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code> 不是 <code>Pair&lt;Number&gt;</code> 的子类。</p><p>假设我们定义了 <code>Pair&lt;T&gt;</code>，然后，我们又针对 <code>Pair&lt;Number&gt;</code> 类型写了一个静态方法，它接收的参数类型是 <code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = PairHelper.add(<span class="keyword">new</span> Pair&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">泛型是一种“代码模板”，可以用一套代码套用各种类型。</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/</id>
    <published>2021-05-20T09:42:40.000Z</published>
    <updated>2021-05-28T04:23:36.206Z</updated>
    
    <content type="html"><![CDATA[<p>反射（Reflection），Java 的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.halo.test.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得 <code>Person</code> 类，只有一个 <code>Object</code> 实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？强制转型？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用 <code>Person</code> 类。不然，去掉import语句，不能编译通过</p><p>而反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="Class-类"><a class="header-anchor" href="#Class-类"></a>Class 类</h2><p>除了 int 等基本类型外，Java 的其他类型全部都是 class（包括 interface ）。</p><p>仔细思考，我们可以得出结论：class（包括 interface ）的本质是数据类型（Type）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而 class 是由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存。</p><p>每加载一种 class，JVM 就为其创建一个 <code>Class</code> 类型的实例，并关联起来。注意：这里的 <code>Class</code> 类型是一个名叫 Class 的 class。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 String 类为例，当 JVM 加载 String 类时，它首先读取 <code>String.class</code> 文件到内存，然后，为 String 类创建一个 <code>Class</code> 实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure><p>这个 <code>Class</code> 实例是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现 <code>Class</code> 类的构造方法是 private，只有 JVM 能创建 <code>Class</code> 实例，我们自己的 Java 程序是无法创建 Class 实例的。</p><p>所以， JVM 持有的每个 <code>Class</code> 实例都指向一个数据类型（class或interface）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>一个 <code>Class</code> 实例包含了该 class 的所有完整信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>由于 JVM 为每个加载的 class 创建了对应的 <code>Class</code> 实例，并在实例中保存了该 class 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应的 class 的所有信息。</p><p>这种通过 <code>Class</code> 实例获取 class 信息的方法称为反射（Reflection）。</p><p>如何获取一个 class 的 <code>Class</code> 实例？有三个方法：</p><p>方法一：直接通过一个 class 的静态变量 class 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个 class 的完整类名，可以通过静态方法 <code>Class.forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>Class</code> 实例在 JVM 中是唯一的，所以，上述方法获取的 <code>Class</code> 实例是同一个实例。可以用 <code>==</code> 比较两个 <code>Class</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下 <code>Class</code> 实例比较和 <code>instanceof</code> 的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用 <code>instanceof</code> 不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code> 判断 class 实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用 <code>instanceof</code> 判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 class 的时候，我们才使用 <code>==</code> 判断 class 实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个 <code>Object</code> 实例时，我们可以通过反射获取该 <code>Object</code> 的 class 信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从 <code>Class</code> 实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到数组（例如 <code>String[]</code>）也是一种 <code>Class</code>，而且不同于 <code>String.class</code>，它的类名是 <code>[Ljava.lang.String</code>。此外，JVM 为每一种基本类型如 <code>int</code> 也创建了 <code>Class</code>，通过 <code>int.class</code> 访问。</p><p>如果获取到了一个 <code>Class</code> 实例，我们就可以通过该 <code>Class</code> 实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于 <code>new String()</code>。通过 <code>Class.newInstance()</code> 可以创建类实例，它的局限是：只能调用 public 的无参数构造方法。带参数的构造方法，或者非 public 的构造方法都无法通过 <code>Class.newInstance()</code> 被调用。</p><h2 id="动态加载"><a class="header-anchor" href="#动态加载"></a>动态加载</h2><p>JVM 在执行 Java 程序的时候，并不是一次性把所有用到的 class 全部加载到内存，而是第一次需要用到 class 时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 Main.java 时，由于用到了 <code>Main</code>，因此，JVM 首先会把 Main.class 加载到内存。然而，并不会加载 Person.class，除非程序执行到 <code>create()</code> 方法，JVM 发现需要加载 <code>Person</code> 类时，才会首次加载 <code>Person.class</code>。如果没有执行 <code>create()</code> 方法，那么 Person.class根本就不会被加载。</p><p>这就是 JVM 动态加载 class 的特性。</p><p>动态加载 class 的特性对于 Java 程序非常重要。利用 JVM 动态加载 class 的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging 总是优先使用 Log4j，只有当 Log4j 不存在时，才使用 JDK 的 logging。利用 JVM 动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是为什么我们只需要把 Log4j 的 jar 包放到 classpath 中，Commons Logging 就会自动使用 Log4j 的原因。</p><h2 id="访问字段"><a class="header-anchor" href="#访问字段"></a>访问字段</h2><p>对任意的一个 Object 实例，只要我们获取了它的 <code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过 <code>Class</code> 实例获取字段信息。<code>Class</code> 类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个 public 的 field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有 public 的 field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 <code>Student</code> 的 <code>Class</code> 实例，然后，分别获取 <code>public</code> 字段、继承的 <code>public</code> 字段以及 <code>private</code> 字段，打印出的 Field ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure><p>一个 Field 对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>name</code>；</li><li><code>getType()</code>：返回字段类型，也是一个 <code>Class</code> 实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>以 String 类的 <code>value</code> 字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>利用反射拿到字段的一个 Field 实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个 <code>Person</code> 实例，我们可以先拿到 <code>name</code> 字段对应的 Field，再获取这个实例的 <code>name</code> 字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先获取 <code>Class</code> 实例，再获取 Field 实例，然后，用 <code>Field.get(Object)</code> 获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个 <code>IllegalAccessException</code>，这是因为 <code>name</code> 被定义为一个 private 字段，正常情况下，<code>Main</code> 类无法访问 <code>Person</code> 类的 private 字段。要修复错误，可以将 private 改为 public，或者，在调用<code>Object value = f.get(p);</code> 前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>Field.setAccessible(true)</code> 的意思是，别管这个字段是不是 public，一律允许访问。再运行代码，就可以打印出 private 字段的值。</p><p>如果使用反射可以获取 private 字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过 <code>p.name</code> 来访问 Person 的 name 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code> 可能会失败。如果 JVM 运行期存在 SecurityManager，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code> 。例如，某个 SecurityManager 可能不允许对 java 和 javax 开头的 package 的类调用 <code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。</p><h2 id="设置字段值"><a class="header-anchor" href="#设置字段值"></a>设置字段值</h2><p>通过 Field 实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过 <code>Field.set(Object, Object)</code> 实现的，其中第一个 <code>Object</code> 参数是指定的实例，第二个 <code>Object</code> 参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的 <code>name</code> 字段从 <code>Xiao Ming</code> 变成了 <code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非 public 字段，需要首先调用 <code>setAccessible(true)</code>。</p><h2 id="调用方法"><a class="header-anchor" href="#调用方法"></a>调用方法</h2><p>我们已经能通过 Class 实例获取所有 Field 对象，同样的，可以通过 Class 实例获取所有 Method 信息。Class 类提供了以下几个方法来获取 Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个 public 的 Method（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个 Method（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有 public 的 Method（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有 Method（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 Student 的 Class 实例，然后，分别获取 public 方法、继承的 public 方法以及 private 方法，打印出的 Method 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个 <code>Method</code> 对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：“getScore”；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个 Class 实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个 Class 数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>当我们获取到一个 Method 对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用 <code>substring</code> 方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 Method 实例调用 <code>invoke</code> 就相当于调用该方法，<code>invoke</code> 的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法"><a class="header-anchor" href="#调用静态方法"></a>调用静态方法</h3><p>如果获取到的 Method 表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code> 方法传入的第一个参数永远为 null。我们以 <code>Integer.parseInt(String)</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用非-public-方法"><a class="header-anchor" href="#调用非-public-方法"></a>调用非 public 方法</h3><p>和 Field 类似，对于非 public 方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code> 获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code> 。为了调用非 public 方法，我们通过 <code>Method.setAccessible(true)</code> 允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a class="header-anchor" href="#多态"></a>多态</h3><p>我们来考察这样一种情况：一个 <code>Person</code> 类定义了 <code>hello()</code> 方法，并且它的子类 <code>Student</code> 也覆写了 <code>hello()</code> 方法，那么，从 <code>Person.class</code> 获取的 Method，作用于 <code>Student</code> 实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是 <code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="调用构造方法"><a class="header-anchor" href="#调用构造方法"></a>调用构造方法</h2><p>我们通常使用new操作符创建新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用 Class 提供的 <code>newInstance()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用 <code>Class.newInstance()</code> 的局限是，它只能调用该类的 public 无参数构造方法。如果构造方法带有参数，或者不是 public，就无法直接通过 <code>Class.newInstance()</code> 来调用。</p><p>为了调用任意的构造方法，Java 的反射 API 提供了 <code>Constructor</code> 对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code> 对象和 Method 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Class 实例获取 Constructor 的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个 Constructor`；</li><li><code>getConstructors()</code>：获取所有 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有 <code>Constructor</code>。</li></ul><p>注意 <code>Constructor</code> 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非 public 的 <code>Constructor</code> 时，必须首先通过 <code>setAccessible(true)</code> 设置允许访问。<code>setAccessible(true)</code> 可能会失败。</p><h2 id="获取继承关系"><a class="header-anchor" href="#获取继承关系"></a>获取继承关系</h2><p>当我们获取到某个 Class 对象时，实际上就获取到了一个类的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure><p>还可以用实例的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取 Class 的方法是通过 <code>Class.forName(&quot;&quot;)</code>，传入 Class 的完整类名获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class s = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>这三种方式获取的 Class 实例都是同一个实例，因为 JVM 对每个加载的 Class 只创建一个 Class 实例来表示它的类型。</p><h3 id="获取父类的-Class"><a class="header-anchor" href="#获取父类的-Class"></a>获取父类的 Class</h3><p>有了 Class 实例，我们还可以获取它的父类的 Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，Integer 的父类类型是 Number，Number 的父类是 Object，Object 的父类是 null。除 Object 外，其他任何非 interface 的 Class都必定存在一个父类类型。</p><h3 id="获取-interface"><a class="header-anchor" href="#获取-interface"></a>获取 interface</h3><p>由于一个类可能实现一个或多个接口，通过 Class 我们就可以查询到实现的接口类型。例如，查询 Integer 实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码可知，Integer 实现的接口有：</p><ul><li><code>java.lang.Comparable</code></li><li><code>java.lang.constant.Constable</code></li><li><code>java.lang.constant.ConstantDesc</code></li></ul><p>要特别注意：<code>getInterfaces()</code> 只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer 的父类是 Number，Number 实现的接口是 <code>java.io.Serializable</code>。</p><p>此外，对所有 interface 的 Class 调用 <code>getSuperclass()</code> 返回的是 null，获取接口的父接口要用 <code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); </span><br><span class="line"><span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); </span><br><span class="line"><span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何 interface，那么 <code>getInterfaces()</code> 返回空数组。</p><h3 id="继承关系"><a class="header-anchor" href="#继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用 <code>instanceof</code> 操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个 Class 实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h3 id="动态代理"><a class="header-anchor" href="#动态代理"></a>动态代理</h3><p>我们来比较 Java 的 class 和 interface 的区别：</p><ul><li>可以实例化 class（非abstract）；</li><li>不能实例化 interface。</li></ul><p>所有 interface 类型的变量总是通过向上转型并指向某个实例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSequence cs = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>有没有可能不编写实现类，直接在运行期创建某个 interface 的实例呢？</p><p>这是可能的，因为 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个 interface 的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口 <code>Hello</code>，但是我们并不去编写实现类，而是直接通过 JDK 提供的一个 <code>Proxy.newProxyInstance()</code> 创建了一个 <code>Hello</code> 接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK 提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个 interface 实例的方法如下：</p><ul><li>定义一个 <code>InvocationHandler</code> 实例，它负责实现接口的方法调用；</li><li>通过 <code>Proxy.newProxyInstance()</code> 创建 interface 实例，它需要3个参数：<ol><li>使用的 <code>ClassLoader</code>，通常就是接口类的 <code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的 <code>InvocationHandler</code> 实例。</li></ol></li><li>将返回的 Object 强制转型为接口。</li></ul><p>动态代理实际上是 JVM 在运行期动态创建 class 字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是 JVM 帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>]]></content>
    
    
    <summary type="html">Java 反射</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-05-20T09:33:40.000Z</published>
    <updated>2021-05-28T04:23:29.107Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="廖雪峰Java教程" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">廖雪峰Java教程</p><p class="url">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176</p></div></a></div><h2 id="Java-的异常"><a class="header-anchor" href="#Java-的异常"></a>Java 的异常</h2><p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p><p>有一些错误是用户造成的，比如，希望用户输入一个 int 类型的年龄，但是用户的输入是 abc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户输入了abc：</span></span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(s); <span class="comment">// NumberFormatException</span></span><br></pre></td></tr></table></figure><p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户删除了该文件：</span></span><br><span class="line">String t = readFile(<span class="string">&quot;C:\\abc.txt&quot;</span>); <span class="comment">// FileNotFoundException!</span></span><br></pre></td></tr></table></figure><p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p><ul><li>网络突然断了，连接不到远程服务器；</li><li>内存耗尽，程序崩溃了；</li><li>用户点“打印”，但根本没有打印机；</li><li>……</li></ul><p>所以，一个健壮的程序必须处理各种各样的错误。</p><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回 0，表示成功，返回其他整数，表示约定的错误码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用 int 类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java 内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种 class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code> 是异常体系的根，它继承自 <code>Object</code>。<code>Throwable</code> 有两个体系：<code>Error</code> 和 <code>Exception</code>，<code>Error</code> 表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而 <code>Exception</code> 则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个 null 的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code> 又分为两大类：</p><ul><li><code>RuntimeException</code> 以及它的子类；</li><li>非 <code>RuntimeException</code>（包括 <code>IOException</code>、<code>ReflectiveOperationException</code> 等等）</li></ul><p>Java规定：</p><ul><li>必须捕获的异常，包括 <code>Exception</code> 及其子类，但不包括 <code>RuntimeException</code> 及其子类，这种类型的异常称为 Checked Exception。</li><li>不需要捕获的异常，包括 <code>Error</code> 及其子类，<code>RuntimeException</code> 及其子类。</li></ul><p>注意：编译器对 <code>RuntimeException</code> 及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理 <code>RuntimeException</code>。是否需要捕获，具体问题具体分析。</p><h2 id="捕获异常"><a class="header-anchor" href="#捕获异常"></a>捕获异常</h2><p>捕获异常使用 <code>try...catch</code> 语句，把可能发生异常的代码放到 <code>try &#123;...&#125;</code> 中，然后使用 <code>catch</code> 捕获对应的 <code>Exception</code> 及其子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不捕获 <code>UnsupportedEncodingException</code>，会出现编译失败的问题</p><p>编译器会报错，错误信息类似：<code>unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</code>，并且准确地指出需要捕获的语句是 <code>return s.getBytes(&quot;GBK&quot;);</code> 。意思是说，像 <code>UnsupportedEncodingException</code> 这样的 Checked Exception，必须被捕获。</p><p>这是因为 <code>String.getBytes(String)</code> 方法定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法定义的时候，使用 <code>throws Xxx</code> 表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。<br><code>在</code>toGBK()<code>方法中，因为调用了</code>String.getBytes(String)<code>方法，就必须捕获</code>UnsupportedEncodingException<code>。我们也可以不捕获它，而是在方法定义处用 </code>throws<code>表示</code>toGBK()<code> 方法可能会抛出</code>UnsupportedEncodingException<code>，就可以让 </code>toGBK()` 方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用 <code>return s.getBytes(&quot;GBK&quot;);</code> 的问题，而是 <code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在 <code>main()</code> 方法中，调用 <code>toGBK()</code>，没有捕获它声明的可能抛出的 <code>UnsupportedEncodingException</code> 。修复方法是在 <code>main()</code> 方法中捕获异常并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要是方法声明的 Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在 <code>main()</code> 方法中捕获，不会出现漏写 <code>try</code> 的情况。这是由编译器保证的。<code>main()</code> 方法也是最后捕获 <code>Exception</code> 的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何 <code>try</code> 代码，可以直接把 <code>main()</code> 方法定义为 <code>throws Exception</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>main()</code> 方法声明了可能抛出 <code>Exception</code>，也就声明了可能抛出所有的 <code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来。所有异常都可以调用 <code>printStackTrace()</code> 方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="多-catch-语句"><a class="header-anchor" href="#多-catch-语句"></a>多 catch 语句</h3><p>可以使用多个 <code>catch</code> 语句，每个 <code>catch</code> 分别捕获对应的 <code>Exception</code> 及其子类。JVM 在捕获到异常后，会从上到下匹配 <code>catch</code> 语句，匹配到某个 <code>catch</code> 后，执行 <code>catch</code> 代码块，然后不再继续匹配。</p><p>简单地说就是：多个 <code>catch</code> 语句只有一个能被执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在多个 <code>catch</code> 的时候，<code>catch</code> 的顺序非常重要，子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>UnsupportedEncodingException</code> 异常是永远捕获不到的，因为它是 <code>IOException</code> 的子类。当抛出 <code>UnsupportedEncodingException</code> 异常时，会被 <code>catch (IOException e) &#123; ... &#125;</code> 捕获并执行。因此，正确的写法是把子类放到前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally-语句"><a class="header-anchor" href="#finally-语句"></a>finally 语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以把执行语句写若干遍：正常执行的放到 try 中，每个 catch 再写一遍。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无论是否发生异常，都会执行 <code>System.out.println(&quot;END&quot;);</code> 这条语句。</p><p>那么如何消除这些重复的代码？Java 的 <code>try ... catch</code> 机制还提供了 <code>finally</code> 语句，<code>finally</code> 语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>finally</code> 有几个特点：</p><ul><li><code>finally</code> 语句不是必须的，可写可不写；</li><li><code>finally</code> 总是最后执行。</li></ul><p>如果没有发生异常，就正常执行 <code>try &#123; ... &#125;</code> 语句块，然后执行 <code>finally</code>。如果发生了异常，就中断执行 <code>try &#123; ... &#125;</code> 语句块，然后跳转执行匹配的 <code>catch</code> 语句块，最后执行 <code>finally</code>。</p><p>可见，<code>finally</code> 是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有 <code>catch</code>，只使用 <code>try ... finally</code> 结构。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为方法声明了可能抛出的异常，所以可以不写 <code>catch</code>。</p><p>TODO: IO情况下不安全问题</p><h3 id="捕获多种异常"><a class="header-anchor" href="#捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条 <code>catch</code> 子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为处理 <code>IOException</code> 和 <code>NumberFormatException</code> 的代码是相同的，所以我们可以把它两用 <code>|</code> 合并到一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a class="header-anchor" href="#抛出异常"></a>抛出异常</h2><h3 id="异常的传播"><a class="header-anchor" href="#异常的传播"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个 <code>try ... catch</code> 被捕获为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>printStackTrace()</code> 可以打印出方法的调用栈，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: null</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:614)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.process2(Main.java:16)</span><br><span class="line">    at Main.process1(Main.java:12)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code> 对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code> 是在 <code>java.lang.Integer.parseInt</code> 方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code> 调用 <code>process1()</code></li><li><code>process1()</code> 调用 <code>process2()</code></li><li><code>process2()</code> 调用 <code>Integer.parseInt(String)</code></li><li><code>Integer.parseInt(String)</code> 调用 <code>Integer.parseInt(String, int)</code></li></ol><p>查看 <code>Integer.java</code> 源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常-v2"><a class="header-anchor" href="#抛出异常-v2"></a>抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考 <code>Integer.parseInt()</code> 方法，抛出异常分两步：</p><ol><li>创建某个 <code>Exception</code> 的实例；</li><li>用 <code>throw</code> 语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在 <code>catch</code> 子句中抛出新的异常，就相当于把抛出的异常类型“转换”了，当 <code>process2()</code> 抛出 <code>NullPointerException</code> 后，被 <code>process1()</code> 捕获，然后抛出 <code>IllegalArgumentException()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 <code>main()</code> 中捕获 <code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常 <code>NullPointerException</code> 的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的 <code>Exception</code> 实例传进去，新的 <code>Exception</code> 就可以持有原始 <code>Exception</code> 信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure><p>注意到 <code>Caused by: Xxx</code>，说明捕获的 <code>IllegalArgumentException</code> 并不是造成问题的根源，根源在于 <code>NullPointerException</code>，是在 <code>Main.process2()</code> 方法抛出的。</p><p>在代码中获取原始异常可以使用 <code>Throwable.getCause()</code> 方法。如果返回 <code>null</code>，说明已经是“根异常”了。</p><p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><p>如果我们在 <code>try</code> 或者 <code>catch</code> 语句块中抛出异常，<code>finally</code> 语句是否会执行？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at Main.main(Main.java:8)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">  at ...</span><br></pre></td></tr></table></figure><p>第一行打印了 <code>caught</code>，说明进入了 catch 语句块。第二行打印了 <code>finally</code> ，说明执行了 finally 语句块。</p><p>因此，在 catch 中抛出异常，不会影响 finally 的执行。JVM 会先执行 finally，然后抛出异常。</p><h3 id="异常屏蔽"><a class="header-anchor" href="#异常屏蔽"></a>异常屏蔽</h3><p>如果在执行 finally 语句时抛出异常，那么，catch 语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>这说明 finally 抛出异常后，原来在 catch 中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用 <code>origin</code> 变量保存原始异常，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 finally 抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 catch 和 finally 都抛出了异常时，虽然 catch 的异常被屏蔽了，但是，finally 抛出的异常仍然包含了它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at java.base&#x2F;java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:652)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.main(Main.java:6)</span><br></pre></td></tr></table></figure><p>通过 <code>Throwable.getSuppressed()</code> 可以获取所有的 <code>Suppressed Exception</code>。</p><p>绝大多数情况下，在 finally 中不要抛出异常。因此，我们通常不需要关心 <code>Suppressed Exception</code>。</p><h2 id="自定义异常"><a class="header-anchor" href="#自定义异常"></a>自定义异常</h2><p>Java 标准库定义的常用异常包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>当我们在代码中需要抛出异常时，尽量使用 JDK 已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个 <code>BaseException</code> 作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code> 需要从一个适合的 <code>Exception</code> 派生，通常建议从 <code>RuntimeException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从 <code>BaseException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>自定义的 <code>BaseException</code> 应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄 <code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h2 id="NullPointerException"><a class="header-anchor" href="#NullPointerException"></a>NullPointerException</h2><p>在所有的 <code>RuntimeException</code> 异常中，Java 程序员最熟悉的恐怕就是 <code>NullPointerException</code> 了。</p><p><code>NullPointerException</code> 即空指针异常，俗称 NPE。如果一个对象为 <code>null</code>，调用其方法或访问其字段就会产生 <code>NullPointerException</code>，这个异常通常是由 JVM 抛出的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自 C 语言，Java 语言中并无指针。我们定义的变量实际上是引用，Null Pointer 更确切地说是 Null Reference，不过两者区别不大。</p><h3 id="处理NullPointerException"><a class="header-anchor" href="#处理NullPointerException"></a>处理NullPointerException</h3><p>如果遇到 <code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code> 是一种代码逻辑错误，遇到 <code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用 <code>catch</code> 来隐藏这种编码错误，好的编码习惯可以极大地降低 <code>NullPointerException</code> 的产生，例如成员变量在定义时初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用空字符串 <code>&quot;&quot;</code> 而不是默认的 <code>null</code> 可避免很多 <code>NullPointerException</code> ，编写业务逻辑时，用空字符串 <code>&quot;&quot;</code> 表示未填写比 <code>null</code> 安全得多。</p><p>返回空字符串 <code>&quot;&quot;</code> 、空数组而不是 <code>null</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为 <code>null</code>。</p><p>如果调用方一定要根据 <code>null</code> 判断，比如返回 <code>null</code> 表示文件不存在，那么考虑返回 <code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过 <code>Optional.isPresent()</code> 判断是否有结果。</p><h3 id="定位-NullPointerException"><a class="header-anchor" href="#定位-NullPointerException"></a>定位 NullPointerException</h3><p>如果产生了 <code>NullPointerException</code>，例如，调用 <code>a.b.c.x()</code> 时产生了 <code>NullPointerException</code>，原因可能是：</p><ul><li><code>a</code> 是 <code>null</code>；</li><li><code>a.b</code> 是 <code>null</code>；</li><li><code>a.b.c</code> 是 <code>null</code>；</li></ul><p>确定到底是哪个对象是 <code>null</code> 以前只能打印这样的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure><p>从 Java 14 开始，如果产生了 <code>NullPointerException</code>，JVM 可以给出详细的信息告诉我们 <code>null</code> 对象到底是谁。我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;p.address.city&quot; is null</span><br><span class="line">at Main.main(Main.java:4)</span><br></pre></td></tr></table></figure><p>可以在 <code>NullPointerException</code> 的详细信息中看到类似 <code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是 <code>city</code> 字段为 <code>null</code>，这样我们就能快速定位问题所在。</p><p>这种增强的 <code>NullPointerException</code> 详细信息是 Java 14 新增的功能，但默认是关闭的，我们可以给 JVM 添加一个 <code>-XX:+ShowCodeDetailsInExceptionMessages</code> 参数启用它，在 JDK 15 及以上默认是开启的。</p><h2 id="使用断言"><a class="header-anchor" href="#使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在 Java 中，使用 <code>assert</code> 关键字来实现断言。我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 <code>assert x &gt;= 0;</code> 即为断言，断言条件 <code>x &gt;= 0</code> 预期为 <code>true</code>。如果计算结果为 <code>false</code>，则断言失败，抛出 <code>AssertionError</code>。</p><p>使用 <code>assert</code> 语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code> 会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p><p>Java 断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在程序中使用 <code>assert</code> 时，例如，一个简单的断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言 <code>x</code> 必须大于 0，实际上 <code>x</code> 为 -1，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code> 的值。为什么 <code>assert</code> 语句不起作用？</p><p>这是因为 JVM 默认关闭断言指令，即遇到 <code>assert</code> 语句就自动忽略了，不执行。</p><p>要执行 <code>assert</code> 语句，必须给 Java 虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code> ）参数启用断言。所以，上述程序必须在命令行下运行才有效果。</p><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.halo.test.Main</code> ，表示只对 <code>com.halo.test.Main</code> 这个类启用断言。或者对特定地包启用断言，命令行参数是：<code>-ea:com.halo.test...</code>（注意结尾有 3 个 <code>.</code> ），表示对 <code>com.halo.test</code> 这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，例如 JUnit。</p><h2 id="使用JDK-Logging"><a class="header-anchor" href="#使用JDK-Logging"></a>使用JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用 <code>System.out.println()</code> 打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码改好了怎么办？当然是删除没有用的 <code>System.out.println()</code> 语句了。</p><p>如果改代码又改出问题怎么办？再加上 <code>System.out.println()</code>。</p><p>反复这么搞几次，很快大家就发现使用 <code>System.out.println()</code> 非常麻烦。</p><p>怎么办？解决方法是使用日志（Logging）。它的目的是为了取代 <code>System.out.println()</code>。</p><p>输出日志，而不是用 <code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写 <code>&quot;ERROR: &quot; + var</code></li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志</li><li>可以按包名控制日志级别，只输出某些包打的日志</li><li>……</li></ol><p>因为 Java 标准库内置了日志包 <code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。再仔细观察发现，4 条日志，只打印了 3 条，<code>logger.fine()</code> 没有打印。这是因为，日志的输出可以设定级别。JDK 的 Logging 定义了 7 个日志级别，从严重到普通：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p><p>因为默认级别是 INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用 Java 标准库内置的 Logging 有以下局限：</p><p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行 main() 方法，就无法修改配置；</p><p>配置不太方便，需要在 JVM 启动时传递参数 <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java 标准库内置的 Logging 使用并不是非常广泛。</p><h2 id="使用-Commons-Logging"><a class="header-anchor" href="#使用-Commons-Logging"></a>使用 Commons Logging</h2><p>和 Java 标准库提供的日志不同，Commons Logging 是一个第三方日志库，它是由 Apache 创建的日志模块。</p><p>Commons Logging 的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin 自动搜索并使用 Log4j（ Log4j 是另一个流行的日志系统），如果没有找到 Log4j，再使用 JDK Logging。</p><p>使用 Commons Logging 只需要和两个类打交道，并且只有两步：</p><ul><li>第一步，通过LogFactory获取Log类的实例</li><li>第二步，使用Log实例的方法打日志。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maven 项目 pom.xml 中添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">INFO: start...</span><br><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure><p>Commons Logging 定义了 6 个日志级别：FATAL、ERROR、WARNING、INFO、DEBUG、TRACE。默认级别是 INFO。</p><p>使用 Commons Logging 时，如果在静态方法中引用 Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用 Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例方法中引用 <code>Log</code>，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到实例变量 <code>log</code> 的获取方式是 <code>LogFactory.getLog(getClass())</code>，虽然也可以用 <code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该 <code>log</code> 实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Java 类的动态特性，子类获取的 <code>log</code> 字段实际上相当于 <code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，Commons Logging 的日志方法，例如 <code>info()</code>，除了标准的 <code>info(String)</code> 外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Log4j"><a class="header-anchor" href="#使用-Log4j"></a>使用 Log4j</h2><p>前面介绍了 Commons Logging ，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 Log4j。</p><p>Log4j 是一种非常流行的日志框架。是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure><p>当我们使用 Log4j 输出一条日志时，Log4j 自动通过不同的 Appender 把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库。</li></ul><p>在输出日志的过程中，通过 <code>Filter</code> 来过滤哪些 log 需要被输出，哪些 log 不需要被输出。例如，仅输出 ERROR 级别的日志。</p><p>最后，通过 Layout 来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心 Log4j 的 API，而是通过配置文件来配置它。</p><p>以 Maven项目 的 XML 配置为例，使用 Log4j 的时候，我们把一个 log4j2.xml 的文件放到 main/resourse 下就可以让 Log4j 读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然配置 Log4j 比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是 INFO 级别的日志，会自动输出到屏幕，而 ERROR 级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j 就会自动切割新的日志文件，并最多保留 10 份。</p><p>在 Maven 项目 pom.xml 中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-jcl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要打印日志，只需要按 Commons Logging 的写法写，不需要改动任何代码，就可以得到 Log4j 的日志输出，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">05-20 17:13:44.186 [main] INFO  com.halo.logging.Main</span><br><span class="line">start...</span><br><span class="line"></span><br><span class="line">05-20 17:13:44.191 [main] WARN  com.halo.logging.Main</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="使用-SLF4J-和-Logback"><a class="header-anchor" href="#使用-SLF4J-和-Logback"></a>使用 SLF4J 和 Logback</h2><p>前面介绍了 Commons Logging 和 Log4j 这一对，它们一个负责充当日志 API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>其实 SLF4J 类似于Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。</p><p>为什么有了 Commons Logging 和 Log4j，又会蹦出来 SLF4J 和 Logback？这是因为 Java 有着非常悠久的开源历史，不但 OpenJDK 本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对 Commons Logging 的接口不满意，有人就搞了 SLF4J。因为对 Log4j 的性能不满意，有人就搞了 Logback。</p><p>我们先来看看 SLF4J 对 Commons Logging 的接口有何改进。在 Commons Logging 中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以 SLF4J 的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J 的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用 SLF4J ？它的接口实际上和 Commons Logging 几乎一模一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 Commons Logging 和 SLF4J 的接口，不同之处就是 <code>Log</code> 变成了 <code>Logger</code>，<code>LogFactory</code> 变成了 <code>LoggerFactory</code>。</p><p>在 Maven 项目中添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>logback-classic</code> 依赖包括了 <code>slf4j-api</code> 所以无需单独引用</p><p>在 Maven 项目中添加相关配置文件 logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:28:08.829 [main] INFO  com.halo.slf4j.Test - start...</span><br><span class="line">17:28:08.832 [main] WARN  com.halo.slf4j.Test - end.</span><br></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从 Commons Logging 加 Log4j 转向了 SLF4J 加 Logback。</p>]]></content>
    
    
    <summary type="html">Java 异常和日志</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇博客环境搭建</title>
    <link href="https://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T07:45:20.000Z</published>
    <updated>2021-05-15T13:34:29.956Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="蘑菇博客项目地址" href="https://gitee.com/moxi159753/mogu_blog_v2"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/Gitee.svg"/></div><div class="right"><p class="text">蘑菇博客项目地址</p><p class="url">https://gitee.com/moxi159753/mogu_blog_v2</p></div></a></div><p>蘑菇博客（MoguBlog），一个基于微服务架构的前后端分离博客系统。Web 端使用 Vue + Element , 移动端使用 uniapp 和 ColorUI。后端使用 Spring Cloud + Spring Boot + mybatis-plus 进行开发，使用 Jwt + Spring Security 做登录验证和权限校验，使用 ElasticSearch 和 Solr 作为全文检索服务，使用 Github Actions 完成博客的持续集成，使用 ELK 收集博客日志，文件支持上传七牛云和 Minio，支持 Docker Compose 脚本一键部署。</p><p>参考资料：</p><div class="tag link"><a class="link-card" title="Windows+VMware一键搭建蘑菇博客本地开发环境" href="http://www.moguit.cn/#/info?blogOid=583"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">Windows+VMware一键搭建蘑菇博客本地开发环境</p><p class="url">http://www.moguit.cn/#/info?blogOid=583</p></div></a></div><h2 id="Docker-环境"><a class="header-anchor" href="#Docker-环境"></a>Docker 环境</h2><p>在 VMware 或 云服务器中 配置 Docker 环境</p><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><p>因为我们需要拉取镜像，所以需要在服务器提前安装好 Docker，首先配置一下 Docker 的阿里 yum 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name&#x3D;Docker CE Edge - \$basearch</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;7&#x2F;\$basearch&#x2F;edge</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后 yum 方式安装 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"># 开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"># 启动docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置 Docker 的镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>因为 Docker 容器之间，需要互相通信访问，所以我们需要创建我们的 Docker 网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mogu</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-Compose"><a class="header-anchor" href="#安装-Docker-Compose"></a>安装 Docker Compose</h3><p>Docker Compose 是用来定义和运行多个 Docker 应用程序的工具。通过 Compose，可以使用 YAML 文件来配置应用程序需要的所有服务，然后使用一个命令即可从YML文件配置中创建并启动所有服务。</p><div class="tag link"><a class="link-card" title="安装 Docker Compose 官方文档" href="https://docs.docker.com/compose/install/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">安装 Docker Compose 官方文档</p><p class="url">https://docs.docker.com/compose/install/</p></div></a></div><div class="tag link"><a class="link-card" title="Docker Compose 下载链接" href="https://github.com/docker/compose/releases"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">Docker Compose 下载链接</p><p class="url">https://github.com/docker/compose/releases</p></div></a></div><p>把下载到的文件使用 ftp 工具，拷贝到 /usr/local/bin/ 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 重命名</span><br><span class="line">mv docker-compose-Linux-x86_64  docker-compose</span><br><span class="line"># 加入执行权限</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"># 查看docker-compose版本</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><h2 id="下载源码"><a class="header-anchor" href="#下载源码"></a>下载源码</h2><p>下载蘑菇博客的<a href="https://gitee.com/moxi159753/mogu_blog_v2">源码</a></p><p>找到，doc\docker-compose 目录，目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose</span><br><span class="line"> ├── bin     # 相关一键启动脚本的目录</span><br><span class="line"> ├── config  # 存放配置文件</span><br><span class="line"> ├── data    # 存放数据文件</span><br><span class="line"> ├── log     # 存放日志文件</span><br><span class="line"> └── yaml    # 存放 docker compose 的 yaml 文件</span><br></pre></td></tr></table></figure><p>下面我们开始，将 docker-compose 文件夹，拷贝服务器目录位置随意，我是拷贝到 /root/docker-compose 目录，然后给命令设置执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入目录</span><br><span class="line">cd docker-compose</span><br><span class="line"># 添加执行权限</span><br><span class="line">chmod +x bin&#x2F;middleware.sh</span><br><span class="line">chmod +x bin&#x2F;kernShutdown.sh</span><br><span class="line">chmod +x bin&#x2F;wait-for-it.sh</span><br></pre></td></tr></table></figure><h2 id="部署核心组件"><a class="header-anchor" href="#部署核心组件"></a>部署核心组件</h2><p>下面我们将部署蘑菇博客所依赖的核心中间件，例如：Nacos、MySQL、Redis、RabbitMQ、Nginx 等</p><p>首先到 docker-compose/bin 目录下，执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开始部署核心组件</span><br><span class="line">sh middleware.sh</span><br><span class="line"># 以后打算关闭的话，执行 .&#x2F;kernShutdown.sh</span><br></pre></td></tr></table></figure><p>在部署完中间件后，我们需要进行测试中间件安装是否成功。</p><h3 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h3><p>利用 SQLyog、IDEA等工具测试连接：</p><p>默认MySQL用户名：root<br>默认MySQL密码：mogu2018</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Idea%E6%B5%8B%E8%AF%95mugo_mysql%E8%BF%9E%E6%8E%A5.png" alt="Idea测试mugo_mysql连接"></p><h3 id="Nacos"><a class="header-anchor" href="#Nacos"></a>Nacos</h3><p>Nacos 后台配置页面，默认账号和密码：nacos  nacos</p><p>访问下面 URL 进行测试 <a href="http://nacos:8848/nacos">http://nacos:8848/nacos</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95nacos_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试nacos_mugo连接"></p><blockquote><p>设置 host 将 nacos 改为对应服务器外网 IP ，记得开放对应端口</p></blockquote><h3 id="Redis"><a class="header-anchor" href="#Redis"></a>Redis</h3><p>默认Redis密码：mogu2018</p><h3 id="RabbitMQ"><a class="header-anchor" href="#RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ是消息队列，我们可以访问其图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 图形化地址</span><br><span class="line">IP地址:15672</span><br><span class="line"># 默认账号和密码为：admin  mogu2018</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95rabbitmq_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试rabbitmq_mugo连接"></p><h2 id="部署非核心组件"><a class="header-anchor" href="#部署非核心组件"></a>部署非核心组件</h2><h3 id="Zipkin"><a class="header-anchor" href="#Zipkin"></a>Zipkin</h3><p>Zipkin是一个开源的分布式的链路追踪系统，每个微服务都会向zipkin报告计时数据，聚合各业务系统调用延迟数据，达到链路调用监控跟踪</p><h3 id="Sentinel"><a class="header-anchor" href="#Sentinel"></a>Sentinel</h3><h3 id="搜索模块"><a class="header-anchor" href="#搜索模块"></a>搜索模块</h3><h2 id="启动后端项目"><a class="header-anchor" href="#启动后端项目"></a>启动后端项目</h2><h3 id="修改项目配置"><a class="header-anchor" href="#修改项目配置"></a>修改项目配置</h3><p>修改的是 mogu_admin 项目的 application.yml，将 dev 改成 prod 然后修改 bootstrap.yaml ，将 dev 改成 prod，同时还需要修改 nacos 和 sentinel ，将 localhost改为对应的服务名称即可。</p><p>我们重复上面操作，将 mogu_web、mogu_sms、mogu_gateway、mogu_picture、mogu_montor 等项目都进行修改。</p><h3 id="启动项目"><a class="header-anchor" href="#启动项目"></a>启动项目</h3><p>修改完成后，直接启动项目即可。其中我们需要启动核心组件包含下面几个【服务启动没有先后顺序】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogu_admin、mogu_web、mogu_sms、mogu_picture、mogu_gateway</span><br></pre></td></tr></table></figure><p>等服务器都启动完成后，下面我们验证一下后台是否正常启动，回到我们的 Nacos 管理界面,如果我们看到下面五个服务都注册到 Nacos 中，那说明启动成功</p><ul><li>mogu_picture</li><li>mogu_sms</li><li>mogu_admin</li><li>mogu_web</li><li>mogu_gateway</li></ul><p>在通过访问下列 swagger 接口，测试接口是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">############ admin端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8601&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ picture端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8602&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ web端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8603&#x2F;swagger-ui&#x2F;index.html</span><br></pre></td></tr></table></figure><p>如果能够进入下面页面的话，说明后台是没有问题的了，下面我们可以验证一下接口</p>]]></content>
    
    
    <summary type="html">蘑菇博客是我目前找到理想的博客系统，基于对该项目的学习，进一步掌握 Java 后端过程</summary>
    
    
    
    <category term="蘑菇博客" scheme="https://halo123.top/categories/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器环境搭建</title>
    <link href="https://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T06:56:51.000Z</published>
    <updated>2021-05-15T06:47:29.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Docker-的环境搭建"><a class="header-anchor" href="#基于-Docker-的环境搭建"></a>基于 Docker 的环境搭建</h2><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><div class="tag link"><a class="link-card" title="Docker文档" href="https://docs.docker.com/engine/install/centos/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">Docker文档</p><p class="url">https://docs.docker.com/engine/install/centos/</p></div></a></div><ol><li><p>卸载系统之前的docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li><li><p>安装依赖的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure></li><li><p>配置镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动Docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>检测Docker是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>查看下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置-Docker-镜像加速"><a class="header-anchor" href="#配置-Docker-镜像加速"></a>配置 Docker 镜像加速</h3><div class="tag link"><a class="link-card" title="阿里云镜像加速" href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/阿里云.svg"/></div><div class="right"><p class="text">阿里云镜像加速</p><p class="url">https://cr.console.aliyun.com/cn-qingdao/instances/mirrors</p></div></a></div><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>您可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器</p><ol><li><p>创建目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;578xeysa.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 后台线程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-MySQL"><a class="header-anchor" href="#安装-MySQL"></a>安装 MySQL</h3><ol><li><p>拉取 MySQL 5.7 的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>检查下载的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 3306:3306</code> 将容器的3306端口映射到主机的3306端口<br><code>--name</code> 指定容器名字<br><code>-v</code>目录挂载<br><code>-e</code>设置mysql参数，初始化root用户的密码<br><code>-d</code>后台运行</p></blockquote></li><li><p>查看 Docker 正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>进入容器内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bin&#x2F;bash</span><br><span class="line"># 退出命令</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure></li><li><p>修改 MySQL 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Redis"><a class="header-anchor" href="#安装-Redis"></a>安装 Redis</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li><p>先配置目录，注意 <code>redis.conf</code> 是文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;mydata&#x2F;redis&#x2F;conf</span><br><span class="line">touch &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>安装，挂载目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">-d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>直接进去 redis 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure></li><li><p>配置 redis 持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>插入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure></li><li><p>设置 redis 容器在 Docker 启动的时候启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update redis --restart&#x3D;always</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Nacos"><a class="header-anchor" href="#安装-Nacos"></a>安装 Nacos</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --env MODE&#x3D;standalone --name nacos nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Elasticsearch、Kibana"><a class="header-anchor" href="#安装-Elasticsearch、Kibana"></a>安装 Elasticsearch、Kibana</h3><ol><li><p>下载镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 存储和检索数据</span><br><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line"># 可视化检索数据</span><br><span class="line">docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure></li><li><p>配置挂载数据文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置文件目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;config</span><br><span class="line"></span><br><span class="line"># 创建数据目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;data</span><br><span class="line"></span><br><span class="line"># 将&#x2F;mydata&#x2F;elasticsearch&#x2F;文件夹中文件都可读可写</span><br><span class="line">chmod -R 777 &#x2F;mydata&#x2F;elasticsearch&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置任意机器可以访问 elasticsearch</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;&#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure></li><li><p>启动 Elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e  &quot;discovery.type&#x3D;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS&#x3D;&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \</span><br><span class="line">-v  &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \</span><br><span class="line">-d elasticsearch:7.4.2 </span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 9200:9200 -p 9300:9300</code>：向外暴露两个端口，9200 用于HTTP REST API请求，9300 ES 在分布式集群状态下 ES 之间的通信端口；<br><code>-e  &quot;discovery.type=single-node&quot;</code>：es 以单节点运行<br><code>-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;</code>：设置启动占用内存，不设置可能会占用当前系统所有内存<br><code>-v</code>：挂载容器中的配置文件、数据文件、插件数据到本机的文件夹；<br><code>-d elasticsearch:7.6.2</code>：指定要启动的镜像</p></blockquote></li><li><p>设置 Elasticsearch 随 Docker 启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前 Docker 开机自启，所以 ES 现在也是开机自启</span><br><span class="line">docker update elasticsearch --restart&#x3D;always</span><br></pre></td></tr></table></figure></li><li><p>启动可视化 Kibana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;&#123;IP地址&#125;:9200 \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-e ELASTICSEARCH_HOSTS=http://&#123;IP地址&#125;:9200</code>: 这里要设置成自己的虚拟机IP地址</p></blockquote></li><li><p>浏览器输入 IP地址:5601 测试</p><blockquote><p>注意：将服务器对应端口的防火墙关闭</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">由于环境搭建比较繁琐，该文章用于记录平时需要配置的一些环境过程，一方面为了复现，另一方面在环境有问题时可以用做参考</summary>
    
    
    
    <category term="Linux" scheme="https://halo123.top/categories/Linux/"/>
    
    
    <category term="Docker" scheme="https://halo123.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/"/>
    <id>https://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/</id>
    <published>2021-05-14T10:56:51.000Z</published>
    <updated>2021-05-30T12:27:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="《LeetCode 101：和你一起你轻松刷题（C++）》" href="https://github.com/changgyhub/leetcode_101"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">《LeetCode 101：和你一起你轻松刷题（C++）》</p><p class="url">https://github.com/changgyhub/leetcode_101</p></div></a></div><h2 id="算法解释"><a class="header-anchor" href="#算法解释"></a>算法解释</h2><p>顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。</p><p>举一个最简单的例子：小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的策略。</p><h2 id="分配问题"><a class="header-anchor" href="#分配问题"></a>分配问题</h2><h3 id="分发饼干"><a class="header-anchor" href="#分发饼干"></a>分发饼干</h3><div class="tag link"><a class="link-card" title="455. 分发饼干" href="https://leetcode-cn.com/problems/assign-cookies/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">455. 分发饼干</p><p class="url">https://leetcode-cn.com/problems/assign-cookies/</p></div></a></div><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 <code>i</code> ，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><div class="tabs" id="分发饼干"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发饼干-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发饼干-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发饼干-1"><p>输入：<code>g = [1,2,3]</code> ，<code>s = [1,1]</code></p><p>输出：<code>1</code></p><p>解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1，2，3。虽然你有两块小饼干，由于他们的尺寸都是 1 ，你只能让胃口值是 1 的孩子满足。所以你应该输出 1 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发饼干-2"><p>输入：<code>g = [1,2]</code>，<code>s = [1,2,3]</code></p><p>输出：<code>2</code></p><p>解释：你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1，2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p><p>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p><p>至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对胃口值进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 对饼干进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环遍历，如果其中一个数组长度小于另一个则跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.<span class="built_in">size</span>() &amp;&amp; cookie &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                <span class="comment">// 满足一个孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否满足都将饼干++</span></span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回满足的孩子数</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="comment"># 升序排序</span></span><br><span class="line">    g.sort()</span><br><span class="line">    s.sort()</span><br><span class="line">    child = cookie = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> cookie &lt; <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> (g[child] &lt;= s[cookie]):</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        cookie += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(test1)</span><br><span class="line">test2 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(test2)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span></span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> result = solution.findContentChildren(g, s);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] g1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s1 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 1&quot;</span>);</span><br><span class="line">        test(g1,s1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] g2 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s2 = &#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 2&quot;</span>);</span><br><span class="line">        test(g2,s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(m \log m + n \log n$)，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。对两个数组排序的时间复杂度是 $O(m \log m + n \log n)$，遍历数组的时间复杂度是 $O(m+n)$，因此总时间复杂度是 $O(m \log m + n \log n)$。</p><p>空间复杂度：$O(\log m + \log n)$，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。空间复杂度主要是排序的额外空间开销。</p><h3 id="分发糖果"><a class="header-anchor" href="#分发糖果"></a>分发糖果</h3><div class="tag link"><a class="link-card" title="135. 分发糖果" href="https://leetcode-cn.com/problems/candy/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">135. 分发糖果</p><p class="url">https://leetcode-cn.com/problems/candy/</p></div></a></div><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><div class="tabs" id="分发糖果"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发糖果-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发糖果-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发糖果-1"><p>输入：<code>[1,0,2]</code></p><p>输出：<code>5</code></p><p>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发糖果-2"><p>输入：<code>[1,2,2]</code></p><p>输出：<code>4</code></p><p>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>虽然这一道题也是运用贪心策略，但我们只需要简单的两次遍历即可：</p><ol><li>把所有孩子的糖果数初始化为 1；</li><li>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；</li><li>再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。</li></ol><p>通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">candies</span><span class="params">(nums, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                candies[i + <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i] &amp;&amp; candies[i - <span class="number">1</span>] &lt;= candies[i]) &#123;</span><br><span class="line">                candies[i - <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">candy</span>(children);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">ratings</span>):</span></span><br><span class="line">    lens = <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span>(lens &lt; <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> lens</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将糖果数量列表每项值初始化为1</span></span><br><span class="line">    num_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先从左往右遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果右边孩子的评分比左边的高</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[i+<span class="number">1</span>] &gt; ratings[i]):</span><br><span class="line">            <span class="comment"># 右边孩子的糖果数更新为左边孩子的糖果数加 1</span></span><br><span class="line">            num_list[i+<span class="number">1</span>] = num_list[i]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再从右往左遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果左边孩子的评分比右边的高</span></span><br><span class="line">        <span class="comment"># 且左边孩子当前的糖果数不大于右边孩子的糖果数</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[j-<span class="number">1</span>] &gt; ratings[j] <span class="keyword">and</span> num_list[j-<span class="number">1</span>] &lt;= num_list[j]):</span><br><span class="line">            num_list[j-<span class="number">1</span>] = num_list[j]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求得总糖果数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> num_list:</span><br><span class="line">        num += k</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</p><p>空间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要保存所有的左规则对应的糖果数量。</p><h2 id="区间问题"><a class="header-anchor" href="#区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a class="header-anchor" href="#无重叠区间"></a>无重叠区间</h3><div class="tag link"><a class="link-card" title="435. 无重叠区间" href="https://leetcode-cn.com/problems/non-overlapping-intervals/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">435. 无重叠区间</p><p class="url">https://leetcode-cn.com/problems/non-overlapping-intervals/</p></div></a></div><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互“接触”，但没有相互重叠。</li></ol><div class="tabs" id="无重叠区间"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#无重叠区间-1">示例 1</button></li><li class="tab"><button type="button" data-href="#无重叠区间-2">示例 2</button></li><li class="tab"><button type="button" data-href="#无重叠区间-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="无重叠区间-1"><p>输入：<code>[ [1,2], [2,3], [3,4], [1,3] ]</code></p><p>输出：<code>1</code></p><p>解释：移除 <code>[1,3]</code> 后，剩下的区间没有重叠。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-2"><p>输入：<code>[ [1,2], [1,2], [1,2] ]</code></p><p>输出：<code>2</code></p><p>解释：你需要移除两个 <code>[1,2]</code> 来使剩下的区间没有重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-3"><p>输入：<code>[ [1,2], [2,3] ]</code></p><p>输出：<code>0</code></p><p>解释：你不需要移除任何区间，因为它们已经是无重叠的了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</p><p>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 <code>std::sort()</code> 函数进行自定义排序。</p><p>在样例中，排序后的数组为 <code>[[1,2], [1,3], [2,4]]</code>。按照我们的贪心策略：</p><ol><li>首先初始化为区间<code>[1,2]</code>；</li><li>由于 <code>[1,3]</code> 与 <code>[1,2]</code> 相交，我们跳过该区间；</li><li>由于 <code>[2,4]</code> 与 <code>[1,2]</code> 不相交，我们将其保留。</li><li>因此最终保留的区间为 <code>[[1,2], [2,4]]</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; test = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">eraseOverlapIntervals</span>(test);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n \log n)$，其中 $n$ 是区间的数量。我们需要 $O(n \log n)$ 的时间对所有的区间按照右端点进行升序排序，并且需要 $O(n)$ 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 $O(n \log n)$。</p><p>空间复杂度：$O(\log n)$，即为排序需要使用的栈空间。</p><h3 id="种花问题"><a class="header-anchor" href="#种花问题"></a>种花问题</h3><div class="tag link"><a class="link-card" title="605. 种花问题" href="https://leetcode-cn.com/problems/can-place-flowers/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">605. 种花问题</p><p class="url">https://leetcode-cn.com/problems/can-place-flowers/</p></div></a></div><br/><p>从一边开始遍历，当这个值为0且左右两边都为0时，将其变成1。最后将结果数组求和与原始值求和值相减即为最大满足值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当n为0时无论什么情况都为true</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 在只有1个位置时，chu了n=0情况下，只有n为1且位置为空才为true</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; flowerbed[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于统计未加入花时的，花数目</span></span><br><span class="line">        <span class="keyword">int</span> before = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[0,0,...]情况下时变成[1,0,...]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; flowerbed[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将[...,0,0,0,...]情况变成[...,0,1,0,...]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[...,0,0]情况变成[...,0,1]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计加入花后的所有花的数目</span></span><br><span class="line">        <span class="keyword">int</span> after = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 当n小于,可以插入花的最大数目时返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((after - before) &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test2 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test3 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test5 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> result = Solution::<span class="built_in">canPlaceFlowers</span>(test4, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销售价值减少的颜色球【中等】"><a class="header-anchor" href="#销售价值减少的颜色球【中等】"></a>销售价值减少的颜色球【中等】</h2><div class="tag link"><a class="link-card" title="1648. 销售价值减少的颜色球" href="https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">1648. 销售价值减少的颜色球</p><p class="url">https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/</p></div></a></div><p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要<font color="#faa755">任意颜色</font>总数为 <code>orders</code> 的球。</p><p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的<font color="#faa755">同色球</font>的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）。</p><p>给你整数数组 <code>inventory</code>，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code>，表示顾客总共想买的球数目。你可以按照任意顺序卖球。</p><p>请你返回卖了 <code>orders</code> 个球以后最大总价值之和。由于答案可能会很大，请你返回答案对 $10^{9} + 7$ 取余数 的结果。</p><div class="tabs" id="销售价值减少的颜色球"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#销售价值减少的颜色球-1">示例 1</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-2">示例 2</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-3">示例 3</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-4">示例 4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="销售价值减少的颜色球-1"><p>输入：<code>inventory = [2,5]</code>，<code>orders = 4</code></p><p>输出：14</p><p>解释：卖 1 个第一种颜色的球（价值为 2），卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。最大总和为 2 + 5 + 4 + 3 = 14。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-2"><p>输入：<code>inventory = [3,5]</code>，<code>orders = 6</code></p><p>输出：19</p><p>解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-3"><p>输入：<code>inventory = [2,8,4,10,6]</code>，<code>orders = 20</code></p><p>输出：110</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-4"><p>输入：<code>inventory = [1000000000]</code>，<code>orders = 1000000000</code></p><p>输出：21</p><p>解释：卖 1000000000 次第一种颜色的球，总价值为 500000000。 500000000 对 $10^{9} + 7$ 取余为 21</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>该题使用贪心算法，很容易想到，对数组进行从大到小排序，每次让值最大的元素加到 <code>result</code>，并使 <code>orders-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">inventory, orders</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 数组元素只有一个时</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inventory) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> orders &gt; <span class="number">0</span>:</span><br><span class="line">            orders = orders-<span class="number">1</span></span><br><span class="line">            result = result + inventory[<span class="number">0</span>]</span><br><span class="line">            inventory[<span class="number">0</span>] = inventory[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result % <span class="number">1000000007</span></span><br><span class="line">    <span class="comment"># 数组元素有多个时</span></span><br><span class="line">    <span class="keyword">while</span> orders &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(inventory):</span><br><span class="line">        <span class="keyword">if</span> inventory[i] &lt; inventory[i + <span class="number">1</span>]:</span><br><span class="line">            inventory = <span class="built_in">sorted</span>(inventory, reverse=<span class="literal">True</span>)</span><br><span class="line">        result += inventory[i]</span><br><span class="line">        inventory[i] = inventory[i] - <span class="number">1</span></span><br><span class="line">        orders = orders - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result % <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">2</span>, <span class="number">5</span>], <span class="number">4</span>))  <span class="comment"># 14</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">3</span>, <span class="number">5</span>], <span class="number">6</span>))  <span class="comment"># 19</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>], <span class="number">20</span>))  <span class="comment"># 110</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">10</span>], <span class="number">10</span>))  <span class="comment"># 55</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">1000000000</span>], <span class="number">1000000000</span>))  <span class="comment"># 21</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">773160767</span>], <span class="number">252264991</span>))  <span class="comment"># 70267492</span></span><br></pre></td></tr></table></figure><p>但题目中给的数据比较大，如果不进行优化会超时，<a href="https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/solution/liang-chong-si-lu-you-hua-tan-xin-suan-fa-you-hua-/">优化思路</a></p><p>不需要一次一次的模拟，而是一次性买入一定数量的球，直至该球数量等于至第二多数量。对于示例 3：<code>inventory = [2,8,4,10,6]</code>，<code>orders = 20</code> 而言：</p><p>首先，从大到小排序。<code>[10, 8, 6, 4, 2]</code>，然后逐步模拟：</p><ul><li><code>[10, 8, 6, 4, 2]</code>，<code>orders = 20</code> 数量最多的同色球的数量为 10，第二多的为 8，颜色数为 1。此时我们可以销售第一个颜色的球 2 次，获利 10 + 9 = 19。</li><li><code>[8, 8, 6, 4, 2]</code>，<code>orders = 18</code> 数量最多的同色球的数量为 8，第二多（与第一不同）的为 6，颜色数为 2。此时我们可以销售 2 × 2 = 4 次，获利 (8 + 7) × 2 = 30。</li><li><code>[6, 6, 6, 4, 2]</code>，<code>orders = 14</code> 数量最多的同色球的数量为 6，第二多（与第一不同）的为 4，颜色数为 3。此时我们可以销售 2 × 3 = 6 次，获利 (6 + 5) × 3 = 33。</li><li><code>[4, 4, 4, 4, 2]</code>，<code>orders = 8</code> 数量最多的同色球的数量为 4，第二多（与第一不同）的为 2，颜色数 = 4。此时我们可以全部卖完，销售 2 × 4 次，获利（4 + 3）× 4 = 28。</li><li>总计收入为 19 + 30 + 33 + 28 = 110.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">inventory, orders</span>):</span></span><br><span class="line">    inventory = <span class="built_in">sorted</span>(inventory, reverse=<span class="literal">True</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    mod = <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">    <span class="keyword">while</span> orders &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 找到第二多元素的索引</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(inventory) <span class="keyword">and</span> inventory[i] &gt;= inventory[<span class="number">0</span>]:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将第二多元素赋值到 nextEle</span></span><br><span class="line">        nextEle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(inventory):</span><br><span class="line">            nextEle = inventory[i]</span><br><span class="line">        <span class="comment"># 具有相同个数的元素有多少个</span></span><br><span class="line">        bucks = i</span><br><span class="line">        <span class="comment"># 当前最多元素与第二多元素个数之差</span></span><br><span class="line">        delta = inventory[<span class="number">0</span>] - nextEle</span><br><span class="line">        <span class="comment"># 最多可以一次性销售多少次</span></span><br><span class="line">        rem = bucks * delta</span><br><span class="line">        <span class="comment"># 一次性销售次数大于卖的个数</span></span><br><span class="line">        <span class="keyword">if</span> rem &gt; orders:</span><br><span class="line">            dec = orders // bucks</span><br><span class="line">            a1 = inventory[<span class="number">0</span>] - dec + <span class="number">1</span></span><br><span class="line">            an = inventory[<span class="number">0</span>]</span><br><span class="line">            res = res + ((((a1 + an) * dec) // <span class="number">2</span>) * bucks)</span><br><span class="line">            res = res + ((inventory[<span class="number">0</span>] - dec) * (orders % bucks))</span><br><span class="line">        <span class="comment"># 一次性销售次数小于卖的个数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以卖出的最低价格</span></span><br><span class="line">            a1 = nextEle + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 可以卖出的最高价格</span></span><br><span class="line">            an = inventory[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 等差数列求和</span></span><br><span class="line">            res = res + ((((a1 + an) * delta) // <span class="number">2</span>) * bucks)</span><br><span class="line">            inventory[<span class="number">0</span>] = nextEle</span><br><span class="line">        <span class="comment"># orders 减去一次性买入个数</span></span><br><span class="line">        orders = orders - rem</span><br><span class="line">        <span class="comment"># 前取模防止溢出</span></span><br><span class="line">        res = res % mod</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res)</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">时间复杂度分析</font></strong>：$n \log(n)$</p>]]></content>
    
    
    <summary type="html">LeetCode刷题之贪心算法</summary>
    
    
    
    <category term="LeetCode" scheme="https://halo123.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://halo123.top/tags/LeetCode/"/>
    
    <category term="贪心算法" scheme="https://halo123.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
