<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HALO</title>
  
  <subtitle>HALO</subtitle>
  <link href="https://halo123.top/atom.xml" rel="self"/>
  
  <link href="https://halo123.top/"/>
  <updated>2021-06-14T15:36:14.091Z</updated>
  <id>https://halo123.top/</id>
  
  <author>
    <name>HALO</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从基因层面对棘皮动物对称性研究</title>
    <link href="https://halo123.top/2021/06/09/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E5%AF%B9%E7%A7%B0%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
    <id>https://halo123.top/2021/06/09/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E5%AF%B9%E7%A7%B0%E6%80%A7%E7%A0%94%E7%A9%B6/</id>
    <published>2021-06-08T16:35:01.000Z</published>
    <updated>2021-06-14T15:36:14.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文链接：<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms | Communications Biology (nature.com)</a></p></blockquote><p>Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms</p><p>从基因组学去洞察棘皮动物体平面从双侧对称转变到五辐射对称</p><h2 id="Abstract"><a class="header-anchor" href="#Abstract"></a>Abstract</h2><p>Echinoderms are an exceptional group of bilaterians that develop pentameral adult symmetry from a bilaterally symmetric larva. However, the genetic basis in evolution and development of this unique transformation remains to be clarified. Here we report newly sequenced genomes, developmental transcriptomes, and proteomes of diverse echinoderms including the green sea urchin (<em>L. variegatus</em>), a sea cucumber (<em>A. japonicus</em>), and with particular emphasis on a sister group of tvhe earliest-diverged echinoderms, the feather star (<em>A. japonica</em>). We learned that the last common ancestor of echinoderms retained a well-organized Hox cluster reminiscent of the hemichordate, and had gene sets involved in endoskeleton development. Further, unlike in other animal groups, the most conserved developmental stages were not at the body plan establishing phase, and genes normally involved in bilaterality appear to function in pentameric axis development. These results enhance our understanding of the divergence of protostomes and deuterostomes almost 500 Mya.</p><blockquote><p>棘皮动物是一类特殊的对称动物，从两侧对称的幼虫发育成五辐射对称的成体。然而，这进化的遗传基础和独特的变态发育仍有待澄清。在这里，我们报告了新测序的基因组、发育转录组和多种棘皮动物的蛋白质组，其中包括绿海胆（ <em>L. variegatus</em>）、海参（<em>A. japonicus</em>）和侧重于一类早期分支的棘皮动物——海羽星（<em>A. japonica</em>）。我们获悉，棘皮动物最后的共同祖先保留着使人想到半索动物的有序的 Hox 基因簇，并且基因簇参与了内骨骼的发育。进一步研究，不像其他动物群，最保守的发育阶段不是在身体平面建立时期，通常涉及两侧对称的基因似乎在五轴对称的发育中发挥作用。这些研究结果加深了我们认识——原口动物和后口动物产生分歧在差不多 500 万年前。</p></blockquote><h2 id="Introduction"><a class="header-anchor" href="#Introduction"></a>Introduction</h2><p>Bilateral symmetry is highly conserved throughout animal evolution. Echinoderms, a group closely related to chordates, are exceptional in this regard, developing pentameral symmetry as adults from bilaterally symmetric larvae. Even sea cucumbers, which show worm-like bilateral structures as adults, retain pentameral symmetry patterning along their oral-aboral axis (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1a</a>)<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR1">1</a></sup>. Understanding the development of pentameral symmetry would provide important insight into the evolutionary mechanisms of major structural changes in evolution<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR2">2</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR3">3</a></sup>. To probe the genetic and developmental transitions behind the evolution of these unique echinoderm features, we sequenced genomes of the green sea urchin (<em>Lytechinus variegatus</em>) and the feather star (<em>Anneissia japonica</em>), representing nearly 500 Mya of evolutionary history. We also added developmental transcriptomic datasets for other echinoderms (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a> and “Methods”), such as the sea cucumber (<em>Apostichopus japonicus</em>), and proteome analyses of feather star skeleton to broadly analyze five living echinoderm classes. These data provide fundamental genomic, transcriptomic, and proteomic insights of body plan evolution in echinoderms, and enhance our understanding of the divergence of protostomes and deuterostomes.</p><blockquote><p>在整个动物进化过程中，两侧对称是高度保守的。作为一个与脊索动物密切相关的棘皮动物，但在这方面是例外的，从两侧对称的幼虫发育成五辐射对称的成体。即使是海参，在成年时表现出类似蠕虫的双侧结构，也沿着它们的口-口轴保持着五辐射对称模式（图 1a）。了解五辐射对称的发展将为了解演化过程中主要结构变化的演化机制提供重要的信息。探究这些独特的棘皮动物特征进化背后的遗传和发育转变，我们对绿海胆（<em>Lytechinus variegatus</em>）和海羽星 (<em>Anneissia japonica</em>）的基因组进行了测序，代表了近 500 万年的进化史。我们还添加了其他棘皮动物的发育转录组数据集（补充 表1-22 和 “方法”章节），比如海参（<em>Apostichopus japonicus</em>），此外通过对海羽星骨骼的蛋白质组研究，对现存的五种棘皮动物进行了广泛的分析。这些数据为棘皮动物体平面进化的基因组学、转录组学和蛋白质组学提供了基础，并加深了我们对原口动物和后口动物差异的理解。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/EchinodermsAndTheirEvolutionaryDiversity.png" alt="EchinodermsAndTheirEvolutionaryDiversity"></p><p><strong>a</strong> Echinoderm species of five living classes were analyzed in this study. Pentameral symmetry can also be observed in the transverse section of the sea cucumber (top), which otherwise shows apparent bilaterality. <strong>b</strong> Evolutionary rate and the phylogenetic tree constructed by RAxML software using the 1196 orthologous protein sequences identified by reciprocal best blast hit (RBBH). The values on branches represent bootstrap values. <strong>c</strong> Schematic representation of genomic organization of ambulacrarian Hox clusters. Arrows and horizontal lines represent Hox genes and chromosomal DNAs, respectively. Dashed lines indicate the presence of unconnected scaffolds. See Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">13</a> for more detailed Hox cluster structures. Hox cluster structures of <em>S. kowalevskii</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a><em>, A. japonicus</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a>, <em>S. purpuratus</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a><em>, O. spiculata</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a> and <em>A. planci</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a> are according to the previous studies.</p><blockquote><p><strong>a</strong> 对5个现存纲的棘皮动物种类进行了分析。尽管海参是明显的两侧对称，但横切面（上）可以观察到五辐射对称。<strong>b</strong> 利用RBBH (reciprocal best blast hit, RBBH）鉴定的 1196 条同源蛋白序列，利用 RAxML 软件构建进化速率和系统发育树。分支上的值表示自展支持率（由于可靠性分析）。<strong>c</strong></p></blockquote><h2 id="Results"><a class="header-anchor" href="#Results"></a>Results</h2><h3 id="Genetic-changes-behind-echinoderm-evolution"><a class="header-anchor" href="#Genetic-changes-behind-echinoderm-evolution"></a>Genetic changes behind echinoderm evolution</h3><blockquote><p>棘皮动物进化背后的遗传变化</p></blockquote><p>The estimated genome sizes were 952 Mb for green sea urchin and 553 Mb for the feather star (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>), with 30,238 and 26,838 protein-coding genes, respectively (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">18</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Basic features of these genomes such as GC content, gene length, and exon number were comparable to those of chordate and hemichordate species (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>). Genome-wide analysis with 1196 one-to-one orthologs (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1b</a>, Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>, and Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a>) robustly corroborated recent reports<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR4">4</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR5">5</a></sup> that Echinodermata consists of the early diverged Crinoidea (including feather star), Asterozoa (including brittle star and sea star), and Echinozoa (including sea urchin and sea cucumber). This is consistent with paleontological evidence that suggests echinoderms first evolved with a stemmed, or imperforate extra-axial morphology<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR3">3</a></sup>. We also found that the overall protein sequences of an early diverged echinoderm species, the feather star, showed a relatively low evolutionary rate. Meanwhile, echinoderms showed only slightly diverged protein sequences from vertebrates, as opposed to an ascidian, a species with highly derived morphological features, and with significantly diverged genomic sequences from vertebrates (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">8</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">26</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">28</a>).</p><blockquote><p>估计绿海胆的基因组大小为 952 Mb 和 羽毛星大小为 553 Mb （补充 图 1），分别有 30238 和 26838 个蛋白质编码基因（补充 表 18-20 和 23）。这些基因组的 GC 含量、基因长度和外显子数等基本特征与脊索类和半脊索类相似（补充 图 2-7）。全基因组分析得到 1196 条同源序列（图 1b，补充 图 7 和 表 23-24），有力地证实了最近的报道的棘皮动物门由早期分叉出的海百合纲（包括海羽星）、海星亚门（包括海蛇尾和海星）和海胆亚门（包括海胆和海参）组成。这与古生物学的证据相一致棘皮动物首先进化出茎的或无孔轴外形态。我们还发现，棘皮动物的早期分支海羽星的整体蛋白质序列显示出相对较低的进化率。与此同时，棘皮动物的蛋白质序列与脊椎动物的差异很小，而与具有高度衍生形态特征的海鞘相反，棘皮动物的基因组序列与脊椎动物的明显不同（补充 图 8 和 补充 表 26-28）。</p></blockquote><p>Given that echinoderms evolved unique features without significant genome-wide changes detected, we tested abundance in sets of gene families that may have played critical roles in the evolution of the echinoderm features. We first tested if numbers of genes potentially involved in development (such as genes involved in cell-cell communications) have expanded in the common ancestor of echinoderms (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">10</a>). In contrast to our expectation, GO term enrichment analysis suggested that no such terms were enriched in the echinoderm-expanded gene set (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11</a>). Rather, GO terms such as “cell communication”, or “signal transduction”, were present in echinoderm-contracted genes (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11a</a>). Further, genes potentially involved in cytoskeletal regulation appear to have experienced extensive modifications during echinoderm evolution. For example, the “plectin repeat domain”, one of the important domains of cytolinkers that connect cytoskeletal elements with each other and to junctional complexes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR6">6</a></sup>, was not found in any of the five echinoderm species (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">12</a>). Similarly, genes potentially involved in actin cytoskeleton regulation such as BCAR1/CAS and PIP5K were found to be positively selected during echinoderm evolution (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">29</a>), suggesting substantial modifications of cytoskeletal function during echinoderm evolution.</p><blockquote><p>鉴于棘皮动物进化出了独特的特征，但没有检测到重大的全基因组变化，我们测试了大量可能在棘皮动物特征的进化中发挥关键作用的基因家族。我们首先测试了在棘皮动物的共同祖先中，潜在参与发育的基因（比如参与细胞间通讯的基因）的数量是否已经增加（补充 图 10 ）。但与我们的预期相反，GO富集分析表明，在棘皮动物扩展的基因集合中没有这样的术语（term）富集（补充 图 11）。但 GO 术语（GO term）例如“细胞通讯”或“信号传导”存在于棘皮动物的收缩基因中。此外，可能参与细胞骨架调控的基因似乎在棘皮动物进化过程中经历了大量的修饰。例如，胶凝素重复结构域（plectin repeat domain）是将细胞骨架元素相互连接和连接复合体的细胞连接物的重要结构域之一，但在 5 种棘皮动物中均未发现。同样，BCAR1/CAS 和 PIP5K 等可能参与肌动蛋白细胞骨架调控的基因，在棘皮动物进化过程中发现被积极选择（补充 表 29），这表明在棘皮动物进化过程中细胞骨架功能发生了重大改变。</p></blockquote><h3 id="Hox-clusters-in-ambulacrarians"><a class="header-anchor" href="#Hox-clusters-in-ambulacrarians"></a>Hox clusters in ambulacrarians</h3><blockquote><p>步带类动物的 Hox 基因簇</p></blockquote><p>We next analyzed genes in the Hox cluster, since previous studies implied that echinoderms may have undergone extensive changes to the genomic-arrangement of these genes early in their evolution<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a></sup>, but this is controversial<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a></sup>. By analyzing the echinoderm genomes, together with BAC sequencing and fluorescent in situ hybridization (FISH) experiments on feather star (see Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">13</a>), we found that <em>A. japonica</em> have 10 clustered Hox genes (Hox1 through Hox11/13a), together with two posterior genes (Hox11/13b and Hox11/13c) located with inverse directions more than 360 kb apart from the cluster of 10 Hox genes (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">14</a>). This situation is reminiscent of hemichordate Hox gene clusters, which consist of 12 genes with the inversion/translocation of two posterior genes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a></sup>. The consistent differences of Hox genes in feather star from those of hemichordates (<em>Saccoglossus kowalevskii</em> and <em>Ptychodera flava</em><sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR9">9</a></sup>) were that the two posterior genes have face-to-face orientations, and two additional posterior genes (Hox11/13d and Hox11/13e) are present as reported in other echinoderm genomes<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a></sup>. These characteristics in turn suggest that the last common ancestor of echinoderms retained a canonical arrangement of 10 Hox genes, while its posterior genes had increased in number and changed their locations. This view accordingly indicates that the changes previously noted with the Hox gene clusters of echinoderms<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR7">7</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR8">8</a></sup>, including the loss of Hox4 or Hox6 and the inversion/translocation of anterior genes, are lineage-specific events, and therefore are unlikely to be involved in the establishment of pentameral body plan. On the other hand, the involvement of the posterior Hox genes, are important candidates in the establishment of the pentameral body plan (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1c</a>).</p><blockquote><p>我们接下来分析了Hox 基因簇中的基因，因为之前的研究表明，棘皮动物在进化早期可能经历了大量的基因组排变化，但这是有争议的。通过分析棘皮动物基因组，结合海羽星 BAC 测序和荧光原位杂交（FISH）实验（见补充 图 13），我们发现 <em>A. japonica</em>  有 10 个 Hox 基因簇（Hox1 到 Hox11/13a），以及 2 个在后部的基因（Hox11/13b 和 Hox11/13c），距 10 个 Hox 基因簇的反向位置超过 360 kb（补充图 14）。这种情况让人想起了半索动物的 Hox 基因簇，该基因簇由 12 个基因组成，其中 2 个后部的基因倒位/易位。海羽星与半索动物（<em>Saccoglossus kowalevskii</em> 和 <em>Ptychodera flava</em>）的 Hox 基因的 2 个后部的基因都有相对的方向这个一致差异，另外 2 个后部的基因（Hox11/13d 和 Hox11/13e）在其他棘皮动物基因组中也有报道。 这些特征表明，棘皮动物的最后一个共同祖先保留了 10 个 Hox 基因簇的典型排列，而其后部的基因数量增加并改变了它们的位置。这个观点因此表明之前发现的棘皮动物 Hox 基因簇的变化，包括 Hox4 、Hox6 和前基因的倒位/易位，是特殊的世系事件，因此不太可能参与建立体平面五辐射对称。另一方面，后部的 Hox 基因的参与是建立体平面五辐射对称的重要候选基因（图 1c）。</p></blockquote><h3 id="Echinoderm-embryogenesis-show-hourglass-like-conservation"><a class="header-anchor" href="#Echinoderm-embryogenesis-show-hourglass-like-conservation"></a>Echinoderm embryogenesis show hourglass-like conservation</h3><blockquote><p>棘皮动物胚胎发生呈沙漏状保守</p></blockquote><p>We next tested if evolution of echinoderm embryogenesis follows the developmental hourglass model<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR11">11</a></sup> as supported in several animal groups<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR12">12</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR14">14</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR15">15</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR16">16</a></sup>. The phylotype hypothesis of the hourglass model predicts that anatomical features of most conserved-embryonic phase represent the body plan of their animal phylum<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR11">11</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR17">17</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR18">18</a></sup>. We tested if the developmental stages most critical for the pentameral body plan show the highest transcriptomic conservation. Recent studies reported that the transcriptomic conservation is instead around blastula to gastrula in sea urchins<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR19">19</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR20">20</a></sup>, however, these studies only examined embryonic sea urchins. We thus analyzed gene expression profiles by covering early-to-late embryos of four diverse echinoderm species, including the publicly available data of purple sea urchins<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR21">21</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR22">22</a></sup> and a sea cucumber<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR23">23</a></sup> (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">15</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">16</a>). Unexpectedly, while the hourglass-like conservation was observed, the most conserved phase was not bracketing the pentameral establishing stages (defined as stages when first pentameral symmetric structures appear), but it was instead during gastrulation (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2a</a> and Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">17–18</a>). This mismatch between the most conserved phase and the phase for establishing the body plan was also supported by pair-wise comparisons of one-to-one orthologs (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a>). These results suggested that, unlike in other animal groups such as vertebrates, the phase for establishing the body plan in echinoderms has experienced substantial diversification during their evolution, further implying that the phylotype hypothesis may not fit within echinoderm embryogenesis. However, a potential caveat of this conclusion would be that the conservation signals from adult rudiments could have been obscured by larval tissues, as adult rudiments share only a small proportion of embryo in early metamorphic stages. Similar analyses with dissected adult rudiment, or single-cell RNAseq technology could clarify this point. While possible contribution of pleiotropic constraints were supported between the closely related species as reported previously<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR24">24</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR25">25</a></sup> (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a>), further studies are needed to clarify the evolutionary mechanism behind the unique evolution of echinoderm embryos.</p><blockquote><p>接下来，我们测试了棘皮动物胚胎发生的进化是否遵循已被几个动物群体支持的发育沙漏模型。沙漏模型预测动物体平面特征在解剖学中最保守胚胎期的表现出来。我们测试了对体平面五辐射对称最关键的发育阶段是否表现出最高的转录组保守。</p><p>我们测试了对体平面五辐射对称最关键的发育阶段是否表现出最高的转录组保护。最近的研究报道了海胆转录组保护是围绕囊胚到原肠胚，然而，这些研究只检测了胚胎海胆。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/%E8%83%9A%E8%83%8E%E6%B2%99%E6%BC%8F.png" alt="胚胎沙漏"></p><blockquote><p>图引自 The developmental hourglass model: a predictor of the basic body plan? doi：10.1242/dev.107318</p></blockquote><p>接下来，我们测试了棘皮动物胚胎发生的进化是否遵循几个动物群体支持的发育沙漏模型。沙漏模型的系统类型假设预测了最保守的胚胎期的解剖特征代表了动物门的体平面。我们测试了对五环体计划最关键的发育阶段是否表现出最高的转录组保护。最近的研究报道了海胆转录组保护是围绕囊胚到原肠胚，然而，这些研究只检测了胚胎海胆。为此，我们对4种棘皮动物的早期至晚期胚胎进行了基因表达谱分析，其中包括已公开的紫海胆和海参(附图15和16)。出乎意料的是，虽然观察到沙漏样保守，但最保守的阶段并不是五边形建立阶段(定义为第一个五边形对称结构出现的阶段)，而是在原肠形成期间(图2a和补充图17 18)。这种最保守的相位和建立体平面的相位之间的不匹配也被一对一的正交法的成对比较所支持(补充图19)。这些结果表明，与脊椎动物等其他动物不同，棘皮动物的体平面建立阶段在进化过程中经历了大量的多样化，进一步表明系统型假说可能不适用于棘皮动物胚胎发生。然而，这一结论的一个潜在警告是，来自成体萌芽的保护信号可能被幼虫组织所掩盖，因为成体萌芽只与早期变质阶段的胚胎共享一小部分。用解剖的成体雏形或单细胞RNAseq技术进行类似的分析可以阐明这一点。虽然先前报道的近亲缘物种之间可能存在多向性限制(补充图20和21)，但需要进一步研究来阐明棘皮动物胚胎独特进化背后的进化机制。</p><h3 id="Partial-co-option-in-pentameral-body-plan-establishment"><a class="header-anchor" href="#Partial-co-option-in-pentameral-body-plan-establishment"></a>Partial co-option in pentameral body plan establishment</h3><blockquote><p>局部选配在体平面五辐射对称的建立</p></blockquote><p>Paleontological studies suggested the possible evolution of pentameral body axes through changes in the mechanisms of bilateral symmetry<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR26">26</a></sup> (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2b</a>). However, developmental genes that control the pentameral symmetry remains largely unknown. We thus focused on genes that are involved in Left/Right-patterning and other axis-forming in bilaterians<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR27">27</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR28">28</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR29">29</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR30">30</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR31">31</a></sup> and examined expression patterns of their homologs in the feather star, particularly at the attachment and cystidean stages when the pentameral body plan forms (Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Among the genes examined, <em>pitx</em> exhibited relatively strong expression in the calyx, where the pentameral structure first becomes evident (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2c–d</a>,). Weak expression of <em>chordin</em> was also detected in the calyx (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>). Meanwhile, expression of <em>bmp2/4</em>, <em>nodal</em>, <em>lefty</em> and <em>not</em> were detected most during gastrula to doliolaria stages (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>), but not in the calyx (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">23</a>), implying that these genes are possibly involved in the body patterning during bilateral planktonic development rather than pentameral body plan development. These results suggest that evolution of the pentameral body plan may have associated partial co-option of genes involved in existing body axes, which in part, coincides with paleontological predictions that modification of bilateral patterning system contributed to the pentameral body plan establishment<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR26">26</a></sup>.</p><blockquote><p>古生物学研究表明，五辐射对称可能是通过两侧对称机制的改变而进化的。</p></blockquote><h3 id="Proteome-analyses-of-echinoderm-skeleton"><a class="header-anchor" href="#Proteome-analyses-of-echinoderm-skeleton"></a>Proteome analyses of echinoderm skeleton</h3><p>Mineralized endoskeleton is another notable feature of echinoderms. Despite the widely conserved endoskeleton structures in echinoderms, some of the proteins first identified in sea urchin biomineralization, such as MSP130, have not been identified in the skeleton of other echinoderm species. The MSP130 gene was suggested to have originated in prokaryotes and was introduced into metazoan genomes, including echinoderms, by horizontal gene transfer<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR32">32</a></sup>. An MSP130-like gene involved in biomineralization has also been identified in a polychaete<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR33">33</a></sup>. The authors suggest that the MSP130 gene was present in the common ancestor to bilaterians, rather than being introduced into protostomes and deuterostomes in separate lateral transfer events. The MSP130 protein was then co-opted into skeleton formation at some point in echinoderm evolution. The gene was duplicated in sea urchins and the resulting paralogues acquired repetitive regions<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR32">32</a></sup>. The MSP130 gene is present in other echinoderm genomes, but is not utilized in the proteome of brittle stars<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR34">34</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR35">35</a></sup> or sea stars<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a></sup>. Here, we performed a proteome analysis and identified 280 proteins that are included within the mineral of the adult feather star skeleton (see “Methods”). These skeletal proteins included a protein similar to the urchin MSP130 proteins, suggesting that the ancestral echinoderm had co-opted this single protein into biomineralization (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a>). A number of other genes encoding skeletal proteins and domains conserved between the purple sea urchin (<em>S. purpuratus</em>) and the feather star were also identified (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig3">3</a>). Among these, we found two proteins with C-type lectin domains, which are also found on the urchin spicule matrix proteins. C-type lectin proteins are absent in sea star skeletons<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a></sup>, and present in only a few copies in brittle star skeletons<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR34">34</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR35">35</a></sup>. Sea urchin skeletons utilize a large number of C-type lectins, mostly with repetitive stretches of acidic amino acids<sup><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR37">37</a></sup>, while the feather star and brittle star proteins lack these repetitive domains (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">25</a>). A possible evolutionary scenario to explain these differences is that the ancestral skeletal C-type lectin genes experienced extensive duplication and acquisition of repetitive domains in the sea urchin lineage. The use of C-type lectins in the sea star skeleton was lost, while the C-type lectins in the feather star and brittle star skeletal proteomes remain largely unchanged. Together, these results suggest that the precursors to all of the genes and domains used in echinoderm skeleton were already present in the common ancestor to echinoderms, which emerged 589.7 Mya (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>). Additionally, these skeleton-related genes may have undergone frequent duplication and loss in specific lineages, together with frequent changes in gene expression, since expression of MSP130-like genes and C-type lectin genes in the skeleton forming cells were lost in some lineages, even though these genes exist in their genomes. In summary, our study highlights the genomic, transcriptomic and proteomic changes behind the evolution of unique features in echinoderms, and offers an exceptional case in understanding the general tendency for the evolution of body plans.</p><h2 id="Methods"><a class="header-anchor" href="#Methods"></a>Methods</h2><h3 id="Animal-care-and-use"><a class="header-anchor" href="#Animal-care-and-use"></a>Animal care and use</h3><p>Animal care and experimental procedures and were conducted in strict accordance with guidelines approved by the Animal Experiments Committee of University of Tokyo (approval ID: 14–03, 16–2). All efforts were made to minimize suffering. Individual animals and embryos were selected blindly from wild types.</p><h3 id="DNA-extraction-library-construction-and-genome-sequencing"><a class="header-anchor" href="#DNA-extraction-library-construction-and-genome-sequencing"></a>DNA extraction, library construction, and genome sequencing</h3><p><em>Lytechinus variegatus</em>: Genomic DNA was extracted from sperms from a single male. We first constructed five different short-insert libraries (394, 424, 479, 496, and 522 bp. See also Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>) from the genomic DNA samples and sequenced them using the Illumina HiSeq 4000 system to survey the genome complexity. After obtaining the genome size, we further constructed four mate-pair libraries (2–18 Kb. See also Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>) from the same DNA sample, and sequenced them for further assembly. The DNA and genome we obtained in this project is independent from those available through EchinoBase (<em>Lytechinus variegatus</em> genome v.2.2).</p><p><em>Anneissia japonica</em>: After collecting adult feather stars in the cove of Koajiro, Sagami Bay (Misaki, Japan) by scuba diving, sperms from a single male was collected during the breeding season when the gonads were ripe with mature gametes. Sperms were embedded in ~0.5% low-melting agarose plugs (SeaPlaque GTG Agarose, Lonza), and in-gel digestion of proteins was performed by immersing the plugs in digestion buffer (10 mM Tris-Cl pH 7.5, 50 mM NaCl, 10 mM EDTA, 0.5% SDS, 200 mg/mL Proteinase K) at 55 °C, overnight. The gel-plugs were washed repeatedly with TE buffer and stored in TE at 4 °C until use. DNA was released from the gel-plugs using GELase (Epicenter). The DNA was further purified using QIAGEN Genomic-tip 20/G (QIAGEN) and dissolved in TE. Five different short-insert libraries (277, 324, 381, 450, and 477 bp) were constructed and sequenced with Illumina HiSeq 4000 system to survey the genome complexity. After obtaining the genome size, we further constructed six mate-pair libraries (2–18 Kb) and sequenced them for further assembly (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>).</p><h3 id="K-mer-based-estimation-of-genome-sizes"><a class="header-anchor" href="#K-mer-based-estimation-of-genome-sizes"></a>K-mer-based estimation of genome sizes</h3><p>We first compared the performances in genome size estimation by K-mer frequency method and GenomeScope. The genome size of green sea urchin estimated by GenomeScope was about 650 Mbp, while that of kmerfreq method was about 952 Mbp. Considering that the genome size estimated by kmerfreq was closer to the genome size estimated from <em>C</em>-value (0.92, <a href="http://www.genomesize.com/">www.genomesize.com</a>) than GenomeScope, we decided to apply kmerfreq method for the genome size estimation. Following formula was used for estimating genome size: <em>Genome</em> size (bp) = K-mer number/<em>average</em> depth <em>of K-mer</em>. Based on the rate of occurrence of K-mers in each genome, the read depths for feather star and green sea urchin were estimated as 147 and 124, respectively, leading to genome size estimations of approximately 553 Mb for feather star and 952 Mb for green sea urchin (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>).</p><h3 id="Raw-read-filtering-and-error-correction-of-short-read-libraries"><a class="header-anchor" href="#Raw-read-filtering-and-error-correction-of-short-read-libraries"></a>Raw read filtering and error correction of short-read libraries</h3><p>HiSeq raw reads with the following features were regarded as low-quality reads and were filtered out: [1] Reads containing &gt;10 bp adapter sequences; [2] Reads in the small insert libraries (refer to Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>) having &gt;10 bp overlap; [3] Reads having <em>N</em>’s &gt;10% of their length; [4] PCR duplicates (paired-end reads completely identical); [5] Reads containing &gt;40 bp low-quality (phred quality score ≤ 5) bases. After the filtering process, we further corrected the qualified K-mers. In brief, K-mers with sequencing errors are usually low in frequency, and we thus corrected these K-mer sequences by refering to high-frequent reads. If the erroneous sites could not be corrected, the low-frequency K-mers from the reads were trimmed. No error correction was made for the long-insert libraries (refer to Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>), as these were only used for scaffolding. The SOAPec_bin_v2.03 software was used to correct the error within reads. Command line: SOAPec_bin_v2.03/bin/KmerFreq_AR -q 33 -b 100000000000 -k 17 -p output reads_files_list; SOAPec_bin_v2.03/bin/Corrector_AR -Q 33 -k 17 <a href="http://output.freq.cz">output.freq.cz</a> output.freq.cz.len reads_files_list.</p><h3 id="Gene-set-and-genomes-obtained-from-public-database"><a class="header-anchor" href="#Gene-set-and-genomes-obtained-from-public-database"></a>Gene set and genomes obtained from public database</h3><p>Refer to Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">24</a> for the publicly available gene set and genomes used in this project.</p><h3 id="Genome-assembly"><a class="header-anchor" href="#Genome-assembly"></a>Genome assembly</h3><p>Genome sequences with the filtered and/or corrected data were assembled by Platanus software. The assembly was carried out using the following steps: (a) Contig construction: Reads from short-insert (&lt;1 Kb) libraries were split into K-mers and used to construct a de Bruijn graph. Short branches caused by errors were removed by “tip removal” step and short repeats were resolved by K-mer extension. Bubble structures caused by heterozygosity or errors were removed. At last, subgraphs without any junctions represent the contigs. (b) Scaffold construction: All the filtered clean reads were re-aligned onto the contig sequences, and the scaffolds were constructed by weighting the consistent rate and paired-end reads relationships on the contigs. Heterozygous regions were removed as bubble or branch structures on the graph by the “bubble removal” or “branch cut” step. These simplification steps are characteristic of Platanus and especially effective for assembling complex heterozygous regions. © Gap filling: Paired-end reads have one end mapped on the contig with the other end located in the gap region were used to fill the gaps in the genome assembly by GapCloser1.10 software. Then the very short assembly sequences (contig shorter than 500 bp) were removed in the genome assembly. The detailed command lines of the Platanus assembly were shown as below: Feather star: platanus assemble -o contig.fa -f short_clean_reads.fq -k 69 -u 0.2 -m 200; platanus scaffold -c contig.fa -b contigBubble.fa -o scaffold.fa -IP R1.fq R2.fq -OP R1.fq R2.fq -u 0.2. Green sea urchin: platanus assemble -o contig.fa -f short_clean_reads.fq -k 29 -u 0.3 -m 200; platanus scaffold -c contig.fa -b contigBubble.fa -o scaffold.fa -IP R1.fq R2.fq -OP R1.fq R2.fq -u 0.3. Results by K-mer analysis Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">1</a>, and statististics of feather star and green sea urchin genomes are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">3</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">4</a>.</p><h3 id="Assessment-of-assembled-genomes"><a class="header-anchor" href="#Assessment-of-assembled-genomes"></a>Assessment of assembled genomes</h3><p>The completeness of the feather star and green sea urchin assemblies was assessed by the BUSCO program (version 2.0), using the eukaryotic and metazoan libraries (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">6–8</a>). Reads from the short-inserts libraries were also mapped to these assembled genomes by BWA and SAMtools software (bwa index -a bwtsw genome.fa; bwa aln -t 6 genome.fa reads.fq; samtools view -b -S out.sam &gt; out.bam; samtools flagstat out.bam) to assess the genomic quality (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">9</a>). In addition, coverage ratio of de novo assembled transcripts obtained by Trinity &lt;ver. 2.2.0 &gt; (perl Trinity --JM 200 G --seqType fq --left reads_R1.fq --right reads_R2.fq --SS_lib_type FR -output out) and TGICL software (tgicl -F transcripts.fasta) over the sequenced genomes using BLAT software (blat genome.fa transcript.fa -t = dna -q = rna out.psl) (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">10–13</a>. De novo assembled the transcripts (made by the RNAseq data we obtained for each species) were also aligned to the fileterd genome and confirmed that 98.64% transcripts in feather star and 99.53% transcripts in green sea urchin were aligned.</p><h3 id="GC-content-of-genome"><a class="header-anchor" href="#GC-content-of-genome"></a>GC content of genome</h3><p>GC content of the feather star and green sea urchin genomes were estimated using a sliding window approach. Briefly, a 500 bp sliding window (250 bp stepwise) was employed to scan along the genome and calculate the GC content, and found that the average GC content of feather star and green sea urchin is about 33.22% and 33.71%, respectively. Both of these values were found to be similar with those of hemichordate and most chordate species except lamprey (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">2</a>).</p><h3 id="Repeat-annotation"><a class="header-anchor" href="#Repeat-annotation"></a>Repeat annotation</h3><p>Tandem repeats in the genomes were identified using Tandem Repeat Finder<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR38">38</a> (v4.04 <a href="http://tandem.bu.edu/trf/trf.html">http://tandem.bu.edu/trf/trf.html</a>) with default parameters (trf sequence.txt 2 7 7 80 10 50 2000 -d -h, these number means: Match, Mismatch, Delta, PM, PI, Minscore, and MaxPeriod), and non-interspersed repeats in the genome using RepeatMasker<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR38">38</a> (open-4–0–5) with default parameters (-nolow (Not mask low_complexity DNA or simple repeats) -no_is (Skips bacterial insertion element check) -norna (Does not mask small RNA (pseudo) genes) -parallel 1 (The number of processors to use in parallel)). Transposable elements (TEs) were identified on both the DNA and protein levels. On the DNA level, RepeatModeler (v1.0.4) and RepeatScout<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR39">39</a> (version 1.0.5) was used to build repeat libraries. In feather star, LTR_FINDER<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR40">40</a> (v1.0.5) software were additionally used to build de novo repeat libraries. RepeatMasker was performed on both de novo libraries and repbase (RepBase16.02) separately to identify homologous repeats with default parameters with format set with 2 (-w 2-table). On the protein level, RM-BLASTX within RepeatProteinMask was used to query the TE protein database with -noLowSimple and <em>P</em>-value 0.0001 (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">3</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">14</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">17</a>).</p><h3 id="Prediction-of-protein-coding-genes"><a class="header-anchor" href="#Prediction-of-protein-coding-genes"></a>Prediction of protein-coding genes</h3><p>Prediction of protein-coding genes was based on integration of three different methods, namely, ab initio prediction, homology-based annotation and RNAseq-based annotation. For ab initio prediction, Augustus<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR41">41</a> (v2.5.5, --uniqueGeneId=true [output gene identifyers] --noInFrameStop=true [Do not report transcripts with in-frame stop codons] --gff3=on [output in gff3 format] —strand=both [–strand=forward and --strand=backward]) and GENSCAN<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR42">42</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR43">43</a> (v1.0, -mini_cds 150 -cds_ns 10) software were used to predict genes. In feather star, SNAP<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR44">44</a> (using ** species for gene prediction) and GlimmerHMM<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR45">45</a> (v3.02, using ** species for gene prediction, and -f [Do not make partial gene predictions] -g [Print output in gff format]) softwares were also used in this analysis. These four software programs were trained by using lamprey, human, ciona, and zebrafish, respectively. Short genes (CDS length &lt; 150 bp) and low-quality genes (gaps covered more than 10% of the coding region) were discarded. Proteins from human (Ensembl:GRCh38), mouse (Ensembl: GRCm38), chicken (Ensembl: Gallus_gallus-5.0), green anole lizard (Ensembl: AnoCar2.0), Xenopus tropicalis (Ensembl: JGI_4.2), zebrafish (Ensembl: GRCz10), sea lamprey (Ensembl: Pmarinus_7.0), lancelet (LanceletDB: v18h27.r3_ref), <em>Ciona instestinalis</em> (NCBI: GCA_000224145.1), acorn worm (NCBI: GCF_000003605.2) and purple sea urchin (NCBI: GCF_000002235.4) were used in the homology-based annotation using tblastn with <em>e</em>-value 1e-5. Blast hits that correspond to reference proteins were concatenated by Solar software and low-quality records were filtered out. Sequence of each reference protein was extended to upstream and downstream by 2 Kb to represent the protein-coding region with default parameters. GeneWise software was used to predict gene structure contained in each protein-coding region. For each gene locus, the longest coding region and/or highest genewise score was retained. In RNAseq-based method, the coding sequences defined by transcripts was aligned against the genome by BLAT<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR46">46</a> (v34, identity &gt; 90%, coverage &gt; 90%), thereby defining the splicing orientation of coding region. Then, PASA software was used to link the spliced alignments with default parameters. The EvidenceModeler<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR47">47</a> (EVM, ver. 1.1) software was further used to integrate data derived from the three methods into an EVM-derived gene set with default parameters, the weight of de novo, homolog and complementary DNA (cDNA) are 1, 5, and 10. Finally, 26,838 and 30,238 protein-coding gene models were annotated in feather star and green sea urchin genome, respectively (Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">18</a>).</p><h3 id="Annotation-of-gene-function-non-protein-coding-genes"><a class="header-anchor" href="#Annotation-of-gene-function-non-protein-coding-genes"></a>Annotation of gene function, non-protein-coding genes</h3><p>InterProScan (v4.8) was used to screen these genes’ protein sequences against five databases (including: Pfam, release 27.0, prints, release 42.0, prosite, release 20.97, ProDom, 2006.1, and smart, release 6.2) to determine the InterPro and GO number of those predicted protein-coding genes. In addition, KEGG, COG, NR, Uniprot/SwissProt, and UniProt/TrEMBL databases were searched for homology-based functions (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a>) using blastp (v2.2.26) with <em>e</em>-value (1e-5). For non-coding genes, tRNAscan-SE 53 (v1.3) software for eukaryotes was used for tRNA annotation in the genomic assembly with default parameters. Ribosomal RNA (rRNA) annotation was based on homology information of invertebrate rRNA collections using BLASTN (v2.2.26) with <em>e</em>-value set as 1e-5. The small nuclear RNA (snRNA) and microRNA (miRNA) were predicted by INFERNAL software (v0.81) against the Rfam database (Release 9.1) with default parameters. The statistical results are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>.</p><p>Potential functions of protein-coding genes were predicted using InterProScan<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR48">48</a> (v4.5), against five databases (Pfam, release 27.0, PRINTS, release 42.0, PROSITE, release 20.97, ProDom, 2006.1, and SMART, release 6.2). In addition, KEGG, COG, NR, Uniprot/SwissProt and UniProt/TrEMBL databases were searched for homology-based functions (Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">19</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">20</a>). For non-coding genes, the tRNAscan-SE<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR49">49</a> (v1.3) software for eukaryote was used for tRNA annotation in the genomic assembly. rRNA annotation was based on homology information of invertebrate rRNA collections using BLASTN (v2.2.26) with <em>e</em>-value (1e-5). The snRNA and miRNA were predicted by INFERNAL software (v0.81) against the Rfam database (Release 9.1). The statistical results are shown in Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">21</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">22</a>.</p><h3 id="Gene-family-analysis"><a class="header-anchor" href="#Gene-family-analysis"></a>Gene family analysis</h3><p><em>orthoMCL</em>: orthoMCL<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR50">50</a> was used to find ortholog genes and/or gene families (ortholog groups) among different species. Amphioxus (<em>Branchiostoma floridae</em>), zebrafish (<em>Danio rerio</em>), ciona (<em>Ciona intestinalis</em>), Drosophila (<em>Drosophila melanogaster</em>), chicken (<em>Gallus gallus</em>), acorn worm (<em>Saccoglossus kowalevskii</em>), green sea urchin (<em>Lytechinus variegatus</em> [Lv]), purple sea urchin (<em>Strongylocentrotus purpuratus</em> [Sp]), medaka (<em>Oryzias latipes</em>), mouse (<em>Mus musculus</em>), brittle star (<em>Ophiothrix spiculata</em>), feather star (<em>Anneissia japonica</em> [Anj]), lamprey (<em>Petromyzon marinus</em>), sea cucumber (<em>Apostichopus japonicus</em> [Apj]), sea star (<em>Acanthaster planci</em>), frog (<em>Xenopus laevis</em>), turtle (<em>Pelodiscus sinensis</em>) gene set were prepared and used here. Gene families and ortholog genes identified by this OrthoMCL is shown in Supplementary Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">5</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">6</a>. For ortholog groups identified among echinoderms were 15618 for Lv-Sp-Apj-Anj, 14758 for Lv-Apj-Anj, 15035 for Lv-Sp-Apj, 14231 for Lv-Sp and 13649 for Lv-Anj.</p><p><em>Reciprocal best blast hit (RBBH), 1:1 orthologs</em>: We also analyzed the ortholog genes by RBBH method. We first selected feather star as the reference species, and aligned the protein sequences in all other 16 species to feather star gene set and vice versa by blast. Second, the aligned results were filtered by <em>e</em>-value (1e-5) and retained only the reciprocal best blast hit for each gene-gene pairs. Third, orthologous gene pairs in all of the 16 species were extracted. Finally, we identified 1196 ortholog genes among these 17 species.</p><h3 id="Phylogenetic-tree-construction-and-divergence-time"><a class="header-anchor" href="#Phylogenetic-tree-construction-and-divergence-time"></a>Phylogenetic tree construction and divergence time</h3><p><em>Molecular phylogenetic analysis</em>: 1196 RBBH ortholog genes (1,447,456 aa) in each species were combined into a super-gene in the same gene order, followed by phylogenetic analysis using RaxML<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR51">51</a> (with PROTGAMMAAUTO model, <em>Drosophila melanogaster</em> was used as the outgroup species) through these super-genes (Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig1">1b</a> and Supplementary Table <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">25</a>). Both of the reconstructed phylogenetic trees robustly showed three clusters, including echinoderms, acorm worm, and chordates. Among them, feather star was the earliest diverging species in echinoderms, brittle star and sea star form one branch, sea urchin and sea cucumber form another branch.</p><p><em>Divergence time estimation</em>: To estimate the divergence time, the super-genes prepared above were analyzed by MCMCtree software, together with several calibration points downloaded from TimeTree website (<a href="http://www.timetree.orgs/">http://www.timetree.orgs</a>) (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">7</a>).</p><h3 id="Relative-evolutionary-rates-of-species"><a class="header-anchor" href="#Relative-evolutionary-rates-of-species"></a>Relative evolutionary rates of species</h3><p>To determine the relatively evolutionary rates of echinoderm species, the super-genes, which we produced from 1196 RBBH orthologs were used. LINTRE software and RRT (Tajima’s relative rate test) analysis were employed, and <em>Drosophila</em> was used as an outgroup to determine the root of the whole tree (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">8</a> and Supplementary Tables <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">26</a>–<a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">28</a>. In addition to the LINTRE analysis, R-package “APE” was also used to deduce robust conclusion (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">9</a>).</p><h3 id="Expansion-and-contraction-of-gene-families"><a class="header-anchor" href="#Expansion-and-contraction-of-gene-families"></a>Expansion and contraction of gene families</h3><p>To identify expanded and contracted gene families in the common ancestor of echinoderms, the gene family result generated from OrthoMCL were used and analyzed by CAFE software (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">11</a>). Profiles of GO terms, protein domains and KEGG pathways of these expanded and contracted genes are shown in Extended data 1 (Extended_data1.xlsx).</p><h3 id="Domains-lost-in-echinoderms"><a class="header-anchor" href="#Domains-lost-in-echinoderms"></a>Domains lost in echinoderms</h3><p>Domains found in any of the chordate species, but not found in any of the the echinoderm species were defined as domains lost in echinoderm lineage. Six echinoderm species (<em>Apostichopus japonicus</em>, <em>Lytechinus variegatus</em>, <em>Acanthaster planci</em>, <em>Ophiothrix spiculata</em>, <em>Anneissia japonica</em>, and <em>Strongylocentrotus purpuratus</em>) and nine chordate species (<em>Mus musculus</em>, <em>Branchiostoma floridae</em>, <em>Ciona intestinalis</em>, <em>Petromyzon marinus</em>, <em>Oryzias latipes</em>, <em>Gallus gallus</em>, <em>Xenopus laevis</em>, <em>Pelodiscus sinensis</em>, and <em>Danio rerio</em>) were blasted (&gt;50% identity and &gt;30% align ratio) to the acorn worm (<em>Saccoglossus kowalevskii</em>) protein gene set and searched for potential domains lost in echinoderms. Seven-hundred forty-seven genes were identified to be the lost genes in echinoderms. Among these genes, six genes were not found in any of the nine chordate species, but found in acorn worm. These genes were enriched with GO terms of biosynthetic process, metabolism process, and the establishment of localization.</p><h3 id="Hox-cluster-analysis"><a class="header-anchor" href="#Hox-cluster-analysis"></a>Hox cluster analysis</h3><p><em>Cloning of Hox genes</em>: To further confirm sequences of Hox genes in the feather star, a total of nine hox genes had been cloned from <em>Anneissia japonica</em> using RT-PCR (Tsurugaya et al., in preparation).</p><p><em>Preparation of A. japonica BAC library</em>: We constructed BAC library, using genomic DNA prepared from the male gonadal pinnules that contained testes. The DNA was partially digested with the restriction enzyme MboI, size-fractionated, and cloned into the vector pCCBAC1(EPICENTER). The bacterial strain DH10B T1 phage resistant (Invitrogen) was used for transfecting the BACs for constructing the library. Single clones were picked into 384-well plates and preserved. Two batches of libraries were produced, which were named Oj1 (average insert size ~100 kb, 35,712 clones) and Oj2 (average insert size ~78 kb, 45,977 clones).</p><p><em>Screening and cloning of BAC clones containing hox genes</em>: Using the cDNA fragments of nine hox genes (hox1, hox2, hox4, hox5, hox7, hox8, hox9/10, hox11/13a, and hox11/13c. Tsurugaya et al., in preparation), we screened the BAC library of <em>A. japonica</em> for the clones that contained Hox genes and their neighboring regions. This screening yielded 23 clones in total, which, however, were not contiguous but separated into four groups.</p><p><em>FISH analysis</em>: Probes for FISH were derived from clones out of the <em>A. japonica</em> BAC library. BAC clones used for FISH were Oj1–26E10 (containing hox1), Oj2–17D15 (hox2), Oj2–75D03 (hox4 and hox5), Oj2–78N14 (hox7 and hox8), Oj1–50I03 (hox8 and hox9/10), and Oj2–102A05 (hox11/13c). BAC clone DNAs were isolated using Qiagen Plasmid Midi Kit (Qiagen) and labeled with biotin or digoxigenin by using Nick Translation Kit (Roche). Hybridization mix was prepared as described previously (3). Two color-chromosomal FISH was carried out as described previously (1, 2) with the following modifications. Blastula or early gastrula stage embryos were treated with 0.08% colchicine (Sigma) in sea water for 30 min. Embryos were fixed in methanol glacial acetic acid (3:1) fixative at 4 °C overnight, then transferred to 100% ethanol, and stored at –20 °C. To prepare metaphase spreads, 80 µL of 60% acetic acid was added to a microfuge tube containing 50–100 embryos. Three minutes later, embryos were dropped onto a prewarmed (48 °C) slide glass, and left until dry (about 30 min). Before hybridization, the slides were treated with 0.5% pepsin (1:100, Wako) in 0.01 N HCl for 3 min, and washed in phosphate-buffered saline (PBS) three times. Then the slides were post-fixed in 1% paraformaldehyde in PBS at r.t. for 30 min, and washed in PBS twice. After dehydration, the air-dried slides were treated with acetone at r.t. for 10 min, and dried again. Following the denaturation of chromosomal DNA and dehydration, hybridization was carried out at 43 °C for 16 h. FISH images were taken using an Olympus BX60 microscope equipped with an Olympus DP70 camera.</p><p><em>Identification of clustered Hox genes</em>: In scaffold 288292 (about 1.86 Mbp in length), hox1, hox2, hox3, hox4, hox5, hox6, hox7, hox8, hox9/10, and hox11/13a were identified. The ten Hox genes were aligned in the order, spanning about 480 kb in length, with the 3ʹend of hox1 about 392 kb away from the end of the scaffold. In scaffold 287987 (about 96 kb), hox11/13b and hox11/13c were identified. To see whether the 12 Hox genes form a single cluster, we carried out two color-chromosomal FISH, using the BAC clones (described above) as probes. The FISH analysis revealed that the eight genes contained in the BAC clones were in close vicinity to one another on a single chromosome (comprising of two sister chromatids). However, the gene order or relative positions of the two scaffolds on the chromosome could not be clarified, leaving four possible gene orders of 12 Hox genes undetermined. Thus, it is suggested that 12 Hox genes are present on a single chromosome, forming two subclusters separated by at least 400 kb in the genome of <em>Anneissia japonica</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a>, hox11/13d and hox11/13e, in another scaffolds 2266 and 6788, respectively. This suggests that the two genes are localized apart from the subcluster of ten Hox genes, which situation is consistent with the previous report showing that Hox11/13d and Hox11/13e do not reside in the Hox gene cluster in echinoderm genomes<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR10">10</a>.</p><h3 id="Embryo-collection-and-RNA-extraction"><a class="header-anchor" href="#Embryo-collection-and-RNA-extraction"></a>Embryo collection and RNA extraction</h3><p><em>Lytechinus variegatus</em>: Adult green sea urchins were originally obtained from Reeftopia in Florida (FL) or from the Duke Marine lab in Beaufort NC. <em>L. variegatus</em> total RNA was prepared from wild type embryos per timepoint using TRIzol (Invitrogen) and DNase treatment. RNA quantitation and integrity were determined using a Qubit® 2.0 Fluorometer (Life Technologies) and a 2100 Bioanalyzer (Agilent Technologies). Total RNA was subjected to three iterations of polyA selection using Dynabeads (Life Technologies) prior to cDNA synthesis. Following stages were collected for RNA extraction and fixation; 2 cell (1 h post fertilization), 60 cell (2.5 hpf), EB (Early Blastula, 4 hpf), HB (Hatched Blastula, 7 hpf), TVP (Thickened Vegetal Plate, 10 hpf), MB (Mesenchyme Blastula, 12 hpf), EG (Early Gastrula, 13 hpf), MG (Mid Gastrula, 15 hpf), LG (Late Gastrula,18 hpf), EP (Early Pluteus, 36 hpf), LP (Late Pluteus, 48 hpf), 7 wpf (7 weeks post fertilization), 8 wpf (8 weeks post fertilization), 1 day post metamorphosis, 1 week post metamorphosis, and adult. In addition, RNA from larval region of 8 weeks post fertilization (8 wpf Larva), and rudiment region of 8 weeks post fertilization (8 wpf Rudiment) were also extracted by dissecting the 8 wpf embryo. Results based on analyses with RNAseq data from two cell to Late pluteus were published<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR52">52</a>. Two independent biological samples were prepared for all the sampled stages.</p><p><em>Apostichopus japonicus</em>: Embryos of fertilized eggs, 4 cell (2 h post fertilization (hpf)), morula (6 hpf), blastula (14 hpf), gastrula (29 hpf), late gastrula (34 hpf), early auricularia larva (48 hpf), mid-auricularia larva (69 hpf), late auricularia larva (15 days post fertilization (dpf)), metamorphosis 1–4 (17–19 dpf), doliolaria larva (19 dpf), pentactula larva (27 dpf), and juvenile (51 dpf) stage were collected and used for this study, as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR23">23</a>. Three independent biological samples were prepared for all the sampled stages.</p><p><em>Anneissia japonica</em>: Adult <em>Anneissia japonica</em> (previously called as <em>Oxycomanthus japonicus</em>, see Summers et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR53">53</a> for the nomenclature) were collected from rocky substrate of about 10 m depth at Koajiro, Sagami Bay, and kept in the sea until the day of spawning. Spawning check was carried out at every neap tide days during October and November, 2015. Spawning was observed in the evening of 20th and 21st of October, 2015, and seven females spawned in total. The obtained eggs were very fragile and surrounded by mucus. Small amounts of the spawned unfertilized eggs were separated in 1.5 mL tubes (100 μL each) for RNA extraction and fixation. The rest of the eggs were inseminated immediately by diluting concentrated sperm, which were directly collected from genital pinnules. The fertilized eggs were washed with filtered sea water several times to remove the mucous, and separated in the filtered sea water in plastic vessels for culture. The culture was done at room temperature (about 10–20 °C). Following stages were collected for RNA extraction and fixation (Supplementary Fig. <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM1">15</a>); 2 cells (1.5 h post fertilization), 8 cells (2.5 hpf), 32 cells (3.5 hpf), gastrula (8 hpf), hatching stage (17 hpf), early doliolaria (24 hpf), mid-late doliolaria (36 hpf), attachment stage (3–4 days pf), early cystidean (4–7 days pf), late cystidean (7–9 days pf), early pentacrinoid (3 weeks pf), late pentacrinoid (1.5 months pf), juvenile (2.5 months pf), arm branching stage (6–7 months pf), and adult (9 months pf). For the RNA extraction, more than 50 μL of specimens were diluted in the 10x volume of TRIzol reagent (Invitrogen). The tissue of the specimens were destructed by pipetting with a micro syringe or grinding with a pestle and mortar in the TRIzol reagent, and immediately stored in –80 °C. For the fixation, specimens were fixed with 4% paraformaldehyde in 0.5 M NaCl and 0.1 M 3-(N-morpholino) propanesulfonic acid (MOPS), pH 7.0 for several days at room temperature (about 22 °C). Fixed specimens were washed with 70% ethanol three times, and stored in 70% ethanol at –20 °C. Two independent biological samples were prepared for all the sampled stages.</p><h3 id="RNA-sequencing-and-gene-expression-data"><a class="header-anchor" href="#RNA-sequencing-and-gene-expression-data"></a>RNA sequencing and gene expression data</h3><p>After adjusting total RNA amounts between samples, non-stranded sequencing libraries (with the TruSeq protocol) were constructed and sequenced using the Illumina HiSeq 4000 platform. For the sea cucumber (<em>A. japonicus</em>) samples, Quartz-seq amplified libraries were made as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. Qualities of raw reads were evaluated using FastQC program (<a href="http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/">http://www.bioinformatics.bbsrc.ac.uk/projects/fastqc/</a>). Read length and single/paired information are as follows; <em>L. variegatus</em> (100 bp, paired-end), <em>A. japonica</em> (150 bp, paired-end), <em>A. japonicus</em> (100 bp, single-end). Adapter sequences of Quartz-Seq samples (Mm early stages 2-cell-blastocyst) were removed using the fastq-mcf program (<a href="https://code.google.com/p/ea-utils/wiki/FastqMcf">https://code.google.com/p/ea-utils/wiki/FastqMcf</a>) as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. RNAseq data were then mapped to genomes of each species using HISAT2 program<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR54">54</a> (ver. 2.05), and calculated relative expression levels by StringTie<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR55">55</a> (ver. 1.3.5) with species-specific GTF files.</p><p><em>Apostichopus japonicus</em>: For the gene expression levels of Japanese sea cucmber, genome and GTF files reported by Zhang et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR56">56</a> were used.</p><p><em>Strongylocentrotus purpuratus</em>: Developmental transcriptomes of the purple sea urchin was obtained from SRA (Accession: PRJNA81157), sequenced by Tu et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR21">21</a>,<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR22">22</a>. The dataset contained developmental stages of 0 hpf, 10 hpf, 18 hpf, 24 hpf, 30 hpf, 40 hpf, 48 hpf, 56 hpf, 64 hpf, 72 hpf, four arm larva, vestibular invagi, pentagonal disc, tube foot protrusion, post metamorphosis, young juvenile, adult.</p><h3 id="Identification-of-conserved-stages"><a class="header-anchor" href="#Identification-of-conserved-stages"></a>Identification of conserved stages</h3><p>Whole embryonic, comparative transcriptomic analysis was performed as previously described to find evolutionarily conserved developmental stages<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>. Relative expression levels (TPM) of ortholog groups (defined by orthomcl<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR57">57</a>) were calculated from the RNAseq data, and then compared their dissimilarities (expDists) among developmental stages of different species. In calculating dissimilarity (1 – Spearman) of ortholog-group-based whole-embryonic transcriptomes (expDists), phylogenetic relationship [Anj(Apj(Sp,Lv))] were taken into consideration to avoid unwanted bias arising from simple pair-wise comparisons<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR58">58</a>. By randomly picking-up one biological replicate sample for each developmental stage (in each species), 100 expression tables (100 biological replicate included expression table, or BRI-exp data) were created (method reported in Hu et al.<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR13">13</a>). We used this 100 BRI table to test statistical significance of changes in Ptop scores (Friedman test).</p><h3 id="Whole-mount-in-situ-hybridization"><a class="header-anchor" href="#Whole-mount-in-situ-hybridization"></a>Whole-mount in situ hybridization</h3><p>Digoxigenin (Dig) labeled riboprobe for <em>pitx</em> gene of <em>A. japonica</em> was prepared from PCR-amplified fragments (911 bp) using following primiers: 5ʹ-GAACGATTCGCTTCCGATGC-3ʹ (forward primer), 5ʹ-TGAGACCGGCGTATTGACAC-3ʹ (reverse primer). Whole-mount in situ hybridization (WISH) was conducted following the protocol for the planktonic larvae of a stalked crinoid <em>Metacrinus rotundus</em><a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR59">59</a> with some modifications. Specimens were fixed with 4% paraformaldehyde (PFA) in 0.5 M NaCl and 0.1 M 3-(N-morpholino) propanesulfonic acid (MOPS), pH 7.0 for over 1 day, and stored at –20 °C in 70% ethanol. The fixed specimens were washed three times with PBST (1× phosphate-buffered saline with 0.1% Tween 20), treated with 0.2 µg/mL proteinase K in PBST at 37 °C for 20 min, re-fixed with 4% PFA at 4 °C for 30 min, washed three times with PBST, and then incubated in hybridization buffer (50% formamide, 5× SSC, 100 µg/mL yeast RNA, 50 µg/mL heparin, 1% Tween 20) at 55 °C for 4–6 h. Hybridization was carried out with 0.2 µg/mL probes in the hybridization buffer at 55 °C for 5 days. The protocol after hybridization was as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR59">59</a>. WISH finished samples were observed and photographed under the BX-51 optical microscope (Olympus).</p><h3 id="Proteomic-analysis"><a class="header-anchor" href="#Proteomic-analysis"></a>Proteomic analysis</h3><p>Proteins were isolated from adult feather skeleton and analyzed as previously described<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR36">36</a>. All organic material was removed from the skeleton by extensive washing with sodium hypochlorite followed by guanidine isothiocyanate. The skeleton was demineralized with acetic acid followed by dialysis. Both soluble and insoluble protein fractions were analyzed. Proteins were separated by sodium dodecyl sulfate–polyacrylamide gel electrophoresis. Each lane was excised into 20 equal sized segments and processed. In-gel digestion with trypsin was performed on each fraction, followed by analysis by nano Liquid chromatography–mass spectrometry (LC-MS/MS) with a Waters nanoAcquity high-performance liquid chromatography system interfaced to a ThermoFisher Q Exactive hybrid quadrupole-orbitrap mass spectrometer. The mass spectrometer was operated in a data-dependent mode. Data were used to search predicted peptides from the <em>A. japonica</em> genome using Mascot and then parsed into the Scaffold algorithm for validation and filtering, using a 95% protein identification score with at least two peptides per protein.</p><h3 id="Statistics-and-reproducibility"><a class="header-anchor" href="#Statistics-and-reproducibility"></a>Statistics and reproducibility</h3><p>Alpha levels of 0.05 were regarded as statistically significant throughout the study, unless otherwise specified. Experiments were repeated multiple times to confirm the reproducibility of the data. See details for individual experiments in the “Methods” sections above.</p><h3 id="Reporting-summary"><a class="header-anchor" href="#Reporting-summary"></a>Reporting summary</h3><p>Further information on research design is available in the <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM5">Nature Research Reporting Summary</a> linked to this article.</p><h2 id="Data-availability"><a class="header-anchor" href="#Data-availability"></a>Data availability</h2><p>Genomic sequence data and assembled genomes for the following species are available through the NCBI database at the indicated BioProject accession IDs: Brittle star genome (PRJNA182997), feather star genome (PRJNA553656), and green sea urchin genome (PRJNA553643). RNAseq data are available for the following species at the indicated BioProject accession IDs: green sea urchin RNAseq data (PRJNA554218), feather star RNAseq data (PRJNA553591), and Japanese sea cucumber RNAseq data (PRJNA553613). Cloned sequences of Hox genes of the feather star (hox1 LC462021, hox2 LC462022, hox4 LC462023, hox5 LC462024, hox7 LC462025, hox8 LC462026, hox9/10 LC462027, hox11/13a LC462028, hox11/13c LC462029) are also available through the NCBI database at the indicated nucleotide accession IDs. Assembled genomes and gene sets can also be accessed through the DRYAD database<a href="https://www.nature.com/articles/s42003-020-1091-1#ref-CR60">60</a> at <a href="https://hub.pubmedplus.com/10.5061/dryad.rbnzs7h7n">https://doi.org/10.5061/dryad.rbnzs7h7n</a>. Proteomic data are available via the ProteomeXchange with identifier PXD019526. Source data for Figs. <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig2">2a</a> and <a href="https://www.nature.com/articles/s42003-020-1091-1#Fig3">3b</a> can be found in Supplementary Data <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM3">1</a> and Supplementary Data <a href="https://www.nature.com/articles/s42003-020-1091-1#MOESM4">2</a>.</p><h2 id="Code-availability"><a class="header-anchor" href="#Code-availability"></a>Code availability</h2><p>No custom or proprietary software was used in the analysis. Versions and parameters for each software package used are described in the reporting summary and elsewhere in the “Methods.”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://www.nature.com/articles/s42003-020-1091-1#MOESM1&quot;&gt;Genomic insights of body plan transitions from bilat</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程</title>
    <link href="https://halo123.top/2021/05/31/Java/Java-J-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://halo123.top/2021/05/31/Java/Java-J-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-31T08:16:54.000Z</published>
    <updated>2021-06-01T06:17:14.669Z</updated>
    
    <content type="html"><![CDATA[<p>参考：《Java 多线程与 Socket 实战微服务框架》</p><h2 id="多线程的概念"><a class="header-anchor" href="#多线程的概念"></a>多线程的概念</h2><h3 id="进程与线程"><a class="header-anchor" href="#进程与线程"></a>进程与线程</h3><p>现在的操作系统都是多任务操作系统。多任务操作系统允许多个进程在同一个 CPU 上运行。进程也是操作系统进行资源分配的最小单位，每个进程都有独立的代码和数据空间，称为<font color="#ea66a6">进程的上下文</font>。CPU 从一个进程切换到另一个进程所做的动作被称为<font color="#ea66a6">上下文切换</font>。操作系统通过频繁的上下文切换来让这些进程看起来像在同时运行一样。</p><p>进程的运行需要较多的资源，因此，操作系统能够同时运行的进程数量是有限的。进程间的切换和通信也存在较大的开销。为了能并行执行更多的任务，提升系统的效率，才引入了线程的概念。线程间的切换开销比进程间的切换开销小得多。</p><p>线程是 CPU 调度的最小单位，它是进程的一部分，只能由进程创建。一个可以进程拥有多个线程，这线线程共享进程的资源和程序代码。也就是说，一个 Java 进程（JVM 进程）至少有一个线程（称为主线程），对应到代码中就是 <code>main</code> 方法所在的线程。通过主线程就可以创建更多线程。此外，线程又分为用户线程和守护线程。两者的区别在于，后者会随主线程结束而结束。一旦所有的用户线程都结束，程序就会停止，所有守护线程也随之终止。</p><p>受操作系统的限制，每个操作系统用户能够同时运行的进程数是有限的，每个进程能够开启的线程数也有上限。在同一个 CPU 核心上，多线程以抢占或主动让出时间片的形式轮流执行。基于同一段代码可以创建多个线程，这些线程共享进程的数据空间，但每个线程有独立的运行栈和程序计数器。</p><h3 id="并发与并行"><a class="header-anchor" href="#并发与并行"></a>并发与并行</h3><p>并发与并行是一个相对资源的概念。</p><ul><li><font color="#ad1a72">并发</font>是指两个或多个事件在同一时间间隔内发生。</li><li><font color="#ad1a72">并行性</font>是指系统具有同时进行运算或操作的特性，在同一时刻能完成两种或两种以上的工作。</li></ul><p>如果我们在同一时间，在多台计算机上同时运行多个任务，这些任务就是在“并行”地执行。同理，如果一台计算机拥有多个 CPU ，这些 CPU 分别在执行多个运算任务，尽管这个计算机的其他资源，比如内存，是多个任务所共享的，但相对 CPU 这一资源来说，这些任务是“并行”的，这被称为“多 CPU 并行”。如果一个 CPU 拥有多个核心，并允许多个线程在不同的核心上同时执行，则称为“多核并行”。</p><p>与之相对应的是，在同一个资源上，通过某些调度算法，让用户看起来计算机是在同时执行多个任务，这就是并发。比如，在单个 CPU 上，通过一定的调度算法，“同时”执行多个任务，让这些任务看起来在一个时间段是“并行”执行的。即使在同一时刻，CPU 也只能执行这些计算任务中的一个。</p><h3 id="线程状态"><a class="header-anchor" href="#线程状态"></a>线程状态</h3><p>线程和进程一样拥有 7 种状态：新建（NEW）、就绪（RUNNABLE 或 READY）、运行（RUNNING）、阻塞（BLOCKED）、等待（WAITING）、计时等待（TIME_WAITING）、终止（TERMINATED 或 DEAD）。线程在存续过程中，其状态会在这 7 种状态之间转换。</p><blockquote><p>Java 5 以前，等待和计时等待也被归于阻塞状态，所以也有 5 种状态的说法。</p></blockquote><ul><li>新建（NEW）：线程被新创建时的状态。</li><li>就绪（RUNNABLE 或 READY）：线程正在参与竞争 CPU 的使用权</li><li>运行（RUNNING）：线程获取到了 CPU 的使用权，正在执行。</li><li>阻塞（BLOCKED）：阻塞状态指的是线程为了等待某个对象的“锁”，而暂时放弃 CPU 的使用权，且不再参与 CPU 使用权的竞争。直到条件满足（超时退出、被中断或唤醒）时，该线程才重新回到就绪状态，重新参与竞争 CPU。</li><li>等待（WAITING）：线程无线等待某个对象的“锁”，或等待另一个线程结束的状态。</li><li>计时等待（TIME_WAITING）：线程在一段时间内等待某个对象的“锁”，或者主动休眠，亦或者等待另一个线程结束。除非被中断，否则时间一到，（超时）线程将会自动回到就绪态。被中断的方法通常会抛出中断异常（InterruptedException），超时的方法会抛出超时异常（TimeoutException）。</li><li>终止（TERMINATED 或 DEAD）：遇到以下情况，线程将终止。线程所运行的代码段被执行完毕，或执行过程中出现异常，亦或者受到外界干预而中断执行。</li></ul><h2 id="Tread-线程类"><a class="header-anchor" href="#Tread-线程类"></a>Tread 线程类</h2><h3 id="基本用法"><a class="header-anchor" href="#基本用法"></a>基本用法</h3><p>通过继承 Tread 类，覆盖其 <code>run()</code> 方法即可编写一个线程类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; , &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：调用 <code>start()</code> 方法后，<code>run()</code> 方法中的代码并不一定立即开始执行。 <code>start()</code> 方法只是将线程变为可就绪状态，什么时候运行是由操作系统决定的。</p></blockquote><h3 id="常用方法介绍"><a class="header-anchor" href="#常用方法介绍"></a>常用方法介绍</h3><p>Thread 类中常用的实例方法</p><ul><li><code>t.start()</code>：启动线程 t 的状态从新建转换为就绪</li><li><code>t.checkAccess()</code>：检查当前线程是否有权限访问线程 t</li><li><code>t.interrupt()</code>：尝试通知线程 t 中断，需要在线程的任务代码中使用</li><li><code>t.isInterrupted()</code>：用于检查是否要求中断。当此方法返回 true 时，当前线程应判断是否要中断执行，如果此时不中断执行，再次调用此方法将返回 false。</li><li><code>t.setPriority()</code>：设置线程 t 的优先级（1 ~ 10），值越大，得到执行的将会越高</li><li><code>t.isDaemon()</code>：判断线程 t 是否为守护线程</li><li><code>t.setDaemon(true)</code>：仅用于在调用 <code>start()</code> 前设置线程 t 为守护线程</li><li><code>t.isAlive()</code>：判断线程 t 是否存活</li><li><code>t.join(1000L)</code>：当前线程等待线程 t 终止。参数为超时时间。</li><li><code>t.setName(&quot;Thread1&quot;)</code>：为线程设置一个名称</li></ul><p>Thread 类中常用的静态方法</p><ul><li><code>Thread.yield()</code>：让当前线程让出 CPU，并转为就绪状态，重新参与 CPU 使用权的竞争。只有优先级大于等于当前进程的线程才可能获得 CPU 使用权。</li><li><code>Thread.sleep(100L)</code>：让当前线程让出 CPU，睡眠（阻塞）100 毫秒，然后回到就绪状态，重新参与 CPU 使用权的竞争。</li><li><code>Thread.currentThread()</code>：得到当前线程对象的引用。</li></ul><h3 id="wait-和-sleep-的区别"><a class="header-anchor" href="#wait-和-sleep-的区别"></a><code>wait</code> 和 <code>sleep</code> 的区别</h3><p><code>wait()</code> 方法时所有 Object 类的方法，是线程同步的重要手段之一。虽然两者都可以让程序阻塞指定的毫秒数，并且都可以通过 <code>interrupt()</code> 方法打断，但两者有很大的不同：</p><ul><li><code>wait()</code> 方法必须在 <code>synchronized</code> 同步块或方法中使用；</li><li><code>wait()</code> 方法会释放由 <code>synchronized</code> 锁上的对象锁，而 <code>sleep()</code> 则不会</li><li>由 <code>wait()</code> 方法形成的阻塞，可以通过针对同一对象锁的 <code>synchronized</code> 作用域用 <code>notify()</code> 或 <code>notifyAll()</code> 来唤醒，而 <code>sleep()</code> 则无法被唤醒，只能定时醒来或被 <code>interrupt()</code> 方法中断。</li></ul><h3 id="sleep-和-yield-的区别"><a class="header-anchor" href="#sleep-和-yield-的区别"></a><code>sleep</code> 和 <code>yield</code> 的区别</h3><p>区别如下：</p><ul><li>线程执行 <code>sleep()</code> 方法后转入阻塞态，并在睡眠一段时间后自动醒来，回到就绪态。而执行 <code>yield()</code> 方法后，当前线程转入的是就绪态。</li><li>当前线程执行 <code>sleep()</code> 方法后，其他线程无论优先级高低，都有机会得以运行；而执行 <code>yield()</code> 方法只会给那些具有相同或更高优先级的线程运行的机会。</li><li><code>sleep()</code> 方法需要声明抛出 <code>InterruptedException</code>，而 <code>yield()</code> 方法没有声明任何异常。</li><li><code>sleep()</code> 方法比 <code>yield()</code> 方法具有更好的可移植性（与操作系统的 CPU 调度有关）。如果在循环中使用 <code>yield()</code> 方法，则在 Linux 上容易导致“死循环”——当前线程在 <code>yield()</code> 后总是又立即抢占到 CPU，导致其他线程得不到执行。</li></ul><h2 id="Runnable-接口"><a class="header-anchor" href="#Runnable-接口"></a>Runnable 接口</h2><p>处理继承 Thread 类外，还可以通过实现 Runnable 接口来编写线程代码。实践经验告诉我们，尽量使用接口而不是继承来进行开发。使用 Runnable 接口可以将线程对象本身与线程所要执行的代码分离，同时避免 Java 的单继承限制。而且线程池也只能接受 Runnable 或 Callable 接口类型的对象作为任务。因此，建议使用 Runnable 或 Callable 接口的形式开发多线程。</p><p>下面是 Runnable 接口使用的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程处于阻塞状态时，中断线程，就会抛出异常。&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> InterruptThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a class="header-anchor" href="#线程池"></a>线程池</h2><p>线程的创建和销毁会消耗资源。在大量并发的情况下，频繁地创建和销毁线程会严重影响系统的性能。因此，通常需要预先创建多个线程，并集中管理起来，形成一个线程池。在需要用到线程时，从线程池中拿出一个线程直接使用，执行完毕时再放回线程池。</p><h3 id="Executors"><a class="header-anchor" href="#Executors"></a>Executors</h3><p>从 Java 5 开始，可以使用 <code>java.util.concurrent.Executors</code> 类来创建线程池：</p><p>（1）创建固定大小的线程池 <code>Executors.newFixedThreadPool(20)</code></p><p>上面的代码创建了一个有着 20 个线程的固定大小线程池。又新任务时，如果池中没有空闲池可用，就加入队列等待。队列大小的上限是 <code>Integer.MAX_VALUE</code>。其优点时避免了线程创建和销毁的开销；缺点是池大小的配置容易过高或过低。无论过高或过低都会影响性能。如果希望自定义队列大小，则使用 <a href="#ThreadPoolExecutor">ThreadPoolExecutor</a></p><p>（2）创建可变大小的线程池 <code>Executors.newCachedThreadPool()</code></p><p>上面代码创建了一个可缓存空闲线程 60 秒的线程池。有新任务时，如果池中没有空闲线程可用，则创建一个新线程并添加到池中，池的大小上限是 <code>Integer.MAX_VALUE</code>。超过 60 秒未被使用的线程将被销毁。其优点是能按需创建线程，并尽可能地回收或复用它们。该方法适用于执行生存期较短的任务。其缺点是池大小的上限太大，“洪峰”来临时容易在短期内创建并持有大量线程。如果希望自定义大小和线程的最大空闲时长，则使用 <a href="#ThreadPoolExecutor">ThreadPoolExecutor</a></p><p>（3）创建一个只有一个线程的线程池 <code>Executors.newSingleThreadExecutor()</code></p><p>该方法等同于 <code>Executors.newFixedThreadPool(1)</code></p><p>（4）创建一个支持定时或周期性任务执行的线程池 <code>Executors.newScheduledThreadPool(2)</code></p><h3 id="ExecutorsService"><a class="header-anchor" href="#ExecutorsService"></a>ExecutorsService</h3><p>通过 Executors 创建的线程池都实现了 ExecutorsService 接口，调用它的 <code>execute</code> 或 <code>submit</code> 方法即可向线程池提交任务。下面介绍了 ExecutorsService 接口的主要方法。</p><ul><li><code>shutdown()</code>：异步关闭线程池。调用后将不再向线程池提交新任务，但允许继续执行已提交到线程池的任务。调用后立即返回，不会阻塞当前线程。</li><li><code>shutdownNow()</code>：立即异步关闭线程池</li></ul><h3 id="ThreadPoolExecutor"><a class="header-anchor" href="#ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><h3 id="基本用法-v2"><a class="header-anchor" href="#基本用法-v2"></a>基本用法</h3><h2 id="Callable-与-Future"><a class="header-anchor" href="#Callable-与-Future"></a>Callable 与 Future</h2><h2 id="线程安全与效率"><a class="header-anchor" href="#线程安全与效率"></a>线程安全与效率</h2><h3 id="什么是线程安全"><a class="header-anchor" href="#什么是线程安全"></a>什么是线程安全</h3><h3 id="线程同步"><a class="header-anchor" href="#线程同步"></a>线程同步</h3><h3 id="饥饿与公平"><a class="header-anchor" href="#饥饿与公平"></a>饥饿与公平</h3><h3 id="锁与死锁"><a class="header-anchor" href="#锁与死锁"></a>锁与死锁</h3><h3 id="线程中断"><a class="header-anchor" href="#线程中断"></a>线程中断</h3><h2 id="volatile-关键字"><a class="header-anchor" href="#volatile-关键字"></a>volatile 关键字</h2><h2 id="synchronized-关键字"><a class="header-anchor" href="#synchronized-关键字"></a>synchronized 关键字</h2><h2 id="wait-notify-notifyAll"><a class="header-anchor" href="#wait-notify-notifyAll"></a>wait notify notifyAll</h2><h2 id="CAS-操作"><a class="header-anchor" href="#CAS-操作"></a>CAS 操作</h2><h2 id="atomic-包"><a class="header-anchor" href="#atomic-包"></a>atomic 包</h2><h2 id="Lock-自旋锁"><a class="header-anchor" href="#Lock-自旋锁"></a>Lock 自旋锁</h2><h2 id="Condition-条件变量"><a class="header-anchor" href="#Condition-条件变量"></a>Condition 条件变量</h2><h2 id="线程安全容器"><a class="header-anchor" href="#线程安全容器"></a>线程安全容器</h2><h2 id="ThreadLocal-类"><a class="header-anchor" href="#ThreadLocal-类"></a>ThreadLocal 类</h2><h2 id="CountDownLatch-计数器"><a class="header-anchor" href="#CountDownLatch-计数器"></a>CountDownLatch 计数器</h2><h2 id="CyclicBarrier-栅栏"><a class="header-anchor" href="#CyclicBarrier-栅栏"></a>CyclicBarrier 栅栏</h2><h2 id="Semaphore-信号量"><a class="header-anchor" href="#Semaphore-信号量"></a>Semaphore 信号量</h2><h2 id="fork-join-框架"><a class="header-anchor" href="#fork-join-框架"></a>fork join 框架</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：《Java 多线程与 Socket 实战微服务框架》&lt;/p&gt;
&lt;h2 id=&quot;多线程的概念&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#多线程的概念&quot;&gt;&lt;/a&gt;多线程的概念&lt;/h2&gt;
&lt;h3 id=&quot;进程与线程&quot;&gt;&lt;a class=&quot;header</summary>
      
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://halo123.top/2021/05/30/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>https://halo123.top/2021/05/30/LeetCode/%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-30T09:32:51.000Z</published>
    <updated>2021-05-31T16:22:52.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-的幂【简单】"><a class="header-anchor" href="#2-的幂【简单】"></a>2 的幂【简单】</h2><div class="tag link"><a class="link-card" title="231. 2 的幂" href="https://leetcode-cn.com/problems/power-of-two/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">231. 2 的幂</p><p class="url">https://leetcode-cn.com/problems/power-of-two/</p></div></a></div><h3 id="题目描述"><a class="header-anchor" href="#题目描述"></a>题目描述</h3><p>给你一个整数 <code>n</code>，请你判断该整数是否是 <code>2</code> 的幂次方。</p><ul><li>如果是，返回 <code>true</code> ；</li><li>否则，返回 <code>false</code> 。</li></ul><blockquote><p>如果存在一个整数 $x$ 使得 $n = 2^{x}$ ，则认为 $n$ 是 2 的幂次方。</p></blockquote><div class="tabs" id="2的幂"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2的幂-1">示例 1</button></li><li class="tab"><button type="button" data-href="#2的幂-2">示例 2</button></li><li class="tab"><button type="button" data-href="#2的幂-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2的幂-1"><p>输入：<code>n = 1</code></p><p>输出：<code>true</code></p><p>解释：$2^{0}=1$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2的幂-2"><p>输入：<code>n = 8</code></p><p>输出：<code>true</code></p><p>解释：$2^{3}=8$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2的幂-3"><p>输入：<code>n = 5</code></p><p>输出：<code>false</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="题解"><a class="header-anchor" href="#题解"></a>题解</h3><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/">位运算</a> 参考题解：</p><p>若 $n = 2^{x}$ 且 $x$ 为自然数（即 $n$ 为 2 的幂），则一定满足一下条件：</p><ul><li>恒有 <code>n &amp; (n-1) == 0</code>（<code>&amp;</code> 表示与运算，两位同时为“1”，结果才为“1”，否则为 0）</li><li>一定满足 <code>n&gt;0</code></li></ul><p>因为 $n$ 二进制最高位为 1，其余所有位为 0；$n−1$ 二进制最高位为 0，其余所有位为 1</p><table><thead><tr><th>2<sup>x</sup></th><th>n</th><th>n-1</th><th>n &amp; (n-1)</th></tr></thead><tbody><tr><td>2<sup>0</sup></td><td>0001</td><td>0000</td><td>0</td></tr><tr><td>2<sup>1</sup></td><td>0010</td><td>0001</td><td>0</td></tr><tr><td>2<sup>2</sup></td><td>0100</td><td>0011</td><td>0</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isPowerOfTwo(<span class="number">8</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfTwo(<span class="number">19</span>)) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="4-的幂-【简单】"><a class="header-anchor" href="#4-的幂-【简单】"></a>4 的幂 【简单】</h2><div class="tag link"><a class="link-card" title="342. 4 的幂" href="https://leetcode-cn.com/problems/power-of-two/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">342. 4 的幂</p><p class="url">https://leetcode-cn.com/problems/power-of-two/</p></div></a></div><h3 id="题目描述-v2"><a class="header-anchor" href="#题目描述-v2"></a>题目描述</h3><p>题目类似于 2 的幂。给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true；否则，返回 false 。</p><h3 id="题解-v2"><a class="header-anchor" href="#题解-v2"></a>题解</h3><p>如果 $n$ 是 4 的幂，那么 $n$ 一定也是 2 的幂。因此我们可以首先判断 $n$ 是否是 2 的幂，在此基础上再判断 $n$ 是否是 4 的幂。</p><p>如果 $n$ 是 4 的幂，那么 $n$ 的二进制表示中有且仅有一个 1 ，并且这个 1 出现在从低位开始的第<font color="#faa755">偶数</font>个二进制位上。</p><p>我们可以构造一个整数 $mask$，使它的所有偶数二进制位都是 0，所有奇数二进制位都是 1。我们将 $n$ 和 $mask$ 进行按位与运算，如果结果为 0，说明 $n$ 二进制表示中的 1 出现在偶数的位置，否则说明其出现在奇数的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPowerOfFour</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; (n - <span class="number">1</span>) == <span class="number">0</span> <span class="keyword">and</span> (n &amp; <span class="number">0xaaaaaaaa</span>) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">4</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">16</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(isPowerOfFour(<span class="number">19</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h2 id="位-1-的个数【简单】"><a class="header-anchor" href="#位-1-的个数【简单】"></a>位 1 的个数【简单】</h2><div class="tag link"><a class="link-card" title="191. 位1的个数" href="https://leetcode-cn.com/problems/number-of-1-bits/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">191. 位1的个数</p><p class="url">https://leetcode-cn.com/problems/number-of-1-bits/</p></div></a></div><h3 id="题目描述-v3"><a class="header-anchor" href="#题目描述-v3"></a>题目描述</h3><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p><div class="tabs" id="位1的个数"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#位1的个数-1">示例 1</button></li><li class="tab"><button type="button" data-href="#位1的个数-2">示例 2</button></li><li class="tab"><button type="button" data-href="#位1的个数-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="位1的个数-1"><p>输入：<code>00000000000000000000000000001011</code></p><p>输出：<code>3</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="位1的个数-2"><p>输入：<code>00000000000000000000000010000000</code></p><p>输出：<code>1</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="位1的个数-3"><p>输入：<code>11111111111111111111111111111101</code></p><p>输出：<code>31</code></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="字符串题解"><a class="header-anchor" href="#字符串题解"></a>字符串题解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 骚操作</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># bin() 返回一个整数 int 或者长整数 long int 的二进制表示。</span></span><br><span class="line">    <span class="comment"># print(bin(n))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="位运算题解"><a class="header-anchor" href="#位运算题解"></a>位运算题解</h3><p>在 Java 中 <code>Integer.bitCount()</code> 方法用于统计二进制中 1 的个数，其源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// HD, Figure 5-2</span></span><br><span class="line">    i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">    i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&gt;&gt;&gt;</code> 表示无符号右移</li><li><code>&amp;</code> 与运算，当两位同时为“1”，结果才为“1”，否则为 0</li></ul><p>代码中的十六进制数的二进制表示如下：</p><table><thead><tr><th>原文</th><th>二进制</th></tr></thead><tbody><tr><td><code>0x55555555</code></td><td><code>01010101 01010101 01010101 01010101</code></td></tr><tr><td><code>0x33333333</code></td><td><code>00110011 00110011 00110011 00110011</code></td></tr><tr><td><code>0x0f0f0f0f</code></td><td><code>00001111 00001111 00001111 00001111</code></td></tr><tr><td><code>0x3f</code></td><td><code>00000000 00000000 00000000 11111111</code></td></tr></tbody></table><p>如果把这些二进制序列看作一个循环的周期序列的话，那么：</p><ul><li>第一个序列的周期是 2，每个周期是 01；</li><li>第二个序列的周期是 4，每个周期是 0011；</li><li>第三个序列的周期是 8，每个周期是 00001111；</li><li>第四个序列的周期是 16，每个周期是 11111111。</li></ul><p>原理是：先两个两个一组，求二进制 1 的个数，并且用两位二进制存储在原处，然后四个四个一组，求二进制位 1 的个数，再把它存储以 4 位二进制到原处。以此类推直到计算完成。</p><p><a href="https://segmentfault.com/a/1190000015763941">算法原型</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) + ((i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x00ff00ff</span>) + ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x0000ffff</span>) + ((i &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>767 的二进制中的 1 的位数计算过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          二进制                       十进制</span><br><span class="line">1  0   1  1   1  1   1  1   1  1     10 11 11 11 11</span><br><span class="line"> 01     10     10     10     10       1 2  2  2  2</span><br><span class="line">         \     &#x2F;       \     &#x2F;           \&#x2F;    \&#x2F;</span><br><span class="line"> 01       0100           0100         1   4    4</span><br><span class="line">               \       &#x2F;                   \  &#x2F;</span><br><span class="line"> 01               1000                1      8</span><br><span class="line">     \          &#x2F;                       \   &#x2F;</span><br><span class="line">         1001                             9</span><br></pre></td></tr></table></figure><!-- 这里先模拟代码执行一遍：假设 `i = 5`，对应的二进制表示为 `0b0101`（1）`i = i - ((i >>> 1) & 0x55555555);`+ `i >>> 1` 的结果为 `0b0010` 等于 2+ `2 & 0x55555555` 等于 `0b0010 & 0b0101 = 0b0000` 十进制结果为 0 + `i - 0b0000` 结果等于 `0b0101`，即第一段代码运行后 `i = 0b0101`（2）`i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);`+ `i & 0x33333333` 等于 `0b0101 & 0b0011 = 0b0001`+ `i >>> 2` 等于 `0b0001`+ `((i >>> 2) & 0x33333333)` 等于 `0b0001 & 0b0011 = 0b0001`+ `(i & 0x33333333) + ((i >>> 2) & 0x33333333)` 等于 `0b0001 + 0b0001 = 0b0010`（3）`i = (i + (i >>> 4)) & 0x0f0f0f0f;`+ `(i >>> 4)` 等于 `0b0000`+ `(i + (i >>> 4))` 等于 `0b0010`+ `(i + (i >>> 4)) & 0x0f0f0f0f` 等于 `0b0010 & 0b1111 = 0b0010`（4）`i = i + (i >>> 8);` 和 `i = i + (i >>> 16);` 结果都是 `0b0010`（5）`i & 0x3f` 等于 `0b0010 & 0b1111 = 0b0010` 等于十进制的 2，即求得 5 的二进制表示中有 2 个 1。 --><p>如果以 <code>0b11111111</code> 为例可以看到每一步的变化</p><ul><li><code>i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</code> 运算完后 <code>i = 0b10101010</code> 。</li><li><code>i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</code> 运算完后 <code>i = 0b01000100</code>。</li><li><code>i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i = i + (i &gt;&gt;&gt; 8);</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i = i + (i &gt;&gt;&gt; 16);</code> 运算完后 <code>i = 0b00001000</code>。</li><li><code>i &amp; 0x3f</code> 返回 <code>0b00001000</code> 等于 8</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-的幂【简单】&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#2-的幂【简单】&quot;&gt;&lt;/a&gt;2 的幂【简单】&lt;/h2&gt;
&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;231. 2 的幂&quot; h</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://halo123.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://halo123.top/tags/LeetCode/"/>
    
    <category term="位运算" scheme="https://halo123.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>千种植物转录组计划</title>
    <link href="https://halo123.top/2021/05/29/Biology/%E5%8D%83%E7%A7%8D%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E7%BB%84%E8%AE%A1%E5%88%92/"/>
    <id>https://halo123.top/2021/05/29/Biology/%E5%8D%83%E7%A7%8D%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E7%BB%84%E8%AE%A1%E5%88%92/</id>
    <published>2021-05-29T09:40:01.000Z</published>
    <updated>2021-06-07T09:16:23.398Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://www.nature.com/articles/s41586-019-1693-2">https://www.nature.com/articles/s41586-019-1693-2</a></p><p style="text-align:center; font-size:30px; ">One thousand plant transcriptomes and the phylogenomics of green plants</p><h2 id="Abstract"><a class="header-anchor" href="#Abstract"></a>Abstract</h2><p>Green plants (Viridiplantae) include around 450,000–500,000 species <sup>[<a href="#ref-CR1">1</a>,<a href="#ref-CR2">2</a>]</sup> of great diversity and have important roles in terrestrial and aquatic ecosystems. Here, as part of the One Thousand Plant Transcriptomes Initiative, we sequenced the vegetative transcriptomes of 1,124 species that span the diversity of plants in a broad sense (Archaeplastida), including green plants (Viridiplantae), glaucophytes (Glaucophyta) and red algae (Rhodophyta). Our analysis provides a robust phylogenomic framework for examining the evolution of green plants. Most inferred species relationships are well supported across multiple species tree and supermatrix analyses, but discordance among plastid and nuclear gene trees at a few important nodes highlights the complexity of plant genome evolution, including polyploidy, periods of rapid speciation, and extinction. Incomplete sorting of ancestral variation, polyploidization and massive expansions of gene families punctuate the evolutionary history of green plants. Notably, we find that large expansions of gene families preceded the origins of green plants, land plants and vascular plants, whereas whole-genome duplications are inferred to have occurred repeatedly throughout the evolution of flowering plants and ferns. The increasing availability of high-quality plant genome sequences and advances in functional genomics are enabling research on genome evolution across the green tree of life.</p><blockquote><p>绿色植物（Viridiplanta）约有 45 万至 50 万不同物种，它们在陆地和水生生态系统中起着重要的作用。作为“千种植物转录组计划”的一部分，我们对泛植物界中的 1124 种物种的转录组进行了测序，包括绿色植物（Viridiplanta）、灰藻门（Glaucophyta）和红藻门（Rhodophyta）。我们的分析为研究绿色植物的进化提供了一个健壮的系统基因组框架。在大多数推测的物种关系、跨多个物种树和超级矩阵的分析中得到了很好的支持。但在质体之间和核基因树的几个重要的节点之间产生了矛盾，凸显出了植物基因组进化的复杂，其中包括多倍性、物种快速形成和灭绝。祖先变异的不完全谱系分选、多倍体化和基因家族的大规模扩张时不时打断绿色植物进化史。尤其，我们发现，尽管在开花植物和蕨类植物的进化过程中推测发生了多次的全基因组的复制，但大规模的基因家族扩张是要早于绿色植物、陆生植物和维管植物的起源。此外，测序得到越来越多的高质量植物基因组序列和功能基因组学的进步，使得研究跨越绿色生命之树的基因组进化成为可能。</p></blockquote><h2 id="Main"><a class="header-anchor" href="#Main"></a>Main</h2><p>Viridiplantae comprise an estimated 450,000–500,000 species<sup>[<a href="#ref-CR1">1</a>,<a href="#ref-CR2">2</a>]</sup>, encompass a high level of diversity and evolutionary timescales<sup>[<a href="#ref-CR3">3</a>]</sup>, and have important roles in all terrestrial and most aquatic ecosystems. This ecological diversity derives from developmental, morphological and physiological innovations that enabled the colonization and exploitation of novel and emergent habitats. These innovations include multicellularity and the development of the plant cuticle, protected embryos, stomata, vascular tissue, roots, ovules and seeds, and flowers and fruit (Fig. 1). Thus, plant evolution ultimately influenced environments globally and created a cascade of diversity in other lineages that span the tree of life. Plant diversity has also fuelled agricultural innovations and growth in the human population<sup>[<a href="#ref-CR4">4</a>]</sup>.</p><blockquote><p>绿色植物约有 45 万至 50 万种，拥有丰富的多样性和长时间的进化历程，并在所有陆地和大多数水生生态系统中发挥着重要的作用。这种生态多样性源于进化，形态和生理上的改变，使得移植、扩张、发展新的栖息地成为可能。这些改变包括多细胞化，植物角质层进化，保护胚胎，气孔，维管组织，根系，胚珠，种子以及花和果实（图片 1）。因此，植物进化最终影响了全球的生态环境，并贯穿了生命之树，创造了许多不同的世系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/Fig1.png" alt="Fig. 1: Diversity within the Viridiplantae."></p><div class="tabs" id="fig1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#fig1-1">Description</button></li><li class="tab"><button type="button" data-href="#fig1-2">描述</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="fig1-1"><p><strong>a</strong>–<strong>e</strong>, Green algae. <strong>a</strong>, <em>Acetabularia</em> sp. (Ulvophyceae). b, <em>Stephanosphaera pluvialis</em> (Chlorophyceae). c, <em>Botryococcus</em> sp. (Trebouxiophyceae). d, <em>Chara</em> sp. (Charophyceae). e, <em>‘Spirotaenia’</em> sp. (taxonomy under review) (Zygnematophyceae). f–p, Land plants. f, Notothylas orbicularis (Anthocerotophyta (hornwort)). g, Conocephalum conicum (Marchantiophyta (thalloid liverwort)). h, Sphagnum sp. (Bryophyta (moss)). i, Dendrolycopodium obscurum (Lycopodiophyta (club moss)). j, Equisetum telmateia (Polypodiopsida, Equisetidae (horsetail)). k, Parablechnum schiedeanum (Polypodiopsida, Polypodiidae (leptosporangiate fern)). l, Ginkgo biloba (Ginkgophyta). m, Pseudotsuga menziesii (Pinophyta (conifer)). n, Welwitschia mirabilis (Gnetophyta). o, Bulnesia arborea (Angiospermae, eudicot, rosid). p, Paphiopedilum lowii (Angiospermae, monocot, orchid). a, Photograph reproduced with permission of Thieme Verlag, Stuttgart66. b–e, Photographs courtesy of M. Melkonian. f–j, l–n, p, Photographs courtesy of D.W.S. k, Photograph courtesy of R. Moran. o, Photograph courtesy of W. Judd.</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="fig1-2"><p>a-e，绿藻类。a，</p><p>TODO</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>Phylogenomic approaches are now widely used to resolve species relationships<sup>[<a href="#ref-CR5">5</a>]</sup> as well as the evolution of genomes, gene families and gene function<sup>[<a href="#ref-CR6">6</a>]</sup>. We used mostly vegetative transcriptomes for a broad taxonomic sampling of 1,124 species together with 31 published genomes to infer species relationships and characterize the relative timing of organismal, molecular and functional diversification across green plants.</p><blockquote><p>系统基因组学方法现在被广泛用于解决物种关系、基因组的进化、基因家族和基因功能。我们利用从 1124 种植物中通过分类学的抽样，获得样品的植物转录组，并结合 31 个已发表的基因组来推断物种关系，描绘出绿色植物的有机体、分子和功能多样性的诞生的相对时间。</p></blockquote><p>We evaluated gene history discordance among single-copy genes. This is expected in the face of rapid species diversification, owing to incomplete sorting of ancestral variation between speciation events7. Hybridization8, horizontal gene transfer9, gene loss following gene and genome duplications10 and estimation error can also contribute to gene-tree discordance. Nevertheless, through rigorous gene and species tree analyses, we derived robust species tree estimates (Fig. 2 and Supplementary Figs. 1–3). Gene-family expansions and genome duplications are recognized sources of variation for the evolution of gene function and biological innovations11,12. We inferred the timing of ancient genome duplications and large gene-family expansions. Our findings suggest that extensive gene-family expansions or genome duplications preceded the evolution of major innovations in the history of green plants.</p><blockquote><p>我们评估了单拷贝基因之间的基因史的不一致性。这是预期在面对快速物种多样化，由于不完整的分类祖先变异之间的物种事件</p></blockquote><h2 id="Integrated-analysis-of-genome-evolution"><a class="header-anchor" href="#Integrated-analysis-of-genome-evolution"></a>Integrated analysis of genome evolution</h2><h2 id="Primary-acquisition-of-the-plastid"><a class="header-anchor" href="#Primary-acquisition-of-the-plastid"></a>Primary acquisition of the plastid</h2><h2 id="The-history-of-Viridiplantae"><a class="header-anchor" href="#The-history-of-Viridiplantae"></a>The history of Viridiplantae</h2><h2 id="Synthesis"><a class="header-anchor" href="#Synthesis"></a>Synthesis</h2><h2 id="Methods"><a class="header-anchor" href="#Methods"></a>Methods</h2><h2 id="Data-availability"><a class="header-anchor" href="#Data-availability"></a>Data availability</h2><h2 id="Code-availability"><a class="header-anchor" href="#Code-availability"></a>Code availability</h2><h2 id="References"><a class="header-anchor" href="#References"></a>References</h2><ol><li id="ref-CR1">Corlett, R. T. Plant diversity in a changing world: status, trends, and conservation needs. Plant Divers. 38, 10–16 (2016). </li><li id="ref-CR2">Lughadha, E. N. et al. Counting counts: revised estimates of numbers of accepted species of flowering plants, seed plants, vascular plants and land plants with a review of other recent estimates. Phytotaxa 272, 82–88 (2016).</li><li id="ref-CR3">Kumar, S., Stecher, G., Suleski, M. & Hedges, S. B. TimeTree: a resource for timelines, timetrees, and divergence times. Mol. Biol. Evol. 34, 1812–1819 (2017).</li><li id="ref-CR4">Schery, R. W. Plants for Man 2nd edn (Prentice-Hall, 1972).</li><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --><!-- <li id="ref-CR2"></li> --></ol><h2 id="Acknowledgements"><a class="header-anchor" href="#Acknowledgements"></a>Acknowledgements</h2><h2 id="Author-information"><a class="header-anchor" href="#Author-information"></a>Author information</h2><h2 id="Ethics-declarations"><a class="header-anchor" href="#Ethics-declarations"></a>Ethics declarations</h2><h2 id="Additional-information"><a class="header-anchor" href="#Additional-information"></a>Additional information</h2><h2 id="Extended-data-figures-and-tables"><a class="header-anchor" href="#Extended-data-figures-and-tables"></a>Extended data figures and tables</h2><h2 id="Supplementary-information"><a class="header-anchor" href="#Supplementary-information"></a>Supplementary information</h2><h2 id="Rights-and-permissions"><a class="header-anchor" href="#Rights-and-permissions"></a>Rights and permissions</h2><h2 id="About-this-article"><a class="header-anchor" href="#About-this-article"></a>About this article</h2><h2 id="Further-reading"><a class="header-anchor" href="#Further-reading"></a>Further reading</h2><h2 id="Comments"><a class="header-anchor" href="#Comments"></a>Comments</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://www.nature.com/articles/s41586-019-1693-2&quot;&gt;https://www.nature.com/articles/s41586-019-1693-2&lt;/a&gt;&lt;/p&gt;
&lt;p style=&quot;text</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
    <category term="植物学" scheme="https://halo123.top/tags/%E6%A4%8D%E7%89%A9%E5%AD%A6/"/>
    
    <category term="进化学" scheme="https://halo123.top/tags/%E8%BF%9B%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>棘皮动物的进化</title>
    <link href="https://halo123.top/2021/05/29/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E7%9A%84%E8%BF%9B%E5%8C%96/"/>
    <id>https://halo123.top/2021/05/29/Biology/%E6%A3%98%E7%9A%AE%E5%8A%A8%E7%89%A9%E7%9A%84%E8%BF%9B%E5%8C%96/</id>
    <published>2021-05-29T08:14:01.000Z</published>
    <updated>2021-06-15T07:40:47.304Z</updated>
    
    <content type="html"><![CDATA[<details ><summary> 主要参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="寒武纪的余烬：棘皮动物篇（上）" href="https://zhuanlan.zhihu.com/p/51287717"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">寒武纪的余烬：棘皮动物篇（上）</p><p class="url">https://zhuanlan.zhihu.com/p/51287717</p></div></a></div><div class="tag link"><a class="link-card" title="寒武纪的余烬：棘皮动物篇（下）" href="https://zhuanlan.zhihu.com/p/51585435"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">寒武纪的余烬：棘皮动物篇（下）</p><p class="url">https://zhuanlan.zhihu.com/p/51585435</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客 0：后口动物的征途" href="https://zhuanlan.zhihu.com/p/27155535"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客 0：后口动物的征途</p><p class="url">https://zhuanlan.zhihu.com/p/27155535</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客１：绽放的奇葩" href="https://zhuanlan.zhihu.com/p/27155622"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客１：绽放的奇葩</p><p class="url">https://zhuanlan.zhihu.com/p/27155622</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客２：亦步亦趋" href="https://zhuanlan.zhihu.com/p/27155675"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客２：亦步亦趋</p><p class="url">https://zhuanlan.zhihu.com/p/27155675</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客３：爬起来，走两步" href="https://zhuanlan.zhihu.com/p/27155812"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客３：爬起来，走两步</p><p class="url">https://zhuanlan.zhihu.com/p/27155812</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客４：异界妖花" href="https://zhuanlan.zhihu.com/p/27155892"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客４：异界妖花</p><p class="url">https://zhuanlan.zhihu.com/p/27155892</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客５：群魔乱舞" href="https://zhuanlan.zhihu.com/p/27155947"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客５：群魔乱舞</p><p class="url">https://zhuanlan.zhihu.com/p/27155947</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客 6：刚柔并济" href="https://zhuanlan.zhihu.com/p/352015660"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客 6：刚柔并济</p><p class="url">https://zhuanlan.zhihu.com/p/352015660</p></div></a></div><div class="tag link"><a class="link-card" title="异界来客7：Alura Une" href="https://zhuanlan.zhihu.com/p/356406403"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">异界来客7：Alura Une</p><p class="url">https://zhuanlan.zhihu.com/p/356406403</p></div></a></div>              </div>            </details><details ><summary> 其他参考资料 </summary>              <div class='content'>              <div class="tag link"><a class="link-card" title="【维基百科】棘皮动物" href="https://en.wikipedia.org/wiki/Echinoderm"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/wiki.68zrhewkzwk0.png"/></div><div class="right"><p class="text">【维基百科】棘皮动物</p><p class="url">https://en.wikipedia.org/wiki/Echinoderm</p></div></a></div><div class="tag link"><a class="link-card" title="【马里兰大学古生物学】棘皮动物 1" href="https://www.geol.umd.edu/~tholtz/G331/lectures/331echin1.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【马里兰大学古生物学】棘皮动物 1</p><p class="url">https://www.geol.umd.edu/~tholtz/G331/lectures/331echin1.html</p></div></a></div><div class="tag link"><a class="link-card" title="【马里兰大学古生物学】棘皮动物 2" href="https://www.geol.umd.edu/~tholtz/G331/lectures/331echin2.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【马里兰大学古生物学】棘皮动物 2</p><p class="url">https://www.geol.umd.edu/~tholtz/G331/lectures/331echin2.html</p></div></a></div><div class="tag link"><a class="link-card" title="【鬼谷说】棘皮动物：六亲不认的演化步伐" href="https://www.bilibili.com/video/BV1Nb411h7bc"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【鬼谷说】棘皮动物：六亲不认的演化步伐</p><p class="url">https://www.bilibili.com/video/BV1Nb411h7bc</p></div></a></div><div class="tag link"><a class="link-card" title="「派大星」入选「十大海洋新物种」名单" href="https://www.zhihu.com/question/450637881"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/知乎icon.png"/></div><div class="right"><p class="text">「派大星」入选「十大海洋新物种」名单</p><p class="url">https://www.zhihu.com/question/450637881</p></div></a></div>              </div>            </details><div class="tag link"><a class="link-card" title="【网站推荐】可视化进化树0" href="https://www.evogeneao.com/en/explore/tree-of-life-explorer"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">【网站推荐】可视化进化树0</p><p class="url">https://www.evogeneao.com/en/explore/tree-of-life-explorer</p></div></a></div><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.24fzifdt0w74.png" alt="进化树"></p><p>该网站通过点击两个物种，可以直观的看到两个物种的关系。</p><h2 id="棘皮动物-Key-Points"><a class="header-anchor" href="#棘皮动物-Key-Points"></a>棘皮动物 Key Points</h2><ul><li>现存的棘皮动物约有 7000 种，已灭绝的物种约有 13000 种，它们的栖息地从浅海到数千米的深海都有广泛分布。</li><li>棘皮动物和脊索动物同属于后口动物（Deuterostomes），即在胚胎的原肠胚期其原口形成为肛门而与之相对的后口形成嘴部的动物。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.6y77h6fg2q80.png" alt="原口动物和后口动物"></p><ul><li>棘皮动物属于无脊椎动物中的高等门类，同时也是后口动物中比较原始的类群，是生物进化史中极为重要的一环</li><li>棘皮动物只存在海洋中，没有涉足陆地和淡水，且几乎都是底栖动物。</li><li>最早鉴定的棘皮动物在寒武纪</li><li>棘皮动物深海和浅海，包括其他生物稀少的区域都有分布，很少有其他群落如此丰富。</li><li>在地质学上，棘皮动物的价值在于它们的骨化骨骼，有的石灰石地层全部由分解了的海百合骨骼构成。可以为了解地质环境提供有价值的线索。</li><li>大多数棘皮动物能够无性繁殖，再生组织、器官和四肢；在某些情况下，它们可以从单个肢体完成再生，如下图所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5b3zosjzwa80.png" alt="断臂再生"></p><ul><li>由于棘皮动物成体次辐射对称，例如海星多出几条或少几条腕并不会对其生命产生太多影响。</li><li>棘皮动物线粒体基因排列顺序相当保守，海参纲和海胆纲间几乎完全一致，二者与海星纲间仅存在一个大片段的倒位，海百合纲中的基因重排也较为有限，仅在蛇尾纲内出现了较多的基因重排现象</li><li>古生物证据却显示，棘皮动物不同纲之间存在有 450 ～ 550 百万年的分化距离</li></ul><h3 id="分类和演化"><a class="header-anchor" href="#分类和演化"></a>分类和演化</h3><p>在胚胎的早期发育过程中，在后口动物中，胚孔（第一个形成的开口）变成了肛门，而在原口动物中，胚孔变成了嘴。在后口动物中，口发育较晚，位于囊胚的另一端，与囊胚孔相对，而肠道将两者连接起来棘皮动物的幼虫具有双侧对称，但在变态过程中，当它们的身体重组并发展出棘皮动物特有的辐射对称。</p><p>成年棘皮动物的特征是拥有一个水管系统和一个由胶原纤维网连接的小骨组成的钙质内骨骼。骨片可以形成棘、叉棘、刺等结构，突出于体表之外，使体表粗糙不平。不同形式的棘行使防卫、清除体表沉积物等功能。故称之为棘皮动物。</p><p>目前现存的棘皮动物门（Echinodermata）下有以下 5 纲：</p><ul><li>海星纲（Asteroidea）；</li><li>蛇尾纲（Ophiuroidea）；</li><li>海胆纲（Echinoidea）；</li><li>海参纲（Holothuroidea）；</li><li>海百合纲（Crinoidea）；</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/image.6rj5hl0h26c0.png" alt="棘皮动物"></p><h4 id="系统发生"><a class="header-anchor" href="#系统发生"></a>系统发生</h4><p>早期棘皮动物的系统发生不确定，主要是不确定蛇尾纲是要分到海星亚门中还是海胆亚门中。后来，2014 年对所有棘皮动物的 219 个基因进行了分析，得出了如下的系统发育树【<a href="https://doi.org/10.1098/rspb.2014.0479">DOI 链接</a>】。2015 年，一项对 23 种棘皮动物的 RNA 转录组的独立分析得出了同一棵树，如下图所示【<a href="https://doi.org/10.1371/journal.pone.0119627">DOI 链接</a>】。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.5x76pwdj7hg0.png" alt="棘皮动物的系统发生树"></p><h4 id="化石历史"><a class="header-anchor" href="#化石历史"></a>化石历史</h4><p>已知最古老的棘皮动物化石可能是来自澳大利亚前寒武纪的 <em>Arkarua</em>。它是一个盘状的化石，边缘有放射状的脊，中央有一个有放射状线标记的五角形凹陷。然而，没有立体或内部结构显示水管系统的存在，鉴定结果不确定。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Arkarua_adami_pennetta.3ax8b8efiym0.png" alt="Arkarua_adami_pennetta"></p><p>最早被普遍接受的棘皮动物出现在下寒武纪早期，棘皮动物留下了大量的化石记录。有一种假说认为，所有棘皮动物的祖先都是简单的、能动的、两侧对称的动物，有嘴、肠和肛门。这种祖先采用了附着的生活方式和悬浮进食，并发展了辐射对称，因为这对这种生存更有利。所有的棘皮动物的幼虫直到现在都是两侧对称的，而且在变态时都发育成径向对称。海星和海百合在变成成体的过程中仍然附着在海床上。</p><p>第一批棘皮动物后来演化出了可以自由活动的群体。棘皮动物早期演化出具有坚硬的内骨骼板和供取食的纤毛状槽。古生代棘皮动物，附着于基质上，口腔面朝上。嘴朝上可能是最原始的状态，在某个阶段，除了海百合的其他大部分的棘皮动物，都改变成为了嘴朝下的姿势。在此之前，腕可能有一个进食功能，就像现在海百合的功能一样。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%871.mg0f1h8wnkw.jpg" alt="早期的几类棘皮动物"></p><blockquote><p>图片引用自 Deciphering the early evolution of echinoderms with Cambrian fossils【<a href="http://doi.org/10.1111/pala.12138">DOI 链接</a>】</p></blockquote><h2 id="棘皮动物门介绍"><a class="header-anchor" href="#棘皮动物门介绍"></a>棘皮动物门介绍</h2><h3 id="生物学特征"><a class="header-anchor" href="#生物学特征"></a>生物学特征</h3><blockquote><p>参考：许崇任《动物生物学》（第 2 版）</p></blockquote><p>棘皮动物成体五辐射对称，幼体全部两侧对称。身体表面具有棘、刺，突出表体之外。一部分体腔形成了特殊的水管系统、血系统和围血系统。骨骼全部起源于中胚层，由钙化的骨片组成。神经系统没有神经节和中枢神经系统。</p><p>由于棘皮动物为辐射卵裂，以肠腔法形成了中胚层和真体腔，原胚孔最终形成了成体的肛门，成体的口在原肠孔相对的一端另外形成，其发育过程与原始的脊索动物类似，属于演化中最原始的后口动物。</p><h4 id="外部形态"><a class="header-anchor" href="#外部形态"></a>外部形态</h4><p>棘皮动物的成体是五辐射对称（或是 5 的倍数辐射对称），即沿中轴可以将身体分为 5 个相等的部分。由于它们的幼虫期是两侧对称的，因此推测成体的五辐射对称应为次生性的，与腔肠动物原始的辐射对称形式完全不同。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%872.26vf7j26v1a8.png" alt="海星幼虫与从幼虫中脱落的海星"></p><blockquote><p>海星幼虫与从幼虫中脱落的海星</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Haeckel_Asteridea_Larvae.oinaxeny2ow.jpg" alt="Haeckel_Asteridea_Larvae"></p><blockquote><p>海星的幼虫</p></blockquote><p>以海星为例，身体由体盘和腕构成。体盘有口的较平的一面称为口面，口面中央有口。另一面略凸称反口面，中央有肛门。腕一般有 5 条，从体盘伸出。在腕的腹面中部有一条步带沟，其中有 2 ~ 4 排管足生出，管足末端有吸盘。腕之间为间步带区，反口面有一个在间步带区的多孔的筛板。腕的顶端靠下有眼点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/Asterias_rubens,_dissection.1lif2idd80qo.svg" alt="海星的解剖示意图"></p><ol><li>幽门胃（Pyloric stomach）</li><li>肠和肛门（Intestine and anus）</li><li>直肠盲囊（Rectal sac）</li><li>石管（Stone canal）</li><li>筛板（Madreporite）</li><li>幽门盲囊（Pyloric caecum）</li><li>消化腺（Digestive glands）</li><li>贲门胃（Cardiac stomach）</li><li>生殖腺（Gonad）</li><li>辐水管（Radial canal）</li><li>步带沟（Ambulacral ridge）</li></ol><h4 id="体壁与骨骼"><a class="header-anchor" href="#体壁与骨骼"></a>体壁与骨骼</h4><p>棘皮动物的体壁由表皮层和表皮层下的结缔组织构成，称为真皮。外面是一层薄的角质层，下面是一层单纤毛的柱状上皮，柱状上皮之下是结缔组织。真皮下是肌肉层，肌肉层内为体腔膜。其他的无脊椎动物体璧不是真皮层。</p><p>棘皮动物的骨骼都起源于中胚层，称为内骨骼，是由许多钙质的骨片组成，骨片上有小孔，位于体壁的结缔组织内。骨片可以形成棘、叉棘、刺等结构，突出于体表之外，使体表粗糙不平。不同形式的棘行使防卫、清除体表沉积物等功能。另外，体壁上还有表皮和体腔上皮向外凸起形成的皮鳃， 表皮和体腔上皮上都有纤毛，分别打动水流和体腔液，进行气体交换。</p><h4 id="水管系统"><a class="header-anchor" href="#水管系统"></a>水管系统</h4><p>水管系统是一个相对封闭的管状系统，担负着棘皮动物运动的功能。海盘车的水管系统包括筛板、石管、环水管、辐水管、管足、吸盘、坛囊几个部分。环水管上有帖氏体，可能有产生体腔细胞的作用。水管系统的内壁是体腔上皮，里面充满液体。管足的外壁是纤毛上皮，与内壁的体腔上皮之间有肌肉层。水管系统内的液体与海水等渗，运动时相当于一个液压系统，使得管足可以伸缩，管足末端的吸盘可以借液压产生的真空吸附在物体上。水管的其他部分共同起着控制、协调系统内水流的作用。实验证明水管系统内的液体是不与外界交换的。</p><h4 id="血系统和围血系统"><a class="header-anchor" href="#血系统和围血系统"></a>血系统和围血系统</h4><p>棘皮动物没有专门的循环器官，但有与其他动物不同的血系统和一套围血系统。在棘皮动物发达的真体腔内充满体腔液，靠体腔上皮细胞的纤毛打动，体腔液完成营养物质的输送。血系统包括一套与水管系统相应的管道，有与辐水管平行的辐血管、与环水管平行的环血管、位于反口面的胃血管和分支，以及与石管平行的轴窦。 血系统的管道中有液体，轴窦和筛板附近的背囊均有搏动能力。包围在血系统之外还有一套围血系统，围血系统是体腔的一部分，形成围绕在血系统之外的一套窦隙。关于棘皮动物血系统和围血系统的作用目前尚了解不多</p><h4 id="消化系统"><a class="header-anchor" href="#消化系统"></a>消化系统</h4><p>棘皮动物的消化系统以海盘车为例，口面中央有一圈围口膜，之间是口，连接口的是贲门胃，贲门胃之后是幽门胃，有 5 对幽门盲囊分布在腕内，后有一短的直肠连通肛门。消化管的上皮有纤毛，腺细胞可分泌消化酶。棘皮动物有肉食性的，也有植食性的。海盘车取食双壳类时，用腕上的吸盘将壳吸住拉开，然后贲门胃翻出，包住食物，先进行初步体外消化，再吞咽回体内。消化的营养物质由幽门盲囊吸收贮存。海星纲的肛门虽然存在，但是已经丧失了机能。消化后的食物残渣仍然由口排出。海蛇尾以小动物或海底沉积物为食，以较为活动的腕送人口中，或腕上的刺和管足送入口中。海胆纲的动物有一咀嚼器，是由复杂的骨片组成，上面有 齿可以用来取食岩石上的海藻。海胆的食性复杂，可以取食小动物，也可以取食植物。它们的消化管很长，食物残渣由肛门排出。海参类为沉积取食或悬浮取食，以触手将食物送入口中。海参的消化管长度是身体的 3 ~ 4 倍，在消化管后端有 1 对分支很多的呼吸树，起呼吸的作用。海百合是悬浮取食，管足上的纤毛将黏着的食物颗粒逐渐送入口中。</p><h4 id="神经系统"><a class="header-anchor" href="#神经系统"></a>神经系统</h4><p>棘皮动物的神经系统是分散的，没有神经节和中枢神经系统。海盘车有3个神经系统，它们是外胚层起源的外神经系统（ectoneural nervous system）、中胚层起源的内神经系统（ento-neural nervous system）和下神经系统（hyponeural nervous system）。外神经系统在口面的表皮细胞下，包括围口膜边缘的1个神经环和由此神经环发出的辐神经，辐神经沿步带沟中部一直延伸到腕的末端，并发出神经到管足和坛囊。内神经系统是.上皮下神经丛在步带沟外边缘加厚形成的1对边缘神经索，发出的神经到步带骨板的肌肉上，并在体腔膜下形成神经丛，支配体壁肌肉。下神经系统也称为体腔神经，位于围血系统的体壁上，在体腔膜下。棘皮动物的感觉器官只有感光的眼点，眼点位于腕的顶端。但是棘皮动物整个表皮中有大量神经感觉细胞，除司触觉外，还能够对光和化学刺激作出反应。</p><h4 id="生殖和发育"><a class="header-anchor" href="#生殖和发育"></a>生殖和发育</h4><p>除了少数海蛇尾和海参外，棘皮动物大多是雌雄异体。如海盘车的生殖腺位于间步带区，一般为 5 对（或 5 的倍数）。生殖孔在反口面靠近腕基部的中央盘上，生殖细胞排出体外受精。受精卵是辐射卵裂，发育后经内陷法形成原肠，再由腔肠法形成中胚层和 3 对体腔囊，即前体腔囊、中体腔囊和后体腔囊。原肠胚时的胚孔最终发育成为成体的肛门，而成体的口则是在原肠孔相对的另一端形成的。棘皮动物各纲的幼虫形态不相同，但基本结构是一样的。棘皮动物的幼虫期是两侧对称的，经变态后形成了辐射对称的幼虫。例如在变态过程中，海盘车的羽腕幼虫右侧的前体腔囊和中体腔囊退化，后体腔囊形成了后来的体腔，左侧的中体腔囊形成了整个水管系统，包括环水管、辐水管以及管足，并逐渐从两侧对称成为辐射对称的形式，说明棘皮动物的五辐射对称是次生性的。</p><h3 id="棘皮动物门的分类"><a class="header-anchor" href="#棘皮动物门的分类"></a>棘皮动物门的分类</h3><p>棘皮动物全部是海洋底栖生活，广泛分布在从浅海到数千米的深海，现存 6000 多种，而化石种类则多达 20000 多种。沿海常见的海星、海蛇尾、海胆、海参等都属于棘皮动物。棘皮动物依据生活方式可分为游在亚门（Eleutherozoa，也叫游走亚门、无柄亚门或活动亚门）和有柄亚门（Pelmatozoa，也叫固着亚门）两大类。1963年，美国无脊椎动物学家巴里·费尔根据棘皮动物体内独特的水管系统，提出了新的分类方案。</p><h4 id="依据生活方式分类"><a class="header-anchor" href="#依据生活方式分类"></a>依据生活方式分类</h4><ul><li>有柄亚门（Pelmatozoa）<ul><li>海蕾纲（Blastoidea）†</li><li>海百合纲（Crinoidea）</li><li>海座星纲（Edrioasteroids）†</li></ul></li><li>游在亚门（Eleutherozoa）<ul><li>海星纲（Asteroidea）</li><li>海胆纲（Echinoidea）</li><li>海参纲（Holothuroidea）</li><li>蛇尾纲（Ophiuroidea）</li></ul></li></ul><blockquote><p>†表示已灭绝</p></blockquote><p><font color="#faa755">有柄亚门</font>：附着或固着生活，在生活史中至少有一个时期具固着用的柄。</p><ul><li>海百合纲（Crinoidea）：海百合纲是棘皮动物中最原始的一类，以柄营固着生活（海百合），或无柄营自由生活（海羽星）。5个腕的基部多分支，使身体看似杯状，但口面和反口面均在同一个面。现存 630 余种。</li></ul><hr><p><font color="#faa755">游在亚门</font>：自由生活，生活史中没有具固着生活的柄。</p><ul><li>海星纲：身体呈星形，中央盘和 5 个（或 5 的倍数）腕之间的界限与海蛇尾比不明显，腕的口面有步带沟，步带沟中有 2 ~ 4 排管足。</li><li>海蛇尾纲：腕细长，与中央盘的界限非常明显，没有步带沟，管足没有坛囊和吸盘。筛板位于口面。本纲是棘皮动物中最大的一类，现存约有 2000 种，分布极广。</li><li>海胆纲：5 个腕向反口面愈合，呈圆球形或扁圆形的骨骼包住身体。体表头长有可以活动的刺。现存种类约 900 种。</li><li>海参纲：身体沿口面和反口面延长，成为长圆柱形，无腕，并以步带区和间步带区附着。口和肛门分别在身体的两端，出现次生性的两侧对称。骨片小而分散，无互相关连的骨板，故体表没有棘和叉棘。口为一圈管足形成的触手所包围。现存种类有 1100 余种。</li></ul><h4 id="依据水管系统分类"><a class="header-anchor" href="#依据水管系统分类"></a>依据水管系统分类</h4><ul><li>海胆亚门（Echinozoa）：<ul><li>海旋板纲（Helicoplacoidea）†</li><li>海蛇函纲（Ophiocistioidea）†</li><li>海蒲团纲（Camptostromatoidea）†</li><li>海盘囊纲（Cyclocystoidea，也称环海林檎纲）†</li><li>海参纲（Holothuroidea）</li><li>海胆纲（Echinoidea）</li></ul></li><li>海扁果亚门（Homalozoa）† ：<ul><li>海桩纲（Stylophora）†</li><li>海笔纲（Homostelea）†</li><li>海箭纲（Homoiostelea）†</li><li>栉海林檎纲（Ctenocystoidea）†</li></ul></li><li>海百合亚门（Crinozoa）：<ul><li>海百合纲（Crinoidea）</li><li>海林檎纲（Cystoidea）†</li><li>拟海百合纲（Paracrinoidea）†</li><li>始海百合纲（Eocrinoidea）†</li><li>海蕾纲（Blastoidea）†</li><li>拟海蕾纲（Parablastoidea）†</li><li>垫海蕾纲（Edrioblastoidea）†</li><li>海座星纲（Edrioasteroidea）†</li><li>鳞海林檎纲（Lepidocystoidea）†</li></ul></li><li>海星亚门（Asterozoa）：<ul><li>海星纲（Asteroidea）</li><li>蛇尾纲（Ophiuroidea）</li><li>体海星纲（Somasteroidea）†</li></ul></li></ul><p>1973年斯普林克尔（J.Sprinkle）有在此基础上从海百合亚门中划分出海蕾亚门（Blastozoa），下设海蕾纲（Blastoidea）、拟海蕾纲（Parablastoidea）、海林檎纲（Cystoidea）及始海百合纲（Eocrinoidea）4纲。</p><h3 id="棘皮动物的进化地位"><a class="header-anchor" href="#棘皮动物的进化地位"></a>棘皮动物的进化地位</h3><p>棘皮动物与一般的无脊椎动物不同，它的卵裂、早期胚胎发育、中胚层的产生、体腔的形成以及骨骼由中胚层产生等，都与脊索动物有相同的地方，而不同于无脊椎动物。从成体口的形成和肛门的形成看，棘皮动物也与脊椎动物相同，所以棘皮动物与脊椎动物都属于后口动物。基于以上事实，科学家现在普遍认为，脊索动物与棘皮动物有共同的祖先。</p><h2 id="化石分析演化历史"><a class="header-anchor" href="#化石分析演化历史"></a>化石分析演化历史</h2><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/1.4hhmjjeama20.svg" alt="棘皮动物演化关系图"></p><h3 id="与半索动物的分别"><a class="header-anchor" href="#与半索动物的分别"></a>与半索动物的分别</h3><p>有研究通过对现存的生物进行基因组测序，通过生物信息学分析，得出棘皮动物门和半索动物门的分开大概在 5.3 亿年前的前寒武纪时期。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.2p55tzf01j00.png" alt="image"></p><blockquote><p>The sea cucumber genome provides insights into morphological evolution and visceral regeneration. <a href="https://doi.org/10.1371/journal.pbio.2003790">DOI 链接</a>】</p></blockquote><p>在寒武纪的化石群中发现了一些难以归类的动物化石，具有一些后口动物的特征命名为 Ctenoimbricata 其中有一个生物名为爬胃虫（<em>Herpetogaster collinsi</em>）化石以及复原图如下，此外还有澄江化石群的长柄火炬虫（<em>Phlogites longus</em>）【<a href="https://figshare.com/articles/figure/_Phlogites_longus_from_the_Lower_Cambrian_Chengjiang_biota_/531245">参考链接</a>】</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.za063wx1w1s.png" alt="爬胃虫"></p><p>通过图片我们可以了解到，此时这种生物是两侧对称，头部有着触手，可能是用于捕获海里的浮游生物，而基部有着类似管状的“脚”，可能是用于固着在海床中。如果觉得抽象，幸运的是现存一种名为海苹果（<em>Pseudocolochirus violaceus</em>）的海参，有着类似的滤食行为。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/海苹果.63qik8szmd80.jpg" alt="海苹果" style="object-fit: cover; border-radius: 10px; width: 50%;" /><p>顺便放一段海苹果的进食视频</p><div class="tag link"><a class="link-card" title="海苹果进食" href="https://www.bilibili.com/video/BV1Rs411p73A"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">海苹果进食</p><p class="url">https://www.bilibili.com/video/BV1Rs411p73A</p></div></a></div><blockquote><p>需要注意的是，这里使用海苹果只是作为演示，不能作为海苹果与爬胃虫之间的进化关系的证明，也不代表爬胃虫的进食方式和海苹果一样。</p></blockquote><h3 id="然后寒武纪来了"><a class="header-anchor" href="#然后寒武纪来了"></a>然后寒武纪来了</h3><p>寒武纪来了，生命大爆发，这一时期的生物有一个特点就是有壳和一定的骨骼，可能因为地质变动，为海洋带来了大量的碳酸钙，同时也是因为有了壳的保护，才能适应当时的竞争环境得以生存。也正因为壳和骨骼的存在，也相对容易的通过化石遗迹保留下来，得以我们去窥看 5 亿多年前的初代目。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4pox3z79k5y0.png" alt="image"></p><blockquote><p>图片来自于：Plated Cambrian Bilaterians Reveal the Earliest Stages of Echinoderm Evolution 【<a href="https://doi.org/10.1371/journal.pone.0038296">DOI 链接</a>】</p></blockquote><p>海笔纲动物的消化道已经扭转了 90 度，肛门转到体侧，所以那条像是尾巴的东西并不是长在身体的“后”部。</p><p>海箭纲的消化道发生了扭转，在口和肛门附近都有一根介于像是“须腕”或者“尾巴”的东西，口旁的也许有辅助进食的功能，肛门旁的可能固定身体或者爬行。</p><p>海桩纲动物的身体结构分为两种：左边一种保留了更多两侧对称的特征，可以在海底自由爬行。它们有一根分段的须腕，口生在须腕的前段和后段之间；右边的完全不对称，基本营固着生活。海桩纲不同于其他棘皮动物的另一个特征是具有类似鳃裂的结构，它们也许就是用口吸入海水，再从鳃裂流出，过滤其中的食物。这种进食方式倒是典型的后口动物式的。</p><p>这些棘皮动物一是打破了两侧对称的构型，外部器官和内脏都发生偏转，身体越长越“歪”；二是除了“身体”之外，在身体侧方，以及口或肛门的附近还延伸出一些类似附肢的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.um0wk3ysoow.png" alt="image"></p><p>这里列出的早期的棘皮动物化石，看到它们只能一脸问号，难以相信它们是刚刚分化的近亲。虽然外表差异极大，但冷静下来它们还是有一定的共同之处</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%877.3vzej82jji00.png" alt="图片7"></p><p>就比如图中红色部分：步带沟；蓝色和绿色部分：体盘；黄色部分：茎和固着器。基本的部件都还有。</p><p>个人认为，在寒武纪这个神奇的世中，棘皮动物和三叶虫这类节肢动物选择了底栖生活，一方面说明海底确实有着足够的食物支持生长，但海旋板纲、海座星纲、始海百合纲它们的嘴是朝上，并且固着在海底，可能通过步带沟将食物送入嘴中。</p><h3 id="百「花」齐放——海百合亚门"><a class="header-anchor" href="#百「花」齐放——海百合亚门"></a>百「花」齐放——海百合亚门</h3><p>海百合亚门，在富含浮游生物的海水滋养下，这类滤食动物异常繁盛。它们的萼上丛生着多达数十条羽状的修长须腕，在海水中有节奏地舒卷张合，把经过的浮游生物送入口中。它的茎由数十段骨片连结而成，骨片之间可以弯曲扭转，使得海百合极其坚韧而又灵活。群集的海百合在海流中起伏摇荡，组成壮观的水下花潮。无数的三叶虫，甲壳类和无颌鱼类在花海中穿梭；细小的海螺，海星和海蛇尾攀附在海百合上，成为海洋生物的一片绿洲。在海百合的冲击下，始海百合类逐渐衰落，最终淡出了历史舞台。</p><p>海百合是古生代和中生代海相沉积层中最丰富的化石类群之一。海百合死后，肌体腐烂，萼部和茎部会分离解体，由于形状和重量的差别，被海水挟带，经常会沉积在不同地方，分别形成数量可观的化石群。茎部骨板是圆形的薄片，中央有五角形的空洞，成堆形成的化石像是一串串的古代钱币。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.3hgj140momk.png" alt="image"></p><p>海百合纲一直延续到 4 亿 5000 万年后，成为现存棘皮动物中唯一的固着滤食类群。</p><p>因其骨化骨骼，在不同的时期可以看到夺目的身姿，下图展示了，不同时期的海百合的种类数目变化</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.9dg9ylbvjtw.png" alt="海百合数目变化"></p><p>可以看到，古生代的海百合种类最多也是海百合最繁盛的时期，但在二叠纪生物大灭绝后，只有少量海百合幸存了下来，但生命力顽强的它们又逐渐的恢复，现存至今。</p><p>海百合虽过着滤食生活，但在演化史中也出现过多种生活形式。下图是奥陶纪和至留纪时期的海百合化石复原图，它们有着较长的茎，吸附于海底中或缠绕于珊珊等生物上。固着是它们的基本形式，而有着较长的茎一方面在进食上有着优势，另一方面也可以减少一些在海底的生物攻击其体盘。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/OrdovicianCrinoidReconstruction.png" alt="奥陶纪海百合复原图"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.68e03qyd9n80.png" alt="志留纪海百合复原图"></p><p>在泥盆纪更出现了一些具有主动捕食形式的海百合，© <a href="https://doi.org/10.4202/app.2010.0020">Jan Bohatý</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4fxw8nbk0os0.png" alt="泥盆纪海百合复原图"></p><p>在侏罗纪出现了，可以固着在漂浮物上的海百合，其中可能原因是植物数组貌似，洪水泛滥将枝干冲入海中，有了这个先天条件，能固着在漂浮物中上的海百合有了一定的被动移动的能力，被选择保留下来自然也不意外。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1pl4ofwlcojk.png" alt="侏罗纪海百合复原图"></p><p>在白垩纪，出现了一种脱离固定的一条演化路线，它们就如同水母一般，可能用其滤食的腕足，拨动海水游动。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.4ipn0x2roae0.png" alt="白垩纪海百合"></p><p>目前现存的海百合在中也存在固着和可以游动（但运动能力有限，可以称为半附着）的这两类海百合，但已经不如古生代时期海底花园那样繁盛。</p><blockquote><p>图片来自于：<a href="http://www.fossilcrinoids.com/index.html">fossilcrinoids.com</a></p></blockquote><h3 id="不「走」寻常路——海星亚门"><a class="header-anchor" href="#不「走」寻常路——海星亚门"></a>不「走」寻常路——海星亚门</h3><p>海星亚门可能起源于类似海座星纲的生物，海座星纲生物过着固定的滤食生活，口是朝上的，用着步带沟将食物送入嘴中，我们知道，固着有着局限性，在环境好时可以躺平，但环境一旦恶劣也难逃灭绝之难。</p><p>说起来也是神奇，这时候这类生物想要突破怎么办，基本的框架都已经搭建好了，突然变成“派大星”也十分困难，但它们翻了个身子就解决了这个问题，用曾经灵活的“舌头”来走路，在这个竞争激烈的环境中，能动对于不能动简直就是降维打击。同时，由于腕上有吸盘，可以打开贝壳，海星也走上了捕食者的道路。</p><h3 id="两个极端的「胜利」——海胆亚门"><a class="header-anchor" href="#两个极端的「胜利」——海胆亚门"></a>两个极端的「胜利」——海胆亚门</h3><p>海参和海胆它们作为进化关系的兄弟，你可能会诧异，这两个家伙现在一点都不像啊，但它们在寒武纪时期就分道扬镳至少有 4.7 亿年，两者选择了不同的进化路线，一个害怕疼就全点防御，海参选择了躺平挨打，但在它们之间有一个类海蛇函纲的生物</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/image.1mo60vhi54ps.png" alt="海蛇函"></p><p>它们可能选择了中间的道路，好不容易挺过二叠纪大灭绝但可能因为环境的改变淡出了历史舞台，而看似胜利的海参和海胆终究逃不过人类的餐桌（误）</p><p>海胆点满了防御，海参则点满了回血和控制。</p><p>海参在遇到危险时，将自己的一部分内脏吐出来，一方面可以缠绕对方，另一方面可以给对方吃，吃饱了也就不攻击本体，而海参通过较强的恢复能力再生。此外，海参还可以通过改变自身的颜色，来较少被发现了可能。</p><h2 id="为什么棘皮动物能存活下来"><a class="header-anchor" href="#为什么棘皮动物能存活下来"></a>为什么棘皮动物能存活下来</h2><p>在经历过大大小小的生物大灭绝事件后，棘皮动物仍在海洋中占着一席之地，更加不可思议的是它们演化出在千变万化的身体形态，但在生活习性上却十分保守，绝大多数过着底栖的生活，未曾涉足陆地和淡水。你可能认为它们“不思进取”，这固然有些道理，没有较大的选择压力，大家在海底“躺平”生活相安无事。我个人认为其关键点有以下几个：</p><ul><li>适应范围广，棘皮动物从深海到浅海，都有分布，并且是广泛分布，正所谓不要把鸡蛋放到一个篮子里，在生物灭绝中，一部分原因可能是没有波及到，但更多的原因可能是其拥有较高的适应能力存活下来。</li><li>再生能力强，面对攻击“缺胳膊少腿”，对于棘皮动物来说只是家常便饭，这种壁虎断尾式的生存方式，无疑保全自身东山再起，更有甚者仅通过断臂就可“克隆”自己。</li><li>辐射对称妙，大自然的规律告诉了我们，这个世界的两侧对称动物的世界，但棘皮动物辐射对称一定程度上限制了其演化的上限，像海参通过“拉长”自己，使自己看起来两侧对称，但实际还是辐射对称。虽然上限低，但辐射对称也有一定好处，除了上述收到攻击时“缺胳膊少腿”时可以多些“胳膊”和“腿”，再遗传变异中多些或少些“胳膊”和“腿”都没太大问题。辐射对称起初是为了滤食而生，定了这个基调，却能演化出千奇百怪的用途，不禁感叹自然的鬼斧神工。</li></ul><blockquote><p>这里引出一个问题：为什么海星通常有五条腕？五辐对称在自切上有优势，通过选择中就被保留了下来。</p></blockquote><h2 id="话题外"><a class="header-anchor" href="#话题外"></a>话题外</h2><h3 id="「派大星」"><a class="header-anchor" href="#「派大星」"></a>「派大星」</h3><p>2021 年 3 月 19 日，全球权威海洋生物学数据库《世界海洋生物目录》发布了 <a href="https://lifewatch.be/en/worms-top10-2020">2020 年度「十大海洋新物种」名单</a>，深海海星新物种 Astrolirus patricki Zhang Zhou, Xiao &amp; Wang, 2020 （中文名又称「派大星」背板海星）入选了 2020 年度「十大海洋新物种」名单。这一新物种的命名者是从小看《海绵宝宝》长大的 90 后博士研究生张睿妍，她表示，「派大星」背板海星目前所发现的所有标本全部都栖息于海绵之上，就像海绵宝宝与派大星一样，是一对难舍难分的「铁哥们」。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-d@master/%E5%9B%BE%E7%89%873.27uo7ocvdt7o.png" alt="十大海洋新物种"></p><blockquote><p>发表文章：A new sponge-associated starfish, Astrolirus patricki sp. nov. (Asteroidea: Brisingida: Brisingidae), from the northwestern Pacific seamounts 【<a href="https://doi.org/10.7717/peerj.9071">DOI 链接</a>】</p></blockquote><hr><p>未完待续。。。</p><h2 id="文献资料"><a class="header-anchor" href="#文献资料"></a>文献资料</h2><p>Weighted gene co-expression network analysis reveals potential genes involved in early metamorphosis process in sea cucumber <em>Apostichopus japonicus</em></p><p>加权基因共表达网络分析揭示了参与海参早期变态过程的潜在基因</p><p>Sea cucumbers, one main class of Echinoderms, have a very fast and drastic metamorphosis process during their development. However, the molecular basis under this process remains largely unknown. Here we systematically examined the gene expression profiles of Japanese common sea cucumber (<em>Apostichopus japonicus</em>) for the first time by RNA sequencing across 16 developmental time points from fertilized egg to juvenile stage. Based on the weighted gene co-expression network analysis (WGCNA), we identified 21 modules. Among them, MEdarkmagenta was highly expressed and correlated with the early metamorphosis process from late auricularia to doliolaria larva. Furthermore, gene enrichment and differentially expressed gene analysis identified several genes in the module that may play key roles in the metamorphosis process. Our results not only provide a molecular basis for experimentally studying the development and morphological complexity of sea cucumber, but also lay a foundation for improving its emergence rate.</p><p>海参是棘皮动物的主要种类之一，在其发育过程中有一个非常迅速和剧烈的变态过程。然而，这一过程的分子基础在很大程度上仍然未知。本研究首次对日本普通海参（Apostichopus japonicus）受精卵至幼期 16 个发育时间点的基因表达谱进行了系统分析。基于加权基因共表达网络分析（WGCNA），我们鉴定出 21 个模块。其中，MEdarkmagenta 表达量高，且与耳状幼虫至海参形幼虫的早期变态过程相关。此外，基因富集和差异表达基因分析确定了模块中几个可能在变态过程中起关键作用的基因。本研究结果不仅为实验研究海参的发育和形态复杂性提供了分子基础，而且为提高海参的出苗率奠定了基础。</p><div class="tag link"><a class="link-card" title="DOI 链接" href="https://doi.org/10.1016/j.bbrc.2017.11.154"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">DOI 链接</p><p class="url">https://doi.org/10.1016/j.bbrc.2017.11.154</p></div></a></div><hr><p>Echinoderm systems for gene regulatory studies in evolution and development</p><p>在进化和发育中用于基因调控研究的棘皮系统</p><p>One of the main challenges in Evolutionary Developmental Biology is to understand to which extent developmental changes are driven by regulatory alterations in the genomic sequence. In the recent years, the focus of comparative developmental studies has moved towards a systems biology approach providing a better understanding of the evolution of gene interactions that form the so called Gene Regulatory Networks (GRN). Echinoderms provide a powerful system to reveal regulatory mechanisms and within the past decade, due to the latest technological innovations, a great number of studies have provided valuable information for comparative GRN analyses. In this review we describe recent advances in evolution of GRNs arising from echinoderm systems, focusing on the properties of conserved regulatory kernels, circuit cooption events and GRN topological rearrangements.</p><p>进化发育生物学的主要挑战之一是理解发育变化在多大程度上是由基因组序列的调节改变驱动的。近年来，比较发育研究的重点已经转向系统生物学的方法，以更好地理解形成所谓的基因调控网络（GRN）的基因相互作用的进化。棘皮动物提供了一个强大的系统来揭示调节机制，在过去的十年中，由于最新的技术创新，大量的研究为 GRN 的比较分析提供了有价值的信息。本文综述了棘皮系统中 GRN 的进化研究进展，主要包括保守调控核的性质、回路合作事件和 GRN 拓扑重排。</p><!-- 1-s2.0-S0959437X16300661-main.pdf --><hr><p>New discoveries of Cambrian pelmatozoan echinoderm ossicles from North China</p><p>来自华北地区的寒武纪棘皮动物有柄亚目听骨的新发现</p><p>A variety of echinoderm ossicles have been discovered in the middle to upper Cambrian rocks of the North China Craton. Material was collected from two localities: Shuangqiao (SQ)section (Paibian) in Hebei Province and Linyi (LY) (Guzhangian?–Paibian?) in Shandong Province. Six types of ossicles can be recognized, including rounded thecal plates, and columnals with a narrow lumen and ridged articulating facets. The combination of characters suggests an unknown stalked echinoderm, probably an eocrinoid, with relatively advanced columnal morphology.</p><!-- 1-s2.0-S1871174X15000438-main.pdf --><hr><p>The earliest scientific descriptions of Chinese fossil echinoderms in a late nineteenth-century publication by Lajos Lóczy (Ludwig von Lóczy)</p><p>对中国棘皮动物化石的最早科学描述是在19世纪后期</p><!-- 1-s2.0-S1871174X15000682-main.pdf --><hr><p>Fossil Echinoderm Studies in China and other countries: Historical and new perspectives</p><p>中国和其他国家的化石棘皮动物研究:历史和新视角</p><!-- 1-s2.0-S1871174X15000888-main.pdf --><hr><p>The onset of the Ordovician evolutionary radiation of benthic animals in the Baltic Region: Explosive diversity of attachment structures of stalked echinoderms, substrate revolution and the role of cyanobacterial communities</p><p>奥陶纪底栖动物进化辐射的开始波罗的海地区:有柄棘皮动物附着结构的爆炸性多样性，底物革命和蓝藻群落的作用</p><p>The study of the Ordovician holdfasts of the Baltic Paleobasin revealed an explosive increase in the morphological diversity of echinoderms of the Baltic Paleobasin, up to 12 major morphological types in the Volkhov Regional Stage (Dapingian), reflecting an explosive growth in the taxonomic and morphological diversity of stalked echinoderms in general, but primarily crinoids. A sudden increase in the size and diversity of holdfasts at that time suggests a considerable increase in calcite production by stalked echinoderms and their adaptation to a wide distribution of a new type of substrate — hardgrounds and firm coarse-grained bioclastic substrates. The possibility of wide distribution of such substrates was due to a considerable increase, of at least an order of magnitude, in the carbonate productivity of benthic communities, whereas the rapid distribution of a new type of substrate and an explosive increase in the diversity and abundance of their inhabitants in the Baltic Basin was related to the appearance of positive feedbacks between the living and non-living components of this ecosystem. The existence of this positive feedback was due to cyanobacterial communities, the development of a biofilm on the substrate, and mineralization of an extracellular polymer substance, which led to the formation of hardgrounds and consolidation of the surface of the bioclastic substrates. The appearance in the Middle Ordovician of positive feedback between the expansion of the bioclastic substrates and an increase in carbonate production by their inhabitants, resulted in the Ordovician substrate revolution and explosive diversification of Ordovician benthic animals. Cyanobacterial films episodically appearing on the substrate, were an essential factor in the formation of this feedback.</p><p>研究显示奥陶纪的波罗的海古盆地显示了波罗的海古盆地棘皮动物形态多样性的爆炸性增长，在沃尔霍夫区域阶段(大坪阶)，有 12 种主要的形态类型，反映了有柄棘皮动物的分类和形态多样性的爆炸性增长，但主要是海百合。</p><!-- 1-s2.0-S1871174X18300489-main.pdf --><hr><p>Evolution of Caribbean echinoderms during the Cenozoic: moving towards a complete picture using all of the fossils</p><p>加勒比地区新生代棘皮动物的演化:利用所有的化石走向完整的画面</p><!-- 1-s2.0-S003101820000208X-main.pdf --><hr><p>Echinoderm development and evolution in the post-genomic era</p><p>后基因组时代的棘皮动物的发展和进化</p><p>The highly recognizable animals within the phylum Echinodermata encompass an enormous disparity of adult and larval body plans. The extensive knowledge of sea urchin development has culminated in the description of the exquisitely detailed gene regulatory network (GRN) that governs the specification of various embryonic<br>territories. This information provides a unique opportunity for comparative studies in other echinoderm taxa to understand the evolution and developmental mechanisms underlying body plan change. This review focuses on recent work that has utilized new genomic resources and systems-level experiments to address questions of<br>evolutionary developmental biology. In particular, we synthesize the results of several recent studies from various echinoderm classes that have explored the development and evolution of the larval skeleton, which is a major feature that distinguishes the two predominant larval subtypes within the Phylum. We specifically<br>examine the ways in which GRNs can evolve, either through cis regulatory and/or protein-level changes in transcription factors. We also examine recent work comparing evolution across shorter time scales that occur within and between species of sea urchin, and highlight the kinds of questions that can be addressed by these comparisons. The advent of new genomic and transcriptomic datasets in additional species from all classes of echinoderm will continue to empower the use of these taxa for evolutionary developmental studies.</p><p>棘皮动物门内的高度可识别的动物包括一个巨大的差异的成虫和幼虫的身体计划。关于海胆发育的广泛知识已经达到了顶峰，详细的基因调控网络(GRN)的描述，管理各种胚胎领土的规格。这一信息为其他棘皮类的比较研究提供了独特的机会，以了解体平面变化的进化和发育机制。本文综述了近年来利用新的基因组资源和系统水平的实验来解决进化发育生物学的问题。特别是，我们综合了最近几项来自不同种类的棘皮动物的研究结果，这些研究探索了幼虫骨骼的发展和进化，这是区分该门中两种主要的幼虫亚型的主要特征。我们特别研究了grn可以通过顺式调控和/或转录因子的蛋白水平变化进化的方式。我们还研究了最近的研究，比较了海胆物种内部和物种之间在较短时间内发生的进化，并强调了通过这些比较可以解决的问题。新的基因组和转录组数据集的出现，将继续授权使用这些类群的进化发展研究</p><!-- 1-s2.0-S0012160616305747-main.pdf --><hr><p>The Cambrian Substrate Revolution and the early evolution of attachment in suspension-feeding echinoderms</p><p>寒武纪基质革命与悬浮取食棘皮动物附着的早期进化</p><p>The Cambrian, characterized by the global appearance of diverse biomineralized metazoans in the fossil record for the first time, represents a pivotal point in the history of life. This period also documents a major change in the nature of the sea floor: Neoproterozoic-type substrates stabilized by microbial mats were replaced by unconsolidated soft substrates with a well-developed mixed layer. The effect of this transition on the ecology and evolution of benthic metazoans is termed the Cambrian Substrate Revolution (CSR), and this is thought to have<br>impacted greatly on early suspension-feeding echinoderms in particular. According to this paradigm, most echinoderms rested directly on non-bioturbated soft substrates as sediment attachers and stickers during the Cambrian Epoch 2. As the substrates became increasingly disturbed by burrowing, forming a progressively<br>thickening mixed layer, echinoderms developed new strategies for attaching to firm and hard substrates. To test this model, we evaluated the mode of attachment of 83 Cambrian suspension-feeding echinoderm species; attachment mode was inferred based on direct evidence in fossil specimens and interpretations of functional<br>morphology. These data were analyzed quantitatively to explore trends in attachment throughout the <a href="http://Cambrian.In">Cambrian.In</a> contrast to previous studies, the majority of Cambrian clades (eocrinoids, helicoplacoids, helicocystoids,isorophid edrioasteroids, and solutes) are now interpreted as hard (shelly) substrate attachers. Only early<br>edrioasteroids attached directly to firm substrates stabilized by microbially induced sedimentary structures.Contrary to the predictions of the CSR paradigm, our study demonstrates that Cambrian echinoderms were morphologically pre-adapted to the substrate changes that occurred during the Cambrian, allowing them to fully<br>exploit the appearance of hardgrounds in the Furongian. We find no support for the claim that the CSR explains the peak in echinoderm diversity during Cambrian Epochs 2–3, or that it caused the extinction of helicoplacoids.</p><p>寒武纪首次在化石记录中以生物矿化的后生动物在全球范围内的出现为特征，代表了生命历史的一个关键点。这一时期也记录了海底性质的一个重大变化:由微生物垫稳定的新元古代类型的基岩被松散的软基岩所取代，后者具有发育良好的混合层。这种转变对底栖后生动物的生态和进化的影响被称为寒武纪底栖动物的进化(CSR)，这被认为对早期悬浮取食的棘皮动物有很大的影响。根据这一范式，在寒武纪第2期，大多数棘皮动物直接依附在非生物扰动的软基质上作为沉积物附着剂和贴纸。由于挖洞对基质的干扰越来越大，形成了一个逐渐增厚的混合层，棘皮动物开发了附着在坚硬基质上的新策略。为了验证该模型，我们对寒武系83种悬浮取食的棘皮动物的附着模式进行了评估;根据化石标本的直接证据和功能形态解释推断附着模式。对这些数据进行了定量分析，以探讨整个寒武纪的附着趋势。与以前的研究相比，寒武纪的大多数支系(类蠕形纲、类螺旋形纲、类螺旋形纲、类等蛾类流星体和溶质)现在被解释为坚硬的(壳类)基质附着体。只有早期的涡旋小行星直接附着在由微生物引起的沉积构造稳定的坚实基质上。与CSR模式的预测相反，我们的研究表明，寒武纪的棘皮动物在形态上预先适应了寒武纪发生的基质变化，使它们能够充分利用弗隆纪的硬地。我们没有发现支持CSR解释寒武纪棘皮动物多样性高峰的说法，或者它导致螺旋形类动物的灭绝。</p><!-- 1-s2.0-S0012825217301265-main.pdf --><hr><p>Fossil echinoderms from the Carboniferous Limestone sea defence blocks at Barton-on-Sea, Hampshire, southern England</p><p>来自英国南部汉普郡巴顿-on- sea石炭纪石灰岩海防御区块的棘皮动物化石</p><!-- 1-s2.0-S0016787803800317-main.pdf --><hr><p>Diversity patterns and biostratigraphy of Cenozoic echinoderms from Florida</p><p>佛罗里达新生代棘皮动物多样性模式与生物地层学</p><!-- 1-s2.0-S0031018200002091-main.pdf --><hr><p>Palaeogeographical and palaeoecological aspects of the Cambro^Ordovician radiation of echinoderms in Gondwanan Africa and peri-Gondwanan Europe</p><p>非洲冈瓦南地区和欧洲冈瓦南周边地区寒武系和奥陶系棘皮动物辐射的古地理和古生态特征</p><!-- 1-s2.0-S0031018203003031-main.pdf --><hr><p>⭐Evolutionary palaeoecology of early epifaunal echinoderms:Response to increasing bioturbation levels during the Cambrian radiation</p><p>早期深层棘皮动物的进化古生态学:寒武纪辐射期间生物扰动水平增加的响应</p><!-- 1-s2.0-S0031018205006942-main.pdf --><hr><p>⭐ Changes in the Early Palaeozoic geography as a possible factor of echinoderm higher taxa formation: Delayed larval development to cross the Iapetus Ocean</p><p>早期古生代的地理变化可能是棘皮动物高级类群形成的因素:穿越伊阿佩托斯洋的幼虫发育延迟</p><!-- 1-s2.0-S0031018206003609-main.pdf --><hr><p>⭐⭐ Climate changes in the Early to Middle Miocene of the Central Paratethys and the origin of its echinoderm fauna</p><p>中新世早期至中新世中期的气候变化中央副穴居动物及其棘皮动物群的起源</p><!-- 1-s2.0-S0031018207002003-main.pdf --><hr><p>⭐⭐ Settling strategy of stalked echinoderms from the Kaili Biota (middle Cambrian), Guizhou Province, South China</p><p>贵州凯里生物区中寒武世有柄棘皮动物的定居策略</p><!-- 1-s2.0-S0031018207004567-main.pdf --><hr><p>⭐ The absence of echinoderms from the Lower Cambrian Chengjiang fauna of China: Palaeoecological and palaeogeographical implications</p><p>中国下寒武统澄江动物群中棘皮动物的缺失:古生态学和古地理意义</p><!-- 1-s2.0-S0031018210000027-main.pdf --><hr><p>⭐ Palaeoecological aspects of the diversification of echinoderms in the Lower Ordovician of central Anti-Atlas, Morocco</p><p>摩洛哥中央反阿特拉斯下奥陶统棘皮动物多样性的古生态学方面</p><!-- 1-s2.0-S0031018216001395-main.pdf --><hr><p>The mechanically adaptive connective tissue of echinoderms: Its potential for<br>bio-innovation in applied technology and ecology</p><p>棘皮动物的机械适应性结缔组织:在应用技术和生态学方面的生物创新潜力</p><!-- 1-s2.0-S0141113611000894-main.pdf --><hr><p>⭐⭐ Complete mitochondrial genome of the sea cucumber Apostichopus japonicus (Echinodermata: Holothuroidea): The first representative from the subclass Aspidochirotacea with the echinoderm ground pattern</p><p>海参(Apostichopus japonicus)线粒体全基因组:棘皮海参亚纲中第一个具有棘皮基部图案的海参亚纲代表</p><!-- 1-s2.0-S0378111909001358-main.pdf --><hr><p>⭐⭐ Phylogenomic Resolution of the Hemichordate and Echinoderm Clade</p><p>半棘皮类和棘皮类的系统基因组解析</p><!-- 1-s2.0-S0960982214012925-main.pdf --><hr><p>⭐ Evolution of mitochondrial gene orders in echinoderms</p><p>棘皮动物线粒体基因顺序的进化</p><!-- 1-s2.0-S1055790307004186-main.pdf --><hr><p>⭐ Do echinoderm genomes measure up?</p><p>棘皮动物的基因组符合标准吗?</p><!-- 1-s2.0-S1874778715000148-main.pdf --><hr><p>⭐⭐ Evolution: Mapping Out Early Echinoderms</p><p>进化:绘制早期棘皮动物图谱</p><!-- 10.1016@j.cub.2020.05.013.pdf --><hr><p>⭐⭐ Global Diversity of Brittle Stars (Echinodermata: Ophiuroidea)</p><p>海蛇尾全球的多样性</p><hr><p>⭐⭐⭐ Genomic insights of body plan transitions from bilateral to pentameral symmetry in Echinoderms</p><p>棘皮动物的体平面从双侧对称到五侧对称的基因组洞见</p><p>Echinoderms are an exceptional group of bilaterians that develop pentameral adult symmetry from a bilaterally symmetric larva. However, the genetic basis in evolution and development of this unique transformation remains to be clarified. Here we report newly sequenced genomes, developmental transcriptomes, and proteomes of diverse echinoderms including the green sea urchin (L. variegatus), a sea cucumber (A. japonicus), and with particular emphasis on a sister group of the earliest-diverged echinoderms, the feather star (A. japonica). We learned that the last common ancestor of echinoderms retained a well-organized Hox cluster reminiscent of the hemichordate, and had gene sets involved in endoskeleton<br>development. Further, unlike in other animal groups, the most conserved developmental stages were not at the body plan establishing phase, and genes normally involved in bilaterality appear to function in pentameric axis development. These results enhance our understanding of the divergence of protostomes and deuterostomes almost 500 Mya.</p><p>棘皮动物是一种特殊的双侧动物，从两侧对称的幼虫发展成五辐对称的成体。然而，这一独特转化的遗传基础在进化和发展仍有待澄清。本文报道了包括绿海胆(L. variegatus)、海参(a . japonicus)在内的多种棘皮动物的基因组、发育转录组和蛋白质组的最新测序结果，并重点报道了最早分化的棘皮动物的一个兄弟类群——羽星(a . japonica)。我们了解到，棘皮动物的最后一个共同祖先保留了一个组织良好的Hox簇，让人联想到半棘虫，并有参与内骨骼发育的基因集。此外，与其他动物不同的是，最保守的发育阶段并不是在身体计划建立阶段，通常参与双向性的基因似乎在五聚体轴的发育中发挥作用。这些结果加深了我们对近500米亚原口动物和后口动物差异的认识。</p><!-- s42003-020-1091-1.pdf --><hr><p>Echinoderm Phylogeny: Morphology and Molecules Approach Accord</p><p>棘皮动物的发展史: 形态学和分子方法一致</p><!-- smith1992.pdf --><hr><p>Echinoderms (Other Than Echinoids)</p><p>棘皮类动物(海胆类除外)</p><!-- smith2005.pdf -->]]></content>
    
    
      
      
    <summary type="html">&lt;details &gt;&lt;summary&gt; 主要参考资料 &lt;/summary&gt;
              &lt;div class=&#39;content&#39;&gt;
              &lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;寒武</summary>
      
    
    
    
    <category term="生物学" scheme="https://halo123.top/categories/%E7%94%9F%E7%89%A9%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>数据的表示和运算</title>
    <link href="https://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"/>
    <id>https://halo123.top/2021/05/26/ComputerComposition/B-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/</id>
    <published>2021-05-26T11:56:05.000Z</published>
    <updated>2021-05-30T08:49:35.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数制与编码"><a class="header-anchor" href="#数制与编码"></a>数制与编码</h2><p>在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：</p><ol><li>二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示 0 和 1。</li><li>二进制位 1 和 0 正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。</li><li>二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。</li></ol><h3 id="进位计数法"><a class="header-anchor" href="#进位计数法"></a>进位计数法</h3><p>进位计数法是一种计数的方法。常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。</p><p>在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 10（0 ~ 9），每个数位计满 10 就向高位进位，即“逢十进一”。十进制数 101，其个位的 1 显然与百位的 1 所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。</p><p>一个 $r$ 进制数（$K_{n} K_{n-1} \cdots K_{0} K_{-1} \cdots K_{-m}$）的数值可表示为：$$K_{n} r^{n}+ K_{n-1} r^{n-1} + \cdots + K_{0} r^{0} + K_{-1} r^{-1} + \cdots + K_{-m} r^{-m} = \sum_{i=n}^{-m} K_{i} r^{i}$$式中，$r$ 是基数；$r^{i}$ 是第 $i$ 位的位权（整数位最低规定为第 0 位）；$K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。</p><ul><li>二进制。计算机中用得最多的是基数为 2 的计数制，即二进制。二进制只有 0 和 1 两种数字符号，计数“逢二进一”。它的任意数位的权为 $2^{i}$，$i$ 为所在位数。</li><li>八进制。八进制作为二进制的一种书写形式，其基数为 8，有 0 ~ 7 共 8 个不同的数字符号，计数“逢八进一”。因为 $r=8=2^{3}$，所以只要把二进制中的 3 位数码编为一组就是一位八进制数码，两者之间的转换极为方便。</li><li>十六进制。十六进制也是二进制的一种常用书写形式，其基数为 16，“逢十六进一”。 每个数位可取 0 ~ 9、A、B、C、D、E、F 中的任意一个，其中 A、B、C、D、E、F 分别表示 10 ~ 15。因为 $r=16=2^{4}$，因此 4 位二进制数码与 1 位十六进制数码相对应。</li></ul><h3 id="不同进制数之间的相互转换"><a class="header-anchor" href="#不同进制数之间的相互转换"></a>不同进制数之间的相互转换</h3><p>（1）二进制数转为八进制数和十六进制数</p><p>对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。</p><ul><li>其整数部分，从小数点开始往左数，将一串二进制数分为 3 位（八进制）一组或 4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；</li><li>对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为 3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。</li></ul><p>同样，由八进制数或十六进制数转换成二进制数， 只需将每位改为 3 位或 4 位二进制数即可（必要时去掉整数最高位或小数最低位的 0）。</p><p>八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较为方便。</p><p>（2）任意进制数转换为十进制数</p><p>将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。</p><p>（3）十进制数转换为任意进制数</p><p>一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分用除基取余法，对小数部分用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。</p><ul><li>除基取余法（整数部分的转换）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为 0 时结束。</li><li>乘基取整法（小数部分的转换）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为 1.0 （或满足精度要求）时结束。</li></ul><p>例如将十进制数 123.6875 转换成二进制数：</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E8%BF%9B%E5%88%B6%E6%95%B0.png" alt="十进制数转换为任意进制数"></p><p>因此整数部分 123 = (1111011)<sub>2</sub> ，小数部分 0.6885 = (0.1011)<sub>2</sub> ，所以 123.6875 = (1111011.1011)<sub>2</sub></p><blockquote><p>注意：在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如 0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示。</p></blockquote><h3 id="真值和机器数"><a class="header-anchor" href="#真值和机器数"></a>真值和机器数</h3><p>在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如 +15、-8 等。这种带“+”或“-”符号的数称为真值。真值是机器数所代表的实际值。</p><p>在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。如 0,101 （这里的逗号“,”实际上并不存在，仅为区分符号位与数值位）表示 +5。这种把符号“数字化”的数称为机器数。</p><h3 id="BCD-码"><a class="header-anchor" href="#BCD-码"></a>BCD 码</h3><p>二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0 ~ 9 这 10 个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但 4 位二进制数可以组合出 16 种代码，因此必有 6 种状态为冗余状态。</p><p>下面列举几种常用的 BCD 码：</p><ol><li>8421 码（最常用）。它是一种有权码，设其各位的数值为 $b_{3}$，$b_{2}$，$b_{2}$，$b_{0}$，则权值从高到低依次为 8，4，2，1，它表示的十进制数为 $D= 8b_{3} +4b_{2} + 2b_{1}+ 1b_{0}$。如 8 → 1000；9 → 1001。若两个 8421 码相加之和小于等于 (1001)<sub>2</sub> 即 (9)<sub>10</sub>，则不需要修正；若相加之和大于等于 (1010)<sub>2</sub> 即 (10)<sub>10</sub>，则要加 6 修正（从 1010 到 1111 这 6 个为无效码，当运算结果落于这个区间时，需要将运算结果加上 6），并向高位进位，进位可以在首次相加或修正时产生。<br><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/8421%E7%A0%81%E4%BF%AE%E6%AD%A3.png" alt="8421码修正"></li><li>余 3 码。这是一种无权码，是在 8421 码的基础上加 (0011)<sub>2</sub> 形成的，因每个数都多余“3”，因此称为余 3 码。如 8 → 1011；9 → 1100。</li><li>2421 码。这也是一种有权码，权值由高到低分别为 2，4，2，1，特点是大于等于 5 的 4 位二进制数中最高位为 1，小于 5 的最高位为 0。如 5 → 1011 而非 0101。</li></ol><h3 id="字符与字符串"><a class="header-anchor" href="#字符与字符串"></a>字符与字符串</h3><p>由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。</p><p>（1）字符编码 ASCII 码</p><p>目前，国际上普遍采用的一种字符系统是 7 位二进制编码的 ASCII 码，它可表示 10 个十进制数码、52 个英文大写字母和小写字母（A ~ Z, a ~ z）及一定数量的专用符号（如 $、%、+、= 等），共 128 个字符。</p><p>在 ASCII 码中，编码值 0 ~ 31 为控制字符，用于通信控制或设备的功能控制；编码值 127 是 DEL 码；编码值 32 是空格 SP；编码值 32 ~ 126 共 95 个字符称为可印刷字符。</p><blockquote><p>提示: 0 ~ 9 的 ASCII 码值为 48 (011 0000) ~ 57 (011 1001)，即去掉高 3 位，只保留低 4 位，正好是二进制形式的 0 ~ 9。</p></blockquote><p>（2）汉字的表示和编码</p><p>在 1981 年的国家标准 GB 2312——1980 中，每个编码用两字节表示，收录了一级汉字 3755 个、二级汉字 3008 个、各种符号 682 个，共计 7445 个。</p><p>目前最新的汉字编码是 2000 年公布的国家标准 GB 18030，它收录了 27484 个汉字。编码标准采用 1 B、2 B 和 4 B。</p><p>汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码是国家标准局于 1981 年颁布的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。</p><p>国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 20 H。国标码两字节的最高位都是 0，ASCII 码的最高位也是 0。为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为“1”，这就是汉字内码。</p><p>区位码和国标码都是输入码，它们和汉字内码的关系（十六进制）如下:</p><ul><li>国标码 = (区位码)<sub>16</sub> + 2020H</li><li>汉字内码 = (国标码)<sub>16</sub> + 8080H</li></ul><h3 id="校验码"><a class="header-anchor" href="#校验码"></a>校验码</h3><p>校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。</p><p>通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。对于码距不小于 2 的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。</p><h4 id="奇偶校验码"><a class="header-anchor" href="#奇偶校验码"></a>奇偶校验码</h4><p>在原编码上加一个校验位，它的码距等于 2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，增加的冗余位称为奇偶校验位。</p><p>奇偶校验实现的方法：由若干位有效信息（如 1 B）再加上一个二进制位（校验位）组成校验码。校验位的取值（0 或 1）将使整个校验码中“1”的个数为奇数或偶数，所以有两种可供选择的校验规律。</p><ul><li>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。</li><li>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。</li></ul><p>缺点：具有局限性，奇偶校验只能发现数据代码中奇数位的出错情况，但不能纠正错误，常用于对存储器数据的检查或传输数据的检查。</p><h4 id="海明校验码"><a class="header-anchor" href="#海明校验码"></a>海明校验码</h4><p>海明码是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。根据纠错理论得：$$L- 1=D+C \ (D \ge C)$$即编码最小码距 $L$ 越大，其检测错误的位数 $D$ 越大，纠正错误的位数 $C$ 也越大，且纠错能力恒小于等于检错能力。海明码就是根据这一理论提出的具有纠错能力的一种编码。</p><p>下面用一个例子来介绍求海明码的步骤。在 $n=4$、$k=3$ 时，求 1010 的海明码。</p><p>（1）确定海明码的位数</p><p>设 $n$ 为有效信息的位数，$k$ 为校验位的位数，则信息位 $n$ 和校验位 $k$ 应满足 $$n+k \le 2^{k}-1$$ 若要检测两位错，则需再增加 1 位校验位，即 $k+1$ 位。海明码位数为 $n+k=7 \le 2^{3}-1$ 成立，则 $n$、$k$ 有效。</p><p>设信息位为 $D_{4} D_{3} D_{2} D_{1}$（1010），共 4 位，校验位为 $P_{3} P_{2} P_{1}$，共 3 位，对应的海明码为 $H_{7} H_{6} H_{5} H_{4} H_{3} H_{2} H_{1}$。</p><p>（2）确定校验位的分布</p><p>规定校验位 $P_i$ 在海明位号为 $2^{i-1}$ 的位置上，其余各位为信息位，因此有：</p><ul><li>$P_1$ 的海明位号为 $2^{i-1} = 2^{0} = 1$，即 $H_1$ 为 $P_1$。</li><li>$P_2$ 的海明位号为 $2^{i-1} = 2^{1} = 2$，即 $H_2$ 为 $P_2$。</li><li>$P_3$ 的海明位号为 $2^{i-1} = 2^{2} = 4$，即 $H_4$ 为 $P_3$。</li></ul><p>将信息位按原来的顺序插入，则海明码各位的分布如下:<br>$$<br>\begin{matrix}<br>H_{7}  &amp; H_{6}  &amp; H_{5}  &amp; H_{4}  &amp; H_{3}  &amp; H_{2}  &amp; H_{1} \\<br>D_{4}  &amp; D_{3}  &amp; D_{2}  &amp; P_{3}  &amp; D_{1}  &amp; P_{2}  &amp; P_{1}<br>\end{matrix}<br>$$</p><p>（3）分组以形成校验关系</p><p>每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。另外，校验位不需要再被校验。分组形成的校验关系如下。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E4%BD%8D.png" alt="海明码校验位"></p><p>（4）校验位取值</p><p>校验位 $P_i$ 的值为第 $i$ 组（由该校验位校验的数据位）所有位求异或（如果两个值不相同，则异或结果为 1。如果两个值相同，异或结果为 0。）。由上分组有：</p><p>$$<br>\begin{align*}<br>P_{1}=D_{1} \oplus D_{2} \oplus D_{4} = 0 \oplus 1 \oplus 1 = 0 \\<br>P_{2}=D_{1} \oplus D_{3} \oplus D_{4} = 0 \oplus 0 \oplus 1 = 1 \\<br>P_{3}=D_{2} \oplus D_{3} \oplus D_{4} = 1 \oplus 0 \oplus 1 = 0<br>\end{align*}<br>$$</p><p>所以，1010 对应的海明码为 1010010</p><p>（5）海明码的校验原理</p><p>每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成 $k$ 个校验方程：</p><p>$$<br>\begin{align*}<br>S_{1}=P_{1} \oplus D_{1} \oplus D_{2} \oplus D_{4} \\<br>S_{2}=P_{2} \oplus D_{1} \oplus D_{3} \oplus D_{4} \\<br>S_{3}=P_{3} \oplus D_{2} \oplus D_{3} \oplus D_{4}<br>\end{align*}<br>$$</p><p>若 $S_{3}S_{2}S_{1} =000$，则说明无错；否则说明出错，且这个数就是错误的位号，如 $S_{3}S_{2}S_{1} = 001$，说明第 1 位出错，即 $H_{1}$ 出错，直接将该位取反就达到纠错的目的。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%B7%E6%98%8E%E7%A0%81%E6%A0%A1%E9%AA%8C%E5%85%83%E7%B4%A0%E5%85%B3%E7%B3%BB.png" alt="海明码校验元素关系"></p><p>海明码的检错能力为 1 位，纠错能力为 2 位。通常使用时会在最头部加上“全校验位”，对整体进行偶校验：</p><ul><li>$S_{3}S_{2}S_{1} =000$ 且全体偶校验成功，无错误</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验失败，有 1 位错误，纠正即可</li><li>$S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验成功，有 2 位称为，需重传</li></ul><p>拓展：</p><div class="tag link"><a class="link-card" title="【3Blue1Brown】汉明码Pa■t1，如何克服噪■" href="https://www.bilibili.com/video/BV1WK411N7kz"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【3Blue1Brown】汉明码Pa■t1，如何克服噪■</p><p class="url">https://www.bilibili.com/video/BV1WK411N7kz</p></div></a></div><div class="tag link"><a class="link-card" title="【3Blue1Brown】汉明码part2，优雅的全貌" href="https://www.bilibili.com/video/BV1pV411y7E8"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">【3Blue1Brown】汉明码part2，优雅的全貌</p><p class="url">https://www.bilibili.com/video/BV1pV411y7E8</p></div></a></div><h4 id="循环冗余校验码"><a class="header-anchor" href="#循环冗余校验码"></a>循环冗余校验码</h4><ul><li>CRC 码的基本思想</li><li>如何构造</li><li>如何检错纠错</li></ul><p>循环冗余校验（Cyclic Redundancy Check，CRC）码的基本思想是：在 $K$ 位信息码后再拼接 $R$ 位的校验码，整个编码的长度为 $N$ 位，因此，这种编码又称 $(N,K)$ 码。</p><ul><li>数据发送、接收方约定一个“除数”</li><li>$K$ 个信息位 + $R$ 个校验位作为“被除数”，添加校验位后需保证除法的余数为 0</li><li>收到数据后，进行除法检查余数是否为 0，若余数非 0 说明出错，则进行重传或纠错</li></ul><p>CRC 码基于线性编码理论，在发送端，将要传送的 $K$ 位二进制信息码左移 $R$ 位，将它与生成多项式 $G(x)$ 做模 2 除法，生成一个 $R$ 位校验码，并附在信息码后，构成一个新的二进制码（CRC 码），共 $K+R$ 位。在接收端，利用生成多项式对接收到的编码做模 2 除法，以检测和确定出错的位置，如无错则整除，其中生成多项式是接收端和发送端的一个约定。</p><p>任意一个二进制数码都可用一个系数仅为“ 0 ”或“ 1 ”的多项式与其对应。生成多项式 $G(x)$ 的最高幂次为 $R$，转换成对应的二进制数有 $R+1$ 位。例如，生成多项式 $x^{3} + x^{2} + 1$ 对应的二进制数为 1101，而二进制数 1011 对应的多项式为 $x^{3} + x^{2} + 1$ 。下面用一个例子来介绍 CRC 的编码和检测过程。</p><p>设生成多项式 $G(x) = x^{3} + x^{2} + 1$，信息码为 101001，求对应的 CRC 码</p><ul><li>生成多项式 $G(x) = 1x^{3} + 1x^{2} + 0x^{1} + 1x^{0}$，故对应的二进制码为 1101。</li><li>$R$ 等于生成多项式最高次幂，即为 3</li><li>$K$ 等于信息码长度，即为 6</li><li>校验码位数 $N = K+R=9$</li></ul><p>（1）位移</p><p>将原信息码左移 $R$ 位，低位补 0，得到 101001000</p><p>（2）相除</p><p>对位移后的信息码，用生成多项式进行模 2 除法，产生余数。</p><blockquote><p>模 2 减法：和模 2 加法的结果相同，都是做异或运算<br>模 2 除法：模 2 除法和算术除法类似，但每位除（减）的结果不影响其他位，即不借位。</p></blockquote><ol><li>用除数对被除数最高几位做模 2 减（异或），不借位。</li><li>除数右移一位，若余数最高位为 1，商为 1，并对余数做模 2 减。若余数最高位为 0，商为 0，除数继续右移一位。</li><li>循环直到余数位数小于除数时，该余数为最终余数。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="CRC码生成过程"></p><p>模 2 除法过程如图上所示，得到余数为 001，则报文 101001 编码后的报文（即 CRC 码）为 101001001</p><p>（3）检错和纠错</p><p>接收端收到的 CRC 码，用生成多项式 $G(x)$ 做模 2 除法，若余数为 0，则码字无错。</p><p>若接收端收的 CRC 码为 $C_{9} C_{8} C_{7} C_{6} C_{5} C_{4} C_{3} C_{2} C_{1} = 101001011$，将这个数据与 1101 进行模 2 除法，得到的余数为 010，则说明 $C_{2}$ 出错（不一定正确），将 $C_{2}$ 取反即可。</p><blockquote><p>注意：余数值与出错位置并不是二进制与十进制转换的关系。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC%E7%A0%81%E4%BD%99%E6%95%B0%E4%B8%8E%E5%87%BA%E9%94%99%E4%BD%8D%E5%85%B3%E7%B3%BB.png" alt="CRC码余数与出错位关系"></p><p>$K$ 个信息位，$R$ 个校验位，若生成多项式选择得当，且 $2^{R} \ge K + R + 1$ ，则 CRC 码可纠正 1 位错。实际应用中一般只用来“检错”。</p><p>理论上可以证明循环冗余校验码的检错能力有以下特点：</p><ol><li>可检测出所有奇数个错误;</li><li>可检测出所有双比特的错误;</li><li>可检测出所有小于等于校验位长度的连续错误;</li></ol><h2 id="定点数的表示与运算"><a class="header-anchor" href="#定点数的表示与运算"></a>定点数的表示与运算</h2><h3 id="定点数的表示"><a class="header-anchor" href="#定点数的表示"></a>定点数的表示</h3><p>在计算机中参与运算的机器数有两大类：无符号（unsigned）数和有符号（signed）数。</p><ol><li><font color="#ea66a6">无符号数</font>。指整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。若机器字长为 8 位，则数的表示范围为 0 ~ 2<sup>8</sup>-1，即 0 ~ 255。</li><li><font color="#ea66a6">有符号数</font>。在机器中，数的“正”“负”号是无法识别的，有符号数用“0”表示“正”号，用“1”表示“负”号，从而将符号也数值化，并通常约定二进制数的最高位为符号位，即将符号位放在有效数字的前面，组成有符号数。</li></ol><p>有符号数的机器表示有原码、补码、反码和移码。为了能正确区别真值和各种机器数，约定用 X 表示真值，用 [X]<sub>原</sub>表示原码，[X]<sub>补</sub>表示补码， [X]<sub>反</sub>表示反码，[X]<sub>移</sub>表示移码。</p><p>定点表示即约定机器数中的小数点位置是固定不变的，小数点不再使用“.”表示，而是约定它的位置。理论上，小数点位置固定在哪一位都可以，但在计算机中通常采用两种简单的约定：将小数点的位置固定在数据的最高位之前，或固定在最低位之后。一般常称前者为定点小数，后者为定点整数。</p><p>（1）定点整数</p><p>定点整数是纯整数，约定小数点位置在有效数值部分最低位之后。若数据 $X$ 的形式为 $ X = x_{0}x_{1}x_{2} \cdots x_{n}$ （其中 $x_{0}$ 为符号位，$x_{1} \sim  x_{n}$ 是数值的有效部分，也称<font color="#ea66a6">尾数</font>，$x_{n}$ 为最低有效位），则在计算机中的表示形式如图所示（设机器字长 $n+1$ 位)。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E5%AE%9A%E7%82%B9%E6%95%B4%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="定点整数的格式"></p><ul><li>当 $x_{0}=0$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其所能表示的最大正数，真值等于 $2^{n}-1$。</li><li>当 $x_{0}=1$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其（原码）所能表示的最小负数，真值等于 $- ( 2^{-n}-1 )$。</li></ul><p>（2）定点小数</p><p>定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前。若数据 $X$ 的形式为 $ X = x_{0}x_{1}x_{2} \cdots x_{n}$ （其中 $x_{0}$ 为符号位，$x_{1} \sim  x_{n}$ 是尾数，$x_{1}$ 为最高有效位），则在计算机中的表示形式如图所示（设机器字长 $n+1$ 位)。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt="定点小数的格式"></p><ul><li>当 $x_{0}=0$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其所能表示的最大正数，真值等于 $1-2^{-n}$。</li><li>当 $x_{0}=1$，$x_{1} \sim x_{n}$，均为 1 时，$X$ 为其（原码）所能表示的最小负数，真值等于 $- ( 1-2^{-n} )$。</li></ul><h3 id="原码、补码、反码、移码"><a class="header-anchor" href="#原码、补码、反码、移码"></a>原码、补码、反码、移码</h3><h4 id="原码"><a class="header-anchor" href="#原码"></a>原码</h4><p>原码是一种比较简单、直观的机器数表示法，<font color="#faa755">用机器数的最高位表示该数的符号，其余的各位表示数的绝对值</font>。原码的定义如下：</p><p>（1）纯整数的原码定义</p><p>$$[x]_{原} = \begin{cases}<br>0, x &amp; 2^{n} &gt; x \ge 0  \\<br>2^{n}-x = 2^{n}+\left | x \right |  &amp; 0 \ge x &gt; -2^{n}<br>\end{cases}$$</p><p>例如：</p><ul><li>若 $x_{1}=+1110$，字长为 8 位，则其原码表示为 $[x_{1}]_{原} = 00001110$，其中最高位是符号位。</li><li>若 $x_{2}=-1110$，字长为 8 位，则其原码表示为 $[x_{2}]_{原} = 2^{7}+1110= 10001110$，其中最高位是符号位。</li></ul><p>若字长为 $n+1$，则原码整数的表示范围为 $-(2^{n}-1) \le x \le 2^{n}-1$（关于原点对称）</p><blockquote><p>注意：真值零的原码表示有正零和负零两种形式，即 $[+0]_{原} = 00000$ 和 $[-0]_{原} = 10000$。</p></blockquote><p>（2）纯小数的原码定义</p><p>$$[x]_{原} = \begin{cases}<br>x &amp; 1 &gt; x \ge 0  \\<br>1-x = 1+\left | x \right |  &amp; 0 \ge x &gt; -1<br>\end{cases}$$</p><p>例如：</p><ul><li>若 $x_{1}=+0.1101$，字长为 8 位，则其原码表示为：$[x_{1}]_{原} = 01101000$，其中最高位是符号位。</li><li>若 $x_{2}=-0.1101$，字长为 8 位，则其原码表示为：$[x_{2}]_{原} = 1-(-0.1101) = 11101000$，其中最高位是符号位。</li></ul><p>更一般地：</p><ul><li>对于正小数 $ x= +0.x_{1}x_{2} \cdots x_{n}$，有 $ [x]_{原}= 0.x_{1}x_{2} \cdots x_{n}$</li><li>对于负小数 $ x= -0.x_{1}x_{2} \cdots x_{n}$，有 $  [x]_{原}= 1.x_{1}x_{2} \cdots x_{n}$。</li></ul><p>若字长为 $n+1$，则原码小数的表示范围为 $-(1-2^{-n}) \le x \le 1-2^{-n}$（关于原点对称）</p><blockquote><p>同样真值零的原码表示有正零和负零两种形式</p></blockquote><h4 id="反码"><a class="header-anchor" href="#反码"></a>反码</h4><p>反码通常用来作为由原码求补码或由补码求原码的中间过渡。</p><ul><li>若符号位为 0，则反码与原码相同</li><li>若符号位为 1，则数值位全部取反</li></ul><p>若字长为 $n+1$，反码的整数和小数表示范围与原码整数和小数表示范围对应相同。</p><blockquote><p>注意：真值零的反码表示不唯一，$[+0]_{反}=0.0000$，$[-0]_{反}=1.1111$</p></blockquote><h4 id="补码"><a class="header-anchor" href="#补码"></a>补码</h4><ul><li>正数的补码 = 原码</li><li>负数的补码 = 反码末位 + 1（要考虑进位）</li></ul><blockquote><p>注意：补码的真值 0 只有一种表示形式 $[+0]_{补}=[-0]_{补}=00000000$，定点整数补码 $[x]_{补}=10000000$ 表示 $x=-2^{7}$，定点小数补码 $[x]_{补}=10000000$ 表示 $x=-1$</p></blockquote><ul><li>若机器字长为 $n+1$，补码整数的表示范围：$-2^{n} \le x \le 2^{n}-1$ （比原码多表示一个 $-2^{n}$）</li><li>若机器字长为 $n+1$，补码小数的表示范围：$-1 \le x \le 1-2^{-n}$ （比原码多表示一个 $-1$）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/%E4%B8%8D%E5%90%8C%E6%9C%BA%E5%99%A8%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="不同机器数之间的转换"></p><h4 id="移码"><a class="header-anchor" href="#移码"></a>移码</h4><p>移码：补码的基础上将符号位取反。</p><blockquote><p>注意：移码只能用于表示整数</p></blockquote><p>移码的正值 0 和整数的表示范围与补码相同。</p><p>移码表示的整数很方便对比真值大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数制与编码&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#数制与编码&quot;&gt;&lt;/a&gt;数制与编码&lt;/h2&gt;
&lt;p&gt;在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二进制只有两种状态，使用有两个稳</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>中文文案排版</title>
    <link href="https://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/"/>
    <id>https://halo123.top/2021/05/26/BasicKnowledge/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%88%E6%8E%92%E7%89%88/</id>
    <published>2021-05-26T08:30:50.000Z</published>
    <updated>2021-05-26T08:34:29.754Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="转自 《中文文案排版指北》" href="https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">转自 《中文文案排版指北》</p><p class="url">https://github.com/sparanoid/chinese-copywriting-guidelines/blob/master/README.zh-CN.md</p></div></a></div><h2 id="空格"><a class="header-anchor" href="#空格"></a>空格</h2><h3 id="中英文之间需要增加空格"><a class="header-anchor" href="#中英文之间需要增加空格"></a>中英文之间需要增加空格</h3><p>正确：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。</p></blockquote><p>错误：</p><blockquote><p>在LeanCloud上，数据存储是围绕<code>AVObject</code>进行的。</p><p>在 LeanCloud上，数据存储是围绕<code>AVObject</code> 进行的。</p></blockquote><p>完整的正确用法：</p><blockquote><p>在 LeanCloud 上，数据存储是围绕 <code>AVObject</code> 进行的。每个 <code>AVObject</code> 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 <code>AVObject</code> 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。</p></blockquote><p>例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。</p><h3 id="中文与数字之间需要增加空格"><a class="header-anchor" href="#中文与数字之间需要增加空格"></a>中文与数字之间需要增加空格</h3><p>正确：</p><blockquote><p>今天出去买菜花了 5000 元。</p></blockquote><p>错误：</p><blockquote><p>今天出去买菜花了 5000元。</p><p>今天出去买菜花了5000元。</p></blockquote><h3 id="数字与单位之间需要增加空格"><a class="header-anchor" href="#数字与单位之间需要增加空格"></a>数字与单位之间需要增加空格</h3><p>正确：</p><blockquote><p>我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB</p></blockquote><p>错误：</p><blockquote><p>我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB</p></blockquote><p>例外：度 / 百分比与数字之间不需要增加空格：</p><p>正确：</p><blockquote><p>今天是 233° 的高温。</p><p>新 MacBook Pro 有 15% 的 CPU 性能提升。</p></blockquote><p>错误：</p><blockquote><p>今天是 233 ° 的高温。</p><p>新 MacBook Pro 有 15 % 的 CPU 性能提升。</p></blockquote><h3 id="全角标点与其他字符之间不加空格"><a class="header-anchor" href="#全角标点与其他字符之间不加空格"></a>全角标点与其他字符之间不加空格</h3><p>正确：</p><blockquote><p>刚刚买了一部 iPhone，好开心！</p></blockquote><p>错误：</p><blockquote><p>刚刚买了一部 iPhone ，好开心！</p><p>刚刚买了一部 iPhone， 好开心！</p></blockquote><h3 id="用-text-spacing-来挽救？"><a class="header-anchor" href="#用-text-spacing-来挽救？"></a>用 <code>text-spacing</code> 来挽救？</h3><p>CSS Text Module Level 4 的 <a href="https://www.w3.org/TR/css-text-4/#text-spacing-property"><code>text-spacing</code></a> 和 Microsoft 的 <a href="https://msdn.microsoft.com/library/ms531164(v=vs.85).aspx"><code>-ms-text-autospace</code></a> 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。</p><h2 id="标点符号"><a class="header-anchor" href="#标点符号"></a>标点符号</h2><h3 id="不重复使用标点符号"><a class="header-anchor" href="#不重复使用标点符号"></a>不重复使用标点符号</h3><p>正确：</p><blockquote><p>德国队竟然战胜了巴西队！</p><p>她竟然对你说「喵」？！</p></blockquote><p>错误：</p><blockquote><p>德国队竟然战胜了巴西队！！</p><p>德国队竟然战胜了巴西队！！！！！！！！</p><p>她竟然对你说「喵」？？！！</p><p>她竟然对你说「喵」？！？！？？！！</p></blockquote><h2 id="全角和半角"><a class="header-anchor" href="#全角和半角"></a>全角和半角</h2><p>不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E5%BD%A2%E5%92%8C%E5%8D%8A%E5%BD%A2">全形和半形</a>』。</p><h3 id="使用全角中文标点"><a class="header-anchor" href="#使用全角中文标点"></a>使用全角中文标点</h3><p>正确：</p><blockquote><p>嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！</p><p>核磁共振成像（NMRI）是什么原理都不知道？JFGI！</p></blockquote><p>错误：</p><blockquote><p>嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！</p><p>嗨!你知道嘛?今天前台的小妹跟我说&quot;喵&quot;了哎！</p><p>核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!</p><p>核磁共振成像(NMRI)是什么原理都不知道?JFGI!</p></blockquote><h3 id="数字使用半角字符"><a class="header-anchor" href="#数字使用半角字符"></a>数字使用半角字符</h3><p>正确：</p><blockquote><p>这个蛋糕只卖 1000 元。</p></blockquote><p>错误：</p><blockquote><p>这个蛋糕只卖 １０００ 元。</p></blockquote><p>例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。</p><h3 id="遇到完整的英文整句、特殊名词，其内容使用半角标点"><a class="header-anchor" href="#遇到完整的英文整句、特殊名词，其内容使用半角标点"></a>遇到完整的英文整句、特殊名词，其内容使用半角标点</h3><p>正确：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」</p><p>推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><p>错误：</p><blockquote><p>贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」</p><p>推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。</p></blockquote><h2 id="名词"><a class="header-anchor" href="#名词"></a>名词</h2><h3 id="专有名词使用正确的大小写"><a class="header-anchor" href="#专有名词使用正确的大小写"></a>专有名词使用正确的大小写</h3><p>大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。</p><p>正确：</p><blockquote><p>使用 GitHub 登录</p><p>我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。</p></blockquote><p>错误：</p><blockquote><p>使用 github 登录</p><p>使用 GITHUB 登录</p><p>使用 Github 登录</p><p>使用 gitHub 登录</p><p>使用 gｲんĤЦ8 登录</p><p>我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。</p><p>我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。</p><p>我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。</p><p>我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。</p><p>我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。</p></blockquote><p>注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 <code>text-transform: uppercase;</code>／<code>text-transform: lowercase;</code> 对表现形式进行定义。</p><h3 id="不要使用不地道的缩写"><a class="header-anchor" href="#不要使用不地道的缩写"></a>不要使用不地道的缩写</h3><p>正确：</p><blockquote><p>我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。</p></blockquote><p>错误：</p><blockquote><p>我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。</p></blockquote><h2 id="争议"><a class="header-anchor" href="#争议"></a>争议</h2><p>以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是<strong>正确</strong>的。</p><h3 id="链接之间增加空格"><a class="header-anchor" href="#链接之间增加空格"></a>链接之间增加空格</h3><p>用法：</p><blockquote><p>请 <a href="#">提交一个 issue</a> 并分配给相关同事。</p><p>访问我们网站的最新动态，请 <a href="#">点击这里</a> 进行订阅！</p></blockquote><p>对比用法：</p><blockquote><p>请<a href="#">提交一个 issue</a>并分配给相关同事。</p><p>访问我们网站的最新动态，请<a href="#">点击这里</a>进行订阅！</p></blockquote><h3 id="简体中文使用直角引号"><a class="header-anchor" href="#简体中文使用直角引号"></a>简体中文使用直角引号</h3><p>用法：</p><blockquote><p>「老师，『有条不紊』的『紊』是什么意思？」</p></blockquote><p>对比用法：</p><blockquote><p>“老师，‘有条不紊’的‘紊’是什么意思？”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;转自 《中文文案排版指北》&quot; href=&quot;https://github.com/sparanoid/chinese-copywriting-guidelines/blob/mast</summary>
      
    
    
    
    <category term="Tips" scheme="https://halo123.top/categories/Tips/"/>
    
    
    <category term="Tips" scheme="https://halo123.top/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理概述</title>
    <link href="https://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/"/>
    <id>https://halo123.top/2021/05/26/ComputerComposition/A-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-26T04:55:05.000Z</published>
    <updated>2021-06-08T07:29:00.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统的组成"><a class="header-anchor" href="#计算机系统的组成"></a>计算机系统的组成</h2><p>硬件系统和软件系统共同构成了一个完整的计算机系统。</p><ul><li><font color="#ea66a6">硬件</font>是指有形的物理设备，是计算机系统中实际物理装置的总称。</li><li><font color="#ea66a6">软件</font>是指在硬件上运行的程序和相关的数据及文档。</li></ul><p>计算机系统性能的好坏，很大程度上是由软件的效率和作用来表征的，而软件性能的发挥又离不开硬件的支持。对某一功能来说，其既可以用软件实现，又可以用硬件实现，则称为<font color="#faa755">软硬件在逻辑上是等效的</font>。</p><p>在设计计算机系统时，要进行软/硬件的功能分配。通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率。而用软件实现可以提高灵活性，但效率往往不如硬件实现高。</p><h2 id="计算机硬件的基本组成"><a class="header-anchor" href="#计算机硬件的基本组成"></a>计算机硬件的基本组成</h2><h3 id="早期的冯·诺依曼机"><a class="header-anchor" href="#早期的冯·诺依曼机"></a>早期的冯·诺依曼机</h3><p>冯·诺依曼在研究 <a href="https://baike.baidu.com/item/EDVAC/8438215?fr=aladdin">EDVAC 机</a> 时提出了“存储程序”的概念，“存储程序”的思想奠定了现代计算机的基本结构，以此概念为基础的各类计算机通称为冯·诺依曼机，其特点如下：</p><ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 5 大部件组成。</li><li>指令和数据以同等地位存储在存储器中，并可按地址寻访。</li><li>指令和数据均用二进制代码表示。</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序。</li><li>早期的冯·诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。</li></ol><blockquote><p>注意：“存储程序”的概念是指将指令以代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</p></blockquote><p>典型的冯·诺依曼机计算机结构如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%85%B8%E5%9E%8B%E7%9A%84%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="典型的冯诺依曼计算机结构"></p><h3 id="现代计算机的组织结构"><a class="header-anchor" href="#现代计算机的组织结构"></a>现代计算机的组织结构</h3><p>在微处理器问世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>而随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能够满足计算机发展的要求。现代计算机已发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率，其结构如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png" alt="以存储器为中心的计算机结构"></p><p>目前绝大多数现代计算机仍遵循冯·诺依曼的存储程序的设计思想。</p><h3 id="计算机的功能部件"><a class="header-anchor" href="#计算机的功能部件"></a>计算机的功能部件</h3><p>传统冯·诺依曼计算机和现代计算机的结构虽然有所不同，但功能部件是一致的，它们的功能部件包括如下几种：</p><p>（1）输入设备</p><p>输入设备的主要功能是将程序和数据以机器所能识别和接受的信息形式输入计算机。最常用也最基本的输入设备是键盘，此外还有鼠标、扫描仪、摄像机等。</p><p>（2）输出设备</p><p>输出设备的任务是将计算机处理的结果以人们所能接受的形式或其他系统所要求的信息形式输出。最常用、最基本的输出设备是显示器、打印机。计算机的输入/输出设备（简称 I/O 设备）是计算机与外界联系的桥梁，是计算机中不可缺少的重要组成部分。</p><p>（3）存储器</p><p>存储器是计算机的存储部件，用来存放程序和数据。存储器分为主存储器（简称主存，也称内存储器）和辅助存储器（简称辅存，也称外存储器）。</p><ul><li>CPU 能够直接访问的存储器是主存储器。</li><li>辅助存储器用于帮助主存储器记忆更多的信息，辅助存储器中的信息必须调入主存后，才能为 CPU 所访问。</li></ul><p>主存储器由许多存储单元组成，每个存储单元包含若干存储元件，每个存储元件存储一位二进制代码“0”或“1”。因此存储单元可存储一串二进制代码，称这串代码为存储字，称这串代码的位数为存储字长，存储字长可以是 1 B（8 bit）或是字节的偶数倍。</p><p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式（相联存储器是按内容访问的）。</p><p>主存储器的最基本组成如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E9%80%BB%E8%BE%91%E5%9B%BE.png" alt="主存储器逻辑图"></p><ul><li>存储体存放二进制信息；</li><li><font color="#ea66a6">地址寄存器</font>（Memory Address Register，<font color="#ea66a6">MAR</font>）存放访存地址，经过地址译码后找到所选的存储单元；</li><li><font color="#ea66a6">数据寄存器</font>（Memory Data Register，<font color="#ea66a6">MDR</font>）用于暂存要从存储器中读或写的信息；</li><li>时序控制逻辑用于产生存储器操作所需的各种时序信号。</li></ul><p>MAR 用于寻址，其位数对应着存储单元的个数，如 MAR 为 10 位，则有 2<sup>10</sup> = 1024 个存储单元，记为 1 K。MAR 的长度与<font color="#ea66a6">程序计数器</font>（Program Counter，<font color="#ea66a6">PC</font>）的长度相等。</p><p>MDR 的位数和存储字长相等，一般为字节的二次幂的整数倍。</p><blockquote><p>注意：MAR 与 MDR 虽然是存储器的一部分，但在现代 CPU 中却是存在于 CPU 中的。另外，高速缓存（Cache）也存在于 CPU 中。</p></blockquote><p>（4）运算器</p><p>运算器是计算机的执行部件，用于进行算术运算和逻辑运算。</p><ul><li>算术运算是按算术运算规则进行的运算，如加、减、乘、除；</li><li>逻辑运算包括与、或、非、异或、比较、移位等运算。</li></ul><p>运算器的核心是算术逻辑单元（Arithmetic and Logical Unit，ALU）。</p><p>运算器包含若干通用寄存器，用于暂存操作数和中间结果，如累加器（Accumulator，ACC）、乘商寄存器（Multiple—Quotient Register，MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等，其中前 3 个寄存器是必须有的。</p><p>运算器内还有程序状态寄存器（Program Status Word，PSW），也称标志寄存器，用于存放 ALU 运算得到的一些标志信息或处理机的状态信息，如结果是否溢出、有无产生进位或借位、结果是否为负等。</p><p>（5）控制器</p><p>控制器是计算机的指挥中心，由其“指挥”各部件自动协调地进行工作。控制器由程序计数器（Program Counter，PC）、指令寄存器（Instruction Register，IR）和控制单元（CU）组成。</p><p>PC 用来存放当前欲执行指令的地址，可以自动加 1 以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路。</p><p>IR 用来存放当前的指令，其内容来自主存的 MDR。</p><ul><li>指令中的操作码 OP(IR) 送至 CU，用以分析指令并发出各种微操作命令序列</li><li>指令中的地址码 Ad(IR) 送往 MAR，用以取操作数。</li></ul><p>一般将运算器和控制器集成到同一个芯片上，称为中央处理器（Central Processing Unit，CPU）。CPU 和主存储器共同构成主机，而除主机外的其他硬件装置（外存、I/O 设备等）统称为外部设备，简称外设。</p><p>下图所示为冯·诺依曼结构的模型机。CPU 包含 ALU、通用寄存器组 GPRs、标志寄存器、控制器、指令寄存器 IR、程序计数器 PC、存储器地址寄存器 MAR 和存储器数据寄存器 MDR。图中从控制器送出的虚线就是控制信号，可以控制如何修改 PC 以得到下一条指令的地址，可以控制 ALU 执行什么运算，可以控制主存是进行读操作还是写操作（读/写控制信号）。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%9C%BA.png" alt="冯诺依曼结构的模型机"></p><p>CPU 和主存之间通过一组总线相连，总线中有地址、控制和数据 3 组信号线。</p><ul><li>MAR 中的地址信息会直接送到地址线上，用于指向读/写操作的主存存储单元；</li><li>控制线中有读/写信号线，指出数据是从 CPU 写入主存还是从主存读出到 CPU，根据是读操作还是写操作来控制将 MDR 中的数据是直接送到数据线上还是将数据线上的数据接收到 MDR 中。</li></ul><h2 id="计算机软件的分类"><a class="header-anchor" href="#计算机软件的分类"></a>计算机软件的分类</h2><h3 id="系统软件和应用软件"><a class="header-anchor" href="#系统软件和应用软件"></a>系统软件和应用软件</h3><p>软件按其功能分类，可分为系统软件和应用软件。</p><ul><li>系统软件是一组保证计算机系统高效、正确运行的基础软件，通常作为系统资源提供给用户使用。系统软件主要有操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序等。</li><li>应用软件是指用户为解决某个应用领域中的各类问题而编制的程序，如各种科学计算类程序、工程设计类程序、数据统计与处理程序等。</li></ul><blockquote><p>注意：数据库管理系统（DBMS）和数据库系统（DBS）是有区别的。DBMS 是位于用户和操作系统之间的一层数据管理软件，是系统软件；而 DBS 是指计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、数据库管理员（DBA）和应用系统构成。</p></blockquote><h3 id="三个级别的语言"><a class="header-anchor" href="#三个级别的语言"></a>三个级别的语言</h3><ol><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言（如C、C++、Java等）是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ol><h2 id="计算机的工作过程"><a class="header-anchor" href="#计算机的工作过程"></a>计算机的工作过程</h2><p>计算机的工作过程分为以下三个步骤：</p><ol><li>把程序和数据装入主存储器。</li><li>将源程序转换成可执行文件。</li><li>从可执行文件的首地址开始逐条执行指令。</li></ol><h3 id="从源程序到可执行文件"><a class="header-anchor" href="#从源程序到可执行文件"></a>从源程序到可执行文件</h3><p>在计算机中编写的 C 语言程序，都必须被转换为一系列的低级机器指令，这些指令按照一种称为可执行目标文件的格式打好包，并以二进制磁盘文件的形式存放起来。</p><p>以 UNIX 系统中的 GCC 编译器程序为例，读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello，整个翻译过程可分为 4 个阶段完成，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%BA%90%E7%A8%8B%E5%BA%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="源程序转换为可执行文件的过程"></p><ol><li>预处理阶段：预处理器（cpp）对源程序中以字符 <code>#</code> 开头的命令进行处理，例如将 <code>#include</code> 命令后面的 .h 文件内容插入程序文件。输出结果是一个以 i 为扩展名的源文件 hello.i</li><li>编译阶段：编译器（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序 hello.s 汇编语言源程序中的每条语句都以一种文本格式描述了一条低级机器语言指令。</li><li>汇编阶段：汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一个称为可重定位目标文件的 hello.o，它是一种二进制文件，因此在文本编辑器中打开它时会显示乱码。</li><li>链接阶段：链接器（ld）将多个可重定位目标文件和标准库函数合并为一个可执行目标文件，或简称可执行文件。本例中，链接器将 hello.o 和标准库函数 <code>prinft</code> 所在的可重定位目标模块 prinft.o 合并，生成可执行文件 hello。最终生成的可执行文件被保存在磁盘上。</li></ol><h3 id="指令执行过程的描述"><a class="header-anchor" href="#指令执行过程的描述"></a>指令执行过程的描述</h3><p>程序中第一条指令的地址置于 PC 中，根据 PC 取出第一条指令，经过译码、执行步骤等，控制计算机各功能部件协同运行，完成这条指令的功能，并计算下一条指令的地址。用新得到的指令地址继续读出第二条指令并执行，直到程序结束为止。</p><p>下面以取数指令（即将指令地址码指示的存储单元中的操作数取出后送至运算器的 ACC 中）为例进行说明，其信息流程如下：</p><p>1、取指令: PC → MAR → M → MDR → IR</p><p>根据 PC 取指令到 IR（指令寄存器）。将 PC 的内容送 MAR（地址寄存器），MAR 中的内容直接送地址线，同时控制器将读信号送读/写信号线，主存根据地址线上的地址和读信号，从指定存储单元读出指令，送到数据线上，MDR（数据寄存器） 从数据线接收指令信息，并传送到 IR 中。</p><p>2、分析指令: OP(IR) → CU</p><p>指令译码并送出控制信号。控制器根据IR中指令的操作码，生成相应的控制信号，送到不同的执行部件。在本例中，IR 中是取数指令，因此读控制信号被送到总线的控制线上。</p><p>3、执行指令：Ad(IR) → MAR → M → MDR → ACC</p><p>取数操作。将 IR 中指令的地址码送 MAR，MAR 中的内容送地址线，同时控制器将读信号送读/写信号线，从主存指定存储单元读出操作数，并通过数据线送至 MDR，再传送到 ACC 中。</p><p>此外，每取完一条指令，还须为取下一条指令做准备，形成下一条指令的地址，即 (PC)+1 → PC。</p><blockquote><p>注意: (PC) 指程序计数器 PC 中存放的内容。PC → MAR 应理解为 (PC) → MAR，即程序计数器中的值经过数据通路送到 MAR，也即表示数据通路时括号可省略（因为只是表示数据流经的途径，而不强调数据本身的流动）。但运算时括号不能省略，即 (PC)+1 → PC 不能写为 PC+1 → PC。</p></blockquote><h2 id="计算机系统的多级层次结构"><a class="header-anchor" href="#计算机系统的多级层次结构"></a>计算机系统的多级层次结构</h2><p>现代计算机是一个硬件与软件组成的综合体。由于面对的应用范围越来越广，因此必须有复杂的系统软件和硬件的支持。由于软/硬件的设计者和使用者都从不同的角度并用不同的语言来对待同一个计算机系统，因此他们各自看到的计算机系统的属性及对计算机系统提出的要求也就不同。</p><p>计算机系统的多级层次结构的作用，就是针对上述情况，根据从各种角度所看到的机器之间的有机联系，来分清彼此之间的界面，明确各自的功能，以便构成合理、高效的计算机系统。</p><p>关于计算机系统层次结构的分层方式，目前尚无统一的标准，这里采用如下图所示的层次结构。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%9A%E7%BA%A7%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="计算机系统的多级层次结构"></p><p>第 1 级是微程序机器层，这是一个实在的硬件层，它由机器硬件直接执行微指令。</p><p>第 2 级是传统机器语言层，它也是一个实际的机器层，由微程序解释机器指令系统。</p><p>第 3 级是操作系统层，它由操作系统程序实现。操作系统程序是由机器指令和广义指令组成的，这些广义指令是为了扩展机器功能而设置的，是由操作系统定义和解释的软件指令，所以这一层也称混合层。</p><p>第 4 级是汇编语言层，它为用户提供一种符号化的语言，借此可编写汇编语言源程序。这一层由汇编程序支持和执行。</p><p>第 5 级是高级语言层，它是面向用户的，是为方便用户编写应用程序而设置的。该层由各种高级语言编译程序支持和执行。</p><p>在高级语言层之上，还可以有应用层，它由解决实际问题和应用问题的处理程序组成，如文字处理软件、数据库软件、多媒体处理软件和办公自动化软件等。</p><p>通常把没有配备软件的纯硬件系统称为“裸机”。第 3 层至第 5 层称为虚拟机，简单来说就是软件实现的机器。虚拟机只对该层的观察者存在，这里的分层和计算机网络的分层类似，对于某层的观察者来说，只能通过该层次的语言来了解和使用计算机，而不必关心下层是如何工作的。</p><p>层次之间的关系紧密，下层是上层的基础，上层是下层的扩展。随着超大规模集成电路技术的不断发展，部分软件功能将由硬件来实现，因而软/硬件交界面的划分也不是绝对的。</p><p>这里主要讨论传统机器 M1 和微程序机器 M0 的组成原理及设计思想。</p><h2 id="计算机的性能指标"><a class="header-anchor" href="#计算机的性能指标"></a>计算机的性能指标</h2><h3 id="计算机的主要性能指标"><a class="header-anchor" href="#计算机的主要性能指标"></a>计算机的主要性能指标</h3><p>（1）机器字长</p><p>机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，通常与 CPU 的寄存器位数、加法器有关。因此，机器字长一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度越高。计算机字长通常选定为字节（8 位）的整数倍。</p><blockquote><p>注意：<a href="#%E6%9C%BA%E5%99%A8%E5%AD%97%E9%95%BF%E3%80%81%E6%8C%87%E4%BB%A4%E5%AD%97%E9%95%BF%E5%92%8C%E5%AD%98%E5%82%A8%E5%AD%97%E9%95%BF%E7%9A%84%E5%85%B3%E7%B3%BB">机器字长、指令字长和存储字长的关系</a></p></blockquote><p>（2）数据通路带宽</p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。这里所说的数据通路宽度是指外部数据总线的宽度，它与 CPU 内部的数据总线宽度（内部寄存器的大小）有可能不同。</p><blockquote><p>注意：各个子系统通过数据总线连接形成的数据传送路径称为数据通路。</p></blockquote><p>（3）主存容量</p><p>主存容量是指主存储器所能存储信息的最大容量，通常以字节来衡量，也可用字数 × 字长（如 512 K × 16位）来表示存储容量。其中，MAR 的位数反映存储单元的个数，MAR 的位数反映可寻址范围的最大值（而不一定是实际存储器的存储容量）。</p><p>例如，MAR 为 16 位，表示 2<sup>16</sup> = 65536，即此存储体内有 65536 个存储单元（可称为 64 K 内存，1 K = 1024），若 MDR 为 32 位，表示存储容量为 64 K × 32 位。</p><p>（4）运算速度</p><ul><li><p>吞吐量。指系统在单位时间内处理请求的数量。它取决于信息能多快地输入内存，CPU 能多快地取指令，数据能多快地从内存取出或存入，以及所得结果能多快地从内存送给一台外部设备。几乎每步都关系到主存，因此系统吞吐量主要取决于主存的存取周期。</p></li><li><p>响应时间。指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。通常包括 CPU 时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O 操作、操作系统开销等的时间）。</p></li><li><p>CPU 时钟周期。通常为节拍脉冲或 T 周期，即主频的倒数，它是 CPU 中最小的时间单位，每个动作至少需要 1 个时钟周期。CPU时钟周期 = 1/主频，主频通常以 Hz（赫兹）为单位，1 Hz 表示每秒 1 次。</p></li><li><p>主频（CPU 时钟频率）。机器内部主时钟的频率，是衡量机器速度的重要参数。对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。例如，常用 CPU 的主频有 1.8 GHz、2.4 GHz、 2.8 GHz 等。</p></li><li><p>CPI（Clock cycle Per Instruction），即执行一条 指令所需的时钟周期数。</p></li><li><p>CPU 执行时间，指运行一个程序所花费的时间。</p><p>CPU 执行时间 = CPU 时钟周期数 / 主频 = (指令条数 × CPI) / 主频。</p><p>上式表明，CPU 的性能（CPU 执行时间）取决于三个要素：主频（时钟频率）；每条指令执行所用的时钟周期数（CPI）；指令条数。</p><p>主频、CPI 和指令条数是相互制约的。例如，更改指令集可以减少程序所含指令的条数，但同时可能引起 CPU 结构的调整，从而可能会增加时钟周期的宽度（降低主频）。</p></li><li><p>MIPS（Million Instructions Per Second），即每秒执行多少百万条指令。</p><p>MIPS = 指令条数 / (执行时间 × 10<sup>6</sup>) = 主频 / CPI</p></li><li><p>MFLOPS（Mega Floating point Operations Per Second），即每秒执行多少百万次浮点运算。</p><p>MFLOPS = 浮点操作次数 / (执行时间 × 10<sup>6</sup>)</p></li><li><p>GFLOPS（Giga Floating point Operations Per Second），即每秒执行多少十亿次浮点运算。</p><p>GFLOPS = 浮点操作次数 / (执行时间 × 10<sup>9</sup>)</p></li><li><p>TFLOPS（Tera Floating point Operations Per Second），即每秒执行多少万亿次浮点运算。</p><p>TFLOPS = 浮点操作次数 / (执行时间 × 10<sup>12</sup>)</p></li></ul><blockquote><p>注意：在描述存储容量、文件大小等时，K、M、G、T 通常用 2 的幂次表示，如 1 Kb = 2<sup>10</sup> b；在描述速率、频率等时，k、M、G、T 通常用 10 的幂次表示，如 1 kb/s = 10 b/s。通常前者用大写的 K，后者用小写的 k，但其他前缀均为大写，表示的含义取决于所用的场景。</p></blockquote><h3 id="几个专业术语"><a class="header-anchor" href="#几个专业术语"></a>几个专业术语</h3><ul><li>系列机。具有基本相同的体系结构，使用相同基本指令系统的多个不同型号的计算机组成的一个产品系列。</li><li>兼容。指计算机软件或硬件的通用性，即使用或运行在某个型号的计算机系统中的硬件/软件也能应用于另一个型号的计算机系统时，称这两台计算机在硬件或软件上存在兼容性。</li><li>软件可移植性。指把使用在某个系列计算机中的软件直接或进行很少的修改就能运行在另一个系列计算机中的可能性。</li><li>固件。将程序固定在 ROM 中组成的部件称为固件。固件是一种具有软件特性的硬件，固件的性能指标介于硬件与软件之间，吸收了软/硬件各自的优点，其执行速度快于软件，灵活性优于硬件，是软/硬件结合的产物。例如，目前操作系统已实现了部分固化（把软件永恒地存储于只读存储器中）。</li></ul><h2 id="常见问题和易混淆知识点"><a class="header-anchor" href="#常见问题和易混淆知识点"></a>常见问题和易混淆知识点</h2><h3 id="计算机由哪几部分组成？以哪部分为中心？"><a class="header-anchor" href="#计算机由哪几部分组成？以哪部分为中心？"></a>计算机由哪几部分组成？以哪部分为中心？</h3><p>计算机由运算器、控制器、存储器、输入设备及输出设备五大部分构成，现代计算机通常把运算器和控制器集成在一个芯片上，合称为中央处理器。</p><p>而在微处理器面世之前，运算器和控制器分离，而且存储器的容量很小，因此设计成以运算器为中心的结构，其他部件都通过运算器完成信息的传递。</p><p>随着微电子技术的进步，同时计算机需要处理、加工的信息量也与日俱增，大量 I/O 设备的速度和 CPU 的速度差距悬殊，因此以运算器为中心的结构不能满足计算机发展的要求。现代计算机已经发展为以存储器为中心，使 I/O 操作尽可能地绕过 CPU，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率。</p><h3 id="主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"><a class="header-anchor" href="#主频高的-CPU-一定比主频低的-CPU-快吗？为什么？"></a>主频高的 CPU 一定比主频低的 CPU 快吗？为什么？</h3><p>衡量 CPU 运算速度的指标有很多，不能以单独的某个指标来判断 CPU 的好坏。CPU 的主频，即 CPU 内核工作的时钟频率。CPU 的主频表示 CPU 内数字脉冲信号振荡的速度，主频和实际的运算速度存在一定的关系，但目前还没有一个确定的公式能够定量两者的数值关系，因为 CPU 的运算速度还要看 CPU 的流水线的各方面的性能指标（架构、缓存、指令集、CPU 的位数、Cache 大小等）。由于主频并不直接代表运算速度，因此在一定情况下很可能会出现主频较高的 CPU 实际运算速度较低的现象。</p><h3 id="不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"><a class="header-anchor" href="#不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？"></a>不同级别的语言编写的程序有什么区别？哪种语言编写的程序能被硬件直接执行？</h3><p>机器语言和汇编语言与机器指令对应，而高级语言不与指令直接对应，具有较好的可移植性。其中机器语言可以被硬件直按执行。</p><h3 id="什么是透明性？透明是指什么都能看见吗？"><a class="header-anchor" href="#什么是透明性？透明是指什么都能看见吗？"></a>什么是透明性？透明是指什么都能看见吗？</h3><p>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念（公开、看得见）正好相反。</p><p>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</p><p>在 CPU 中，IR、MAR 和 MDR 对各类程序员都是透明的。</p><h3 id="计算机体系结构和计算机组成的区别和联系是什么？"><a class="header-anchor" href="#计算机体系结构和计算机组成的区别和联系是什么？"></a>计算机体系结构和计算机组成的区别和联系是什么？</h3><p>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。</p><p>计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数、如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例<br>如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。</p><p>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如，IBM System/370 结构就包含了多种价位和性能的机型。</p><h3 id="基准程序执行得越快说明机器的性能越好吗"><a class="header-anchor" href="#基准程序执行得越快说明机器的性能越好吗"></a>基准程序执行得越快说明机器的性能越好吗?</h3><p>一般情况下， 基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。</p><h3 id="机器字长、指令字长和存储字长的关系"><a class="header-anchor" href="#机器字长、指令字长和存储字长的关系"></a>机器字长、指令字长和存储字长的关系</h3><ul><li>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。</li><li>指令字长：一个指令字中包含的二进制代码的位数。</li><li>存储字长：一个存储单元存储的二进制代码的长度。</li></ul><p>它们都必须是字节的整数倍。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的 2 倍，则需要 2 次访存来取出一条指令，因此取指周期为机器周期的 2 倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意 64 位操作系统是指特别为 64 位架构的计算机而设计的操作系统，它能够利用 64 位处理器的优势。但 64 位机器既可以使用 64 位操作系统，又可以使用 32 位操作系统。而 32 位处理器是无法使用 64 位操作系统的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机系统的组成&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#计算机系统的组成&quot;&gt;&lt;/a&gt;计算机系统的组成&lt;/h2&gt;
&lt;p&gt;硬件系统和软件系统共同构成了一个完整的计算机系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;#ea66a6</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://halo123.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>VSCode 下 C\C++ 开发环境配置</title>
    <link href="https://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/"/>
    <id>https://halo123.top/2021/05/24/C/VSCode%E4%B8%8BC%E5%BC%80%E5%8F%91/</id>
    <published>2021-05-24T13:15:36.000Z</published>
    <updated>2021-05-28T13:52:06.180Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：</p><div class="tag link"><a class="link-card" title="哔哩哔哩视频" href="https://www.bilibili.com/video/BV13K411M78v"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg"/></div><div class="right"><p class="text">哔哩哔哩视频</p><p class="url">https://www.bilibili.com/video/BV13K411M78v</p></div></a></div><h2 id="开发环境搭建"><a class="header-anchor" href="#开发环境搭建"></a>开发环境搭建</h2><ul><li>MinGW-w64 编译器 <a href="http://www.mingw-w64.org/doku.php/download">官网下载链接</a></li><li>CMake工具 <a href="https://cmake.org/download/">官网下载链接</a></li></ul><p>将下载的压缩包解压，并将 解压后的文件夹的 bin 文件夹目录放到环境变量中。</p><p>VSCode 插件，在插件中搜索下载</p><ul><li>C\C++：智能提示、debug 和代码浏览</li><li>CMake：CMake 的语法支持</li><li>CMake Tools：CMake 的扩展支持</li></ul><hr><p>CMake Tools 安装遇到的坑</p><p>问题描述：</p><p>CMake Tools 版本为 1.7.3，报错代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bad CMake executable . Is it installed or settings contain the correct path (cmake.cmakePath)? </span><br></pre></td></tr></table></figure><p>原因是 CMake Tools 没有找到正确的 CMake 安装路径</p><p>解决方法：在设置中指定 cmake.exe 的文件地址。具体方法是打开设置（快捷键 Ctrl + 逗号）搜索 cmake.cmakePath 可以看到 Name/path of the CMake executable to use. 默认为 cmake 将其设置自己安装 cmake.exe 文件地址，例如我的设置是 E:\Program\Develop\Cmake\bin\cmake.exe。</p><p>参考解决地址：<a href="https://github.com/microsoft/vscode-cmake-tools/issues/685">https://github.com/microsoft/vscode-cmake-tools/issues/685</a></p><h2 id="基于-g-命令"><a class="header-anchor" href="#基于-g-命令"></a>基于 g++ 命令</h2><h3 id="编译单文件"><a class="header-anchor" href="#编译单文件"></a>编译单文件</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里顺便写段实例代码，打开命令行 VSCode 默认快捷键为 Ctrl 加反引号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;g++ .\main.cpp</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode&gt;.\a.exe</span><br><span class="line">Before swap:</span><br><span class="line">val1 &#x3D; 10   </span><br><span class="line">val2 &#x3D; 20   </span><br><span class="line">After swap: </span><br><span class="line">val1 &#x3D; 20   </span><br><span class="line">val2 &#x3D; 10  </span><br></pre></td></tr></table></figure><p>这里会默认生成 a.exe 可执行文件，通过命令行可以运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt; g++ -g .\main.cpp -o swap</span><br></pre></td></tr></table></figure><p>通过上一段命令可以生成名为 swap 的可调试的可执行文件</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/VSCode%E9%85%8D%E7%BD%AElaunch.json.png" alt="VSCode配置launch"></p><p>选择 g++.exe - Build and debug active file ，会在目录 .vscode 下自动生成 launch.json 文件夹，同时产生了与 cpp 同名的 .exe 文件用于断点调试</p><h3 id="编译多文件"><a class="header-anchor" href="#编译多文件"></a>编译多文件</h3><p>将上述代码拆分成多个文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many_main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Before swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(val1, val2);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;After swap:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val1 = &quot;</span> &lt;&lt; val1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val2 = &quot;</span> &lt;&lt; val2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many_swap.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;many.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// many.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure><p>通过 g++ 编译多文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g .\many_main.cpp .\many_swap.cpp -o many_swap </span><br></pre></td></tr></table></figure><p>如果使用 VSCode 默认生成的 launch.json 进行调试会出错，这里需要进行配置，修改 <code>program</code> 属性为 g++ 生成的可调式的可执行文件名，并注释 <code>preLaunchTask</code>，这里因为自己使用 g++ 命令编程完成，不在需要 VSCode 进行编译</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\many_swap.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="comment">// &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于-Cmake"><a class="header-anchor" href="#基于-Cmake"></a>基于 Cmake</h2><p>在主目录中新建 CMakeLists.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">project(SWAP)</span><br><span class="line"></span><br><span class="line">add_executable(cmake_swap many_main.cpp many_swap.cpp)</span><br></pre></td></tr></table></figure><p>使用 Shift + Ctrl + P 调出配置搜索，搜索 CMake:Configure 选择 mingw</p><p>之后会自动生成 build 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E:\Project\CodeBase\C\VSCode&gt;cd build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;cmake ..</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: E:&#x2F;Project&#x2F;CodeBase&#x2F;C&#x2F;VSCode&#x2F;build</span><br><span class="line"></span><br><span class="line">E:\Project\CodeBase\C\VSCode\build&gt;mingw32-make.exe</span><br></pre></td></tr></table></figure><p>就会在 build 文件夹中生成 cmake_swap.exe （根据 CMakeLists.txt 配置生成）</p><p>如果电脑中安装了 VS 可以会调用微软的 MSVC 编译器，第一次使用时用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br></pre></td></tr></table></figure><p>来代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake ..</span><br></pre></td></tr></table></figure><h2 id="修改-launch-json-和-tasks-json"><a class="header-anchor" href="#修改-launch-json-和-tasks-json"></a>修改 launch.json 和 tasks.json</h2><p>launch.json 需要关注的点为：</p><ul><li><code>program</code>：可执行文件的路径</li><li><code>preLaunchTask</code>：对应 tasks.json 的 <code>label</code> 属性的值</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;g++.exe - Build and debug active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\build\\cmake_swap.exe&quot;</span>,</span><br><span class="line">            <span class="comment">// 调试时需要添加的参数</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tasks.json 用于调试之前的编译工作指令，需要关注的点为：</p><ul><li><code>args</code>：多文件需要指定文件名</li><li><code>label</code>：与 launch.json 的 <code>preLaunchTask</code> 对应</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;C/C++: g++.exe build active file&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;E:\\Program\\Develop\\MinGW\\mingw64\\bin\\g++.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;detail&quot;</span>: <span class="string">&quot;Task generated by Debugger.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 CMake 文件的自动配置 tasks.json 如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;mingw32-make.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: []</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;dependsOn&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考视频：&lt;/p&gt;
&lt;div class=&quot;tag link&quot;&gt;&lt;a class=&quot;link-card&quot; title=&quot;哔哩哔哩视频&quot; href=&quot;https://www.bilibili.com/video/BV13K411M78v&quot;&gt;&lt;div class=&quot;left&quot;&gt;</summary>
      
    
    
    
    <category term="C\C++" scheme="https://halo123.top/categories/C-C/"/>
    
    
    <category term="C" scheme="https://halo123.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="https://halo123.top/2021/05/23/Java/Java-I-IO/"/>
    <id>https://halo123.top/2021/05/23/Java/Java-I-IO/</id>
    <published>2021-05-23T08:31:54.000Z</published>
    <updated>2021-05-27T13:59:27.027Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：《Java 技术手册》</p><h2 id="File-类"><a class="header-anchor" href="#File-类"></a>File 类</h2><p>File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文件和文件夹。是以前 Java 处理文件 I/O 的基础。这个抽象既能表示文件，也能表示目录，不过有时使用起来有些麻烦，写出的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个文件对象，表示用户的家目录</span></span><br><span class="line">File homedir = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;user.home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个对象，表示配置文件</span></span><br><span class="line"><span class="comment">// （家目录中应该存在这个文件）</span></span><br><span class="line">File f = <span class="keyword">new</span> File(homedir, <span class="string">&quot;app.conf&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查文件是否存在，是否真是文件，以及是否可读</span></span><br><span class="line"><span class="keyword">if</span> (f.exists() &amp;&amp; f.isFile() &amp;&amp; f.canRead()) &#123;</span><br><span class="line">    <span class="comment">// 创建一个文件对象，表示新配置目录</span></span><br><span class="line">    File configdir = <span class="keyword">new</span> File(f, <span class="string">&quot;.configdir&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后创建这个目录</span></span><br><span class="line">    configdir.mkdir();</span><br><span class="line">    <span class="comment">// 最后，把配置文件移到新位置</span></span><br><span class="line">    f.renameTo(<span class="keyword">new</span> File(configdir, <span class="string">&quot;.config&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码展现了 File 类使用灵活的一面，但也演示了这种抽象带来的一些问题。一般情况下，需要调用很多方法查询 File 对象才能判断这个对象到底表示的是什么，以及具有什么能力。</p><p>File 类中有相当多的方法，但根本没有直接提供一些基本功能（尤其是无法读取文件的内容），下述代码简要总结了 File 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限管理</span></span><br><span class="line"><span class="keyword">boolean</span> canX = f.canExecute();</span><br><span class="line"><span class="keyword">boolean</span> canR = f.canRead();</span><br><span class="line"><span class="keyword">boolean</span> canW = f.canWrite();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> ok;</span><br><span class="line">ok = f.setReadOnly();</span><br><span class="line">ok = f.setExecutable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setReadable(<span class="keyword">true</span>);</span><br><span class="line">ok = f.setWritable(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用不同的方式表示文件名</span></span><br><span class="line">File absF = f.getAbsoluteFile();</span><br><span class="line">File canF = f.getCanonicalFile();</span><br><span class="line">String absName = f.getAbsolutePath();</span><br><span class="line">String canName = f.getCanonicalPath();</span><br><span class="line">String name = f.getName();</span><br><span class="line">String pName = getParent();</span><br><span class="line">URI fileURI = f.toURI(); <span class="comment">// 创建文件路径的URI形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件的元数据</span></span><br><span class="line"><span class="keyword">boolean</span> exists = f.exists();</span><br><span class="line"><span class="keyword">boolean</span> isAbs = f.isAbsolute();</span><br><span class="line"><span class="keyword">boolean</span> isDir = f.isDirectory();</span><br><span class="line"><span class="keyword">boolean</span> isFile = f.isFile();</span><br><span class="line"><span class="keyword">boolean</span> isHidden = f.isHidden();</span><br><span class="line"><span class="keyword">long</span> modTime = f.lastModified(); <span class="comment">// 距Epoch时间的毫秒数</span></span><br><span class="line"><span class="keyword">boolean</span> updateOK = f.setLastModified(updateTime); <span class="comment">// 毫秒</span></span><br><span class="line"><span class="keyword">long</span> fileLen = f.length();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件管理操作</span></span><br><span class="line"><span class="keyword">boolean</span> renamed = f.renameTo(destFile);</span><br><span class="line"><span class="keyword">boolean</span> deleted = f.delete();</span><br><span class="line"><span class="comment">// 创建文件不会覆盖现有文件</span></span><br><span class="line"><span class="keyword">boolean</span> createdOK = f.createNewFile();</span><br><span class="line"><span class="comment">// 处理临时文件</span></span><br><span class="line">File tmp = File.createTempFile(<span class="string">&quot;my-tmp&quot;</span>, <span class="string">&quot;.tmp&quot;</span>);</span><br><span class="line">tmp.deleteOnExit();</span><br><span class="line"><span class="comment">// 处理目录</span></span><br><span class="line"><span class="keyword">boolean</span> createdDir = dir.mkdir();</span><br><span class="line">String[] fileNames = dir.list();</span><br><span class="line">File[] files = dir.listFiles();</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：《Java 技术手册》&lt;/p&gt;
&lt;h2 id=&quot;File-类&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#File-类&quot;&gt;&lt;/a&gt;File 类&lt;/h2&gt;
&lt;p&gt;File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文</summary>
      
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-G-%E6%B3%9B%E5%9E%8B/</id>
    <published>2021-05-20T13:47:40.000Z</published>
    <updated>2021-05-28T04:23:12.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是泛型"><a class="header-anchor" href="#什么是泛型"></a>什么是泛型</h2><p>在讲解什么是泛型之前，我们先观察 Java 标准库提供的 <code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p><p>实际上 <code>ArrayList</code> 内部就是一个 <code>Object[]</code> 数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用上述 <code>ArrayList</code> 存储 String 类型，会有这么几个缺点：</p><ul><li>需要强制转型；</li><li>不方便，易出错。</li></ul><p>例如，代码必须这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>很容易出现 <code>ClassCastException</code>，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>要解决上述问题，我们可以为 String 单独编写一种 ArrayList：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringArrayList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，存入的必须是 String，取出的也一定是 String，不需要强制转型，因为编译器会强制检查放入的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringArrayList list = <span class="keyword">new</span> StringArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 编译错误: 不允许放入非String类型:</span></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br></pre></td></tr></table></figure><p>问题暂时解决。然而，新的问题是，如果要存储 Integer，还需要为 Integer 单独编写一种 ArrayList，实际上，还需要为其他所有 class 单独编写一种 ArrayList。这是不可能的，JDK 的 class 就有上千个，而且它还不知道其他人编写的 class。</p><p>为了解决新的问题，我们必须把 <code>ArrayList</code> 变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T</code> 可以是任何 class。这样一来，我们就实现了，编写一次模版，可以创建任意类型的 <code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></table></figure><p>因此，泛型就是定义一种模板，例如 <code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的 <code>ArrayList&lt;类型&gt;</code>。由编译器针对类型作检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strList.add(<span class="string">&quot;hello&quot;</span>); <span class="comment">// OK</span></span><br><span class="line">String s = strList.get(<span class="number">0</span>); <span class="comment">// OK</span></span><br><span class="line">strList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>)); <span class="comment">// compile error!</span></span><br><span class="line">Integer n = strList.get(<span class="number">0</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h3 id="向上转型"><a class="header-anchor" href="#向上转型"></a>向上转型</h3><p>在 Java 标准库中的 <code>ArrayList&lt;T&gt;</code> 实现了 <code>List&lt;T&gt;</code> 接口，它可以向上转型为 <code>List&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即类型 <code>ArrayList&lt;T&gt;</code> 可以向上转型为 <code>List&lt;T&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>要特别注意：不能把 <code>ArrayList&lt;Integer&gt;</code> 向上转型为 <code>ArrayList&lt;Number&gt;</code> 或 <code>List&lt;Number&gt;</code> 。</p><p>假设 <code>ArrayList&lt;Integer&gt;</code> 可以向上转型为 <code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ArrayList&lt;Integer&gt;类型：</span></span><br><span class="line">ArrayList&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">// 添加一个Integer：</span></span><br><span class="line">integerList.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;Number&gt;：</span></span><br><span class="line">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class="line"><span class="comment">// 添加一个Float，因为Float也是Number：</span></span><br><span class="line">numberList.add(<span class="keyword">new</span> Float(<span class="number">12.34</span>));</span><br><span class="line"><span class="comment">// 从ArrayList&lt;Integer&gt;获取索引为1的元素（即添加的Float）：</span></span><br><span class="line">Integer n = integerList.get(<span class="number">1</span>); <span class="comment">// ClassCastException!</span></span><br></pre></td></tr></table></figure><p>我们把一个 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code> 类型后，这个 <code>ArrayList&lt;Number&gt;</code> 就可以接受 Float 类型，因为 Float 是 Number 的子类。但是，<code>ArrayList&lt;Number&gt;</code> 实际上和 <code>ArrayList&lt;Integer&gt;</code> 是同一个对象，也就是 <code>ArrayList&lt;Integer&gt;</code> 类型，它不可能接受 Float 类型， 所以在获取 Integer 的时候将产生  <code>ClassCastException</code>。</p><p>实际上，编译器为了避免这种错误，根本就不允许把 <code>ArrayList&lt;Integer&gt;</code> 转型为 <code>ArrayList&lt;Number&gt;</code>。</p><p><code>ArrayList&lt;Integer&gt;</code> 和 <code>ArrayList&lt;Number&gt;</code> 两者完全没有继承关系。</p><h2 id="使用泛型"><a class="header-anchor" href="#使用泛型"></a>使用泛型</h2><p>使用 ArrayList 时，如果不定义泛型类型时，泛型类型实际上就是 Object：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器警告</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>此时，只能把 <code>&lt;T&gt;</code> 当作 Object 使用，没有发挥泛型的优势。</p><p>当我们定义泛型类型 <code>&lt;String&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;String&gt;</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>当我们定义泛型类型 <code>&lt;Number&gt;</code> 后，<code>List&lt;T&gt;</code> 的泛型接口变为强类型 <code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br><span class="line">Number first = list.get(<span class="number">0</span>);</span><br><span class="line">Number second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br></pre></td></tr></table></figure><p>编译器看到泛型类型 <code>List&lt;Number&gt;</code> 就可以自动推断出后面的 <code>ArrayList&lt;T&gt;</code> 的泛型类型必须是 <code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><p>除了 <code>ArrayList&lt;T&gt;</code> 使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code> 可以对任意数组进行排序，但待排序的元素必须实现 <code>Comparable&lt;T&gt;</code> 这个泛型接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回负数: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回正数: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接对 String 数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(ss);</span><br><span class="line">System.out.println(Arrays.toString(ss));</span><br></pre></td></tr></table></figure><p>这是因为 String 本身已经实现了 <code>Comparable&lt;String&gt;</code> 接口。如果换成我们自定义的 Person 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Bob&quot;</span>, <span class="number">61</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">88</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">75</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，我们会得到 <code>ClassCastException</code>，即无法将 Person 转型为 Comparable。我们修改代码，让 Person 实现 <code>Comparable&lt;T&gt;</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">&quot;,&quot;</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以正确实现按 <code>name</code> 进行排序。也可以修改比较逻辑，例如，按 <code>score</code> 从高到低排序。</p><h2 id="编写泛型"><a class="header-anchor" href="#编写泛型"></a>编写泛型</h2><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如 <code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p><p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p><p>可以按照以下步骤来编写一个泛型类。</p><p>首先，按照某种类型，例如 <code>String</code>，来编写类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String first;</span><br><span class="line">    <span class="keyword">private</span> String last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(String first, String last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，标记所有的特定类型，这里是 <code>String</code>，最后，把特定类型 <code>String</code> 替换为 <code>T</code>，并申明 <code>&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>熟练后即可直接从 <code>T</code> 开始编写。</p><h3 id="静态方法"><a class="header-anchor" href="#静态方法"></a>静态方法</h3><p>编写泛型类时，要特别注意，泛型类型 <code>&lt;T&gt;</code> 不能用于静态方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对静态方法使用&lt;T&gt;:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会导致编译错误，我们无法在静态方法 <code>create()</code> 的方法参数和返回类型上使用泛型类型 <code>T</code>。</p><p>可以在 <code>static</code> 修饰符后面加一个 <code>&lt;T&gt;</code>，编译就能通过：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以编译通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">create</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上，这个 <code>&lt;T&gt;</code> 和 <code>Pair&lt;T&gt;</code> 类型的 <code>&lt;T&gt;</code> 已经没有任何关系了。</p><p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的 <code>create()</code> 静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态泛型方法应该使用其他类型区分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;K&gt; <span class="function">Pair&lt;K&gt; <span class="title">create</span><span class="params">(K first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;K&gt;(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p><h3 id="多个泛型类型"><a class="header-anchor" href="#多个泛型类型"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望 <code>Pair</code> 不总是存储两个类型一样的对象，就可以使用类型 <code>&lt;T, K&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> K last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, K last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getLast</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，需要指出两种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;test&quot;</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>Java 标准库的 <code>Map&lt;K, V&gt;</code> 就是使用两种泛型类型的例子。它对 Key 使用一种类型，对 Value 使用另一种类型。</p><h3 id="擦拭法"><a class="header-anchor" href="#擦拭法"></a>擦拭法</h3><p>泛型是一种类似“模板代码”的技术，不同语言的泛型实现方式不一定相同。Java 语言的泛型实现方式是擦拭法（Type Erasure）。</p><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。例如，我们编写了一个泛型类 <code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object first;</span><br><span class="line">    <span class="keyword">private</span> Object last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，Java 使用擦拭法实现泛型，导致了：</p><ul><li>编译器把类型 <code>&lt;T&gt;</code> 视为 Object；</li><li>编译器根据 <code>&lt;T&gt;</code> 实现安全的强制转型。</li></ul><p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = p.getFirst();</span><br><span class="line">String last = p.getLast();</span><br></pre></td></tr></table></figure><p>而虚拟机执行的代码并没有泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair p = <span class="keyword">new</span> Pair(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">String first = (String) p.getFirst();</span><br><span class="line">String last = (String) p.getLast();</span><br></pre></td></tr></table></figure><p>所以，Java 的泛型是由编译器在编译时实行的，编译器内部永远把所有类型 <code>T</code> 视为 Object 处理，但是，在需要转型的时候，编译器会根据 <code>T</code> 的类型自动为我们实行安全地强制转型。</p><p>了解了 Java 泛型的实现方式——擦拭法，我们就知道了 Java 泛型的局限：</p><p>局限一：<code>&lt;T&gt;</code> 不能是基本类型，例如 int，因为实际类型是 Object，Object 类型无法持有基本类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>局限二：无法取得带泛型的 Class。观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p1 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Pair&lt;Integer&gt; p2 = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        Class c1 = p1.getClass();</span><br><span class="line">        Class c2 = p2.getClass();</span><br><span class="line">        System.out.println(c1==c2); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c1==Pair.class); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>T</code> 是 Object，我们对 <code>Pair&lt;String&gt;</code> 和 <code>Pair&lt;Integer&gt;</code> 类型获取 Class 时，获取到的是同一个 Class，也就是 Pair 类的 Class。</p><p>换句话说，所有泛型实例，无论 <code>T</code> 的类型是什么，<code>getClass()</code> 返回同一个 <code>Class</code> 实例，因为编译后它们全部都是 <code>Pair&lt;Object&gt;</code>。</p><p>局限三：无法判断带泛型的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p = <span class="keyword">new</span> Pair&lt;&gt;(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line"><span class="comment">// Compile error:</span></span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Pair&lt;String&gt;) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因和前面一样，并不存在 <code>Pair&lt;String&gt;.class</code>，而是只有唯一的 <code>Pair.class</code>。</p><p>局限四：不能实例化 <code>T</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Compile error:</span></span><br><span class="line">        first = <span class="keyword">new</span> T();</span><br><span class="line">        last = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无法通过编译，因为构造方法的两行语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T();</span><br><span class="line">last = <span class="keyword">new</span> T();</span><br></pre></td></tr></table></figure><p>擦拭后实际上变成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> Object();</span><br><span class="line">last = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>这样一来，创建 <code>new Pair&lt;String&gt;()</code> 和创建 <code>new Pair&lt;Integer&gt;()</code> 就全部成了 Object，显然编译器要阻止这种类型不对的代码。</p><p>要实例化 <code>T</code> 类型，我们必须借助额外的 <code>Class&lt;T&gt;</code> 参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        first = clazz.newInstance();</span><br><span class="line">        last = clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码借助 <code>Class&lt;T&gt;</code> 参数并通过反射来实例化T类型，使用的时候，也必须传入 <code>Class&lt;T&gt;</code> 。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(String.class);</span><br></pre></td></tr></table></figure><p>因为传入了 <code>Class&lt;String&gt;</code> 的实例，所以我们借助 <code>String.class</code> 就可以实例化 String 类型。</p><h3 id="不恰当的覆写方法"><a class="header-anchor" href="#不恰当的覆写方法"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为，定义的 <code>equals(T t)</code> 方法实际上会被擦拭成 <code>equals(Object t)</code>，而这个方法是继承自 Object 的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p><p>换个方法名，避开与 <code>Object.equals(Object)</code> 的冲突就可以成功编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">same</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span> == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型继承"><a class="header-anchor" href="#泛型继承"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是 <code>Pair&lt;Integer&gt;</code>，子类的类型是 <code>IntPair</code>，可以这么继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，因为子类 <code>IntPair</code> 并没有泛型类型，所以，正常使用即可。</p><p>前面讲了，我们无法获取 <code>Pair&lt;T&gt;</code> 的 <code>T</code> 类型，即给定一个变量 <code>Pair&lt;Integer&gt; p</code>，无法从 <code>p</code> 中获取到 <code>Integer</code> 类型。</p><p>但是，在父类是泛型类型的情况下，编译器就必须把类型 <code>T</code>（对 <code>IntPair</code> 来说，也就是 <code>Integer</code> 类型）保存到子类的 class 文件中，不然编译器就不知道 <code>IntPair</code> 只能存取 Integer 这种类型。</p><p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code> 可以获取到父类的泛型类型 Integer。获取父类的泛型类型代码比较复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;IntPair&gt; clazz = IntPair.class;</span><br><span class="line">        Type t = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            ParameterizedType pt = (ParameterizedType) t;</span><br><span class="line">            Type[] types = pt.getActualTypeArguments(); <span class="comment">// 可能有多个泛型类型</span></span><br><span class="line">            Type firstType = types[<span class="number">0</span>]; <span class="comment">// 取第一个泛型类型</span></span><br><span class="line">            Class&lt;?&gt; typeClass = (Class&lt;?&gt;) firstType;</span><br><span class="line">            System.out.println(typeClass); <span class="comment">// Integer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T last;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntPair</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntPair</span><span class="params">(Integer first, Integer last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Java 引入了泛型，所以，只用 Class 来标识类型已经不够了。实际上，Java 的类型系统结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                      ┌────┐</span><br><span class="line">                      │Type│</span><br><span class="line">                      └────┘</span><br><span class="line">                         ▲</span><br><span class="line">                         │</span><br><span class="line">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class="line">   │            │                  │               │</span><br><span class="line">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class="line">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class="line">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="extends-通配符"><a class="header-anchor" href="#extends-通配符"></a>extends 通配符</h2><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code> 不是 <code>Pair&lt;Number&gt;</code> 的子类。</p><p>假设我们定义了 <code>Pair&lt;T&gt;</code>，然后，我们又针对 <code>Pair&lt;Number&gt;</code> 类型写了一个静态方法，它接收的参数类型是 <code>Pair&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Pair&lt;Number&gt; p)</span> </span>&#123;</span><br><span class="line">        Number first = p.getFirst();</span><br><span class="line">        Number last = p.getLast();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + last.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是可以正常编译的。使用的时候，我们传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = PairHelper.add(<span class="keyword">new</span> Pair&lt;Number&gt;(<span class="number">1</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">泛型是一种“代码模板”，可以用一套代码套用各种类型。</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-E-%E5%8F%8D%E5%B0%84/</id>
    <published>2021-05-20T09:42:40.000Z</published>
    <updated>2021-05-28T04:23:36.206Z</updated>
    
    <content type="html"><![CDATA[<p>反射（Reflection），Java 的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.halo.test.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得 <code>Person</code> 类，只有一个 <code>Object</code> 实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？强制转型？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用 <code>Person</code> 类。不然，去掉import语句，不能编译通过</p><p>而反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p><h2 id="Class-类"><a class="header-anchor" href="#Class-类"></a>Class 类</h2><p>除了 int 等基本类型外，Java 的其他类型全部都是 class（包括 interface ）。</p><p>仔细思考，我们可以得出结论：class（包括 interface ）的本质是数据类型（Type）。无继承关系的数据类型无法赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// OK</span></span><br><span class="line">String s = <span class="keyword">new</span> Double(<span class="number">123.456</span>); <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure><p>而 class 是由 JVM 在执行过程中动态加载的。JVM 在第一次读取到一种 class 类型时，将其加载进内存。</p><p>每加载一种 class，JVM 就为其创建一个 <code>Class</code> 类型的实例，并关联起来。注意：这里的 <code>Class</code> 类型是一个名叫 Class 的 class。它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 String 类为例，当 JVM 加载 String 类时，它首先读取 <code>String.class</code> 文件到内存，然后，为 String 类创建一个 <code>Class</code> 实例并关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = <span class="keyword">new</span> Class(String);</span><br></pre></td></tr></table></figure><p>这个 <code>Class</code> 实例是 JVM 内部创建的，如果我们查看 JDK 源码，可以发现 <code>Class</code> 类的构造方法是 private，只有 JVM 能创建 <code>Class</code> 实例，我们自己的 Java 程序是无法创建 Class 实例的。</p><p>所以， JVM 持有的每个 <code>Class</code> 实例都指向一个数据类型（class或interface）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Random</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.util.Random&quot;  │</span><br><span class="line">└───────────────────────────┘</span><br><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; Runnable</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.Runnable&quot;│</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>一个 <code>Class</code> 实例包含了该 class 的所有完整信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name &#x3D; &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package &#x3D; &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super &#x3D; &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface &#x3D; CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field &#x3D; value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method &#x3D; indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure><p>由于 JVM 为每个加载的 class 创建了对应的 <code>Class</code> 实例，并在实例中保存了该 class 的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个 <code>Class</code> 实例，我们就可以通过这个 <code>Class</code> 实例获取到该实例对应的 class 的所有信息。</p><p>这种通过 <code>Class</code> 实例获取 class 信息的方法称为反射（Reflection）。</p><p>如何获取一个 class 的 <code>Class</code> 实例？有三个方法：</p><p>方法一：直接通过一个 class 的静态变量 class 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class;</span><br></pre></td></tr></table></figure><p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></table></figure><p>方法三：如果知道一个 class 的完整类名，可以通过静态方法 <code>Class.forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>因为 <code>Class</code> 实例在 JVM 中是唯一的，所以，上述方法获取的 <code>Class</code> 实例是同一个实例。可以用 <code>==</code> 比较两个 <code>Class</code> 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class cls1 = String.class;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>注意一下 <code>Class</code> 实例比较和 <code>instanceof</code> 的差别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true，因为n是Integer类型</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true，因为n是Number类型的子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer.class; <span class="comment">// true，因为n.getClass()返回Integer.class</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number.class; <span class="comment">// false，因为Integer.class!=Number.class</span></span><br></pre></td></tr></table></figure><p>用 <code>instanceof</code> 不但匹配指定类型，还匹配指定类型的子类。而用 <code>==</code> 判断 class 实例可以精确地判断数据类型，但不能作子类型比较。</p><p>通常情况下，我们应该用 <code>instanceof</code> 判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个 class 的时候，我们才使用 <code>==</code> 判断 class 实例。</p><p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个 <code>Object</code> 实例时，我们可以通过反射获取该 <code>Object</code> 的 class 信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printObjectInfo</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Class cls = obj.getClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要从 <code>Class</code> 实例获取获取的基本信息，参考下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printClassInfo(<span class="string">&quot;&quot;</span>.getClass());</span><br><span class="line">        printClassInfo(Runnable.class);</span><br><span class="line">        printClassInfo(java.time.Month.class);</span><br><span class="line">        printClassInfo(String[].class);</span><br><span class="line">        printClassInfo(<span class="keyword">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassInfo</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Class name: &quot;</span> + cls.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;Simple name: &quot;</span> + cls.getSimpleName());</span><br><span class="line">        <span class="keyword">if</span> (cls.getPackage() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Package name: &quot;</span> + cls.getPackage().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;is interface: &quot;</span> + cls.isInterface());</span><br><span class="line">        System.out.println(<span class="string">&quot;is enum: &quot;</span> + cls.isEnum());</span><br><span class="line">        System.out.println(<span class="string">&quot;is array: &quot;</span> + cls.isArray());</span><br><span class="line">        System.out.println(<span class="string">&quot;is primitive: &quot;</span> + cls.isPrimitive());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到数组（例如 <code>String[]</code>）也是一种 <code>Class</code>，而且不同于 <code>String.class</code>，它的类名是 <code>[Ljava.lang.String</code>。此外，JVM 为每一种基本类型如 <code>int</code> 也创建了 <code>Class</code>，通过 <code>int.class</code> 访问。</p><p>如果获取到了一个 <code>Class</code> 实例，我们就可以通过该 <code>Class</code> 实例来创建对应类型的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取String的Class实例:</span></span><br><span class="line">Class cls = String.class;</span><br><span class="line"><span class="comment">// 创建一个String实例:</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><p>上述代码相当于 <code>new String()</code>。通过 <code>Class.newInstance()</code> 可以创建类实例，它的局限是：只能调用 public 的无参数构造方法。带参数的构造方法，或者非 public 的构造方法都无法通过 <code>Class.newInstance()</code> 被调用。</p><h2 id="动态加载"><a class="header-anchor" href="#动态加载"></a>动态加载</h2><p>JVM 在执行 Java 程序的时候，并不是一次性把所有用到的 class 全部加载到内存，而是第一次需要用到 class 时才加载。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            create(args[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 Main.java 时，由于用到了 <code>Main</code>，因此，JVM 首先会把 Main.class 加载到内存。然而，并不会加载 Person.class，除非程序执行到 <code>create()</code> 方法，JVM 发现需要加载 <code>Person</code> 类时，才会首次加载 <code>Person.class</code>。如果没有执行 <code>create()</code> 方法，那么 Person.class根本就不会被加载。</p><p>这就是 JVM 动态加载 class 的特性。</p><p>动态加载 class 的特性对于 Java 程序非常重要。利用 JVM 动态加载 class 的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging 总是优先使用 Log4j，只有当 Log4j 不存在时，才使用 JDK 的 logging。利用 JVM 动态加载特性，大致的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j:</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">&quot;org.apache.logging.log4j.Logger&quot;</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是为什么我们只需要把 Log4j 的 jar 包放到 classpath 中，Commons Logging 就会自动使用 Log4j 的原因。</p><h2 id="访问字段"><a class="header-anchor" href="#访问字段"></a>访问字段</h2><p>对任意的一个 Object 实例，只要我们获取了它的 <code>Class</code>，就可以获取它的一切信息。</p><p>我们先看看如何通过 <code>Class</code> 实例获取字段信息。<code>Class</code> 类提供了以下几个方法来获取字段：</p><ul><li><code>Field getField(name)</code>：根据字段名获取某个 public 的 field（包括父类）</li><li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li><li><code>Field[] getFields()</code>：获取所有 public 的 field（包括父类）</li><li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public字段&quot;score&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;score&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段&quot;name&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private字段&quot;grade&quot;:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">&quot;grade&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 <code>Student</code> 的 <code>Class</code> 实例，然后，分别获取 <code>public</code> 字段、继承的 <code>public</code> 字段以及 <code>private</code> 字段，打印出的 Field ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int Student.score</span><br><span class="line">public java.lang.String Person.name</span><br><span class="line">private int Student.grade</span><br></pre></td></tr></table></figure><p>一个 Field 对象包含了一个字段的所有信息：</p><ul><li><code>getName()</code>：返回字段名称，例如，<code>name</code>；</li><li><code>getType()</code>：返回字段类型，也是一个 <code>Class</code> 实例，例如，<code>String.class</code>；</li><li><code>getModifiers()</code>：返回字段的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>以 String 类的 <code>value</code> 字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.getName(); <span class="comment">// &quot;value&quot;</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>利用反射拿到字段的一个 Field 实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p><p>例如，对于一个 <code>Person</code> 实例，我们可以先拿到 <code>name</code> 字段对应的 Field，再获取这个实例的 <code>name</code> 字段的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码先获取 <code>Class</code> 实例，再获取 Field 实例，然后，用 <code>Field.get(Object)</code> 获取指定实例的指定字段的值。</p><p>运行代码，如果不出意外，会得到一个 <code>IllegalAccessException</code>，这是因为 <code>name</code> 被定义为一个 private 字段，正常情况下，<code>Main</code> 类无法访问 <code>Person</code> 类的 private 字段。要修复错误，可以将 private 改为 public，或者，在调用<code>Object value = f.get(p);</code> 前，先写一句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>调用 <code>Field.setAccessible(true)</code> 的意思是，别管这个字段是不是 public，一律允许访问。再运行代码，就可以打印出 private 字段的值。</p><p>如果使用反射可以获取 private 字段的值，那么类的封装还有什么意义？</p><p>答案是正常情况下，我们总是通过 <code>p.name</code> 来访问 Person 的 name 字段，编译器会根据 public、protected 和 private 决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code> 可能会失败。如果 JVM 运行期存在 SecurityManager，那么它会根据规则进行检查，有可能阻止 <code>setAccessible(true)</code> 。例如，某个 SecurityManager 可能不允许对 java 和 javax 开头的 package 的类调用 <code>setAccessible(true)</code>，这样可以保证 JVM 核心库的安全。</p><h2 id="设置字段值"><a class="header-anchor" href="#设置字段值"></a>设置字段值</h2><p>通过 Field 实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p><p>设置字段值是通过 <code>Field.set(Object, Object)</code> 实现的，其中第一个 <code>Object</code> 参数是指定的实例，第二个 <code>Object</code> 参数是待修改的值。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Ming&quot;</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">&quot;Xiao Hong&quot;</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Xiao Hong&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，打印的 <code>name</code> 字段从 <code>Xiao Ming</code> 变成了 <code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非 public 字段，需要首先调用 <code>setAccessible(true)</code>。</p><h2 id="调用方法"><a class="header-anchor" href="#调用方法"></a>调用方法</h2><p>我们已经能通过 Class 实例获取所有 Field 对象，同样的，可以通过 Class 实例获取所有 Method 信息。Class 类提供了以下几个方法来获取 Method：</p><ul><li><code>Method getMethod(name, Class...)</code>：获取某个 public 的 Method（包括父类）</li><li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个 Method（不包括父类）</li><li><code>Method[] getMethods()</code>：获取所有 public 的 Method（包括父类）</li><li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有 Method（不包括父类）</li></ul><p>我们来看一下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student.class;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getScore&quot;</span>, String.class));</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">&quot;getName&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">&quot;getGrade&quot;</span>, <span class="keyword">int</span>.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先获取 Student 的 Class 实例，然后，分别获取 public 方法、继承的 public 方法以及 private 方法，打印出的 Method 类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p>一个 <code>Method</code> 对象包含一个方法的所有信息：</p><ul><li><code>getName()</code>：返回方法名称，例如：“getScore”；</li><li><code>getReturnType()</code>：返回方法返回值类型，也是一个 Class 实例，例如：<code>String.class</code>；</li><li><code>getParameterTypes()</code>：返回方法的参数类型，是一个 Class 数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li><li><code>getModifiers()</code>：返回方法的修饰符，它是一个 int，不同的 bit 表示不同的含义。</li></ul><p>当我们获取到一个 Method 对象时，就可以对它进行调用。我们以下面的代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">String r = s.substring(<span class="number">6</span>); <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>如果用反射来调用 <code>substring</code> 方法，需要以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod(<span class="string">&quot;substring&quot;</span>, <span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 Method 实例调用 <code>invoke</code> 就相当于调用该方法，<code>invoke</code> 的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p><h3 id="调用静态方法"><a class="header-anchor" href="#调用静态方法"></a>调用静态方法</h3><p>如果获取到的 Method 表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以 <code>invoke</code> 方法传入的第一个参数永远为 null。我们以 <code>Integer.parseInt(String)</code> 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod(<span class="string">&quot;parseInt&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">&quot;12345&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用非-public-方法"><a class="header-anchor" href="#调用非-public-方法"></a>调用非 public 方法</h3><p>和 Field 类似，对于非 public 方法，我们虽然可以通过 <code>Class.getDeclaredMethod()</code> 获取该方法实例，但直接对其调用将得到一个 <code>IllegalAccessException</code> 。为了调用非 public 方法，我们通过 <code>Method.setAccessible(true)</code> 允许其调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a class="header-anchor" href="#多态"></a>多态</h3><p>我们来考察这样一种情况：一个 <code>Person</code> 类定义了 <code>hello()</code> 方法，并且它的子类 <code>Student</code> 也覆写了 <code>hello()</code> 方法，那么，从 <code>Person.class</code> 获取的 Method，作用于 <code>Student</code> 实例时，调用的方法到底是哪个？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student:hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，发现打印出的是 <code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method m = Person.class.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br></pre></td></tr></table></figure><p>实际上相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="调用构造方法"><a class="header-anchor" href="#调用构造方法"></a>调用构造方法</h2><p>我们通常使用new操作符创建新的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>如果通过反射来创建新的实例，可以调用 Class 提供的 <code>newInstance()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = Person.class.newInstance();</span><br></pre></td></tr></table></figure><p>调用 <code>Class.newInstance()</code> 的局限是，它只能调用该类的 public 无参数构造方法。如果构造方法带有参数，或者不是 public，就无法直接通过 <code>Class.newInstance()</code> 来调用。</p><p>为了调用任意的构造方法，Java 的反射 API 提供了 <code>Constructor</code> 对象，它包含一个构造方法的所有信息，可以创建一个实例。<code>Constructor</code> 对象和 Method 非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer.class.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer.class.getConstructor(String.class);</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 Class 实例获取 Constructor 的方法如下：</p><ul><li><code>getConstructor(Class...)</code>：获取某个 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructor(Class...)</code>：获取某个 Constructor`；</li><li><code>getConstructors()</code>：获取所有 public 的 <code>Constructor</code>；</li><li><code>getDeclaredConstructors()</code>：获取所有 <code>Constructor</code>。</li></ul><p>注意 <code>Constructor</code> 总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p><p>调用非 public 的 <code>Constructor</code> 时，必须首先通过 <code>setAccessible(true)</code> 设置允许访问。<code>setAccessible(true)</code> 可能会失败。</p><h2 id="获取继承关系"><a class="header-anchor" href="#获取继承关系"></a>获取继承关系</h2><p>当我们获取到某个 Class 对象时，实际上就获取到了一个类的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = String.class; <span class="comment">// 获取到String的Class</span></span><br></pre></td></tr></table></figure><p>还可以用实例的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">Class cls = s.getClass(); <span class="comment">// s是String，因此获取到String的Class</span></span><br></pre></td></tr></table></figure><p>最后一种获取 Class 的方法是通过 <code>Class.forName(&quot;&quot;)</code>，传入 Class 的完整类名获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class s = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br></pre></td></tr></table></figure><p>这三种方式获取的 Class 实例都是同一个实例，因为 JVM 对每个加载的 Class 只创建一个 Class 实例来表示它的类型。</p><h3 id="获取父类的-Class"><a class="header-anchor" href="#获取父类的-Class"></a>获取父类的 Class</h3><p>有了 Class 实例，我们还可以获取它的父类的 Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer.class;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，可以看到，Integer 的父类类型是 Number，Number 的父类是 Object，Object 的父类是 null。除 Object 外，其他任何非 interface 的 Class都必定存在一个父类类型。</p><h3 id="获取-interface"><a class="header-anchor" href="#获取-interface"></a>获取 interface</h3><p>由于一个类可能实现一个或多个接口，通过 Class 我们就可以查询到实现的接口类型。例如，查询 Integer 实现的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码可知，Integer 实现的接口有：</p><ul><li><code>java.lang.Comparable</code></li><li><code>java.lang.constant.Constable</code></li><li><code>java.lang.constant.ConstantDesc</code></li></ul><p>要特别注意：<code>getInterfaces()</code> 只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer.class.getSuperclass();</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer 的父类是 Number，Number 实现的接口是 <code>java.io.Serializable</code>。</p><p>此外，对所有 interface 的 Class 调用 <code>getSuperclass()</code> 返回的是 null，获取接口的父接口要用 <code>getInterfaces()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(java.io.DataInputStream.class.getSuperclass()); </span><br><span class="line"><span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line">System.out.println(java.io.Closeable.class.getSuperclass()); </span><br><span class="line"><span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><p>如果一个类没有实现任何 interface，那么 <code>getInterfaces()</code> 返回空数组。</p><h3 id="继承关系"><a class="header-anchor" href="#继承关系"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用 <code>instanceof</code> 操作符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果是两个 Class 实例，要判断一个向上转型是否成立，可以调用 <code>isAssignableFrom()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object.class.isAssignableFrom(Integer.class); <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer.class.isAssignableFrom(Number.class); <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h3 id="动态代理"><a class="header-anchor" href="#动态代理"></a>动态代理</h3><p>我们来比较 Java 的 class 和 interface 的区别：</p><ul><li>可以实例化 class（非abstract）；</li><li>不能实例化 interface。</li></ul><p>所有 interface 类型的变量总是通过向上转型并指向某个实例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharSequence cs = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure><p>有没有可能不编写实现类，直接在运行期创建某个 interface 的实例呢？</p><p>这是可能的，因为 Java 标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个 interface 的实例。</p><p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p><p>定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Good morning, &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例，转型为接口并调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello hello = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br></pre></td></tr></table></figure><p>这种方式就是我们通常编写代码的方式。</p><p>还有一种方式是动态代码，我们仍然先定义了接口 <code>Hello</code>，但是我们并不去编写实现类，而是直接通过 JDK 提供的一个 <code>Proxy.newProxyInstance()</code> 创建了一个 <code>Hello</code> 接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK 提供的动态创建接口对象的方式，就叫动态代理。</p><p>一个最简单的动态代理实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期动态创建一个 interface 实例的方法如下：</p><ul><li>定义一个 <code>InvocationHandler</code> 实例，它负责实现接口的方法调用；</li><li>通过 <code>Proxy.newProxyInstance()</code> 创建 interface 实例，它需要3个参数：<ol><li>使用的 <code>ClassLoader</code>，通常就是接口类的 <code>ClassLoader</code>；</li><li>需要实现的接口数组，至少需要传入一个接口进去；</li><li>用来处理接口方法调用的 <code>InvocationHandler</code> 实例。</li></ol></li><li>将返回的 Object 强制转型为接口。</li></ul><p>动态代理实际上是 JVM 在运行期动态创建 class 字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloDynamicProxy</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloDynamicProxy</span><span class="params">(InvocationHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        handler.invoke(</span><br><span class="line">           <span class="keyword">this</span>,</span><br><span class="line">           Hello.class.getMethod(<span class="string">&quot;morning&quot;</span>, String.class),</span><br><span class="line">           <span class="keyword">new</span> Object[] &#123; name &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是 JVM 帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>]]></content>
    
    
    <summary type="html">Java 反射</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://halo123.top/2021/05/20/Java/Java-D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2021-05-20T09:33:40.000Z</published>
    <updated>2021-05-28T04:23:29.107Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="廖雪峰Java教程" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">廖雪峰Java教程</p><p class="url">https://www.liaoxuefeng.com/wiki/1252599548343744/1255943543190176</p></div></a></div><h2 id="Java-的异常"><a class="header-anchor" href="#Java-的异常"></a>Java 的异常</h2><p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p><p>有一些错误是用户造成的，比如，希望用户输入一个 int 类型的年龄，但是用户的输入是 abc：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设用户输入了abc：</span></span><br><span class="line">String s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(s); <span class="comment">// NumberFormatException</span></span><br></pre></td></tr></table></figure><p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户删除了该文件：</span></span><br><span class="line">String t = readFile(<span class="string">&quot;C:\\abc.txt&quot;</span>); <span class="comment">// FileNotFoundException!</span></span><br></pre></td></tr></table></figure><p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p><ul><li>网络突然断了，连接不到远程服务器；</li><li>内存耗尽，程序崩溃了；</li><li>用户点“打印”，但根本没有打印机；</li><li>……</li></ul><p>所以，一个健壮的程序必须处理各种各样的错误。</p><p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><p>方法一：约定返回错误码。</p><p>例如，处理一个文件，如果返回 0，表示成功，返回其他整数，表示约定的错误码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> code = processFile(<span class="string">&quot;C:\\test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error:</span></span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// file not found:</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// no read permission:</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// unknown error:</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用 int 类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p><p>方法二：在语言层面上提供一个异常处理机制。</p><p>Java 内置了一套异常处理机制，总是使用异常来表示错误。</p><p>异常是一种 class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String s = processFile(“C:\\test.txt”);</span><br><span class="line">    <span class="comment">// ok:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// file not found:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">    <span class="comment">// no read permission:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// io error:</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// other error:</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从继承关系可知：<code>Throwable</code> 是异常体系的根，它继承自 <code>Object</code>。<code>Throwable</code> 有两个体系：<code>Error</code> 和 <code>Exception</code>，<code>Error</code> 表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而 <code>Exception</code> 则是运行时的错误，它可以被捕获并处理。</p><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><code>NumberFormatException</code>：数值类型的格式错误</li><li><code>FileNotFoundException</code>：未找到文件</li><li><code>SocketException</code>：读取网络失败</li></ul><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><code>NullPointerException</code>：对某个 null 的对象调用方法或字段</li><li><code>IndexOutOfBoundsException</code>：数组索引越界</li></ul><p><code>Exception</code> 又分为两大类：</p><ul><li><code>RuntimeException</code> 以及它的子类；</li><li>非 <code>RuntimeException</code>（包括 <code>IOException</code>、<code>ReflectiveOperationException</code> 等等）</li></ul><p>Java规定：</p><ul><li>必须捕获的异常，包括 <code>Exception</code> 及其子类，但不包括 <code>RuntimeException</code> 及其子类，这种类型的异常称为 Checked Exception。</li><li>不需要捕获的异常，包括 <code>Error</code> 及其子类，<code>RuntimeException</code> 及其子类。</li></ul><p>注意：编译器对 <code>RuntimeException</code> 及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理 <code>RuntimeException</code>。是否需要捕获，具体问题具体分析。</p><h2 id="捕获异常"><a class="header-anchor" href="#捕获异常"></a>捕获异常</h2><p>捕获异常使用 <code>try...catch</code> 语句，把可能发生异常的代码放到 <code>try &#123;...&#125;</code> 中，然后使用 <code>catch</code> 捕获对应的 <code>Exception</code> 及其子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不捕获 <code>UnsupportedEncodingException</code>，会出现编译失败的问题</p><p>编译器会报错，错误信息类似：<code>unreported exception UnsupportedEncodingException; must be caught or declared to be thrown</code>，并且准确地指出需要捕获的语句是 <code>return s.getBytes(&quot;GBK&quot;);</code> 。意思是说，像 <code>UnsupportedEncodingException</code> 这样的 Checked Exception，必须被捕获。</p><p>这是因为 <code>String.getBytes(String)</code> 方法定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法定义的时候，使用 <code>throws Xxx</code> 表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。<br><code>在</code>toGBK()<code>方法中，因为调用了</code>String.getBytes(String)<code>方法，就必须捕获</code>UnsupportedEncodingException<code>。我们也可以不捕获它，而是在方法定义处用 </code>throws<code>表示</code>toGBK()<code> 方法可能会抛出</code>UnsupportedEncodingException<code>，就可以让 </code>toGBK()` 方法通过编译器检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用 <code>return s.getBytes(&quot;GBK&quot;);</code> 的问题，而是 <code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在 <code>main()</code> 方法中，调用 <code>toGBK()</code>，没有捕获它声明的可能抛出的 <code>UnsupportedEncodingException</code> 。修复方法是在 <code>main()</code> 方法中捕获异常并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(bs));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要是方法声明的 Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在 <code>main()</code> 方法中捕获，不会出现漏写 <code>try</code> 的情况。这是由编译器保证的。<code>main()</code> 方法也是最后捕获 <code>Exception</code> 的机会。</p><p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何 <code>try</code> 代码，可以直接把 <code>main()</code> 方法定义为 <code>throws Exception</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>main()</code> 方法声明了可能抛出 <code>Exception</code>，也就声明了可能抛出所有的 <code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p><p>捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来。所有异常都可以调用 <code>printStackTrace()</code> 方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        <span class="comment">// 先记下来再说:</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="多-catch-语句"><a class="header-anchor" href="#多-catch-语句"></a>多 catch 语句</h3><p>可以使用多个 <code>catch</code> 语句，每个 <code>catch</code> 分别捕获对应的 <code>Exception</code> 及其子类。JVM 在捕获到异常后，会从上到下匹配 <code>catch</code> 语句，匹配到某个 <code>catch</code> 后，执行 <code>catch</code> 代码块，然后不再继续匹配。</p><p>简单地说就是：多个 <code>catch</code> 语句只有一个能被执行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在多个 <code>catch</code> 的时候，<code>catch</code> 的顺序非常重要，子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码，<code>UnsupportedEncodingException</code> 异常是永远捕获不到的，因为它是 <code>IOException</code> 的子类。当抛出 <code>UnsupportedEncodingException</code> 异常时，会被 <code>catch (IOException e) &#123; ... &#125;</code> 捕获并执行。因此，正确的写法是把子类放到前面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finally-语句"><a class="header-anchor" href="#finally-语句"></a>finally 语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p><p>可以把执行语句写若干遍：正常执行的放到 try 中，每个 catch 再写一遍。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码无论是否发生异常，都会执行 <code>System.out.println(&quot;END&quot;);</code> 这条语句。</p><p>那么如何消除这些重复的代码？Java 的 <code>try ... catch</code> 机制还提供了 <code>finally</code> 语句，<code>finally</code> 语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>finally</code> 有几个特点：</p><ul><li><code>finally</code> 语句不是必须的，可写可不写；</li><li><code>finally</code> 总是最后执行。</li></ul><p>如果没有发生异常，就正常执行 <code>try &#123; ... &#125;</code> 语句块，然后执行 <code>finally</code>。如果发生了异常，就中断执行 <code>try &#123; ... &#125;</code> 语句块，然后跳转执行匹配的 <code>catch</code> 语句块，最后执行 <code>finally</code>。</p><p>可见，<code>finally</code> 是用来保证一些代码必须执行的。</p><p>某些情况下，可以没有 <code>catch</code>，只使用 <code>try ... finally</code> 结构。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为方法声明了可能抛出的异常，所以可以不写 <code>catch</code>。</p><p>TODO: IO情况下不安全问题</p><h3 id="捕获多种异常"><a class="header-anchor" href="#捕获多种异常"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条 <code>catch</code> 子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为处理 <code>IOException</code> 和 <code>NumberFormatException</code> 的代码是相同的，所以我们可以把它两用 <code>|</code> 合并到一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抛出异常"><a class="header-anchor" href="#抛出异常"></a>抛出异常</h2><h3 id="异常的传播"><a class="header-anchor" href="#异常的传播"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个 <code>try ... catch</code> 被捕获为止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer.parseInt(<span class="keyword">null</span>); <span class="comment">// 会抛出NumberFormatException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>printStackTrace()</code> 可以打印出方法的调用栈，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: null</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:614)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.process2(Main.java:16)</span><br><span class="line">    at Main.process1(Main.java:12)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code> 对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code> 是在 <code>java.lang.Integer.parseInt</code> 方法中被抛出的，从下往上看，调用层次依次是：</p><ol><li><code>main()</code> 调用 <code>process1()</code></li><li><code>process1()</code> 调用 <code>process2()</code></li><li><code>process2()</code> 调用 <code>Integer.parseInt(String)</code></li><li><code>Integer.parseInt(String)</code> 调用 <code>Integer.parseInt(String, int)</code></li></ol><p>查看 <code>Integer.java</code> 源码可知，抛出异常的方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且，每层调用均给出了源代码的行号，可直接定位。</p><h3 id="抛出异常-v2"><a class="header-anchor" href="#抛出异常-v2"></a>抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p><p>如何抛出异常？参考 <code>Integer.parseInt()</code> 方法，抛出异常分两步：</p><ol><li>创建某个 <code>Exception</code> 的实例；</li><li>用 <code>throw</code> 语句抛出。</li></ol><p>下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个方法捕获了某个异常后，又在 <code>catch</code> 子句中抛出新的异常，就相当于把抛出的异常类型“转换”了，当 <code>process2()</code> 抛出 <code>NullPointerException</code> 后，被 <code>process1()</code> 捕获，然后抛出 <code>IllegalArgumentException()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在 <code>main()</code> 中捕获 <code>IllegalArgumentException</code>，我们看看打印的异常栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常 <code>NullPointerException</code> 的信息了。</p><p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的 <code>Exception</code> 实例传进去，新的 <code>Exception</code> 就可以持有原始 <code>Exception</code> 信息。对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure><p>注意到 <code>Caused by: Xxx</code>，说明捕获的 <code>IllegalArgumentException</code> 并不是造成问题的根源，根源在于 <code>NullPointerException</code>，是在 <code>Main.process2()</code> 方法抛出的。</p><p>在代码中获取原始异常可以使用 <code>Throwable.getCause()</code> 方法。如果返回 <code>null</code>，说明已经是“根异常”了。</p><p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p><p>如果我们在 <code>try</code> 或者 <code>catch</code> 语句块中抛出异常，<code>finally</code> 语句是否会执行？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at Main.main(Main.java:8)</span><br><span class="line">Caused by: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">  at ...</span><br></pre></td></tr></table></figure><p>第一行打印了 <code>caught</code>，说明进入了 catch 语句块。第二行打印了 <code>finally</code> ，说明执行了 finally 语句块。</p><p>因此，在 catch 中抛出异常，不会影响 finally 的执行。JVM 会先执行 finally，然后抛出异常。</p><h3 id="异常屏蔽"><a class="header-anchor" href="#异常屏蔽"></a>异常屏蔽</h3><p>如果在执行 finally 语句时抛出异常，那么，catch 语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;caught&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caught</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>这说明 finally 抛出异常后，原来在 catch 中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p><p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用 <code>origin</code> 变量保存原始异常，然后调用 <code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在 finally 抛出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Exception origin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Integer.parseInt(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            origin = e;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Exception e = <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">            <span class="keyword">if</span> (origin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(origin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 catch 和 finally 都抛出了异常时，虽然 catch 的异常被屏蔽了，但是，finally 抛出的异常仍然包含了它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br><span class="line">Suppressed: java.lang.NumberFormatException: For input string: &quot;abc&quot;</span><br><span class="line">    at java.base&#x2F;java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:652)</span><br><span class="line">    at java.base&#x2F;java.lang.Integer.parseInt(Integer.java:770)</span><br><span class="line">    at Main.main(Main.java:6)</span><br></pre></td></tr></table></figure><p>通过 <code>Throwable.getSuppressed()</code> 可以获取所有的 <code>Suppressed Exception</code>。</p><p>绝大多数情况下，在 finally 中不要抛出异常。因此，我们通常不需要关心 <code>Suppressed Exception</code>。</p><h2 id="自定义异常"><a class="header-anchor" href="#自定义异常"></a>自定义异常</h2><p>Java 标准库定义的常用异常包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p>当我们在代码中需要抛出异常时，尽量使用 JDK 已定义的异常类型。例如，参数检查不合法，应该抛出 <code>IllegalArgumentException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p>一个常见的做法是自定义一个 <code>BaseException</code> 作为“根异常”，然后，派生出各种业务类型的异常。</p><p><code>BaseException</code> 需要从一个适合的 <code>Exception</code> 派生，通常建议从 <code>RuntimeException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从 <code>BaseException</code> 派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>自定义的 <code>BaseException</code> 应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述构造方法实际上都是原样照抄 <code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h2 id="NullPointerException"><a class="header-anchor" href="#NullPointerException"></a>NullPointerException</h2><p>在所有的 <code>RuntimeException</code> 异常中，Java 程序员最熟悉的恐怕就是 <code>NullPointerException</code> 了。</p><p><code>NullPointerException</code> 即空指针异常，俗称 NPE。如果一个对象为 <code>null</code>，调用其方法或访问其字段就会产生 <code>NullPointerException</code>，这个异常通常是由 JVM 抛出的，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针这个概念实际上源自 C 语言，Java 语言中并无指针。我们定义的变量实际上是引用，Null Pointer 更确切地说是 Null Reference，不过两者区别不大。</p><h3 id="处理NullPointerException"><a class="header-anchor" href="#处理NullPointerException"></a>处理NullPointerException</h3><p>如果遇到 <code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code> 是一种代码逻辑错误，遇到 <code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用 <code>catch</code> 来隐藏这种编码错误，好的编码习惯可以极大地降低 <code>NullPointerException</code> 的产生，例如成员变量在定义时初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用空字符串 <code>&quot;&quot;</code> 而不是默认的 <code>null</code> 可避免很多 <code>NullPointerException</code> ，编写业务逻辑时，用空字符串 <code>&quot;&quot;</code> 表示未填写比 <code>null</code> 安全得多。</p><p>返回空字符串 <code>&quot;&quot;</code> 、空数组而不是 <code>null</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] readLinesFromFile(String file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getFileSize(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回空数组而不是null:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得调用方无需检查结果是否为 <code>null</code>。</p><p>如果调用方一定要根据 <code>null</code> 判断，比如返回 <code>null</code> 表示文件不存在，那么考虑返回 <code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过 <code>Optional.isPresent()</code> 判断是否有结果。</p><h3 id="定位-NullPointerException"><a class="header-anchor" href="#定位-NullPointerException"></a>定位 NullPointerException</h3><p>如果产生了 <code>NullPointerException</code>，例如，调用 <code>a.b.c.x()</code> 时产生了 <code>NullPointerException</code>，原因可能是：</p><ul><li><code>a</code> 是 <code>null</code>；</li><li><code>a.b</code> 是 <code>null</code>；</li><li><code>a.b.c</code> 是 <code>null</code>；</li></ul><p>确定到底是哪个对象是 <code>null</code> 以前只能打印这样的日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(a.b);</span><br><span class="line">System.out.println(a.b.c);</span><br></pre></td></tr></table></figure><p>从 Java 14 开始，如果产生了 <code>NullPointerException</code>，JVM 可以给出详细的信息告诉我们 <code>null</code> 对象到底是谁。我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p.address.city.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String[] name = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    Address address = <span class="keyword">new</span> Address();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String city;</span><br><span class="line">    String street;</span><br><span class="line">    String zipcode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot invoke &quot;String.toLowerCase()&quot; because &quot;p.address.city&quot; is null</span><br><span class="line">at Main.main(Main.java:4)</span><br></pre></td></tr></table></figure><p>可以在 <code>NullPointerException</code> 的详细信息中看到类似 <code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是 <code>city</code> 字段为 <code>null</code>，这样我们就能快速定位问题所在。</p><p>这种增强的 <code>NullPointerException</code> 详细信息是 Java 14 新增的功能，但默认是关闭的，我们可以给 JVM 添加一个 <code>-XX:+ShowCodeDetailsInExceptionMessages</code> 参数启用它，在 JDK 15 及以上默认是开启的。</p><h2 id="使用断言"><a class="header-anchor" href="#使用断言"></a>使用断言</h2><p>断言（Assertion）是一种调试程序的方式。在 Java 中，使用 <code>assert</code> 关键字来实现断言。我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 <code>assert x &gt;= 0;</code> 即为断言，断言条件 <code>x &gt;= 0</code> 预期为 <code>true</code>。如果计算结果为 <code>false</code>，则断言失败，抛出 <code>AssertionError</code>。</p><p>使用 <code>assert</code> 语句时，还可以添加一个可选的断言消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure><p>这样，断言失败的时候，<code>AssertionError</code> 会带上消息 <code>x must &gt;= 0</code>，更加便于调试。</p><p>Java 断言的特点是：断言失败时会抛出 <code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p><p>对于可恢复的程序错误，不应该使用断言。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> arr != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该抛出异常并在上层捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;array cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在程序中使用 <code>assert</code> 时，例如，一个简单的断言：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">assert</span> x &gt; <span class="number">0</span>;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言 <code>x</code> 必须大于 0，实际上 <code>x</code> 为 -1，断言肯定失败。执行上述代码，发现程序并未抛出 <code>AssertionError</code>，而是正常打印了 <code>x</code> 的值。为什么 <code>assert</code> 语句不起作用？</p><p>这是因为 JVM 默认关闭断言指令，即遇到 <code>assert</code> 语句就自动忽略了，不执行。</p><p>要执行 <code>assert</code> 语句，必须给 Java 虚拟机传递 <code>-enableassertions</code>（可简写为 <code>-ea</code> ）参数启用断言。所以，上述程序必须在命令行下运行才有效果。</p><p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.halo.test.Main</code> ，表示只对 <code>com.halo.test.Main</code> 这个类启用断言。或者对特定地包启用断言，命令行参数是：<code>-ea:com.halo.test...</code>（注意结尾有 3 个 <code>.</code> ），表示对 <code>com.halo.test</code> 这个包启动断言。</p><p>实际开发中，很少使用断言。更好的方法是编写单元测试，例如 JUnit。</p><h2 id="使用JDK-Logging"><a class="header-anchor" href="#使用JDK-Logging"></a>使用JDK Logging</h2><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用 <code>System.out.println()</code> 打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p><p>代码改好了怎么办？当然是删除没有用的 <code>System.out.println()</code> 语句了。</p><p>如果改代码又改出问题怎么办？再加上 <code>System.out.println()</code>。</p><p>反复这么搞几次，很快大家就发现使用 <code>System.out.println()</code> 非常麻烦。</p><p>怎么办？解决方法是使用日志（Logging）。它的目的是为了取代 <code>System.out.println()</code>。</p><p>输出日志，而不是用 <code>System.out.println()</code>，有以下几个好处：</p><ol><li>可以设置输出样式，避免自己每次都写 <code>&quot;ERROR: &quot; + var</code></li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志</li><li>可以按包名控制日志级别，只输出某些包打的日志</li><li>……</li></ol><p>因为 Java 标准库内置了日志包 <code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">May 20, 2021 4:42:58 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。再仔细观察发现，4 条日志，只打印了 3 条，<code>logger.fine()</code> 没有打印。这是因为，日志的输出可以设定级别。JDK 的 Logging 定义了 7 个日志级别，从严重到普通：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。</p><p>因为默认级别是 INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p><p>使用 Java 标准库内置的 Logging 有以下局限：</p><p>Logging 系统在 JVM 启动时读取配置文件并完成初始化，一旦开始运行 main() 方法，就无法修改配置；</p><p>配置不太方便，需要在 JVM 启动时传递参数 <code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p><p>因此，Java 标准库内置的 Logging 使用并不是非常广泛。</p><h2 id="使用-Commons-Logging"><a class="header-anchor" href="#使用-Commons-Logging"></a>使用 Commons Logging</h2><p>和 Java 标准库提供的日志不同，Commons Logging 是一个第三方日志库，它是由 Apache 创建的日志模块。</p><p>Commons Logging 的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin 自动搜索并使用 Log4j（ Log4j 是另一个流行的日志系统），如果没有找到 Log4j，再使用 JDK Logging。</p><p>使用 Commons Logging 只需要和两个类打交道，并且只有两步：</p><ul><li>第一步，通过LogFactory获取Log类的实例</li><li>第二步，使用Log实例的方法打日志。</li></ul><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Maven 项目 pom.xml 中添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">INFO: start...</span><br><span class="line">May <span class="number">20</span>, <span class="number">2021</span> <span class="number">4</span>:<span class="number">56</span>:<span class="number">02</span> PM com.halo.logging.Main main</span><br><span class="line">WARNING: end.</span><br></pre></td></tr></table></figure><p>Commons Logging 定义了 6 个日志级别：FATAL、ERROR、WARNING、INFO、DEBUG、TRACE。默认级别是 INFO。</p><p>使用 Commons Logging 时，如果在静态方法中引用 Log，通常直接定义一个静态类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用 Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例方法中引用 <code>Log</code>，通常定义一个实例变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到实例变量 <code>log</code> 的获取方式是 <code>LogFactory.getLog(getClass())</code>，虽然也可以用 <code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该 <code>log</code> 实例。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Java 类的动态特性，子类获取的 <code>log</code> 字段实际上相当于 <code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><p>此外，Commons Logging 的日志方法，例如 <code>info()</code>，除了标准的 <code>info(String)</code> 外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Log4j"><a class="header-anchor" href="#使用-Log4j"></a>使用 Log4j</h2><p>前面介绍了 Commons Logging ，可以作为“日志接口”来使用。而真正的“日志实现”可以使用 Log4j。</p><p>Log4j 是一种非常流行的日志框架。是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure><p>当我们使用 Log4j 输出一条日志时，Log4j 自动通过不同的 Appender 把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库。</li></ul><p>在输出日志的过程中，通过 <code>Filter</code> 来过滤哪些 log 需要被输出，哪些 log 不需要被输出。例如，仅输出 ERROR 级别的日志。</p><p>最后，通过 Layout 来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心 Log4j 的 API，而是通过配置文件来配置它。</p><p>以 Maven项目 的 XML 配置为例，使用 Log4j 的时候，我们把一个 log4j2.xml 的文件放到 main/resourse 下就可以让 Log4j 读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然配置 Log4j 比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是 INFO 级别的日志，会自动输出到屏幕，而 ERROR 级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j 就会自动切割新的日志文件，并最多保留 10 份。</p><p>在 Maven 项目 pom.xml 中添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-jcl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-jcl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要打印日志，只需要按 Commons Logging 的写法写，不需要改动任何代码，就可以得到 Log4j 的日志输出，类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">05-20 17:13:44.186 [main] INFO  com.halo.logging.Main</span><br><span class="line">start...</span><br><span class="line"></span><br><span class="line">05-20 17:13:44.191 [main] WARN  com.halo.logging.Main</span><br><span class="line">end.</span><br></pre></td></tr></table></figure><h2 id="使用-SLF4J-和-Logback"><a class="header-anchor" href="#使用-SLF4J-和-Logback"></a>使用 SLF4J 和 Logback</h2><p>前面介绍了 Commons Logging 和 Log4j 这一对，它们一个负责充当日志 API，一个负责实现日志底层，搭配使用非常便于开发。</p><p>其实 SLF4J 类似于Commons Logging，也是一个日志接口，而 Logback 类似于 Log4j，是一个日志的实现。</p><p>为什么有了 Commons Logging 和 Log4j，又会蹦出来 SLF4J 和 Logback？这是因为 Java 有着非常悠久的开源历史，不但 OpenJDK 本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p><p>因为对 Commons Logging 的接口不满意，有人就搞了 SLF4J。因为对 Log4j 的性能不满意，有人就搞了 Logback。</p><p>我们先来看看 SLF4J 对 Commons Logging 的接口有何改进。在 Commons Logging 中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以 SLF4J 的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J 的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>如何使用 SLF4J ？它的接口实际上和 Commons Logging 几乎一模一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下 Commons Logging 和 SLF4J 的接口，不同之处就是 <code>Log</code> 变成了 <code>Logger</code>，<code>LogFactory</code> 变成了 <code>LoggerFactory</code>。</p><p>在 Maven 项目中添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/ch.qos.logback/logback-classic --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>logback-classic</code> 依赖包括了 <code>slf4j-api</code> 所以无需单独引用</p><p>在 Maven 项目中添加相关配置文件 logback.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>log/output.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>log/output.log.%i<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxFileSize</span>&gt;</span>1MB<span class="tag">&lt;/<span class="name">MaxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行即可获得类似如下的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17:28:08.829 [main] INFO  com.halo.slf4j.Test - start...</span><br><span class="line">17:28:08.832 [main] WARN  com.halo.slf4j.Test - end.</span><br></pre></td></tr></table></figure><p>从目前的趋势来看，越来越多的开源项目从 Commons Logging 加 Log4j 转向了 SLF4J 加 Logback。</p>]]></content>
    
    
    <summary type="html">Java 异常和日志</summary>
    
    
    
    <category term="Java" scheme="https://halo123.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://halo123.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蘑菇博客环境搭建</title>
    <link href="https://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://halo123.top/2021/05/15/MoGuBlog/A_%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T07:45:20.000Z</published>
    <updated>2021-05-15T13:34:29.956Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="蘑菇博客项目地址" href="https://gitee.com/moxi159753/mogu_blog_v2"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/Gitee.svg"/></div><div class="right"><p class="text">蘑菇博客项目地址</p><p class="url">https://gitee.com/moxi159753/mogu_blog_v2</p></div></a></div><p>蘑菇博客（MoguBlog），一个基于微服务架构的前后端分离博客系统。Web 端使用 Vue + Element , 移动端使用 uniapp 和 ColorUI。后端使用 Spring Cloud + Spring Boot + mybatis-plus 进行开发，使用 Jwt + Spring Security 做登录验证和权限校验，使用 ElasticSearch 和 Solr 作为全文检索服务，使用 Github Actions 完成博客的持续集成，使用 ELK 收集博客日志，文件支持上传七牛云和 Minio，支持 Docker Compose 脚本一键部署。</p><p>参考资料：</p><div class="tag link"><a class="link-card" title="Windows+VMware一键搭建蘑菇博客本地开发环境" href="http://www.moguit.cn/#/info?blogOid=583"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">Windows+VMware一键搭建蘑菇博客本地开发环境</p><p class="url">http://www.moguit.cn/#/info?blogOid=583</p></div></a></div><h2 id="Docker-环境"><a class="header-anchor" href="#Docker-环境"></a>Docker 环境</h2><p>在 VMware 或 云服务器中 配置 Docker 环境</p><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><p>因为我们需要拉取镜像，所以需要在服务器提前安装好 Docker，首先配置一下 Docker 的阿里 yum 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo&lt;&lt;EOF</span><br><span class="line">[docker-ce-edge]</span><br><span class="line">name&#x3D;Docker CE Edge - \$basearch</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;7&#x2F;\$basearch&#x2F;edge</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后 yum 方式安装 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># yum安装</span><br><span class="line">yum -y install docker-ce</span><br><span class="line"># 查看docker版本</span><br><span class="line">docker --version  </span><br><span class="line"># 开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"># 启动docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>配置 Docker 的镜像源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;b9pmyelo.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>然后重启 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><p>因为 Docker 容器之间，需要互相通信访问，所以我们需要创建我们的 Docker 网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create mogu</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-Compose"><a class="header-anchor" href="#安装-Docker-Compose"></a>安装 Docker Compose</h3><p>Docker Compose 是用来定义和运行多个 Docker 应用程序的工具。通过 Compose，可以使用 YAML 文件来配置应用程序需要的所有服务，然后使用一个命令即可从YML文件配置中创建并启动所有服务。</p><div class="tag link"><a class="link-card" title="安装 Docker Compose 官方文档" href="https://docs.docker.com/compose/install/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">安装 Docker Compose 官方文档</p><p class="url">https://docs.docker.com/compose/install/</p></div></a></div><div class="tag link"><a class="link-card" title="Docker Compose 下载链接" href="https://github.com/docker/compose/releases"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">Docker Compose 下载链接</p><p class="url">https://github.com/docker/compose/releases</p></div></a></div><p>把下载到的文件使用 ftp 工具，拷贝到 /usr/local/bin/ 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 重命名</span><br><span class="line">mv docker-compose-Linux-x86_64  docker-compose</span><br><span class="line"># 加入执行权限</span><br><span class="line">sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"># 查看docker-compose版本</span><br><span class="line">docker-compose -v</span><br></pre></td></tr></table></figure><h2 id="下载源码"><a class="header-anchor" href="#下载源码"></a>下载源码</h2><p>下载蘑菇博客的<a href="https://gitee.com/moxi159753/mogu_blog_v2">源码</a></p><p>找到，doc\docker-compose 目录，目录结构如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-compose</span><br><span class="line"> ├── bin     # 相关一键启动脚本的目录</span><br><span class="line"> ├── config  # 存放配置文件</span><br><span class="line"> ├── data    # 存放数据文件</span><br><span class="line"> ├── log     # 存放日志文件</span><br><span class="line"> └── yaml    # 存放 docker compose 的 yaml 文件</span><br></pre></td></tr></table></figure><p>下面我们开始，将 docker-compose 文件夹，拷贝服务器目录位置随意，我是拷贝到 /root/docker-compose 目录，然后给命令设置执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入目录</span><br><span class="line">cd docker-compose</span><br><span class="line"># 添加执行权限</span><br><span class="line">chmod +x bin&#x2F;middleware.sh</span><br><span class="line">chmod +x bin&#x2F;kernShutdown.sh</span><br><span class="line">chmod +x bin&#x2F;wait-for-it.sh</span><br></pre></td></tr></table></figure><h2 id="部署核心组件"><a class="header-anchor" href="#部署核心组件"></a>部署核心组件</h2><p>下面我们将部署蘑菇博客所依赖的核心中间件，例如：Nacos、MySQL、Redis、RabbitMQ、Nginx 等</p><p>首先到 docker-compose/bin 目录下，执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 开始部署核心组件</span><br><span class="line">sh middleware.sh</span><br><span class="line"># 以后打算关闭的话，执行 .&#x2F;kernShutdown.sh</span><br></pre></td></tr></table></figure><p>在部署完中间件后，我们需要进行测试中间件安装是否成功。</p><h3 id="MySQL"><a class="header-anchor" href="#MySQL"></a>MySQL</h3><p>利用 SQLyog、IDEA等工具测试连接：</p><p>默认MySQL用户名：root<br>默认MySQL密码：mogu2018</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Idea%E6%B5%8B%E8%AF%95mugo_mysql%E8%BF%9E%E6%8E%A5.png" alt="Idea测试mugo_mysql连接"></p><h3 id="Nacos"><a class="header-anchor" href="#Nacos"></a>Nacos</h3><p>Nacos 后台配置页面，默认账号和密码：nacos  nacos</p><p>访问下面 URL 进行测试 <a href="http://nacos:8848/nacos">http://nacos:8848/nacos</a></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95nacos_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试nacos_mugo连接"></p><blockquote><p>设置 host 将 nacos 改为对应服务器外网 IP ，记得开放对应端口</p></blockquote><h3 id="Redis"><a class="header-anchor" href="#Redis"></a>Redis</h3><p>默认Redis密码：mogu2018</p><h3 id="RabbitMQ"><a class="header-anchor" href="#RabbitMQ"></a>RabbitMQ</h3><p>RabbitMQ是消息队列，我们可以访问其图形化界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 图形化地址</span><br><span class="line">IP地址:15672</span><br><span class="line"># 默认账号和密码为：admin  mogu2018</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B5%8B%E8%AF%95rabbitmq_mugo%E8%BF%9E%E6%8E%A5.png" alt="测试rabbitmq_mugo连接"></p><h2 id="部署非核心组件"><a class="header-anchor" href="#部署非核心组件"></a>部署非核心组件</h2><h3 id="Zipkin"><a class="header-anchor" href="#Zipkin"></a>Zipkin</h3><p>Zipkin是一个开源的分布式的链路追踪系统，每个微服务都会向zipkin报告计时数据，聚合各业务系统调用延迟数据，达到链路调用监控跟踪</p><h3 id="Sentinel"><a class="header-anchor" href="#Sentinel"></a>Sentinel</h3><h3 id="搜索模块"><a class="header-anchor" href="#搜索模块"></a>搜索模块</h3><h2 id="启动后端项目"><a class="header-anchor" href="#启动后端项目"></a>启动后端项目</h2><h3 id="修改项目配置"><a class="header-anchor" href="#修改项目配置"></a>修改项目配置</h3><p>修改的是 mogu_admin 项目的 application.yml，将 dev 改成 prod 然后修改 bootstrap.yaml ，将 dev 改成 prod，同时还需要修改 nacos 和 sentinel ，将 localhost改为对应的服务名称即可。</p><p>我们重复上面操作，将 mogu_web、mogu_sms、mogu_gateway、mogu_picture、mogu_montor 等项目都进行修改。</p><h3 id="启动项目"><a class="header-anchor" href="#启动项目"></a>启动项目</h3><p>修改完成后，直接启动项目即可。其中我们需要启动核心组件包含下面几个【服务启动没有先后顺序】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mogu_admin、mogu_web、mogu_sms、mogu_picture、mogu_gateway</span><br></pre></td></tr></table></figure><p>等服务器都启动完成后，下面我们验证一下后台是否正常启动，回到我们的 Nacos 管理界面,如果我们看到下面五个服务都注册到 Nacos 中，那说明启动成功</p><ul><li>mogu_picture</li><li>mogu_sms</li><li>mogu_admin</li><li>mogu_web</li><li>mogu_gateway</li></ul><p>在通过访问下列 swagger 接口，测试接口是否正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">############ admin端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8601&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ picture端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8602&#x2F;swagger-ui&#x2F;index.html</span><br><span class="line"></span><br><span class="line">############ web端swagger ##################</span><br><span class="line">http:&#x2F;&#x2F;localhost:8603&#x2F;swagger-ui&#x2F;index.html</span><br></pre></td></tr></table></figure><p>如果能够进入下面页面的话，说明后台是没有问题的了，下面我们可以验证一下接口</p>]]></content>
    
    
    <summary type="html">蘑菇博客是我目前找到理想的博客系统，基于对该项目的学习，进一步掌握 Java 后端过程</summary>
    
    
    
    <category term="蘑菇博客" scheme="https://halo123.top/categories/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器环境搭建</title>
    <link href="https://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://halo123.top/2021/05/15/WebAfterEnd/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-05-15T06:56:51.000Z</published>
    <updated>2021-05-15T06:47:29.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于-Docker-的环境搭建"><a class="header-anchor" href="#基于-Docker-的环境搭建"></a>基于 Docker 的环境搭建</h2><h3 id="安装Docker"><a class="header-anchor" href="#安装Docker"></a>安装Docker</h3><div class="tag link"><a class="link-card" title="Docker文档" href="https://docs.docker.com/engine/install/centos/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/DockerIcon.svg"/></div><div class="right"><p class="text">Docker文档</p><p class="url">https://docs.docker.com/engine/install/centos/</p></div></a></div><ol><li><p>卸载系统之前的docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li><li><p>安装依赖的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure></li><li><p>配置镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p>启动Docker服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>检测Docker是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></li><li><p>查看下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="配置-Docker-镜像加速"><a class="header-anchor" href="#配置-Docker-镜像加速"></a>配置 Docker 镜像加速</h3><div class="tag link"><a class="link-card" title="阿里云镜像加速" href="https://cr.console.aliyun.com/cn-qingdao/instances/mirrors"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/icon/阿里云.svg"/></div><div class="right"><p class="text">阿里云镜像加速</p><p class="url">https://cr.console.aliyun.com/cn-qingdao/instances/mirrors</p></div></a></div><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>您可以通过修改daemon配置文件 /etc/docker/daemon.json 来使用加速器</p><ol><li><p>创建目录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器地址</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;578xeysa.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 后台线程</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></li><li><p>重启 Docker 服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-MySQL"><a class="header-anchor" href="#安装-MySQL"></a>安装 MySQL</h3><ol><li><p>拉取 MySQL 5.7 的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>检查下载的镜像</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;log:&#x2F;var&#x2F;log&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-v &#x2F;mydata&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 3306:3306</code> 将容器的3306端口映射到主机的3306端口<br><code>--name</code> 指定容器名字<br><code>-v</code>目录挂载<br><code>-e</code>设置mysql参数，初始化root用户的密码<br><code>-d</code>后台运行</p></blockquote></li><li><p>查看 Docker 正在运行的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>进入容器内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bin&#x2F;bash</span><br><span class="line"># 退出命令</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li><li><p>查看 MySQL 位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure></li><li><p>修改 MySQL 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;mysql&#x2F;conf&#x2F;my.cnf</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect&#x3D;&#39;SET collation_connection &#x3D; utf8_unicode_ci&#39;</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8&#39;</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">collation-server&#x3D;utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>重启 MySQL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Redis"><a class="header-anchor" href="#安装-Redis"></a>安装 Redis</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure></li><li><p>先配置目录，注意 <code>redis.conf</code> 是文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p &#x2F;mydata&#x2F;redis&#x2F;conf</span><br><span class="line">touch &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>安装，挂载目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;data:&#x2F;data \</span><br><span class="line">-v &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">-d redis redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li><p>直接进去 redis 客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis redis-cli</span><br></pre></td></tr></table></figure></li><li><p>配置 redis 持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;mydata&#x2F;redis&#x2F;conf&#x2F;redis.conf</span><br></pre></td></tr></table></figure><p>插入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart redis</span><br></pre></td></tr></table></figure></li><li><p>设置 redis 容器在 Docker 启动的时候启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update redis --restart&#x3D;always</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Nacos"><a class="header-anchor" href="#安装-Nacos"></a>安装 Nacos</h3><ol><li><p>拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8848:8848 --env MODE&#x3D;standalone --name nacos nacos&#x2F;nacos-server</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装-Elasticsearch、Kibana"><a class="header-anchor" href="#安装-Elasticsearch、Kibana"></a>安装 Elasticsearch、Kibana</h3><ol><li><p>下载镜像文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 存储和检索数据</span><br><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line"># 可视化检索数据</span><br><span class="line">docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure></li><li><p>配置挂载数据文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置文件目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;config</span><br><span class="line"></span><br><span class="line"># 创建数据目录</span><br><span class="line">mkdir -p &#x2F;mydata&#x2F;elasticsearch&#x2F;data</span><br><span class="line"></span><br><span class="line"># 将&#x2F;mydata&#x2F;elasticsearch&#x2F;文件夹中文件都可读可写</span><br><span class="line">chmod -R 777 &#x2F;mydata&#x2F;elasticsearch&#x2F;</span><br><span class="line"></span><br><span class="line"># 配置任意机器可以访问 elasticsearch</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;&#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure></li><li><p>启动 Elasticsearch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e  &quot;discovery.type&#x3D;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS&#x3D;&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;config&#x2F;elasticsearch.yml \</span><br><span class="line">-v &#x2F;mydata&#x2F;elasticsearch&#x2F;data:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;data \</span><br><span class="line">-v  &#x2F;mydata&#x2F;elasticsearch&#x2F;plugins:&#x2F;usr&#x2F;share&#x2F;elasticsearch&#x2F;plugins \</span><br><span class="line">-d elasticsearch:7.4.2 </span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-p 9200:9200 -p 9300:9300</code>：向外暴露两个端口，9200 用于HTTP REST API请求，9300 ES 在分布式集群状态下 ES 之间的通信端口；<br><code>-e  &quot;discovery.type=single-node&quot;</code>：es 以单节点运行<br><code>-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;</code>：设置启动占用内存，不设置可能会占用当前系统所有内存<br><code>-v</code>：挂载容器中的配置文件、数据文件、插件数据到本机的文件夹；<br><code>-d elasticsearch:7.6.2</code>：指定要启动的镜像</p></blockquote></li><li><p>设置 Elasticsearch 随 Docker 启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当前 Docker 开机自启，所以 ES 现在也是开机自启</span><br><span class="line">docker update elasticsearch --restart&#x3D;always</span><br></pre></td></tr></table></figure></li><li><p>启动可视化 Kibana</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS&#x3D;http:&#x2F;&#x2F;&#123;IP地址&#125;:9200 \</span><br><span class="line">-p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br></pre></td></tr></table></figure><blockquote><p>配置说明：<br><code>-e ELASTICSEARCH_HOSTS=http://&#123;IP地址&#125;:9200</code>: 这里要设置成自己的虚拟机IP地址</p></blockquote></li><li><p>浏览器输入 IP地址:5601 测试</p><blockquote><p>注意：将服务器对应端口的防火墙关闭</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">由于环境搭建比较繁琐，该文章用于记录平时需要配置的一些环境过程，一方面为了复现，另一方面在环境有问题时可以用做参考</summary>
    
    
    
    <category term="Linux" scheme="https://halo123.top/categories/Linux/"/>
    
    
    <category term="Docker" scheme="https://halo123.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/"/>
    <id>https://halo123.top/2021/05/14/LeetCode/GreedyAlgorithm/</id>
    <published>2021-05-14T10:56:51.000Z</published>
    <updated>2021-05-30T12:27:38.664Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><div class="tag link"><a class="link-card" title="《LeetCode 101：和你一起你轻松刷题（C++）》" href="https://github.com/changgyhub/leetcode_101"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">《LeetCode 101：和你一起你轻松刷题（C++）》</p><p class="url">https://github.com/changgyhub/leetcode_101</p></div></a></div><h2 id="算法解释"><a class="header-anchor" href="#算法解释"></a>算法解释</h2><p>顾名思义，贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。</p><p>举一个最简单的例子：小明和小王喜欢吃苹果，小明可以吃五个，小王可以吃三个。已知苹果园里有吃不完的苹果，求小明和小王一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。又因为全局结果是局部结果的简单求和，且局部结果互不相干，因此局部最优的策略也同样是全局最优的策略。</p><h2 id="分配问题"><a class="header-anchor" href="#分配问题"></a>分配问题</h2><h3 id="分发饼干"><a class="header-anchor" href="#分发饼干"></a>分发饼干</h3><div class="tag link"><a class="link-card" title="455. 分发饼干" href="https://leetcode-cn.com/problems/assign-cookies/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">455. 分发饼干</p><p class="url">https://leetcode-cn.com/problems/assign-cookies/</p></div></a></div><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 <code>i</code> ，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><div class="tabs" id="分发饼干"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发饼干-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发饼干-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发饼干-1"><p>输入：<code>g = [1,2,3]</code> ，<code>s = [1,1]</code></p><p>输出：<code>1</code></p><p>解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1，2，3。虽然你有两块小饼干，由于他们的尺寸都是 1 ，你只能让胃口值是 1 的孩子满足。所以你应该输出 1 。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发饼干-2"><p>输入：<code>g = [1,2]</code>，<code>s = [1,2,3]</code></p><p>输出：<code>2</code></p><p>解释：你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1，2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>因为饥饿度最小的孩子最容易吃饱，所以我们先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子之后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，直到没有满足条件的饼干存在。</p><p>简而言之，这里的贪心策略是，给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p><p>至于具体实现，因为我们需要获得大小关系，一个便捷的方法就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少个对子可以满足条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; g, vector&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对胃口值进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 对饼干进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 循环遍历，如果其中一个数组长度小于另一个则跳出循环</span></span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.<span class="built_in">size</span>() &amp;&amp; cookie &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                <span class="comment">// 满足一个孩子</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 无论是否满足都将饼干++</span></span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回满足的孩子数</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cookies = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">findContentChildren</span>(children, cookies);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;example 2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="comment"># 升序排序</span></span><br><span class="line">    g.sort()</span><br><span class="line">    s.sort()</span><br><span class="line">    child = cookie = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(child &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> cookie &lt; <span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> (g[child] &lt;= s[cookie]):</span><br><span class="line">            child += <span class="number">1</span></span><br><span class="line">        cookie += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(test1)</span><br><span class="line">test2 = findContentChildren([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(test2)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>, cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span></span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        <span class="keyword">int</span> result = solution.findContentChildren(g, s);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] g1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s1 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 1&quot;</span>);</span><br><span class="line">        test(g1,s1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] g2 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] s2 = &#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;example 2&quot;</span>);</span><br><span class="line">        test(g2,s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(m \log m + n \log n$)，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。对两个数组排序的时间复杂度是 $O(m \log m + n \log n)$，遍历数组的时间复杂度是 $O(m+n)$，因此总时间复杂度是 $O(m \log m + n \log n)$。</p><p>空间复杂度：$O(\log m + \log n)$，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。空间复杂度主要是排序的额外空间开销。</p><h3 id="分发糖果"><a class="header-anchor" href="#分发糖果"></a>分发糖果</h3><div class="tag link"><a class="link-card" title="135. 分发糖果" href="https://leetcode-cn.com/problems/candy/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">135. 分发糖果</p><p class="url">https://leetcode-cn.com/problems/candy/</p></div></a></div><p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><div class="tabs" id="分发糖果"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分发糖果-1">示例 1</button></li><li class="tab"><button type="button" data-href="#分发糖果-2">示例 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分发糖果-1"><p>输入：<code>[1,0,2]</code></p><p>输出：<code>5</code></p><p>解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分发糖果-2"><p>输入：<code>[1,2,2]</code></p><p>输出：<code>4</code></p><p>解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>虽然这一道题也是运用贪心策略，但我们只需要简单的两次遍历即可：</p><ol><li>把所有孩子的糖果数初始化为 1；</li><li>先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1；</li><li>再从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1。</li></ol><p>通过这两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，在每次遍历中，只考虑并更新相邻一侧的大小关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">candies</span><span class="params">(nums, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从左遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i + <span class="number">1</span>] &gt; ratings[i]) &#123;</span><br><span class="line">                candies[i + <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i - <span class="number">1</span>] &gt; ratings[i] &amp;&amp; candies[i - <span class="number">1</span>] &lt;= candies[i]) &#123;</span><br><span class="line">                candies[i - <span class="number">1</span>] = candies[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">accumulate</span>(candies.<span class="built_in">begin</span>(), candies.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; children = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">candy</span>(children);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">candy</span>(<span class="params">ratings</span>):</span></span><br><span class="line">    lens = <span class="built_in">len</span>(ratings)</span><br><span class="line">    <span class="keyword">if</span>(lens &lt; <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> lens</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将糖果数量列表每项值初始化为1</span></span><br><span class="line">    num_list = [<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 先从左往右遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, lens-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果右边孩子的评分比左边的高</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[i+<span class="number">1</span>] &gt; ratings[i]):</span><br><span class="line">            <span class="comment"># 右边孩子的糖果数更新为左边孩子的糖果数加 1</span></span><br><span class="line">            num_list[i+<span class="number">1</span>] = num_list[i]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再从右往左遍历一遍</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lens-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 如果左边孩子的评分比右边的高</span></span><br><span class="line">        <span class="comment"># 且左边孩子当前的糖果数不大于右边孩子的糖果数</span></span><br><span class="line">        <span class="keyword">if</span>(ratings[j-<span class="number">1</span>] &gt; ratings[j] <span class="keyword">and</span> num_list[j-<span class="number">1</span>] &lt;= num_list[j]):</span><br><span class="line">            num_list[j-<span class="number">1</span>] = num_list[j]+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求得总糖果数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> num_list:</span><br><span class="line">        num += k</span><br><span class="line">    <span class="keyword">return</span> num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>, <span class="number">2</span>]))</span><br><span class="line"><span class="built_in">print</span>(candy([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要遍历两次数组以分别计算满足左规则或右规则的最少糖果数量。</p><p>空间复杂度：$O(n)$，其中 $n$ 是孩子的数量。我们需要保存所有的左规则对应的糖果数量。</p><h2 id="区间问题"><a class="header-anchor" href="#区间问题"></a>区间问题</h2><h3 id="无重叠区间"><a class="header-anchor" href="#无重叠区间"></a>无重叠区间</h3><div class="tag link"><a class="link-card" title="435. 无重叠区间" href="https://leetcode-cn.com/problems/non-overlapping-intervals/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">435. 无重叠区间</p><p class="url">https://leetcode-cn.com/problems/non-overlapping-intervals/</p></div></a></div><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p>注意:</p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 <code>[1,2]</code> 和 <code>[2,3]</code> 的边界相互“接触”，但没有相互重叠。</li></ol><div class="tabs" id="无重叠区间"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#无重叠区间-1">示例 1</button></li><li class="tab"><button type="button" data-href="#无重叠区间-2">示例 2</button></li><li class="tab"><button type="button" data-href="#无重叠区间-3">示例 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="无重叠区间-1"><p>输入：<code>[ [1,2], [2,3], [3,4], [1,3] ]</code></p><p>输出：<code>1</code></p><p>解释：移除 <code>[1,3]</code> 后，剩下的区间没有重叠。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-2"><p>输入：<code>[ [1,2], [1,2], [1,2] ]</code></p><p>输出：<code>2</code></p><p>解释：你需要移除两个 <code>[1,2]</code> 来使剩下的区间没有重叠</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="无重叠区间-3"><p>输入：<code>[ [1,2], [2,3] ]</code></p><p>输出：<code>0</code></p><p>解释：你不需要移除任何区间，因为它们已经是无重叠的了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其它区间的空间就越大，就越能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不相交的区间。</p><p>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小且和前一个选择的区间不重叠的区间。我们这里使用 C++ 的 Lambda，结合 <code>std::sort()</code> 函数进行自定义排序。</p><p>在样例中，排序后的数组为 <code>[[1,2], [1,3], [2,4]]</code>。按照我们的贪心策略：</p><ol><li>首先初始化为区间<code>[1,2]</code>；</li><li>由于 <code>[1,3]</code> 与 <code>[1,2]</code> 相交，我们跳过该区间；</li><li>由于 <code>[2,4]</code> 与 <code>[1,2]</code> 不相交，我们将其保留。</li><li>因此最终保留的区间为 <code>[[1,2], [2,4]]</code>。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [](vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; prev) &#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector &lt;vector&lt;<span class="keyword">int</span>&gt;&gt; test = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = Solution::<span class="built_in">eraseOverlapIntervals</span>(test);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">复杂度分析</font></strong></p><p>时间复杂度：$O(n \log n)$，其中 $n$ 是区间的数量。我们需要 $O(n \log n)$ 的时间对所有的区间按照右端点进行升序排序，并且需要 $O(n)$ 的时间进行遍历。由于前者在渐进意义下大于后者，因此总时间复杂度为 $O(n \log n)$。</p><p>空间复杂度：$O(\log n)$，即为排序需要使用的栈空间。</p><h3 id="种花问题"><a class="header-anchor" href="#种花问题"></a>种花问题</h3><div class="tag link"><a class="link-card" title="605. 种花问题" href="https://leetcode-cn.com/problems/can-place-flowers/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">605. 种花问题</p><p class="url">https://leetcode-cn.com/problems/can-place-flowers/</p></div></a></div><br/><p>从一边开始遍历，当这个值为0且左右两边都为0时，将其变成1。最后将结果数组求和与原始值求和值相减即为最大满足值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">canPlaceFlowers</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当n为0时无论什么情况都为true</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nums = flowerbed.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 在只有1个位置时，chu了n=0情况下，只有n为1且位置为空才为true</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; flowerbed[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于统计未加入花时的，花数目</span></span><br><span class="line">        <span class="keyword">int</span> before = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[0,0,...]情况下时变成[1,0,...]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; flowerbed[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将[...,0,0,0,...]情况变成[...,0,1,0,...]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> &amp;&amp; flowerbed[i - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                flowerbed[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将[...,0,0]情况变成[...,0,1]</span></span><br><span class="line">        <span class="keyword">if</span> (flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            flowerbed[flowerbed.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计加入花后的所有花的数目</span></span><br><span class="line">        <span class="keyword">int</span> after = <span class="built_in">accumulate</span>(flowerbed.<span class="built_in">begin</span>(), flowerbed.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 当n小于,可以插入花的最大数目时返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((after - before) &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test2 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test3 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test4 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; test5 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> result = Solution::<span class="built_in">canPlaceFlowers</span>(test4, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销售价值减少的颜色球【中等】"><a class="header-anchor" href="#销售价值减少的颜色球【中等】"></a>销售价值减少的颜色球【中等】</h2><div class="tag link"><a class="link-card" title="1648. 销售价值减少的颜色球" href="https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/leetcodeicon.svg"/></div><div class="right"><p class="text">1648. 销售价值减少的颜色球</p><p class="url">https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/</p></div></a></div><p>你有一些球的库存 <code>inventory</code> ，里面包含着不同颜色的球。一个顾客想要<font color="#faa755">任意颜色</font>总数为 <code>orders</code> 的球。</p><p>这位顾客有一种特殊的方式衡量球的价值：每个球的价值是目前剩下的<font color="#faa755">同色球</font>的数目。比方说还剩下 6 个黄球，那么顾客买第一个黄球的时候该黄球的价值为 6。这笔交易以后，只剩下 5 个黄球了，所以下一个黄球的价值为 5 （也就是球的价值随着顾客购买同色球是递减的）。</p><p>给你整数数组 <code>inventory</code>，其中 <code>inventory[i]</code> 表示第 <code>i</code> 种颜色球一开始的数目。同时给你整数 <code>orders</code>，表示顾客总共想买的球数目。你可以按照任意顺序卖球。</p><p>请你返回卖了 <code>orders</code> 个球以后最大总价值之和。由于答案可能会很大，请你返回答案对 $10^{9} + 7$ 取余数 的结果。</p><div class="tabs" id="销售价值减少的颜色球"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#销售价值减少的颜色球-1">示例 1</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-2">示例 2</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-3">示例 3</button></li><li class="tab"><button type="button" data-href="#销售价值减少的颜色球-4">示例 4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="销售价值减少的颜色球-1"><p>输入：<code>inventory = [2,5]</code>，<code>orders = 4</code></p><p>输出：14</p><p>解释：卖 1 个第一种颜色的球（价值为 2），卖 3 个第二种颜色的球（价值为 5 + 4 + 3）。最大总和为 2 + 5 + 4 + 3 = 14。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-2"><p>输入：<code>inventory = [3,5]</code>，<code>orders = 6</code></p><p>输出：19</p><p>解释：卖 2 个第一种颜色的球（价值为 3 + 2），卖 4 个第二种颜色的球（价值为 5 + 4 + 3 + 2）。最大总和为 3 + 2 + 5 + 4 + 3 + 2 = 19。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-3"><p>输入：<code>inventory = [2,8,4,10,6]</code>，<code>orders = 20</code></p><p>输出：110</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="销售价值减少的颜色球-4"><p>输入：<code>inventory = [1000000000]</code>，<code>orders = 1000000000</code></p><p>输出：21</p><p>解释：卖 1000000000 次第一种颜色的球，总价值为 500000000。 500000000 对 $10^{9} + 7$ 取余为 21</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>该题使用贪心算法，很容易想到，对数组进行从大到小排序，每次让值最大的元素加到 <code>result</code>，并使 <code>orders-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">inventory, orders</span>):</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 数组元素只有一个时</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(inventory) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> orders &gt; <span class="number">0</span>:</span><br><span class="line">            orders = orders-<span class="number">1</span></span><br><span class="line">            result = result + inventory[<span class="number">0</span>]</span><br><span class="line">            inventory[<span class="number">0</span>] = inventory[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result % <span class="number">1000000007</span></span><br><span class="line">    <span class="comment"># 数组元素有多个时</span></span><br><span class="line">    <span class="keyword">while</span> orders &gt; <span class="number">0</span> <span class="keyword">and</span> i &lt; <span class="built_in">len</span>(inventory):</span><br><span class="line">        <span class="keyword">if</span> inventory[i] &lt; inventory[i + <span class="number">1</span>]:</span><br><span class="line">            inventory = <span class="built_in">sorted</span>(inventory, reverse=<span class="literal">True</span>)</span><br><span class="line">        result += inventory[i]</span><br><span class="line">        inventory[i] = inventory[i] - <span class="number">1</span></span><br><span class="line">        orders = orders - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result % <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">2</span>, <span class="number">5</span>], <span class="number">4</span>))  <span class="comment"># 14</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">3</span>, <span class="number">5</span>], <span class="number">6</span>))  <span class="comment"># 19</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>], <span class="number">20</span>))  <span class="comment"># 110</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">10</span>], <span class="number">10</span>))  <span class="comment"># 55</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">1000000000</span>], <span class="number">1000000000</span>))  <span class="comment"># 21</span></span><br><span class="line">    <span class="built_in">print</span>(maxProfit([<span class="number">773160767</span>], <span class="number">252264991</span>))  <span class="comment"># 70267492</span></span><br></pre></td></tr></table></figure><p>但题目中给的数据比较大，如果不进行优化会超时，<a href="https://leetcode-cn.com/problems/sell-diminishing-valued-colored-balls/solution/liang-chong-si-lu-you-hua-tan-xin-suan-fa-you-hua-/">优化思路</a></p><p>不需要一次一次的模拟，而是一次性买入一定数量的球，直至该球数量等于至第二多数量。对于示例 3：<code>inventory = [2,8,4,10,6]</code>，<code>orders = 20</code> 而言：</p><p>首先，从大到小排序。<code>[10, 8, 6, 4, 2]</code>，然后逐步模拟：</p><ul><li><code>[10, 8, 6, 4, 2]</code>，<code>orders = 20</code> 数量最多的同色球的数量为 10，第二多的为 8，颜色数为 1。此时我们可以销售第一个颜色的球 2 次，获利 10 + 9 = 19。</li><li><code>[8, 8, 6, 4, 2]</code>，<code>orders = 18</code> 数量最多的同色球的数量为 8，第二多（与第一不同）的为 6，颜色数为 2。此时我们可以销售 2 × 2 = 4 次，获利 (8 + 7) × 2 = 30。</li><li><code>[6, 6, 6, 4, 2]</code>，<code>orders = 14</code> 数量最多的同色球的数量为 6，第二多（与第一不同）的为 4，颜色数为 3。此时我们可以销售 2 × 3 = 6 次，获利 (6 + 5) × 3 = 33。</li><li><code>[4, 4, 4, 4, 2]</code>，<code>orders = 8</code> 数量最多的同色球的数量为 4，第二多（与第一不同）的为 2，颜色数 = 4。此时我们可以全部卖完，销售 2 × 4 次，获利（4 + 3）× 4 = 28。</li><li>总计收入为 19 + 30 + 33 + 28 = 110.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">inventory, orders</span>):</span></span><br><span class="line">    inventory = <span class="built_in">sorted</span>(inventory, reverse=<span class="literal">True</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    mod = <span class="number">1e9</span>+<span class="number">7</span></span><br><span class="line">    <span class="keyword">while</span> orders &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 找到第二多元素的索引</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(inventory) <span class="keyword">and</span> inventory[i] &gt;= inventory[<span class="number">0</span>]:</span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将第二多元素赋值到 nextEle</span></span><br><span class="line">        nextEle = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(inventory):</span><br><span class="line">            nextEle = inventory[i]</span><br><span class="line">        <span class="comment"># 具有相同个数的元素有多少个</span></span><br><span class="line">        bucks = i</span><br><span class="line">        <span class="comment"># 当前最多元素与第二多元素个数之差</span></span><br><span class="line">        delta = inventory[<span class="number">0</span>] - nextEle</span><br><span class="line">        <span class="comment"># 最多可以一次性销售多少次</span></span><br><span class="line">        rem = bucks * delta</span><br><span class="line">        <span class="comment"># 一次性销售次数大于卖的个数</span></span><br><span class="line">        <span class="keyword">if</span> rem &gt; orders:</span><br><span class="line">            dec = orders // bucks</span><br><span class="line">            a1 = inventory[<span class="number">0</span>] - dec + <span class="number">1</span></span><br><span class="line">            an = inventory[<span class="number">0</span>]</span><br><span class="line">            res = res + ((((a1 + an) * dec) // <span class="number">2</span>) * bucks)</span><br><span class="line">            res = res + ((inventory[<span class="number">0</span>] - dec) * (orders % bucks))</span><br><span class="line">        <span class="comment"># 一次性销售次数小于卖的个数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 可以卖出的最低价格</span></span><br><span class="line">            a1 = nextEle + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 可以卖出的最高价格</span></span><br><span class="line">            an = inventory[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 等差数列求和</span></span><br><span class="line">            res = res + ((((a1 + an) * delta) // <span class="number">2</span>) * bucks)</span><br><span class="line">            inventory[<span class="number">0</span>] = nextEle</span><br><span class="line">        <span class="comment"># orders 减去一次性买入个数</span></span><br><span class="line">        orders = orders - rem</span><br><span class="line">        <span class="comment"># 前取模防止溢出</span></span><br><span class="line">        res = res % mod</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(res)</span><br></pre></td></tr></table></figure><p><strong><font color="#33a3dc">时间复杂度分析</font></strong>：$n \log(n)$</p>]]></content>
    
    
    <summary type="html">LeetCode刷题之贪心算法</summary>
    
    
    
    <category term="LeetCode" scheme="https://halo123.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://halo123.top/tags/LeetCode/"/>
    
    <category term="贪心算法" scheme="https://halo123.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://halo123.top/2021/05/13/DataStructure/H_Sort/"/>
    <id>https://halo123.top/2021/05/13/DataStructure/H_Sort/</id>
    <published>2021-05-13T00:35:51.000Z</published>
    <updated>2021-05-28T04:26:20.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的基本概念"><a class="header-anchor" href="#排序的基本概念"></a>排序的基本概念</h2><h2 id="排序的定义"><a class="header-anchor" href="#排序的定义"></a>排序的定义</h2><p>排序，就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。</p><p>算法的稳定性。若待排序表中有两个元素 $R_i$ 和 $R_j$ ，其对应的关键字相同即 $\mathrm{ key}_i= \mathrm{ key}_j$，且在排序前 $R_i$ 在 $R_j$ 的前面，若使用某一排序算法排序后，$R_i$ 仍然在 $R_j$ 的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。需要注意的是，算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。如果待排序表中的关键字不允许重复，则排序结果是唯一的，那么选择排序算法时的稳定与否就无关紧要。</p><p>注意：对于不稳定的排序算法，只需举出一组关键字的实例，说明它的不稳定性即可。</p><p>在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：</p><ol><li>内部排序，是指在排序期间元素全部存放在内存中的排序；</li><li>外部排序，是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。（除了关注算法时间和空间复杂度外，还要考虑如何使读写磁盘的次数更少）</li></ol><p>一般情况下，内部排序算法在执行过程中都要进行两种操作：比较和移动。通过比较两个关键字的大小，确定对应元素的前后关系，然后通过移动元素以达到有序。当然，并非所有的内部排序算法都要基于比较操作，事实上，基数排序就不基于比较。</p><p>每种排序算法都有各自的优缺点，适合在不同的环境下使用，就其全面性能而言，很难提出一种被认为是最好的算法。通常可以将排序算法分为插入排序、交换排序、选择排序、归并排序和基数排序五大类，后面几节会分别进行详细介绍。内部排序算法的性能取决于算法的时间复杂度和空间复杂度，而时间复杂度一般是由比较和移动的次数决定的。</p><h2 id="插入排序"><a class="header-anchor" href="#插入排序"></a>插入排序</h2><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序和希尔排序。</p><h3 id="直接插入排序"><a class="header-anchor" href="#直接插入排序"></a>直接插入排序</h3><p>根据上面的插入排序思想，不难得出一种最简单也最直观的直接插入排序算法。假设在排序过程中，待排序表 <code>L[1...n]</code> 在某次排序过程中的某一时刻状态如下: 有序序列 <code>L[1...i-1]</code> ，<code>L(i)</code>，无序序列 <code>L[i+1...n]</code></p><p>要将元素 <code>L(i)</code> 插入到已有序的子序列 <code>L[1...i-1]</code> 中，需要执行以下操作（为避免混淆，下面用 <code>L[]</code> 表示一个表，而用<code>L()</code> 表示一个元素）：</p><ol><li>查找出 <code>L(i)</code> 在 <code>L[1...i-1]</code> 中的插入位置 <code>k</code>。</li><li>将 <code>L[k...i-1]</code> 中的所有元素依次后移一个位置。</li><li>将 <code>L(i)</code> 复制到 <code>L(k)</code>。</li></ol><p>为了实现对 <code>L[1...n]</code> 的排序，可以将 <code>L(2)</code>~<code>L (n)</code> 依次插入到前面已排好序的子序列中，初始 <code>L[1]</code> 可以视为是一个已排好序的子序列。上述操作执行 $n-1$ 次就能得到一个有序的表。插入排序在实现上通常采用就地排序（空间复杂度为 $O(n)$ ）， 因而在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间。</p><p>下面是直接插入排序的代码，其中再次用到了我们前面提到的“哨兵”（作用相同）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;  <span class="comment">// 若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];  <span class="comment">// 复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; --j)  <span class="comment">// 从后往前查找待插入位置</span></span><br><span class="line">                A[j + <span class="number">1</span>] = A[j];               <span class="comment">// 向后挪位</span></span><br><span class="line">            A[j + <span class="number">1</span>] = A[<span class="number">0</span>];                   <span class="comment">// 复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$ 。</p><p>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 $n-1$ 趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。</p><p>在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 $O(n)$。</p><p>在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达到最大，为 $\sum_{i=2}^{n}i$ ，总的移动次数也达到最大，为 $\sum_{i=2}^{n}(i+1)$ 。</p><p>平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与总的移动次数均约为 $\frac{n^2}{4}$ 。</p><p>因此，直接插入排序算法的时间复杂度为 $O(n^2)$。</p><p>稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置发生变化的情况，即直接插入排序是一个稳定的排序方法。</p><p>适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后查找指定元素的位置。</p><p>注意：大部分排序算法都仅适用于顺序存储的线性表。</p><h3 id="折半插入排序"><a class="header-anchor" href="#折半插入排序"></a>折半插入排序</h3><p>从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作：</p><ol><li>从前面的有序子表中查找出待插入元素应该被插入的位置；</li><li>给插入位置腾出空间，将待插入元素复制到表中的插入位置。</li></ol><p>注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统一地移动待插入位置之后的所有元素。当排序表为顺序表时，可以对直接插入排序算法做如下改进：由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统一地向后移动元素。算法代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;  <span class="comment">// 依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];            <span class="comment">// 将A[i]暂存到A[0]</span></span><br><span class="line">        low = <span class="number">1</span>;                <span class="comment">// 设置折半查找的范围</span></span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;        <span class="comment">// 折半查找(默认递增有序)</span></span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取中间点</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;  <span class="comment">// 查找左半子表</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;  <span class="comment">// 查找右半子表，保证算法稳定性</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j) &#123;</span><br><span class="line">            A[j + <span class="number">1</span>] = A[j];  <span class="comment">// 统一后移元素，空出插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        A[high + <span class="number">1</span>] = A[<span class="number">0</span>];  <span class="comment">// 插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述算法中，不难看出折半插入排序仅减少了比较元素的次数，约为 $O(n\log_{2}{n})$ ，该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数 $n$ ；而元素的移动次数并未改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为 $O(n^2)$，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一种稳定的排序方法。</p><h3 id="希尔排序"><a class="header-anchor" href="#希尔排序"></a>希尔排序</h3><p>从前面的分析可知，直接插入排序算法的时间复杂度为 $O(n^2)$ ，但若待排序列为“正序”时，其时间复杂度可提高至 $O(n)$，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。</p><p>希尔排序的基本思想是：先将待排序表分割成若干形如 <code>L[i,i+d,i+2d,...,i+kd]</code> 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。</p><p>希尔排序的过程如下：先取一个小于 $n$ 的步长 $d_i$ ，把表中的全部记录分成 $d_1$ 组，所有距离为 $d$ 的倍数的记录放在同一组， 在各组内进行直接插入排序；然后取第二个步长 $d_2&lt;d_1$，重复上述过程，直到所取到的 $d_t = 1$，即所有记录已放在同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故可以很快得到最终结果。到目前为止，尚未求得一个最好的增量序列，希尔提出的方法是 $d_1=\frac{n}{2},\ d_{i+1}=\left \lfloor  \frac{d_i}{2} \right \rfloor$，并且最后一个增量等于 1。</p><p>希尔排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d, i, j;</span><br><span class="line">    <span class="comment">// A[0]只是暂存单元，不是哨兵</span></span><br><span class="line">    <span class="keyword">for</span> (d = n / <span class="number">2</span>; d &gt; <span class="number">1</span>; d = d / <span class="number">2</span>) &#123;  <span class="comment">// 步长变化</span></span><br><span class="line">        <span class="keyword">for</span> (i = d + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - d]) &#123;  <span class="comment">// 需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>] = A[i];        <span class="comment">// 暂存在 A[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - d; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j -= d) &#123;</span><br><span class="line">                    A[j + d] = A[j];  <span class="comment">// 记录后移，查找插入的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j + d] = A[<span class="number">0</span>];  <span class="comment">// 插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>希尔排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$。</p><p>时间效率：由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当 $n$ 在某个特定范围时，希尔排序的时间复杂度约为 $O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为 $O(n^2)$。</p><p>稳定性：当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种不稳定的排序方法。</p><p>适用性：希尔排序算法仅适用于线性表为顺序存储的情况。</p><h2 id="交换排序"><a class="header-anchor" href="#交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序"></a>冒泡排序</h3><p>冒泡排序的基本思想是：从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即 <code>A[i-1] &gt; A[i]</code>），则交换它们，直到序列比较完。我们称它为第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置），关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”（或关键字最大的元素如石头一般下沉至水底）。下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置……这样最多做 $n-1$ 趟冒泡就能把所有元素排好序。</p><p>冒泡排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">// 表示本轮冒泡是否发生了交换的标志</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j]) &#123;</span><br><span class="line">                temp = A[j - <span class="number">1</span>];  <span class="comment">// 交换</span></span><br><span class="line">                A[j - <span class="number">1</span>] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 本次遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，因而空间复杂度为 $O(1)$ 。</p><p>时间效率：当初始序列有序时，显然第一趟冒泡后 <code>flag</code> 依然为 <code>false</code> （本趟冒泡没有元素交换），从而直接跳出循环，比较次数为$n- 1$ ，移动次数为 0，从而最好情况下的时间复杂度为 $O(n)$ ；当初始序列为逆序时，需要进行 $n- 1$ 趟排序，第 $i$ 趟排序要进行 $n -i$ 次关键字的比较，而且每次比较后都必须移动元素 3 次来交换元素位置。这种情况下，比较次数= $\frac{n(n-1)}{2}$ ，移动次数 = $\frac{3n(n-1)}{2}$ 从而，最坏情况下的时间复杂度为 $O(n^2)$ ，其平均时间复杂度也为 $O(n^2)$ 。</p><p>稳定性：由于 <code>i&gt;j</code> 且 <code>A[i]=A[j]</code> 时，不会发生交换，因此冒泡排序是一种 稳定的排序方法。</p><p>注意：冒泡排序中所产生的有序子序列一定是全局有序的（不同于直接插入排序），也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。</p><h3 id="快速排序"><a class="header-anchor" href="#快速排序"></a>快速排序</h3><p>快速排序的基本思想是基于分治法的：在待排序表 <code>L[1..n]</code> 中任取一个元素 <code>pivot</code> 作为枢轴（或基准，通常取首元素），通过一趟排序将待排序表划分为独立的两部分 <code>L[1...&lt;k-1]</code> 和 <code>L[k+1...n]</code>，使得 <code>L[1...k-1]</code> 中的所有元素小于 <code>pivot</code> ， <code>L[k+1...n]</code> 中的所有元素大于等于 <code>pivot</code> ，则 <code>pivot</code> 放在了其最终位置 <code>L(k)</code> 上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;  <span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos - <span class="number">1</span>);   <span class="comment">// 划分左子表</span></span><br><span class="line">        QuickSort(A, pivotpos + <span class="number">1</span>, high);  <span class="comment">// 划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[low];  <span class="comment">// 第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt; pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];  <span class="comment">// 比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];  <span class="comment">// 比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;  <span class="comment">// 枢轴元素存放到的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序算法的性能分析如下：</p><p>空间效率：由于快速排序是递归的，需要借助一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。 最好情况下为 $O(\log_{2}{n})$ ；最坏情况下，因为要进行 $n-1$ 次递归调用，所以栈的深度为 $O(n)$ ；平均情况下，栈的深度为 $O(\log_{2}{n})$。</p><p>时间效率：快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含 $n-1$ 个元素和 0 个元素时，这种最大程度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为 $O(n^2)$。</p><p>有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。</p><p>在最理想的状态下，即 <code>Partition()</code> 可能做到最平衡的划分，得到的两个子问题的大小都不可能大于 $\frac{n}{2}$ ，在这种情况下，快速排序的运行速度将大大提升，此时，时间复杂度为 $O(n\log_{2}{n})$ 。 好在快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，而不是接近其最坏情况下的运行时间。快速排序是所有内部排序算法中平均性能最优的排序算法。</p><p>稳定性：在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。</p><p>注意：在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放到其最终的位置上。</p><h2 id="选择排序"><a class="header-anchor" href="#选择排序"></a>选择排序</h2><p>选择排序的基本思想是：每一趟（如第 $i$ 趟）在后面 $n-i+1 \ (i=1,2,\cdots ,n-1)$ 个待排序元素中选取关键字最小的元素，作为有序子序列的第 $i$ 个元素，直到第 $n-1$ 趟做完，待排序元素只剩下 1 个，就不用再选了。</p><h3 id="简单选择排序"><a class="header-anchor" href="#简单选择排序"></a>简单选择排序</h3><p>根据上面选择排序的思想，可以很直观地得出简单选择排序算法的思想：假设排序表为 $L[1…n]$ ，第 $i$ 趟排序即从 $L[i…n]$ 中选择关键字最小的元素与 $L(i)$ 交换，每一趟排序可以确定一个元素的最终位置，这样经过 $n-1$ 趟排序就可使得整个排序表有序。简单选择排序算法的代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;    <span class="comment">// 一共进行n-1趟</span></span><br><span class="line">        <span class="keyword">int</span> min = i;                     <span class="comment">// 记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)  <span class="comment">// 在A[i...n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; A[min]) min = j;  <span class="comment">// 更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) swap(A[i], A[min]);  <span class="comment">//封装的 swap() 函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单选择排序算法的性能分析如下：</p><p>空间效率：仅使用常数个辅助单元，故空间效率为 $O(1)$。</p><p>时间效率：从上述伪码中不难看出，在简单选择排序过程中，元素移动的操作次数很少，不会超过 $3(n- 1)$ 次，最好的情况是移动 0 次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关，始终是 $\frac{n(n- 1)}{2}$ 次，因此时间复杂度始终是 $O(n^2)$ 。</p><p>稳定性：在第 $i$ 趟找到最小元素后，和第 $i$ 个元素交换，可能会导致第 $i$ 个元素与其含有相同关键字元素的相对位置发生改变。因此，简单选择排序是一种不稳定的排序方法。</p><h3 id="堆排序"><a class="header-anchor" href="#堆排序"></a>堆排序</h3><p>堆的定义如下，$n$ 个关键字序列 <code>L[1..n]</code> 称为堆，当且仅当该序列满足：</p><ol><li><code>L(i)&gt;=L(2i)</code> 且 <code>L(i)&gt;=L(2i+1)</code> 或</li><li><code>L(i)&lt;=L(2i)</code> 且 <code>L(i)&lt;=L(2i+1)</code> （$1\le i \le \left \lfloor \frac{n}{2} \right \rfloor $）</li></ol><p>可以将该一维数组视为一棵完全二叉树，</p><ul><li>满足条件 1 的堆称为大根堆（大顶堆），大根堆的<font color="#faa755">最大元素存放在根结点</font>，且其任一非根结点的值小于等于其双亲结点值。</li><li>满足条件 2 的堆称为小根堆（小顶堆），小根堆的定义刚好相反，<font color="#faa755">根结点是最小元素</font>。</li></ul><p>堆排序的思路很简单：首先将存放在 <code>L[1...n]</code> 中的 $n$ 个元素建成初始堆，由于堆本身的特点（以大顶堆为例），堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见堆排序需要解决两个问题：</p><ol><li>如何将无序序列构造成初始堆</li><li>输出堆顶元素后，如何将剩余元素调整成新的堆</li></ol><p>堆排序的关键是构造初始堆。$n$ 个结点的完全二叉树，最后一个结点是第 $\left \lfloor \frac{n}{2} \right \rfloor$  个结点的孩子。对第  $\left \lfloor \frac{n}{2} \right \rfloor$   个结点为根的子树筛选（对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对各结点（ $\left \lfloor \frac{n}{2} \right \rfloor -1 \sim  1$） 为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。</p><p>下面是建立大根堆算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;  <span class="comment">// 从后往前调整所有的非终端结点</span></span><br><span class="line">        HeadAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将以 k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];                             <span class="comment">// A[0] 暂存子树的根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿 key 较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="number">1</span>]) &#123; <span class="comment">// i &lt; len 保证有右兄弟</span></span><br><span class="line">            i++;  <span class="comment">// 取 key 较大的子结点的下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// 筛选结束</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = A[i];  <span class="comment">// 将 A[i] 调整到双亲结点上</span></span><br><span class="line">            k = i;        <span class="comment">// 修改 k 值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];  <span class="comment">// 被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是堆排序算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    BuildMaxHeap(A, len);  <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        Swap(A[i], A[<span class="number">1</span>]);  <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        HeadAdjust(A, <span class="number">1</span>, i - <span class="number">1</span>);  <span class="comment">// 调整，把剩余的 i-1 个元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序适合关键字较多的情况（如 $n&gt;1000$ ）。例如，在 1 亿个数中选出前 100 个最大值。首先使用一个大小为 100 的数组，读入前 100 个数，建立小顶堆，而后依次读入余下的数，若小于堆顶则舍弃，否则用该数取代堆顶并重新调整堆，待数据读取完毕，堆中 100 个数即为所求。</p><p>堆排序算法的性能分析如下：</p><p>空间效率：仅使用了常数个辅助单元，所以空间复杂度为 $O(1)$。</p><p>时间效率：建堆时间为 $O(n)$ 【<a href="https://www.bilibili.com/video/BV1b7411N798?p=83&amp;t=1290">推导过程</a>】，之后有 $n- 1$ 次向下调整操作，每次调整的时间复杂度为 $O(h)$，故在最好、最坏和平均情况下，堆排序的时间复杂度为 $O(n \log_{2}{n})$。</p><p>稳定性：进行筛选时，有可能把后面相同关键字的元素调整到前面，所以堆排序算法是一种不稳定的排序方法。</p><p>堆的插入：新元素放到表尾（堆底），根据大/小根堆的要求，新元素不断“上升”，直到无法继续上升为止。每次“上升”调整只需对比关键字 1 次。</p><p>堆的删除：被删除元素用表尾（堆底）元素代替，根据大/小根堆的要求，替代元素不断“下坠”，知道无法继续下坠为止。每次“下坠”调整可能需要对比关键字 2 次，也可能只需对比 1 次。</p><h2 id="归并排序和基数排序"><a class="header-anchor" href="#归并排序和基数排序"></a>归并排序和基数排序</h2><h3 id="归并排序"><a class="header-anchor" href="#归并排序"></a>归并排序</h3><p>归并排序与上述基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有 $n$ 个记录，则可将其视为 $n$ 个有序的子表，每个子表的长度为 1 ，然后两两归并，得到 $\left \lceil \frac{n}{2}  \right \rceil $ 个长度为 2 或 1 的有序表；继续两两归并如此重复，直到合并成一个长度为 $n$ 的有序表为止，这种排序方法称为 2 路归并排序。</p><p>$m$ 路归并，每选出一个元素需要对比关键字 $m-1$ 次</p><p><code>Merge()</code> 的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表 <code>A[low..mid]</code>、<code>A[mid+1...high]</code> 存放在同一顺序表中的相邻位置，先将它们复制到辅助数组 <code>B</code> 中。每次从对应 <code>B</code> 中的两个段取出一个记录进行关键字的比较，将较小者放入 <code>A</code> 中，当数组 <code>B</code> 中有一段的下标超出其对应的表长（即该段的所有元素都已复制到 <code>A</code> 中）时，将另一段中的剩余部分直接复制到 <code>A</code> 中。算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n = A.length;</span><br><span class="line"><span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));  <span class="comment">// 辅助数组B</span></span><br><span class="line"><span class="comment">// A[low..mid]和A[mid+1...high]各自有序，将两个部分归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (k = low; k &lt;= high; k++) &#123;</span><br><span class="line">        B[k] = A[k];  <span class="comment">// 将 A 中所有元素复制到 B 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt; mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">            A[k] = B[i++];  <span class="comment">// 将较小值复制到 A 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;  <span class="comment">// 处理剩余大值元素</span></span><br><span class="line">        A[k++] = B[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">        A[k++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：上面的代码中，最后两个 <code>while</code> 循环只有一个会执行。</p><p>一趟归并排序的操作是，调用 $\left \lceil \frac{n}{2h}  \right \rceil $ 次算法 <code>merge()</code>，将 <code>L[1...n]</code> 中前后相邻且长度为 $h$ 的有序段进行两两归并，得到前后相邻、长度为 $2h$ 的有序段，整个归并排序需要进行 $\left \lceil \log_{2}{n}  \right \rceil $ 趟。</p><p>递归形式的 2 路归并排序算法是基于分治的，其过程如下。</p><p>分解：将含有 $n$ 个元素的待排序表分成各含 $\frac{n}{2}$ 个元素的子表，采用 2 路归并排序算法对两个子表递归地进行排序。</p><p>合并：合并两个已排序的子表得到排序结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;   <span class="comment">// 从中间划分</span></span><br><span class="line">        MergeSort(A, low, mid);       <span class="comment">// 对左半部分归并排序</span></span><br><span class="line">        MergeSort(A, mid + <span class="number">1</span>, high);  <span class="comment">// 对右半部分归并排序</span></span><br><span class="line">        Merge(A, low, mid, high);     <span class="comment">// 归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 路归并排序算法的性能分析如下：</p><p>空间效率：<code>Merge()</code> 操作中，辅助空间刚好为 $n$ 个单元，所以算法的空间复杂度为 $O(n)$ 。</p><p>时间效率：每趟归并的时间复杂度为 $O(n)$，共需进行 $\left \lceil \log_{2}{n}  \right \rceil $ 趟归并，所以算法的时间复杂度为 $O(n \log_{2}{n})$。</p><p>稳定性：由于 <code>Merge()</code> 操作不会改变相同关键字记录的相对次序，所以 2 路归并排序算法是一种稳定的排序方法。</p><p>注意：一般而言，对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $K^m=N$，从而 $m=\log_{k}{N}$，又考虑到 $m$ 为整数，所以 $m=\left \lceil \log_{k}{N}  \right \rceil$ 。这和前面的 2 路归并是一致的。</p><h3 id="基数排序"><a class="header-anchor" href="#基数排序"></a>基数排序</h3><p>基数排序是一种很特别的排序方法，它不基于比较和移动进行排序，而基于关键字各位的大小进行排序。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。</p><p>假设长度为 $n$ 的线性表中每个结点 $a_j$ 的关键字由 $d$ 元组（$k_{j}^{d-1} , k_{j}^{d-2} , \cdots , k_{j}^{1} , k_{j}^{0}$）组成，满足 $0 \le k_{j}^{i} \le r-1 \ (0\le j &lt;n , 0 \le i \le d-1) $。其中 $k_{j}^{d-1}$ 为主位关键字，$k_{j}^{0}$ 为最次位关键字。</p><p>为实现多关键字排序，通常有两种方法：</p><ol><li>最高位优先（MSD）法，按关键字位<font color="#faa755">权重递减</font>依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列。</li><li>最低位优先（LSD）法，按关键字<font color="#faa755">权重递增</font>依次进行排序，最后形成一个有序序列。</li></ol><p>下面描述以 $r$ 为基数的最低位优先基数排序的过程，在排序过程中，使用 $r$ 个队列 $Q_0 , Q_1 , \cdots ,Q_{r-1}$ 。基数排序的过程如下：对 $i=0 , 1 , \cdots , d-1$ ，依次做一次 “分配”和“收集”（其实是一次稳定的排序过程）。</p><ol><li>分配：开始时，把 $Q_0 , Q_1 , \cdots , Q_{r-1}$ 各个队列置成空队列，然后依次考察线性表中的每个结点 $a_j \ (j=0 , 1 , \cdots , n-1)$ ，若 $a_j$ 的关键字 $k_{j}^{i} = k$，就把 $a_j$ 放进 $Q_k$ 队列中。</li><li>收集：把 $Q_0 , Q_1 , \cdots , Q_{r-1}$ 各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。</li></ol><p>基数排序<strong>算法的性能</strong>分析如下：</p><p>空间效率：趟排序需要的辅助存储空间为 $r$ （ $r$ 个队列：$r$ 个队头指针和r个队尾指针），但以后的排序中会重复使用这些队列，所以基数排序的空间复杂度为 $O®$。</p><p>时间效率：基数排序需要进行 $d$ 趟分配和收集，一趟分配需要 $O(n)$，一趟收集需要 $O®$ ，所以基数排序的时间复杂度为 $O(d(n+ r))$ ，它与序列的初始状态无关。</p><p>稳定性：对于基数排序算法而言，很重要一点就是按位排序时必须是稳定的。因此，这也保证了基数排序的稳定性。</p><p>基数排序<strong>擅长解决的问题</strong>：</p><ol><li>数据元素的关键字可以方便地拆分为 $d$ 组，且 $d$ 较小</li><li>每组关键字的取值范围不大，即 $r$ 较小</li><li>数据元素个数 $n$ 较大</li></ol><h2 id="外部排序"><a class="header-anchor" href="#外部排序"></a>外部排序</h2><h3 id="外部排序的基本概念"><a class="header-anchor" href="#外部排序的基本概念"></a>外部排序的基本概念</h3><p>在许多应用中，经常需要对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序。因此，需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换。这种排序方法就称为<font color="#ea66a6">外部排序</font>。</p><h3 id="外部排序的方法"><a class="header-anchor" href="#外部排序的方法"></a>外部排序的方法</h3><p>文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。因为磁盘读/写的机械动作所需的时间远远超过内存运算的时间（相比而言可以忽略不计），因此在外部排序过程中的时间代价主要考虑访问磁盘的次数，即 I/O 次数。<br>外部排序通常采用归并排序法。它包括两个相对独立的阶段：</p><ol><li>根据内存缓冲区大小，将外存上的文件分成若干长度为 $l$ 的子文件，依次读入内存并利用内部排序方法对它们进行排序，<br>并将排序后得到的有序子文件重新写回外存，称这些有序子文件为<font color="#ea66a6">归并段</font>或<font color="#ea66a6">顺串</font></li><li>对这些归并段进行逐趟归并，使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止。</li></ol><p>一般地，对 $r$ 个初始归并段，做 $k$ 路平衡归并：</p><ol><li>最多只能有 $k$ 个段归并为一个；</li><li>每一趟归并中，若有 $m$ 个归并段参与归并，则经过这一趟处理得到  $\left \lceil \frac{m}{k} \right \rceil $ 个新的归并段。</li></ol><p>第一趟可将 $r$ 个初始归并段归并为 $\left \lceil \frac{r}{k} \right \rceil $ 个归并段，以后每趟归并将 $m$ 个归并段归并成 $\left \lceil \frac{m}{k} \right \rceil $ 个归并段，直至最后形成一个大的归并段为止。树的高度 $=\left \lceil \log_{k}{r} \right \rceil = $ 归并趟数 $S$ 。可见，只要增大归并路数 $k$ ，或减少初始归并段个数 $r$ ，都能减少归并趟数 $S$，进而减少读写磁盘的次数，达到提高外部排序速度的目的。</p><p>多路归并带来的<strong>负面影响</strong>：</p><ol><li>$k$ 路归并时，需要开辟 $k$ 个输入缓冲区，内存开销增加</li><li>每挑选一个关键字需要对比关键字 $k-1$ 次，内部归并所需时间增加</li></ol><h3 id="多路平衡归并与败者树"><a class="header-anchor" href="#多路平衡归并与败者树"></a>多路平衡归并与败者树</h3><p>增加归并路数 $k$ 能减少归并趟数 $S$，进而减少 I/O 次数。然而，增加归并路数 $k$ 时，内部归并的时间将增加。做内部归并时，在 $k$ 个元素中选择关键字最小的记录需要比较 $k-1$ 次。每趟归并 $n$ 个元素需要做 $(n- 1)(k- 1)$ 次比较，$S$ 趟归并总共需要的比较次数为 $$S(n-1)(k-1)=\left \lceil \log_{k}{r} \right \rceil (n-1)(k-1)=\frac{\left \lceil \log_{2}{r} \right \rceil(n-1)(k-1)}{\left \lceil \log_{2}{k} \right \rceil}$$式中，$\frac{k-1}{\left \lceil \log_{2}{k} \right \rceil}$ 随 $k$ 增长而增长，因此内部归并时间亦随 $k$ 的增长而增长。这将抵消由于增大 $k$ 而减少外存访问次数所得到的效益。因此，不能使用普通的内部归并算法。</p><p>为了使内部归并不受 $k$ 的增大的影响，引入了败者树。败者树是树形选择排序的一种变体，可视为一棵完全二叉树。$k$ 个叶结点分别存放 $k$ 个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点。若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数。</p><p>因为 $k$ 路归并的败者树深度为 $\left \lceil \log_{2}{k} \right \rceil$， 因此 $k$ 个记录中选择最小关键字，最多需要 $\left \lceil \log_{2}{k} \right \rceil$ 次比较。所以总的比较次数为：$$S(n-1)\left \lceil \log_{2}{k} \right \rceil=\left \lceil \log_{k}{r} \right \rceil (n-1)\left \lceil \log_{2}{k} \right \rceil =(n-1)\left \lceil \log_{2}{r} \right \rceil$$可见，使用败者树后，内部归并的比较次数与 $k$ 无关了。因此，只要内存空间允许，增大归并路数 $k$ 将有效地减少归并树的高度，从而减少 I/O 次数，提高外部排序的速度。</p><p>值得说明的是，归并路数 $k$ 并不是越大越好。归并路数 $k$ 增大时，相应地需要增加输入缓冲区的个数。若可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使得内存、外存交换数据的次数增大。当 $k$ 值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加。</p><h3 id="置换－选择排序（生成初始归并段）"><a class="header-anchor" href="#置换－选择排序（生成初始归并段）"></a>置换－选择排序（生成初始归并段）</h3><p>减少初始归并段个数 $r$ 也可以减少归并趟数 $S$ 。若总的记录个数为 $n$ ，每个归并段的长度为 $l$ ，则归并段的个数 $r=\left \lceil \frac{n}{l} \right \rceil $。采用内部排序方法得到的各个初始归并段长度都相同（除最后一段外），它依赖于内部排序时可用内存工作区的大小。因此，必须探索新的方法，用来产生更长的初始归并段。</p><p>设初始待排文件为 FI，初始归并段输出文件为 FO，内存工作区为 WA，FO 和 WA 的初始状态为空，WA 可容纳 $w$ 个记录。置换-选择算法的步骤如下:</p><ol><li>从 FI 输入 $w$ 个记录到工作区 WA。</li><li>从 WA 中选出其中关键字取最小值的记录，记为 MINIMAX 记录。</li><li>将 MINIMAX 记录输出到 FO 中去。</li><li>若 FI 不空，则从 FI 输入下一个记录到 WA 中。</li><li>从 WA 中所有关键字比 MINIMAX 记录的关键字大的记录中选出最小关键字记录，作为新的 MINIMAX 记录。</li><li>重复 3~5，直至在 WA 中选不出新的 MINIMAX 记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到 FO 中去。</li><li>重复 2~6，直至 WA 为空。由此得到全部初始归并段。</li></ol><p>上述算法，在 WA 选择 MINIMAX 记录的过程需利用败者树来实现</p><h3 id="最佳归并树"><a class="header-anchor" href="#最佳归并树"></a>最佳归并树</h3><p>归并过程中的磁盘 I/O 次数 = 归并树的 WPL * 2</p><p>要让磁盘 I/O 次数最少，就要使归并树 WPL 最小，即哈夫曼树</p><p>将哈夫曼树的思想推广到 $m$ 叉树的情形，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的 I/O 次数最少的最佳归并树。</p><p>若初始归并段不足以构成一棵严格 $k$ 叉树时，需添加长度为 0 的“虚段”，按照哈夫曼树的原则，权为 0 的叶子应离树根最远。</p><p>如何判定添加虚段的数目</p><p>设度为 0 的结点有 $n_0 (=n)$ 个，度为 $k$ 的结点有 $n_k$ 个，则对严格 $k$ 叉树有 $n_0=(k-1)n_k+1$，由此可得 $n_k=\frac{(n_0-1)}{(k-1)}$。</p><ul><li>若 $(n_0-1) \bmod (k-1)=0 $ ，则说明这 $n_0$ 个叶结点（初始归并段）正好可以构造 $k$ 叉归并树。此时，内结点有 $n_k$ 个。</li><li>若 $(n_0-1) \bmod (k-1) =u  \ne 0$ ，则说明对于这 $n_0$ 个叶结点，其中有 $u$ 个多余，不能包含在 $k$ 叉归并树中。为构造包含所有 $n_0$ 个初始归并段的 $k$ 叉归并树，应在原有 $n_k$ 个内结点的基础上再增加 1 个内结点，即再加上 $k-u-1$ 个空归并段，就可以建立归并树。</li></ul>]]></content>
    
    
    <summary type="html">排序</summary>
    
    
    
    <category term="数据结构" scheme="https://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="https://halo123.top/2021/05/12/DataStructure/G_Search/"/>
    <id>https://halo123.top/2021/05/12/DataStructure/G_Search/</id>
    <published>2021-05-12T09:16:51.000Z</published>
    <updated>2021-05-14T11:54:17.069Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ol><li>查找的基本概念</li><li>顺序查找法</li><li>分块查找法</li><li>折半查找法</li><li>B 树及其基本操作、B+ 树的基本概念</li><li>散列表</li><li>查找算法的分析及应用</li></ol><p>【复习提示】</p><p>本章是考研命题的重点。对于散列查找，应掌握散列表的构造、冲突处理方法（各种方法的处理过程）、查找成功和查找失败的平均查找长度、散列查找的特征和性能分析。对于折半查找，应掌握折半查找的过程、构造判定树、分析平均查找长度等。B 树和 B+ 树是本章的难点。对于 B 树，考研大纲要求掌握插入、删除和查找的操作过程；对于B+树，仅要求了解其基本概念和性质。</p><h2 id="查找的基本概念"><a class="header-anchor" href="#查找的基本概念"></a>查找的基本概念</h2><ul><li>查找。在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：一 是查找成功，即在数据集合中找到了满足条件的数据元素；二是查找失败。</li><li>查找表（查找结构）。用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有 4 种：<ol><li>查询某个特定的数据元素是否在查找表中</li><li>检索满足条件的某个特定的数据元素的各种属性</li><li>在查找表中插入一个数据元素</li><li>从查找表中删除某个数据元素。</li></ol></li><li>静态查找表。若一个查找表的操作只涉及上述操作 1 和 2，则无须动态地修改查找表，此类查找表称为静态查找表。与此对应，需要动态地插入或删除的查找表称为动态查找表。适合静态查找表的查找方法有顺序查找、折半查找、散列查找等；适合动态查找表的查找方法有二叉排序树的查找、散列查找等。二叉平衡树和 B 树都是二叉排序树的改进。</li><li>关键字。数据元素中<font color="#faa755">唯一标识</font>该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。例如，在由一个学生元素构成的数据集合中，学生元素中“学号”这一数据项的值唯一地标识一名学生。</li><li>平均查找长度。在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值，其数学定义为：$$ASL=\sum_{i=1}^{n}P_iC_i$$式中，$n$ 是查找表的长度；$P_i$ 是查找第 $i$ 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_i=\frac{1}{n}$；$C_i$ 是找到第 $i$ 个数据元素所需进行的比较次数。平均查找长度是衡量查找算法效率的最主要的指标。</li></ul><h2 id="顺序查找和折半查找"><a class="header-anchor" href="#顺序查找和折半查找"></a>顺序查找和折半查找</h2><h3 id="顺序查找"><a class="header-anchor" href="#顺序查找"></a>顺序查找</h3><p>顺序查找又称线性查找，主要用于在线性表中进行查找。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找。下面分别进行讨论。</p><h4 id="一般线性表的顺序查找"><a class="header-anchor" href="#一般线性表的顺序查找"></a>一般线性表的顺序查找</h4><p>作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检查关键字是否满足给定的条件。若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置；若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息。下面给出其算法，主要是为了说明其中引入的“哨兵”的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   <span class="comment">// 查找表的数据结构（顺序表）</span></span><br><span class="line">    <span class="keyword">int</span> *elem;     <span class="comment">// 动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;  <span class="comment">// 表的长度</span></span><br><span class="line">&#125; SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>] = key;  <span class="comment">// &quot;哨兵&quot;，存放在数组索引0的位置</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = ST.TableLen; ST.elem[i] != key; --i) &#123;  <span class="comment">// 从后往前找</span></span><br><span class="line">        <span class="keyword">return</span> i;  <span class="comment">// 查找成功，则返回元素下标；查找失败，则返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述算法中，将 <code>ST.elem[0]</code> 称为“哨兵”。引入它的目的是使得 <code>Search_ Seq</code> 内的循环不必判断数组是否会越界，因为满足 <code>i==0</code> 时，循环一定会跳出。需要说明的是，在程序中引入“哨兵”并不是这个算法独有的。引入“哨兵”可以避免很多不必要的判断语句，从而提高程序效率。</p><p>对于有 $n$ 个元素的表，给定值 <code>key</code> 与表中第 $i$ 个元素相等，即定位第 $i$ 个元素时，需进行 $n-i+ 1$ 次关键字的比较，即 $C_i=n-i+1$。查找成功时，顺序查找的平均长度为$$ASL=\sum_{i=1}^{n}P_i(n-i+1)$$当每个元素的查找概率相等，即 $P_i=\frac{1}{n}$ 时，有：$$ASL=\sum_{i=1}^{n}P_i(n-i+1)=\frac{n+1}{2}$$查找不成功时，与表中各关键字的比较次数显然是 $n + 1$ 次，从而顺序查找不成功的平均查找长度为 $ASL=n+1$ 。</p><p>通常，查找表中记录的查找概率并不相等。若能预先得知每个记录的查找概率，则应先对记录的查找概率进行排序，使表中记录按查找概率由小至大重新排列。</p><p>综上所述，顺序查找的缺点是当 $n$ 较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。同时还需注意，对线性的链表只能进行顺序查找。</p><h4 id="有序表顺序查找"><a class="header-anchor" href="#有序表顺序查找"></a>有序表顺序查找</h4><p>若在查找之前就已经知道表是关键字有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。</p><p>假设表 <code>L</code> 是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为 <code>key</code>，当查找到第 $i$ 个元素时，发现第 $i$ 个元素对应的关键字小于 <code>key</code>，但第 $i+ 1$ 个元素对应的关键字大于 <code>key</code>，这时就可返回查找失败的信息，因为第 $i$ 个元素之后的元素的关键字均大于 <code>key</code>，所以表中不存在关键字为 <code>key</code> 的元素。</p><p>可以用查找判定树来描述有序顺序表的查找过程。树中的圆形结点表示有序顺序表中存在的元素；树中的矩形结点称为失败结点（若有 $n$ 个结点，则相应地有 $n + 1$ 个查找失败结点），它描述的是那些不在表中的数据值的集合。若查找到失败结点，则说明查找不成功。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%9C%89%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%88%A4%E5%AE%9A%E6%A0%91.png" alt="有序顺序表上的顺序查找判定树"></p><p>在有序表的顺序查找中，查找成功的平均查找长度和一般线性表的顺序查找一样。查找失败时，查找指针一定走到了某个失败结点。这些失败结点是我们虚构的空结点，实际上是不存在的，所以到达失败结点时所查找的长度等于它上面的一个圆形结点的所在层数。查找不成功的平均查找长度在相等查找概率的情形下为：$$ASL=\sum_{j=1}^{n} q_j(l_j-1)=\frac{1+2+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$$式中，$q_j$ 是到达第 $j$ 个失败节点的概率，在相等查找概率的情况下，它为 $\frac{1}{n+1}$；$l_i$ 是第 $j$ 个失败结点所在的层数。</p><p>注意，有序表的顺序查找和后面的折半查找的思想是不一样的，且有序表的顺序查找中的线性表可以是链式存储结构。</p><h3 id="折半查找"><a class="header-anchor" href="#折半查找"></a>折半查找</h3><p>折半查找又称二分查找，它仅适用于<font color="#faa755">有序</font>的<font color="#faa755">顺序表</font>。</p><p>折半查找的基本思想：首先将给定值 <code>key</code> 与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分（例如，在查找表升序排列时，若给定值 <code>key</code> 大于中间元素，则所查找的元素只可能在后半部分）。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。算法代码实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SeqList L, ElemType key)</span> </span>&#123; <span class="comment">// 升序排列</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = L.TableLen - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;  <span class="comment">// 取中间位置</span></span><br><span class="line">        <span class="keyword">if</span> (L.elem[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;  <span class="comment">// 查找成功则返回所在位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L.elem[mid] &gt; key) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;  <span class="comment">//从前半部分继续查找&#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;  <span class="comment">// 从后半部分继续查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 查找失败，返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>折半查找的过程可用二叉树来描述，称为判定树。树中每个圆形结点表示一个记录，结点中的值为该记录的关键字值；树中最下面的叶结点都是方形的，它表示查找不成功的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%8F%8F%E8%BF%B0%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%A4%E5%AE%9A%E6%A0%91.png" alt="描述折半查找过程的判定树"></p><p>从判定树可以看出，查找成功时的查找长度为从根结点到目的结点的路径上的结点数，而查找不成功时的查找长度为从根结点到对应失败结点的父结点的路径上的结点数；每个结点值均大于其左子结点值，且均小于于其右子结点值。若有序序列有 $n$ 个元素，则对应的判定树有 $n$ 个圆形的非叶结点和 $n+ 1$ 个方形的叶结点。显然，判定树是一棵平衡二叉树。</p><p>由上述分析可知，用折半查找法查找到给定值的比较次数最多不会超过树的高度。在等概率查找时，查找成功的平均查找长度为：$$ASL=\frac{1}{n} \sum_{i=1}^{n} l_i=\frac{1}{n}(1\times 1+2\times 2+\cdots +h \times  2^{h-1})=\frac{n+1}{n} \log_{2}{(n+1)}-1\approx \log_{2}{(n+1)-1}$$式中，$h$ 是树的高度，并且元素个数为 $n$ 时树高 $h = \left \lceil \log_{2}{(n+1)} \right \rceil $。所以，折半查找的时间复杂度为 $O(\log_{2}{n})$，平均情况下比顺序查找的效率高。</p><p>因为折半查找需要方便地定位查找区域，所以它要求线性表必须具有随机存取的特性。因此，该查找法仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列。</p><h3 id="分块查找"><a class="header-anchor" href="#分块查找"></a>分块查找</h3><p>分块查找又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。</p><p>分块查找的基本思想：将查找表分为若干子块。<font color="#faa755">块内</font>的元素可以<font color="#faa755">无序</font>，但<font color="#faa755">块间</font>的元素是<font color="#faa755">有序</font>的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType maxValue;</span><br><span class="line">    <span class="keyword">int</span> low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line"><span class="comment">// 顺序表存储实际元素</span></span><br><span class="line">ElemType List[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="分块查找示意图"></p><p>分块查找的过程分为两步：</p><ol><li>在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；</li><li>在块内顺序查找。</li></ol><p>若索引表中不包含目标关键字，则折半查找索引表最终停在 <code>low</code> &gt; <code>high</code> 要在 <code>low</code> 所指分块中查找。原因是最终 <code>low</code> 左边一定小于目标关键字，<code>high</code> 右边一 定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字。</p><p>分块查找的平均查找长度为索引查找和块内查找的平均长度之和。设索引查找和块内查找的平均查找长度分别为 $L_I$，$L_S$，则分块查找的平均查找长度为：$$ASL=L_I+L_S$$将长度为 $n$ 的查找表均匀地分为 $b$ 块，每块有 $s$ 个记录，在等概率情况下，若在块内和索引表中均采用顺序查找，则平均查找长度为：$$ASL=L_I+L_S=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$$此时，若 $s=\sqrt{n} $，则平均查找长度取最小值 $\sqrt{n}+1 $；若对索引表采用折半查找时，则平均查找长度为：$$ASL=L_1+L_2= \left \lceil \log_{2}{(b+1)} \right \rceil+\frac{s+1}{2}$$</p><h2 id="B-树和-B-树"><a class="header-anchor" href="#B-树和-B-树"></a>B 树和 B+ 树</h2><div class="tag link"><a class="link-card" title="B 树可视化" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg"/></div><div class="right"><p class="text">B 树可视化</p><p class="url">https://www.cs.usfca.edu/~galles/visualization/BTree.html</p></div></a></div><h3 id="B-树及其基本操作"><a class="header-anchor" href="#B-树及其基本操作"></a>B 树及其基本操作</h3><p>B 树，又称多路平衡查找树，B 树中所有结点的孩子个数的最大值称为 B 树的阶，通常用 $m$ 表示。一棵 $m$ 阶 B 树或为空树，或为满足如下特性的 $m$ 叉树：</p><ol><li>树中每个结点至多有 $m$ 棵子树，即至多含有 $m-1$ 个关键字。</li><li>若根结点不是终端结点，则至少有两棵子树。</li><li>除根结点外的所有非叶结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树，即至少含有 $\left \lceil \frac{m}{2} \right \rceil -1$ 个关键字。（保证查找效率）</li><li>所有非叶结点的结构如下：[ $n$ | $P_0$ | $K_1$ | $P_1$ | $K_2$ | $P_2$ | $\cdots $| $K_n$ | $P_n$ ]。其中，$K_i\ (i=1,2,\cdots ,n)$ 为结点的关键字，且满足 $K_1&lt;K_2&lt;\cdots K_n$ ；$P_i\ (i=0,1,\cdots ,n)$ 为指向子树根结点的指针，且指针 $P_{i-1}$ 所指子树中所有结点的关键字均小于 $K_i$ ，$P_i$ 所指子树中所有结点的关键字均大于 $K_i$，$n \ (\left \lceil \frac{m}{2} \right \rceil -1\le n \le m-1)$ 为结点中关键字的个数。</li><li>所有的叶结点都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。（对于任何一个结点，其所有子树的高度都要相同）</li></ol><p>$m$ 阶 B 树的核心特性：</p><ol><li>根节点的子树数 $\in [2,m]$，关键字数 $\in [i,m-1]$；其他结点的子树数 $\in [ \left \lceil \frac{m}{2} \right \rceil ,m ]$；关键字数 $\in [ \left \lceil \frac{m}{2} \right \rceil -1,m-1 ]$</li><li>对于任何一个结点，其所有子树的高度都要相同</li></ol><p>B 树是所有结点的平衡因子均等于 <font color="#faa755">0</font> 的多路平衡查找树。</p><p>下图所示的 B 树中所有结点的最大孩子数 $m=5$，因此它是一棵 5 阶 B 树，在 $m$ 阶 B 树中结点最多可以有 $m$ 个孩子。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E4%B8%80%E9%A2%975%E9%98%B6B%E6%A0%91%E7%9A%84%E5%AE%9E%E4%BE%8B.png" alt="一颗5阶B树的实例"></p><p>可以借助该实例来分析上述性质：</p><ol><li>结点的孩子个数等于该节点中关键字个数加 1。</li><li>如果根结点没有关键字就没有子树，此时 B 树为空；如果根节点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加 1。</li><li>除根结点外的所有非终端结点至少有 $\left \lceil \frac{m}{2} \right \rceil = \left \lceil \frac{5}{2} \right \rceil =3$ 棵子树（即至少有 $\left \lceil \frac{m}{2} \right \rceil -1=\left \lceil \frac{5}{2} \right \rceil -1=2$ 个关键字），至多有 5 棵子树（即至多有 4 个关键字）。</li><li>结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指向子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字。或者看成下层结点关键字总是落在由上层结点关键字所划分的区间内，如第二层最左结点的关键字划分成了 3 个区间：$(-\infty, 5),(5, 11),(11, +\infty)$，该结点 3 个指针所指子树的关键字均落在这 3 个区间内。</li><li>所有叶结点均在第 4 层，代表查找失败的位置。</li></ol><h4 id="B-树的高度（磁盘存取次数）"><a class="header-anchor" href="#B-树的高度（磁盘存取次数）"></a>B 树的高度（磁盘存取次数）</h4><p>B 树中的大部分操作所需的磁盘存取次数与 B 树的高度成正比。</p><p>下面来分析 B 树在不同情况下的高度。当然，首先应该明确 B 树的高度不包括最后的不带任何信息的叶结点所处的那一层（有些书对 B 树的高度的定义中，包含最后的那一层）。</p><p>若 $n\ge 1$，则对任意一棵包含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的 B 树：</p><ol><li>因为 B 树中每个结点最多有 $m$ 棵子树， $m-1$ 个关键字，所以在一棵高度为 $h$ 的 $m$ 阶 B 树中关键字的个数应满足 $n\le (m-1)(1+m+m^2+\cdots +m<sup>{h-1}=m</sup>h-1)$ ，因此有 $h\ge \log_{m}{(n+1)}$ 。最小高度</li><li>若让每个结点中的关键字个数达到最少，则容纳同样多关键字的 B 树的高度达到最大。由 B 树的定义：第一层至少有 1 个结点；第二层至少有 2 个结点；除根结点外的每个非终端结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树，则第三层至少有 $ 2 \left \lceil \frac{m}{2} \right \rceil $ 个结点……第 $h+ 1$ 层至少有 $2(\left \lceil \frac{m}{2} \right \rceil )^{h-1}$ 个结点，注意到第 $h+ 1$ 层是不包含任何信息的叶结点。对于关键字个数为 $n$ 的 B 树，叶结点即查找不成功的结点为 $n+ 1$ ，由此有 $n+ 1\ge 2(\left \lceil \frac{m}{2} \right \rceil )^{h-1}$，即 $h\le \log_{\left \lceil \frac{m}{2} \right \rceil }{(\frac{n+1}{2})+1} $。</li></ol><p>故含 $n$ 个关键字、高度为 $h$ 、阶数为 $m$ 的 B 树有：$ \log_{m}{(n+1)}\le h\le \log_{\left \lceil \frac{m}{2} \right \rceil }{(\frac{n+1}{2})+1} $</p><h4 id="B-树的查找"><a class="header-anchor" href="#B-树的查找"></a>B 树的查找</h4><p>在 B 树上进行查找与二叉查找树很相似，只是每个结点都是多个关键字的有序表，在每个结点上所做的不是两路分支决定，而是根据该结点的子树所做的多路分支决定。B 树的查找包含两个基本操作：</p><ol><li>在B树中找结点；</li><li>在结点内找关键字。</li></ol><p>由于 B 树常存储在磁盘上，因此前一个查找操作是在磁盘上进行的，而后一个查找操作是在内存中进行的，即在找到目标结点后，先将结点信息读入内存，然后在结点内采用顺序查找法或折半查找法。在 B 树上查找到某个结点后，先在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中去查找。查找到叶结点时（对应指针为空指针），则说明树中没有对应的关键字，查找失败。</p><h4 id="B-树的插入"><a class="header-anchor" href="#B-树的插入"></a>B 树的插入</h4><p>与二叉查找树的插入操作相比，B树的插入操作要复杂得多。在二叉查找树中，仅需查找到需插入的终端结点的位置。但是,在 B 树中找到插入的位置后，并不能简单地将其添加到终端结点中，因为此时可能会导致整棵树不再满足 B 树定义中的要求。将关键字 key 插入 B 树的过程如下：</p><ol><li>定位。利用前述的 B 树查找算法，找出插入该关键字的<font color="#faa755">最低层</font>中的某个非叶结点（在 B 树中查找 key 时，会找到表示查找失败的叶结点，这样就确定了最底层非叶结点的插入位置。注意：插入位置一定是最低层中的某个非叶结点）。</li><li>插入。在 B 树中，每个非失败结点的关键字个数都在区间 $[\left \lceil \frac{m}{2} \right \rceil -1,m- 1]$ 内。插入后的结点关键字个数小于 $m$ ，可以直接插入；插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于 $m-1$ 时，必须对结点进行分裂。</li></ol><p>分裂的方法是：取一个新结点，在插入 key 后的原结点，从中间位置（$\left \lceil \frac{m}{2} \right \rceil $）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（$\left \lceil \frac{m}{2} \right \rceil $）的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致 B 树高度增 1。</p><h4 id="B-树的删除"><a class="header-anchor" href="#B-树的删除"></a>B 树的删除</h4><p>B 树中的删除操作与插入操作类似，但要稍微复杂一些，即要使得删除后的结点中的关键字个数 $\ge \left \lceil \frac{m}{2} \right \rceil -1$ ，因此将涉及结点的“合并”问题。</p><p>当被删关键字 $k$ 不在终端结点（最低层非叶结点）中时，可以用 $k$ 的前驱（或后继） $k’$ 来替代 $k$ ，然后在相应的结点中删除 $k’$， 关键字 $k$ 必定落在某个终端结点中，则转换成了被删关键字在终端结点中的情形。</p><ul><li>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素。</li><li>直接后继：当前关键字右侧指针所指子树中“最左下”的元素。</li></ul><p>当被删关键字在终端结点（最低层非叶结点）中时，有下列三种情况：</p><ol><li>直接删除关键字。若被删除关键字所在结点的关键字个数 $\ge \left \lceil \frac{m}{2} \right \rceil -1$ ，表明删除该关键字后仍满足 B 树的定义，则直接删去该关键字。</li><li>兄弟够借。若被删除关键字所在结点删除前的关键字个数$=\left \lceil \frac{m}{2} \right \rceil -1$，且与此结点相邻的右（或左）兄弟结点的关键字个数$\ge \left \lceil \frac{m}{2} \right \rceil$，则需要调整该结点、右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡。当右兄弟很宽裕时，用当前结点的后继、后继的后继来填补空缺；当左兄弟很宽裕时，用当前结点的前驱、前驱的前驱来填补空缺。</li><li>兄弟不够借。若被删除关键字所在结点删除前的关键字个数 $=\left \lceil \frac{m}{2} \right \rceil -1$，且此时与该结点相邻的左、右兄弟结点的关键字个数均 $=\left \lceil \frac{m}{2} \right \rceil -1$，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并。在合并过程中，双亲结点中的关键字个数会减 1 。 若其双亲结点是根结点且关键字个数减少至 0 （根结点关键字个数为 1 时，有 2 棵子树），则直接将根结点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到 $=\left \lceil \frac{m}{2} \right \rceil -2$，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合 B 树的要求为止。</li></ol><h3 id="B-树的基本概念"><a class="header-anchor" href="#B-树的基本概念"></a>B+ 树的基本概念</h3><p>B+ 树是应数据库所需而出现的一种 B 树的变形树。</p><p>一棵 $m$ 阶的 B+ 树需满足下列条件：</p><ol><li>每个分支结点最多有 $m$ 棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 $\left \lceil \frac{m}{2} \right \rceil $ 棵子树。</li><li>结点的子树个数与关键字个数相等。</li><li>所有<font color="#faa755">叶结点包含全部关键字</font>及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来。(支持顺序查找)</li><li>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针。（类似分块查找）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/B+%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="B+树结构示意图"></p><p>$m$ 阶的 B+ 树与 $m$ 阶的 B 树的主要差异如下：</p><ol><li>在 B+ 树中，具有 $n$ 个关键字的结点只含有 $n$ 棵子树，即每个关键字对应一棵子树；而在 B 树中，具有 $n$ 个关键字的结点含有 $n+1$ 棵子树。</li><li>在 B+ 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\left \lceil \frac{m}{2} \right \rceil \le n \le m$  （根结点：$1\le n \le m$）；在 B 树中，每个结点（非根内部结点）的关键字个数 $n$ 的范围是 $\left \lceil \frac{m}{2} \right \rceil -1 \le n \le m-1 $ （根结点：$1\le n \le m-1$）。</li><li>在 B+ 树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li><li>在 B+ 树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在 B 树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</li></ol><p>分支结点的某个关键字是其子树中最大关键字的副本。通常在 B+ 树中有两个头指针：一个指向根结点，另一个指向关键字最小的叶结点。因此，可以对 B+ 树进行两种查找运算：一种是从最小关键字开始的顺序查找，另一种是从根结点开始的多路查找。</p><p>B+ 树的查找、插入和删除操作和 B 树的基本类似。只是在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的该关键字为止。所以，在 B+ 树中查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径。</p><p>在 B+ 树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得 B+ 树的阶更大，树高更矮，读磁盘次数更少，查找更快。</p><h2 id="散列表"><a class="header-anchor" href="#散列表"></a>散列表</h2><h3 id="散列表的基本概念"><a class="header-anchor" href="#散列表的基本概念"></a>散列表的基本概念</h3><p>在前面介绍的线性表和树表的查找中，记录在表中的位置与记录的关键字之间不存在确定关系，因此，在这些表中查找记录时需进行一系列的关键字比较。这类查找方法建立在“比较”的基础上，查找的效率取决于比较的次数。</p><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 <code>Hash(key)=Addr</code>  （这里的地址可以是数组下标、索引或内存地址等）。</p><p>散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为<font color="#ea66a6">冲突</font>，这些发生碰撞的不同关键字称为<font color="#ea66a6">同义词</font>。一方面，设计得好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的方法。</p><p>散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。</p><p>理想情况下，对散列表进行查找的时间复杂度为 $O(1)$，即与表中元素的个数无关。下面分别介绍常用的散列函数和处理冲突的方法。</p><h3 id="散列函数的构造方法"><a class="header-anchor" href="#散列函数的构造方法"></a>散列函数的构造方法</h3><p>在构造散列函数时，必须注意以下几点：</p><ol><li>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。</li><li>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生。</li><li>散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址。</li></ol><p>下面介绍常用的散列函数：</p><h4 id="直接定址法"><a class="header-anchor" href="#直接定址法"></a>直接定址法</h4><p>直接取关键字的某个线性函数值为散列地址，散列函数为$H(\mathrm{key} )=\mathrm{key} $ 或 $H(\mathrm{key})=a\times \mathrm{key} +b$ 式中，$a$ 和 $b$ 是常数。</p><p>这种方法计算最简单，且不会产生冲突。它适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费。</p><h4 id="除留余数法"><a class="header-anchor" href="#除留余数法"></a>除留余数法</h4><p>这是一种最简单、最常用的方法，假定散列表表长为 $m$，取一个不大于 $m$ 但最接近或等于 $m$ 的<font color="#faa755">质数</font> $p$ ，利用以下公式把关键字转换成散列地址。散列函数为 $H(\mathrm{key})=\mathrm{key} % p$</p><p>除留余数法的关键是选好 $p$ ，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性。</p><h4 id="数字分析法"><a class="header-anchor" href="#数字分析法"></a>数字分析法</h4><p>设关键字是 $r$ 进制数（如十进制数），而 $r$ 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些， 每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时应<font color="#faa755">选取数码分布较为均匀的若干位作为散列地址</font>。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</p><h4 id="平方取中法"><a class="header-anchor" href="#平方取中法"></a>平方取中法</h4><p>顾名思义，这种方法取关键字的平方值的中间几位作为散列地址。具体取多少位要视实际情况而定。这种方法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。<br>在不同的情况下，不同的散列函数具有不同的性能，因此不能笼统地说哪种散列函数最好。在实际选择中，采用何种构造散列函数的方法取决于关键字集合的情况，但目标是为了尽量降低产生冲突的可能性。</p><h3 id="处理冲突的方法"><a class="header-anchor" href="#处理冲突的方法"></a>处理冲突的方法</h3><p>应该注意到，任何设计出来的散列函数都不可能绝对地避免冲突。为此，必须考虑在发生冲突时应该如何处理，即为产生冲突的关键字寻找下一个“空”的 Hash 地址。用 $H_i$ 表示处理冲突中第 $i$ 次探测得到的散列地址，假设得到的另一个散列地址 $H_1$ 仍然发生冲突，只得继续求下一个地址 $H_2$，以此类推，直到 $H_k$ 不发生冲突为止，则 $H_k$ 为关键字在表中的地址。</p><h4 id="拉链法（链接法）"><a class="header-anchor" href="#拉链法（链接法）"></a>拉链法（链接法）</h4><p>显然，对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为 $i$ 的同义词链表的头指针存放在散列表的第 $i$ 个单元中，因而查找、插入和删除操作主要在同义词链中进行。拉链法适用于经常进行插入和删除的情况。</p><h4 id="开放定址法"><a class="header-anchor" href="#开放定址法"></a>开放定址法</h4><p>所谓开放定址法，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式为$$H_i=H(\mathrm{key})+d_i % m$$式中，$H(\mathrm{key})$ 为散列函数；$i=0,1,2,\cdots ,k \ (k \le m-1)$；$m$ 表示散列表长；$d_i$ 为增量序列。取定某一增量序列后，对应的处理方法就是确定的。通常有以下 4 种取法：</p><ol><li>线性探测法。当 $d_i=0,1,2,\cdots ,m-1$ 时，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中下一个单元（探测到表尾地址 $m-1$ 时，下一个探测地址是表首地址 0 ），直到找出一个空闲单元（当表未填满时一定能找到- 一个空闲单元）或查遍全表。线性探测法可能使第 $i$ 个散列地址的同义词存入第 $i+ 1$ 个散列地址，这样本应存入第 $i+1$ 个散列地址的元素就争夺第 $i+2$ 个散列地址的元素的地址…从而造成大量元素在相邻的散列地址上，“聚集”(或堆积）起来，大大降低了查找效率。</li><li>平方探测法。当 $d_{i} = {0^2} ,{1^2}, {-1^2} ,{2^2} ,{-2^2}, \cdots ,{k^2} ,{-k^2}$ 时，称为平方探测法，其中 $k \le \frac{m}{2}$ ，散列表长度 $m$ 必须是一个可以表示成 $4k+3$ 的素数，又称二次探测法。平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。</li><li>伪随机序列法。当 $d_i=$ 伪随机数序列时，称为伪随机序列法。</li><li>再散列法。除了原始的散列函数 $H(\mathrm{key})$ 之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。</li></ol><p>注意：在开放定址的情形下，不能随便物理删除表中的已有元素，因为若删除元素，则会截断其他具有相同散列地址的元素的查找地址。因此，要删除-一个元素时，可给它做一个删除标记，进行逻辑删除。但这样做的副作用是:执行多次删除后，表面，上看起来散列表很满，实际上有许多位置未利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</p><h3 id="散列查找及性能分析"><a class="header-anchor" href="#散列查找及性能分析"></a>散列查找及性能分析</h3><p>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字 key ，根据散列函数可以计算出其散列地址，执行步骤如下：</p><p>初始化： <code>Addr=Hash(key);</code></p><ol><li>检测查找表中地址为 <code>Addr</code> 的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与 <code>key</code> 的值，若相等，则返回查找成功标志，否则执行步骤 2 。</li><li>用给定的处理冲突方法计算“下一个散列地址”，并把 <code>Addr</code> 置为此地址，转入步骤 1 。</li></ol><p>对同一组关键字，设定相同的散列函数，则不同的处理冲突的方法得到的散列表不同，它们的平均查找长度也不同。</p><p>从散列表的查找过程可见：</p><ol><li>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突”的产生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需要以平均查找长度作为衡量散列表的查找效率的度量。</li><li>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子。</li></ol><p>装填因子。散列表的装填因子一般记为 $\alpha $，定义为一个表的装满程度，即：$\alpha =\frac{n}{m}$ 式中 $n$ 表示表中记录数，$m$ 表示散列表长度。</p><p>散列表的平均查找长度依赖于散列表的装填因子 $\alpha $，而不直接依赖于 $n$ 或 $m$ 。直观地看，$\alpha $ 越大，表示装填的记录越“满”，发生冲突的可能性越大，反之发生冲突的可能性越小。</p>]]></content>
    
    
    <summary type="html">查找</summary>
    
    
    
    <category term="数据结构" scheme="https://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="https://halo123.top/2021/05/09/DataStructure/F_graph/"/>
    <id>https://halo123.top/2021/05/09/DataStructure/F_graph/</id>
    <published>2021-05-09T14:50:51.000Z</published>
    <updated>2021-06-04T03:12:54.635Z</updated>
    
    <content type="html"><![CDATA[<div class="tag link"><a class="link-card" title="C语言实现图数据结构" href="https://github.com/TheAlgorithms/C/tree/master/data_structures/graphs"><div class="left"><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/GithubIcon.jpg"/></div><div class="right"><p class="text">C语言实现图数据结构</p><p class="url">https://github.com/TheAlgorithms/C/tree/master/data_structures/graphs</p></div></a></div><h2 id="图的基本概念"><a class="header-anchor" href="#图的基本概念"></a>图的基本概念</h2><h3 id="图的定义"><a class="header-anchor" href="#图的定义"></a>图的定义</h3><p>图 $G$ 由顶点集 $V$ 和边集 $E$ 组成，记为 $G=(V,E)$，其中 $V(G)$ 表示图 $G$ 中顶点的有限非空集；$E(G)$ 表示图 $G$ 中顶点之间的关系 （边）集合。若 $V= \{v_1,v_2,\dots v_n\}$，则用 $|V|$ 表示图 $G$ 中顶点的个数，也称图 $G$ 的阶，$E= \{(\mu,\nu)|\mu \in V,\nu \in V  \} $，用 $|E|$ 表示图 $G$ 中边的条数。</p><p>注意：线性表可以是空表，树可以是空树，但图不可以是空图。就是说，图中不能一个顶点也没有，图的顶点集 $V$ 一定非空，但边集 $E$ 可以为空，此时图中只有顶点而没有边。</p><p>下面是图的一些基本概念及术语。</p><h3 id="有向图和无向图"><a class="header-anchor" href="#有向图和无向图"></a>有向图和无向图</h3><p>若 $E$ 是有向边（也称弧）的有限集合时，则图 $G$ 为有向图。弧是顶点的有序对，记为 $ \langle v,w\rangle $ ，其中 $v$，$w$ 是顶点，$v$ 称为弧尾，$w$ 称为弧头， $\langle v, w \rangle $  称为从顶点 $v$ 到顶点 $w$ 的弧，也称 $v$ 邻接到 $w$，或 $w$ 邻接自 $v$。</p><p>若 $E$ 是无向边（简称边）的有限集合时，则图 $G$ 为无向图。边是顶点的无序对，记为 $(v,w)$ 或 $(w,v)$，因为$(v, w)=(w,v)$ 其中 $v$，$w$ 是顶点。可以说顶点 $w$ 和顶点 $v$ 互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$ ，或者说边 $(v, w)$ 和顶点 $v$，$w$ 相关联。</p><h3 id="简单图和多重图"><a class="header-anchor" href="#简单图和多重图"></a>简单图和多重图</h3><p>一个图 $G$ 若满足：</p><ol><li>不存在重复边；</li><li>不存在顶点到自身的边，则称图 $G$ 为简单图。</li></ol><p>数据结构中仅讨论简单图。</p><p>若图 $G$ 中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则 $G$ 为多重图。多重图的定义和简单图是相对的。</p><h3 id="顶点的度、入度和出度"><a class="header-anchor" href="#顶点的度、入度和出度"></a>顶点的度、入度和出度</h3><p>图中每个顶点的度定义为以该顶点为一个端点的边的数目。</p><p>对于无向图，顶点 $v$  的度是指依附于该顶点的边的条数，记为 $\mathrm{TD} (v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的无向图中$$ \sum_{i=1}^{n} \mathrm{TD} (v_i)=2e $$即无向图的全部顶点的度的和等于边数的2倍，因为每条边和两个顶点相关联。</p><p>对于有向图，顶点 $v$ 的度分为入度和出度，入度是以顶点 $v$ 为终点的有向边的数目，记为 $\mathrm{ID}(v)$；而出度是以顶点 $v$ 为起点的有向边的数目，记为  $\mathrm{OD}(v)$。顶点 $v$ 的度等于其入度和出度之和，即 $\mathrm{TD} (v)=\mathrm{ID}(v)+\mathrm{OD}(v)$。</p><p>在具有 $n$ 个顶点、$e$ 条边的有向图中，$$\sum_{i=1}^{n} \mathrm{ID} (v_i)=\sum_{i=1}^{n} \mathrm{OD} (v_i)=e $$即有向图的全部顶点的入度之和与出度之和相等，并且等于边数。这是因为每条有向边都有一个起点和终点。</p><h3 id="路径、路径长度和回路"><a class="header-anchor" href="#路径、路径长度和回路"></a>路径、路径长度和回路</h3><p>顶点 $v_p$ 到顶点 $v_q$ 之间的一条路径是指顶点序列 $v_p,v_{i1},v_{i2},\dots ,v_{im},v_q$，当然关联的边也可以理解为路径的构成要素。</p><p>路径上边的数目称为路径长度。</p><p>第一个顶点和最后一个顶点相同的路径称为回路或环。若一个图有 $n$ 个顶点，并且有大于 $n-1$ 条边，则此图一定有环。</p><h3 id="简单路径、简单回路"><a class="header-anchor" href="#简单路径、简单回路"></a>简单路径、简单回路</h3><p>在路径序列中，顶点不重复出现的路径称为简单路径。</p><p>除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</p><h3 id="距离"><a class="header-anchor" href="#距离"></a>距离</h3><p>从顶点 $u$ 出发到顶点 $v$ 的最短路径若存在，则此路径的长度称为从 $u$ 到 $v$ 的距离；若从 $u$ 到 $v$ 根本不存在路径，则记该距离为无穷( $∞$ )</p><h3 id="连通、连通图"><a class="header-anchor" href="#连通、连通图"></a>连通、连通图</h3><p>在无向图中，若从顶点 $v$ 到顶点 $w$ 有路径存在，则称 $v$ 和 $w$ 是连通的。若图 $G$ 中任意两个顶点都是连通的，则称图 $G$ 为<font color="#ea66a6">连通图</font>，否则称为非连通图。</p><p>若图 $G$ 是连通图，则至少有 $n-1$ 条边。若 $G$ 是非连通图，则至多可能有 $C_{n-1}^{2}$ 条边</p><h3 id="强连通图"><a class="header-anchor" href="#强连通图"></a>强连通图</h3><p>在有向图中，若从顶点 $v$ 到顶点 $w$ 和从顶点 $w$ 到顶点 $v$ 之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称此图为强连通图。</p><p>若 $G$ 是强连通图，则最少有 $n$ 条边（形成回路）</p><p>注意：强连通图、强连通分量只是针对有向图而言的。一般在无向图中讨论连通性，在有向图中考虑强连通性。</p><h3 id="子图"><a class="header-anchor" href="#子图"></a>子图</h3><p>设有两个图 $G=(V,E)$ 和 $G’=(V’,E’)$ ，若 $V’$ 是 $V$ 的子集，且 $E’$ 是 $E$ 的子集，则称 $G’$ 是 $G$ 的子图。若有满足 $V(G’)=V(G)$ 的子图 $G’$ ，则称其为 $G$ 的生成子图。</p><p>注意：并非 $V$ 和 $E$ 的任何子集都能构成 $G$ 的子图，因为这样的子集可能不是图，即 $E$ 的子集中的某些边关联的顶点可能不在这个 $V$ 的子集中。</p><h3 id="连通分量、强连通分量"><a class="header-anchor" href="#连通分量、强连通分量"></a>连通分量、强连通分量</h3><p>无向图中的极大连通子图称为连通分量。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E5%8F%8A%E5%85%B6%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.png" alt="无向图及其连通分量"></p><p>有向图中的极大强连通子图称为有向图的强连通分量。</p><blockquote><p>注意：要区分极大连通子图和极小连通子图，极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。</p></blockquote><h3 id="生成树、生成森林"><a class="header-anchor" href="#生成树、生成森林"></a>生成树、生成森林</h3><p>连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为 $n$ ，则它的生成树含有 $n-1$ 条边。</p><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。</p><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林。</p><h3 id="边的权和网"><a class="header-anchor" href="#边的权和网"></a>边的权和网</h3><p>在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。这种边上带有权值的图称为带权图，也称网。</p><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p><h3 id="完全图"><a class="header-anchor" href="#完全图"></a>完全图</h3><p>无向完全图：无向图中任意两个顶点之间都存在边，若无向图的顶点数 $|V|=n$ ，则 $|E|\in [0,C_n^2]=[0,\frac{n(n-1)}{2} ] $</p><p>有向完全图：有向图中任意两个顶点之间都存在方向相反的两条弧，若有向图的顶点数 $|V|=n$ ，则 $|E|\in [0,2C_n^2]=[0,n(n-1) ] $</p><h3 id="稠密图、稀疏图"><a class="header-anchor" href="#稠密图、稀疏图"></a>稠密图、稀疏图</h3><p>边数很少的图称为稀疏图，反之称为稠密图。</p><p>稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图 $G$ 满足 $|E| &lt; |V|\log|V|$ 时，可以将 $G$ 视为稀疏图。</p><h3 id="树、有向树"><a class="header-anchor" href="#树、有向树"></a>树、有向树</h3><p>树：不存在回路，且连通的无向图。$n$ 个顶点的树，必有 $n-1$ 条边。</p><p>一个顶点的入度为0，其余顶点的入度均为 1 的有向图，称为有向树。</p><h2 id="图的存储及基本操作"><a class="header-anchor" href="#图的存储及基本操作"></a>图的存储及基本操作</h2><h3 id="邻接矩阵法"><a class="header-anchor" href="#邻接矩阵法"></a>邻接矩阵法</h3><p>所谓邻接矩阵存储，是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。</p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/有向图、无向图及网的邻接矩阵.png" alt="有向图、无向图及网的邻接矩阵" style="zoom:200%;" /><p>图的邻接矩阵存储结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100  <span class="comment">// 顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;     <span class="comment">// 带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];               <span class="comment">// 顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];  <span class="comment">// 邻接矩阵，边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;  <span class="comment">// 图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在简单应用中，可直接用二维数组作为图的邻接矩阵（顶点信息等均可省略）。</li><li>当邻接矩阵中的元素仅表示相应的边是否存在时，<code>EdgeType</code> 可定义为值为 0 和 1 的枚举类型。</li><li>无向图的邻接矩阵是<font color="#faa755">对称矩阵</font>，对规模特大的邻接矩阵可采用<a href="http://halo123.top/2021/05/02/DataStructure/C_StacksAndQueues/#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5">压缩存储</a>。</li><li>邻接矩阵表示法的空间复杂度为 $O(n^2)$，其中 $n$ 为图的顶点数 $|V|$。</li></ol><p>图的邻接矩阵存储表示法具有以下特点：</p><ol><li>对于无向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的度 $TD(v)$。时间复杂度 $O(|V|)$。</li><li>对于有向图，邻接矩阵的第 $i$ 行（或第 $i$ 列）非零元素（或非 $∞$ 元素）的个数正好是第 $i$ 个顶点的出度 $OD(v)$ [或入度 $ID(v)$ ]。第 $i$ 行结点的度即为，第 $i$ 行和列的非零元素（或非 $∞$ 元素）的个数之和。时间复杂度 $O(|V|)$。</li><li>设图 $G$ 的邻接矩阵为 $\mathbf{A} $，$\mathbf{A}^n$ 的元素  $A^n[i][j]$ 等于由顶点 $i$ 到顶点 $j$ 的长度为 $n$ 的路径的数目。（妙啊）</li><li>稠密图适合使用邻接矩阵的存储表示。</li><li>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。 因此，在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素。</li><li>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是，要确定图中有多少条边，则必须按行、按列对每个元素进行检测，所花费的时间代价很大。</li></ol><h3 id="邻接表法"><a class="header-anchor" href="#邻接表法"></a>邻接表法</h3><p>当一个图为稀疏图时，使用邻接矩阵法显然要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，大大减少了这种不必要的浪费。</p><p>所谓邻接表，是指对图 $G$ 中的每个顶点 $v_i$ 建立一个单链表，第 $i$ 个单链表中的结点表示依附于顶点 $v_i$ 的边（对于有向图则是以顶点 $v_i$ 为尾的弧），这个单链表就称为顶点 $v_i$ 的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100 <span class="comment">// 图中顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;  <span class="comment">// 顶点的数据类型</span></span><br><span class="line"><span class="comment">// &quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;            <span class="comment">// &quot;边/弧&quot;指向哪个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">// InfoType info       // 边权值</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    VertexType data;  <span class="comment">// 顶点信息</span></span><br><span class="line">    ArcNode *first;   <span class="comment">// 第一条边/弧</span></span><br><span class="line">&#125; VNode, AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="无向图邻接表表示法实例"></p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95%E5%AE%9E%E4%BE%8B.png" alt="有向图邻接表表示法实例"></p><p>图的邻接表存储方法具有以下特点：</p><ol><li>若 $G$ 为无向图，则所需的存储空间为 $O(|V|+ 2|E|)$；若 $G$ 为有向图，则所需的存储空间为 $O(|V|+ |E|)$。前者的倍数 2 是由于无向图中，每条边在邻接表中出现了两次。</li><li>对于稀疏图，采用邻接表表示将极大地节省存储空间。</li><li>在邻接表中，给定一顶点，能很容易地找出它的所有邻边，因为只需要读取它的邻接表。在邻接矩阵中，相同的操作则需要扫描一行，花费的时间为 $O(n)$ 。 但是，若要确定给定的两个顶点间是否存在边，则在邻接矩阵中可以立刻查到，而在邻接表中则需要在相应结点对应的边表中查找另一结点，效率较低。</li><li>在有向图的邻接表表示中，求一个给定顶点的<font color="#faa755">出度</font>只需计算其邻接表中的结点个数；但求其顶点的<font color="#faa755">入度</font>则需要遍历全部的邻接表。因此，也有人采用逆邻接表的存储方式来加速求解给定顶点的入度。当然，这实际上与邻接表存储方式是类似的。</li><li>图的邻接表表示并不唯一，因为在每个项点对应的单链表中，各边结点的链接次序可以是任意的，它取决于建立邻接表的算法及边的输入次序。</li></ol><h3 id="十字链表法"><a class="header-anchor" href="#十字链表法"></a>十字链表法</h3><p>十字链表是<font color="#faa755">有向图</font>的一种链式存储结构。在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点。</p><p>弧结点中有 5 个域：尾域（<code>tailvex</code>） 和头域（<code>headvex</code>）分别指示弧尾和弧头这两个顶点在图中的位置；链域 <code>hlink</code> 指向弧头相同的下一条弧；链域 <code>tlink</code> 指向弧尾相同的下一条弧；<code>info</code> 域指向该弧的相关信息。这样，弧头相同的弧就在同一个链表上，弧尾相同的弧也在同一个链表上。</p><p>顶点结点中有 3 个域：<code>data</code> 域存放顶点相关的数据信息，如顶点名称；<code>firstin</code> 和 <code>firstout</code> 两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="有向图的十字链表表示"></p><p>在十字链表中，既容易找到 $V_i$ 为尾的弧，又容易找到 $V_i$ 为头的弧，因而容易求得顶点的出度和入度。图的十字链表表示是不唯一的， 但一个十字链表表示确定一个 图。空间复杂度：$O(|V|+|E|)$</p><p>TODO 代码实现十字链表法</p><h3 id="邻接多重表法"><a class="header-anchor" href="#邻接多重表法"></a>邻接多重表法</h3><p>邻接多重表是<font color="#faa755">无向图</font>的另一种链式存储结构。</p><p>在邻接表中，容易求得顶点和边的各种信息，但在邻接表中求两个顶点之间是否存在边而对边执行删除等操作时，需要分别在两个顶点的边表中遍历，效率较低。</p><p>与十字链表类似，在邻接多重表中，每条边用一个结点表示，其结构如下所示。</p><p>其中，<code>mark</code> 为标志域，可用以标记该条边是否被搜索过；<code>ivex</code> 和 <code>jvex</code> 为该边依附的两个顶点在图中的位置；<code>ilink</code> 指向下一条依附于顶点 <code>ivex</code> 的边；<code>jlink</code> 指向下一条依附于顶点 <code>jvex</code> 的边，<code>info</code> 为指向和边相关的各种信息的指针域。</p><p>每个顶点也用一个结点表示，它由如下所示的两个域组成。</p><p>其中，<code>data</code> 域存储该顶点的相关信息，<code>firstedge</code> 域指示第一条依附于该顶点的边。</p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。对无向图而言，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA.png" alt="无向图的邻接多重表表示"></p><p>空间复杂度：$O(|V|+|E|)$。</p><h3 id="图的基本操作"><a class="header-anchor" href="#图的基本操作"></a>图的基本操作</h3><p>图的基本操作是独立于图的存储结构的。而对于不同的存储方式，操作算法的具体实现会有着不同的性能。在设计具体算法的实现时，应考虑采用何种存储方式的算法效率会更高。</p><p>图的基本操作主要包括（仅抽象地考虑，故忽略掉各变量的类型）：</p><ul><li><code>Adjacent (G,x,y)</code>：判断图 $G$ 是否存在边  $ \langle x,y \rangle $  或 $(x,y)$。邻接矩阵时间复杂度：$O(1)$，邻接表时间复杂度：$O(1)\sim  O(|V|)$。</li><li><code>Neighbors (G,x)</code>：列出图 $G$ 中与结点 $x$ 邻接的边。邻接矩阵时间复杂度：$O(|V|)$；邻接表无向图时间复杂度：$O(1)\sim  O(|V|)$，邻接表有向图出边时间复杂度：$O(1)\sim O(|V|)$，邻接表有向图入边时间复杂度：$O(|E|)$。</li><li><code>InsertVertex(G,x)</code>：在图 $G$ 中插入顶点 $x$ 。邻接矩阵和邻接表时间复杂度：$O(1)$</li><li><code>DeleteVertex(G,x)</code>：从图 $G$ 中删除顶点 $x$。邻接矩阵无向图时间复杂度：$O(|V|)$，邻接表无向图时间复杂度：$O(1)\sim O(|E|)$；邻接矩阵有向图时间复杂度：$O(|V|)$，邻接表删出边：$O(1)\sim O(|V|)$，邻接表删入边：$O(|E|)$</li><li><code>AddEdge (G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $ \langle x,y \rangle $ 不存在，则向图 $G$ 中添加该边。邻接矩阵 $O(1)$，邻接表 $O(1)$</li><li><code>RemoveEdge(G,x,y)</code>：若无向边 $(x, y)$ 或有向边 $ \langle x,y \rangle $ 存在，则从图 $G$ 中删除该边。邻接矩阵 $O(1)$，邻接表 $O(1) \sim O(|V|)$</li><li><code>FirstNeighbor(G,x)</code>：求图 $G$ 中顶点 $x$ 的第一个邻接点，若有则返回顶点号。若 $x$ 没有邻接点或图中不存在 $x$ ，则返回 -1。邻接矩阵无向图 $O(1)\sim O(|V|)$，邻接表无向图 $O(1)$；邻接矩阵有向图 $O(1)\sim O(|V|)$，邻接表有向图找出边邻接点：$O(1)$，邻接表有向图找入边邻接点：$O(1)\sim O(|E|)$</li><li><code>NextNeighbor (G,x,y)</code>：假设图 $G$ 中顶点 $y$ 是顶点 $x$ 的一个邻接点，返回除 $y$ 外顶点 $x$ 的下一个邻接点的顶点号，若 $y$ 是 $x$ 的最后一个邻接点，则返回 -1。邻接矩阵 $O(1)\sim O(|V|)$，邻接表 $O(1)$；</li><li><code>Get_edge_value(G,x,y)</code>：获取图 $G$ 中边 $(x, y)$ 或 $ \langle x,y \rangle $ 对应的权值。时间复杂度同 <code>Adjacent (G,x,y)</code></li><li><code>Set_edge_value(G,x,y,v)</code>：设置图 $G$ 中边 $(x, y)$ 或 $ \langle x,y \rangle $ 对应的权值为 $v$ 。时间复杂度同 <code>Adjacent (G,x,y)</code></li></ul><p>此外，还有图的遍历算法：按照某种方式访问图中的每个顶点且仅访问一次。图的遍历算法包括深度优先遍历和广度优先遍历。</p><p>TODO 分析十字链表法和邻接多重表法下的基本操作的时间复杂度</p><h2 id="图的遍历"><a class="header-anchor" href="#图的遍历"></a>图的遍历</h2><p>图的遍历是指从图中的某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。注意到树是一种特殊的图，所以树的遍历实际上也可视为一种特殊的图的遍历。图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。</p><p>图的遍历比树的遍历要复杂得多，因为图的任一顶点都可能和其余的顶点相邻接，所以在访问某个顶点后，可能沿着某条路径搜索又回到该顶点上。为避免同一顶点被访问多次，在遍历图的过程中，必须记下每个已访问过的顶点，为此可以设一个辅助数组 <code>visited[]</code> 来标记顶点是否被访问过。图的遍历算法主要有两种：广度优先搜索和深度优先搜索。</p><h3 id="广度优先搜索"><a class="header-anchor" href="#广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索（Breadth-First- Search, BFS）类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点 $v$ ，接着由 $v$ 出发，依次访问 $v$ 的各个未访问过的邻接顶点 $w_1,w_2,\dots ,w_i$ 然后依次访问 $w_1,w_2,\dots ,w_i$ 的所有未被访问过的邻接顶点；再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点，直至图中所有顶点都被访问过为止。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作为始点，重复上述过程，直至图中所有顶点都被访问到为止。Dijkstra 单源最短路径算法和 Prim 最小生成树算法也应用了类似的思想。</p><p>换句话说，广度优先搜索遍历图的过程是以 $v$ 为起始点，由近至远依次访问和 $v$ 有路径相通且路径长度为 1，2，… 的顶点。广度优先搜索是一种分层的查找过程，每向前走一步可能访问一批顶点，不像深度优先搜索那样有往回退的情况，因此它不是一个递归的算法。为了实现逐层的访问，算法必须<font color="#faa755">借助一个辅助队列</font>，以记忆正在访问的顶点的下一层顶点。</p><p>广度优先遍历算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];  <span class="comment">// 访问标记数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;  <span class="comment">// 对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">        visited[i] = <span class="literal">false</span>;  <span class="comment">// 访问标记数组初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);                         <span class="comment">// 初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j) &#123;  <span class="comment">// 从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[j]) &#123;  <span class="comment">// 对每个连通分量调用一次 BFS</span></span><br><span class="line">            <span class="built_in">BFS</span>(G, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);               <span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;      <span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q, v);          <span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, v);  <span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);           <span class="comment">//访问顶点w</span></span><br><span class="line">                visited[w] = <span class="literal">true</span>;  <span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">// if</span></span><br><span class="line">        &#125;<span class="comment">// for</span></span><br><span class="line">    &#125;<span class="comment">// while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同一个图的邻接矩阵表示方式唯一，因此广度优先历序列唯一</li><li>同一个图邻接表表示方式不唯一，因此广度优先遍历序列不唯一</li></ul><p>辅助数组 <code>visited[]</code> 标志顶点是否被访问过，其初始状态为 <code>false</code> 。在图的遍历过程中，一旦某个顶点 $v_i$ 被访问，就立即置 <code>visited[i]</code> 为 <code>true</code> ，防止它被多次访问。</p><p>图的广度优先搜索的过程与二叉树的层序遍历是完全一致的， 这也说明了图的广度优先搜索遍历算法是二叉树的层次遍历算法的扩展。图的广度优先遍历还可用于求一些问题的最优解,</p><h4 id="BFS-算法的性能分析"><a class="header-anchor" href="#BFS-算法的性能分析"></a>BFS 算法的性能分析</h4><p>无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 <code>Q</code>，$n$ 个顶点均需入队一次，在最坏的情况下，空间复杂度为 $O(|V|)$ 。</p><p>采用邻接表存储方式时，每个顶点均需搜索一次（或入队一次）， 故时间复杂度为 $O(|V|)$ ，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为 $O(|E|)$ ， 算法总的时间复杂度为 $O(|V|+|E|)$。采用邻接矩阵存储方式时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，故算法总的时间复杂度为 $O(|V|^2)$ 。</p><h4 id="广度优先生成树"><a class="header-anchor" href="#广度优先生成树"></a>广度优先生成树</h4><p>在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树。需要注意的是，一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一， 故其广度优先生成树也是不唯一的。</p><h3 id="深度优先搜索"><a class="header-anchor" href="#深度优先搜索"></a>深度优先搜索</h3><p>与广度优先搜索不同，深度优先搜索（Depth-First-Search，DFS）类似于树的先序遍历。如其名称中所暗含的意思一样，这种搜索算法所遵循的搜索策略是尽可能“深”地搜索一个图。</p><p>它的基本思想如下：首先访问图中某一起始顶点 $v$ ，然后由 $v$ 出发，访问与 $v$ 邻接且未被访问的任一顶点 $w_1$，再访问与 $w_1$ 邻接且未被访问的任一顶点 $w_2$ …… 重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。</p><p>一般情况下，其递归形式的算法十分简洁，算法过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MaxVertexNum];  <span class="comment">// 访问标记数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;  <span class="comment">// 对图 G 进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        visited[v] = <span class="literal">false</span>;  <span class="comment">// 初始化已访问标记数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.vexnum; ++v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[v]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">visit</span>(v);           <span class="comment">// 访问顶点 v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;  <span class="comment">// 设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighor</span>(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;  <span class="comment">// w 为 u 的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：图的邻接矩阵表示是唯一的，但对于邻接表来说，若边的输入次序不同，生成的邻接表也不同。因此，对于同样一个图，基于邻接矩阵的遍历所得到的 DFS 序列和 BFS 序列是唯一的，基于邻接表的遍历所得到的 DFS 序列和 BFS 序列是不唯一的。</p><h4 id="DFS-算法的性能分析"><a class="header-anchor" href="#DFS-算法的性能分析"></a>DFS 算法的性能分析</h4><p>DFS 算法是一个递归算法，需要借助一个递归工作栈，故其空间复杂度为 $O(|V|)$。</p><p>遍历图的过程实质上是对每个顶点查找其邻接点的过程，其耗费的时间取决于所用的存储结构。以邻接矩阵表示时，查找每个顶点的邻接点所需的时间为 $O(|V|)$ ，故总的时间复杂度为 $O(|V|^2)$。以邻接表表示时，查找所有顶点的邻接点所需的时间为 $O(E)$，访问顶点所需的时间为 $O(|V|)$，此时，总的时间复杂度为 $O(|V|+|E|)$ 。</p><h4 id="深度优先的生成树和生成森林"><a class="header-anchor" href="#深度优先的生成树和生成森林"></a>深度优先的生成树和生成森林</h4><p>与广度优先搜索一样，深度优先搜索也会产生一棵深度优先生成树。当然，这是有条件的，即对连通图调用 DFS 才能产生深度优先生成树，否则产生的将是深度优先生成森林。与BFS类似，基于邻接表存储的深度优先生成树是不唯一的。</p><h3 id="图的遍历与图的连通性"><a class="header-anchor" href="#图的遍历与图的连通性"></a>图的遍历与图的连通性</h3><p>图的遍历算法可以用来判断图的连通性。</p><p>对于无向图来说，若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点；若无向图是非连通的，则从某一个 顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问。对于有向图来说，若从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点，否则不能访问到所有顶点。</p><p>故在 <code>BFSTraverse()</code> 或 <code>DFSTraverse()</code> 中添加了第二个 for 循环，再选取初始点，继续进行遍历，以防止一次无法遍历图的所有顶点。对于无向图，上述两个函数调用 <code>BFS(G,i)</code> 或 <code>DFS(G,i)</code> 的次数等于该图的连通分量数；而对于有向图则不是这样，因为一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通量，非强连通分量一次调用 <code>BFS(G,i)</code> 或 <code>DFS(G, i)</code> 无法访问到该连通分量的所有顶点。</p><h2 id="图的应用"><a class="header-anchor" href="#图的应用"></a>图的应用</h2><p>本节是历年考查的重点。图的应用主要包括：最小生成（代价）树、最短路径、拓扑排序和关键路径。一般而言，这部分内容直接以算法设计题形式考查的可能性很小，而更多的是结合图的实例来考查算法的具体操作过程，读者必须学会手工模拟给定图的各个算法的执行过程。此外，还需掌握对给定模型建立相应的图去解决问题的方法。</p><h3 id="最小生成树"><a class="header-anchor" href="#最小生成树"></a>最小生成树</h3><p>一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。对于生成树来说，若砍去它的一条边，则会使生成树变成非连通图；若给它增加一条边， 则会形成图中的一条回路。</p><p>对于一个带权连通无向图 $G=(V, E)$，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设 $R$ 为 $G$ 的所有生成树的集合，若 $T$ 为 $R$ 中边的权值之和最小的那棵生成树，则 $T$ 称为 $G$ 的<font color="#ea66a6">最小生成树</font>（Minimum-Spanning-Tree, MST）。</p><p>不难看出，最小生成树具有如下性质：</p><ol><li>最小生成树不是唯一的，即最小生成树的树形不唯一，$R$ 中可能有多个最小生成树。当图 $G$ 中的各边权值互不相等时， $G$ 的最小生成树是唯一的；若无向连通图 $G$ 的边数比顶点数少1，即 $G$ 本身是一棵树时，则 $G$ 的最小生成树就是它本身。</li><li>最小生成树的边的权值之和总是唯一的， 虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。</li><li>最小生成树的边数为顶点数减 1。</li></ol><p>构造最小生成树有多种算法，但大多数算法都利用了最小生成树的下列性质：假设 $G=(V, E)$ 是一个带权连通无向图，$U$ 是顶点集 $V$ 的一个非空子集。若 $(u, v)$ 是一条具有最小权值的边，其中 $u\in U$，$v \in V-U$，则必存在一棵包含边 $(u, v)$ 的最小生成树。</p><p>基于该性质的最小生成树算法主要有 Prim 算法和 Kruskal 算法，它们都基于贪心算法的策略。对这两种算法应主要掌握算法的本质含义和基本思想，并能够手工模拟算法的实现步骤。</p><h4 id="Prim-算法"><a class="header-anchor" href="#Prim-算法"></a>Prim 算法</h4><p>Prim（普里姆）算法的执行非常类似于寻找图的最短路径的 Djkstra 算法。</p><p>Prim算法构造最小生成树的过程如下图所示。初始时从图中任取一顶点（如顶点1）加入树 $T$，此时树中只含有一个顶点，之后选择一个与当前 $T$ 中顶点集合距离最近的顶点，并将该顶点和相应的边加入$T$，每次操作后 $T$ 中的顶点数和边数都增1。以此类推，直至图中所有的顶点都并入 $T$，得到的 $T$ 就是最小生成树。此时 $T$ 中必然有 $n-1$ 条边。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Prim%E7%AE%97%E6%B3%95%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Prim算法构造最小生成树的过程"></p><p>Prim 算法的步骤如下：</p><ul><li>假设 $G= \{V, E\}$ 是连通图，其最小生成树 $T=(U,E_T)$，$E_T$ 是最小生成树中边的集合。</li><li>初始化：向空树 $T= (U, E_T)$ 中添加图 $G=(V, E)$ 的任一顶点 $u_0$，使 $U= \{u_0\}$ ，$E_T=\varnothing $。</li><li>循环（重复下列操作直至 $U=V$）：从图 $G$ 中选择满足 $\{(u, v)|u \in U, v \in V-U\}$ 且具有最小权值的边 $(u,v)$ 加入树 $T$，置 $U=U\cup \{ v\}$，$E_T= E_T \cup \{(u,v) \}$。</li></ul><p>Prim 算法的时间复杂度为 $O(|V|^2)$，不依赖于 $|E|$，因此它适用于求解<font color="#faa755">边稠密</font>的图的最小生成树。虽然采用其他方法能改进 Prim 算法的时间复杂度，但增加了实现的复杂性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ program to implement Prim&#x27;s Algorithm</span></span><br><span class="line"><span class="comment">// https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/prim.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PII = std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">const</span> std::vector&lt;std::vector&lt;PII&gt; &gt; &amp;graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// priority queue to maintain edges with respect to weights</span></span><br><span class="line">    std::priority_queue&lt;PII, std::vector&lt;PII&gt;, std::greater&lt;PII&gt; &gt; Q;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="keyword">bool</span>&gt; <span class="title">marked</span><span class="params">(graph.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> minimum_cost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, x));</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// Select the edge with minimum weight</span></span><br><span class="line">        PII p = Q.<span class="built_in">top</span>();</span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        x = p.second;</span><br><span class="line">        <span class="comment">// Checking for cycle</span></span><br><span class="line">        <span class="keyword">if</span> (marked[x] == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minimum_cost += p.first;</span><br><span class="line">        marked[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> PII &amp;neighbor : graph[x]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = neighbor.second;</span><br><span class="line">            <span class="keyword">if</span> (marked[y] == <span class="literal">false</span>) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum_cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nodes = <span class="number">0</span>, edges = <span class="number">0</span>;</span><br><span class="line">    std::cin &gt;&gt; nodes &gt;&gt; edges;  <span class="comment">// number of nodes &amp; edges in graph</span></span><br><span class="line">    <span class="keyword">if</span> (nodes == <span class="number">0</span> || edges == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;PII&gt; &gt; <span class="built_in">graph</span>(nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Edges with their nodes &amp; weight</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, weight = <span class="number">0</span>;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; weight;</span><br><span class="line">        graph[x].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(weight, y));</span><br><span class="line">        graph[y].<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(weight, x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Selecting 1 as the starting node</span></span><br><span class="line">    <span class="keyword">int</span> minimum_cost = <span class="built_in">prim</span>(<span class="number">1</span>, graph);</span><br><span class="line">    std::cout &lt;&lt; minimum_cost &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">// 0 1 6</span></span><br><span class="line">    <span class="comment">// 0 2 5</span></span><br><span class="line">    <span class="comment">// 0 3 1</span></span><br><span class="line">    <span class="comment">// 1 3 5</span></span><br><span class="line">    <span class="comment">// 1 4 3</span></span><br><span class="line">    <span class="comment">// 2 3 4</span></span><br><span class="line">    <span class="comment">// 4 5 6</span></span><br><span class="line">    <span class="comment">// 3 5 4</span></span><br><span class="line">    <span class="comment">// 2 5 2</span></span><br><span class="line">    <span class="comment">// 3 4 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kruskal-算法"><a class="header-anchor" href="#Kruskal-算法"></a>Kruskal 算法</h4><p>与 Prim 算法从顶点开始扩展最小生成树不同，Kruskal （克鲁斯卡尔）算法是一种按权值的递增次序选择合适的边来构造最小生成树的方法。</p><p>Kruskal 算法构造最小生成树的过程如下图所示。初始时为只有 $n$ 个顶点而无边的非连通图 $T= \{V, \{\}\}$，每个顶点自成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在 $T$ 中不同的连通分量上，则将此边加入 $T$ ，否则舍弃此边而选择下一条权值最小的边。以此类推，直至 $T$ 中所有顶点都在一个连通<br>分量上。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Kruskal%E7%AE%97%E6%B3%95%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Kruskal算法构造最小生成树的过程"></p><p>Kruskal算法的步骤如下：</p><ul><li>假设 $G=(V, E)$ 是连通图，其最小生成树 $T=(U, E_T)$。</li><li>初始化：$U=V$，$E_T=\varnothing$。即每个顶点构成一棵独立的树，$T$ 此时是一个仅含 $|V|$ 个顶点的森林。</li><li>循环（重复下列操作直至 $T$ 是一棵树）：按 $G$ 的边的权值递增顺序依次从 $E- E_T$ 中选择一条边，若这条边加入 $T$ 后不构成回路，则将其加入 $E_T$，否则舍弃，直到 $E_T$ 中含有 $n-1$ 条边。</li></ul><p>根据图的相关性质，若一条边连接了两棵不同树中的顶点，则对这两棵树来说，它必定是连通的，将这条边加入森林中，完成两棵树的合并，直到整个森林合并成一棵树。</p><p>通常在 Kruskal 算法中，采用堆来存放边的集合，因此每次选择最小权值的边只需 $O(\log|E|)$ 的时间。此外，由于生成树 $T$ 中的所有边可视为一个等价类，因此每次添加新的边的过程类似于求解等价类的过程，由此可以采用并查集的数据结构来描述 $T$，从而构造 $T$ 的时间复杂度为 $O(|E|\log_{2}{|E|})$ 。因此，Kruskal 算法适合于<font color="#faa755">边稀疏而顶点较多</font>的图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/kruskal.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;boost/multiprecision/cpp_int.hpp&gt;</span></span><br><span class="line"><span class="comment">// using namespace boost::multiprecision;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mx = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">int64_t</span>;</span><br><span class="line"></span><br><span class="line">std::array&lt;ll, mx&gt; parent;</span><br><span class="line">ll node, edge;</span><br><span class="line">std::vector&lt;std::pair&lt;ll, std::pair&lt;ll, ll&gt;&gt;&gt; edges;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node + edge; ++i) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent[i] != i) &#123;</span><br><span class="line">        parent[i] = parent[parent[i]];</span><br><span class="line">        i = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root_x = <span class="built_in">root</span>(x);  <span class="comment">// Disjoint set union by rank</span></span><br><span class="line">    <span class="keyword">int</span> root_y = <span class="built_in">root</span>(y);</span><br><span class="line">    parent[root_x] = root_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ll mincost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; ++i) &#123;</span><br><span class="line">        ll x = edges[i].second.first;</span><br><span class="line">        ll y = edges[i].second.second;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">root</span>(x) != <span class="built_in">root</span>(y)) &#123;</span><br><span class="line">            mincost += edges[i].first;</span><br><span class="line">            <span class="built_in">join</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = <span class="number">0</span>, to = <span class="number">0</span>, cost = <span class="number">0</span>, totalcost = <span class="number">0</span>;</span><br><span class="line">        std::cin &gt;&gt; node &gt;&gt; edge;  <span class="comment">// Enter the nodes and edges</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="number">0</span> &amp;&amp; edge == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// Enter 0 0 to break out</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">initial</span>();  <span class="comment">// Initialise the parent array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge; ++i) &#123;</span><br><span class="line">            std::cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;</span><br><span class="line">            edges.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(cost, std::<span class="built_in">make_pair</span>(from, to)));</span><br><span class="line">            totalcost += cost;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">kruskal</span>() &lt;&lt; std::endl;</span><br><span class="line">        edges.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径"><a class="header-anchor" href="#最短路径"></a>最短路径</h3><p>广度优先搜索查找最短路径只是对无权图而言的。当图是带权图时，把从一个顶点 $v_0$ 到图中其余任意一个顶点 $v_i$ 的一条路径（可能不止一条）所经过边上的权值之和，定义为该路径的带权路径长度，把带权路径长度最短的那条路径称为最短路径。</p><p>求解最短路径的算法通常都依赖于一种性质，即两点之间的最短路径也包含了路径上其他顶点间的最短路径。带权有向图 $G$ 的最短路径问题一般可分为两类：一是单源最短路径，即求图中某一顶点到其他各顶点的最短路径，可通过经典的 Dijkstra （迪杰斯特拉）算法求解；二是求每对顶点间的最短路径，可通过 Floyd（弗洛伊德）算法来求解。</p><h4 id="BFS-算法求无权图的单源最短路径"><a class="header-anchor" href="#BFS-算法求无权图的单源最短路径"></a>BFS 算法求无权图的单源最短路径</h4><p>无权图可以视为一种特殊的带权图，只是每条边的权值都为 1。</p><p>若图 $G=(V, E)$ 为非带权图，定义从顶点 $u$ 到顶点 $v$ 的最短路径 $d(u, v)$ 为从 $u$ 到 $v$ 的任何路径中最少的边数；若从 $u$ 到 $v$ 没有通路，则 $d(u,v)= \infty$ 。</p><p>使用 BFS，我们可以求解一个满足上述定义的非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。</p><p>BFS 算法求解单源最短路径问题的伪算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// d[i] 表示从 u 到 i 结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;</span><br><span class="line">        d[i] = INT_MAX;  <span class="comment">// 初始化路径长度</span></span><br><span class="line">        path[i] = <span class="number">-1</span>;    <span class="comment">// 最短路径从哪个顶点过来</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[u] = <span class="number">0</span>;</span><br><span class="line">    visited[u] = <span class="literal">true</span>;     <span class="comment">// 标记已经访问过</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, u);         <span class="comment">// 加入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;  <span class="comment">// BFS 算法主过程</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, u);     <span class="comment">// 顶点 u 出队列</span></span><br><span class="line">        <span class="keyword">for</span> (w = <span class="built_in">FirstNeighbor</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, u, w)) &#123;</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;      <span class="comment">// w 为 u 的尚未访问的邻接顶点</span></span><br><span class="line">                d[w] = d[u] + <span class="number">1</span>;    <span class="comment">// 路径的长度加 1</span></span><br><span class="line">                path[w] = u;        <span class="comment">// 最短路径应从 u 到 w</span></span><br><span class="line">                visited[w] = <span class="literal">true</span>;  <span class="comment">// 对 w 做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, w);      <span class="comment">// 顶点 w 入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dijkstra-算法求单源最短路径问题"><a class="header-anchor" href="#Dijkstra-算法求单源最短路径问题"></a>Dijkstra 算法求单源最短路径问题</h4><p>Dijkstra 算法设置一个集合 $S$ 记录已求得的最短路径的顶点，初始时把源点 $v_0$ 放入 $S$ ，集合 $S$ 每并入一个新顶点 $v_i$，都要修改源点 $v_0$ 到集合 $V-S$ 中顶点当前的最短路径长度值。</p><p>在构造的过程中还设置了几个辅助数组：</p><ul><li><code>dist[]</code> ：记录从源点 $v_0$ 到其他各顶点当前的最短路径长度，它的初态为：若从 $v_0$ 到 $v_i$ 有弧，则 <code>dist[i]</code> 为弧上的权值；否则置 <code>dist[i]</code> 为 $\infty$。</li><li><code>path[]</code> ：<code>path[i]</code> 表示从源点到顶点 $i$ 之间的最短路径的前驱结点。在算法结束时，可根据其值追溯得到源点 $v_0$ 到顶点 $v_i$ 的最短路径。</li><li><code>final[]</code>：标记各顶点是否已找到最短路径。</li></ul><p>假设从顶点 0 出发，即 $v_0=0$ ，集合 $S$ 最初只包含顶点 0，邻接矩阵 <code>arcs</code> 表示带权有向图，<code>arcs[i][j]</code> 表示有向边 <code>&lt;i, j&gt;</code> 的权值，若不存在有向边 <code>&lt;i,j&gt;</code>, 则 <code>arcs[i][j]</code> 为 $\infty$。</p><p>Dijkstra 算法的步骤如下（不考虑对 <code>path[]</code> 的操作）：</p><ol><li>初始化：集合 $S$ 初始为 $\{0\}$，<code>dist[]</code> 的初始值 <code>dist[i]=arcs[0][i]</code>，$i=1,2,\cdots ,n-1$。</li><li>从顶点集合 $V-S$ 中选出 $v_j$，满足 <code>dist[j]</code>$=\mathrm{Min}$  $\{ $ <code>dist[i]</code> $| v_i \in V-S \}$，$v_j$ 就是当前求得的一条从 $v_0$ 出发的最短路径的终点，令 $S=S\cup \{j\}$。</li><li>修改从 $v_0$ 出发到集合 $V- S$ 上任一顶点 $v_k$ 可达的最短路径长度：若 <code>dist[j]</code>$+$<code>arcs[j][k]</code>$&lt;$<code>dist[k]</code>，则更新<code>dist[k]</code>$=$<code>dist[j]</code>$+$<code>arcs[j][k]</code>。</li><li>重复2和3操作共 $n-1$ 次，直到所有的顶点都包含在 $S$ 中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/Dijkatra%E7%AE%97%E6%B3%95.png" alt="Dijkatra算法"></p><p>算法执行过程的说明如下：</p><ul><li>初始化：集合 $S$ 初始为 $\{v_1\}$，$v_1$可达以和 $v_2$，$v_5$ 不可达 $v_3$ 和 $v_4$，因此 <code>dist[]</code> 数组各元素的初值依次设置为<code>dist[2]=10</code>，<code>dist[3]=MAX_INF</code>，<code>dist[4]=MAX_INF</code>，<code>dist[5]=5</code>。</li><li>第一轮：选出最小值 <code>dist[5]</code>，将顶点 $v_5$ 并入集合 $S$ ，即此时已找到 $v_1$ 到 $v_5$ 的最短路径。当 $v_5$ 加入 $S$ 后，从  $v_1$  到集合 $V-S$ 中可达顶点的最短路径长度可能会产生变化。因此需要更新 <code>dist[]</code> 数组。 $v_5$ 可达 $v_2$ ，因  $v_1$→ $v_5$→$v_2$ 的距离 8 比 <code>dist[2]=10</code> 小，更新 <code>dist[2]=8</code>； $v_5$ 可达 $v_3$， $v_1$→ $v_5$ → $v_3$ 的距离 14，更新 <code>dist[3]=14</code>； $v_5$ 可达$v_4$， $v_1$→$v_5$→$v_4$ 的距离 7，更新 <code>dist[4]=7</code>。</li><li>第二轮：选出最小值 <code>dist[4]</code>，将顶点 $v_4$ 并入集合 $S$。继续更新 <code>dist[]</code> 数组。$v_4$ 不可达$v_2$，<code>dist[2]</code> 不变；$v_4$ 可达$v_3$，$v_1$→$v_5$→$v_4$→$v_3$ 的距离 13 比 <code>dist[3]</code> 小，故更新 <code>dist[3]=13</code>。</li><li>第三轮：选出最小值 <code>dist[2]</code>，将顶点 $v_2$ 并入集合 $S$。继续更新 <code>dist[]</code> 数组。$v_2$ 可达 $v_3$，$v_1$→$v_5$→$v_2$→$v_3$ 的距离 9比 <code>dist[3]</code> 小，更新 <code>dist[3]=9</code>。</li><li>第四轮：选出唯一最小值 <code>dist[3]</code>，将顶点 $v_3$ 并入集合 $S$，此时全部顶点都已包含在 $S$ 中。</li></ul><p>显然，Dijkstra 算法也是基于贪心策略的。</p><p>使用邻接矩阵表示时，时间复杂度为 $O(|V|^2)$。使用带权的邻接表表示时，虽然修改 <code>dist[]</code> 的时间可以减少，但由于在<code>dist[]</code> 中选择最小分量的时间不变，时间复杂度仍为 $O(|V|^2)$。</p><p>人们可能只希望找到从源点到某个特定顶点的最短路径，但这个问题和求解源点到其他所有顶点的最短路径一样复杂，时间复杂度也为 $O(|V|^2)$。</p><p>值得注意的是，边上带有负权值时，Dijkstra算法并不适用。若允许边上带有负权值，则在与 $S$ （已求得最短路径的顶点集，归入 $S$ 内的结点的最短路径不再变更）内某点（记为a）以负边相连的点（记为b）确定其最短路径时，其最短路径长度加上这条负边的权值结果可能小于 a 原先确定的最短路径长度，而此时 a在 Dijkstra 算法下是无法更新的。</p><h4 id="Floyd-算法求各顶点之间最短路径问题"><a class="header-anchor" href="#Floyd-算法求各顶点之间最短路径问题"></a>Floyd 算法求各顶点之间最短路径问题</h4><p>求所有顶点之间的最短路径问题描述如下：已知一个各边权值均大于 0 的带权有向图，对任意两个顶点 $v_i\ne v_j$，要求求出 $v_i$ 与 $v_j$ 之间的最短路径和最短路径长度。</p><p>Floyd 算法的基本思想是：递推产生一个 $n$ 阶方阵序列 $ A^{(-1)}\ ,A^{(0)},\cdots ,A^{(k)},\cdots A^{(n-1)}$，其中 $A^{(k)}[i][j]$ 表示从顶点 $v_i$ 到顶点 $v_j$ 的路径长度，$k$ 表示绕行第 $k$ 个顶点的运算步骤。</p><p>初始时，对于任意两个顶点 $v_i$ 和 $v_j$ ，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以 $ \infty$ 作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点 $k \ (k=0, 1,\cdots ,n-1)$ 作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Structure for storing a graph</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> vertexNum;</span><br><span class="line">    <span class="keyword">int</span> **edges;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs a graph with V vertices and E edges</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(struct Graph *G, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;vertexNum = V;</span><br><span class="line">    G-&gt;edges = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G-&gt;edges[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(V * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) G-&gt;edges[i][j] = INT_MAX;</span><br><span class="line">        G-&gt;edges[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adds the given edge to the graph</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(struct Graph *G, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    G-&gt;edges[src][dst] = weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility function to print distances</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> dist[], <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nThe Distance matrix for Floyd - Warshall\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[i * V + j] != INT_MAX)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, dist[i * V + j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;INF\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main function that finds the shortest path from a vertex</span></span><br><span class="line"><span class="comment">// to all other vertices using Floyd-Warshall Algorithm.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloydWarshall</span><span class="params">(struct Graph *graph)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V = graph-&gt;vertexNum;</span><br><span class="line">    <span class="keyword">int</span> dist[V][V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialise distance array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) dist[i][j] = graph-&gt;edges[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate distances</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; V; k++)</span><br><span class="line">        <span class="comment">// Choose an intermediate vertex</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">            <span class="comment">// Choose a source vertex for given intermediate</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++)</span><br><span class="line">                <span class="comment">// Choose a destination vertex for above source vertex</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp;</span><br><span class="line">                    dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                    <span class="comment">// If the distance through intermediate vertex is less than</span></span><br><span class="line">                    <span class="comment">// direct edge then update value in distance array</span></span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert 2d array to 1d array for print</span></span><br><span class="line">    <span class="keyword">int</span> dist1d[V * V];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; V; j++) dist1d[i * V + j] = dist[i][j];</span><br><span class="line"></span><br><span class="line">    print(dist1d, V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver Function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, E;</span><br><span class="line">    <span class="keyword">int</span> src, dst, weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> <span class="title">G</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter number of vertices: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter number of edges: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;E);</span><br><span class="line">    createGraph(&amp;G, V);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; E; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nEdge %d \nEnter source: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;src);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter destination: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;dst);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter weight: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;weight);</span><br><span class="line">        addEdge(&amp;G, src, dst, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    FloydWarshall(&amp;G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Floyd 算法的时间复杂度为 $O(|V|^3)$ 。不过由于其代码很紧凑，且并不包含其他复杂的数据结构，因此隐含的常数系数是很小的，即使对于中等规模的输入来说，它仍然是相当有效的。空间复杂度：$O(|V|^2)$</p><p>Floyd 算法允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd 算法同样适用于带权无向图，因为带权无向图可视为权值相同往返二重边的有向图。</p><p>也可以用单源最短路径算法来解决每对顶点之间的最短路径问题。轮流将每个顶点作为源点，并且在所有边权值均非负时，运行一次 Dijkstra 算法，其时间复杂度为 $O(|V|^3) $ 。</p><h3 id="有向无环图描述表达式"><a class="header-anchor" href="#有向无环图描述表达式"></a>有向无环图描述表达式</h3><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称 DAG 图。</p><p>有向无环图是描述含有公共子式的表达式的有效工具。例如表达式：$$((a+b)\ast (b\ast (c+d)&gt;+(c +d)\ast e)\ast ((c+d)\ast e)$$可以用二叉树来表示。仔细观察该表达式，可发现有一些相同的子表达式 $(c + d)$ 和 $(c + d)\ast e$ ，而在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%8F%E8%BF%B0.png" alt="表达式描述"></p><h3 id="拓扑排序"><a class="header-anchor" href="#拓扑排序"></a>拓扑排序</h3><p>AOV 网：若用 DAG 图表示一个工程，其顶点表示活动，用有向边 $\langle V_i,V_j\rangle $ 表示活动 $V_i$；必须先于活动 $V_j$；进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为 AOV 网。在 AOV 网中，活动 $V_i$ 是活动 $V_j$ 的直接前驱，活动 $V_j$ 是活动 $V_i$ 的直接后继，这种前驱和后继关系具有传递性，且任何活动 $V_i$ 不能以它自己作为自己的前驱或后继。</p><p>拓扑排序：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：</p><ul><li>每个顶点出现且只出现一次。</li><li>若顶点 A 在序列中排在顶点 B 的前面，则在图中不存在从顶点 B 到顶点 A 的路径。</li></ul><p>或定义为：拓扑排序是对有向无环图的顶点的一种排序， 它使得若存在一条从顶点 A 到顶点 B 的路径，则在排序中顶点 B 出现在顶点 A 的后面。每个 AOV 网都有一个或多个拓扑排序序列。</p><p>对一个 AOV 网进行拓扑排序的算法有很多，下面介绍比较常用的一种方法的步骤：</p><ol><li>AOV 网中选择一个没有前驱的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复步骤 1 和 2 直到当前的 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">    InitStack(S);  <span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            Push(S, i);  <span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;           <span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(S)) &#123;    <span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        Pop(S, i);           <span class="comment">//栈顶元素出栈</span></span><br><span class="line">        print[count++] = i;  <span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span> (p = G.vertices[i].firstarc; pip = p-&gt;nextarc) &#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度减1,并且将入度减为0的顶点压入栈s</span></span><br><span class="line">            v = p-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span> (!(--indegree[v])) &#123;</span><br><span class="line">                Push(S, v);  <span class="comment">//入度为0， 则入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; G.vexnum) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//拓扑排序成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于输出每个顶点的同时还要删除以它为起点的边，故拓扑排序的时间复杂度为 $O(|V|+|E|)$。此外，利用深度优先遍历也可实现拓扑排序。</p><p>TODO 深度优先遍历代码实现拓扑排序</p><p>对一个 AOV 网，如果采用下列步骤进行排序，则称之为逆拓扑排序：</p><ol><li>从 AOV 网中选择一个没有后继（出度为 0 ）的顶点并输出。</li><li>从网中删除该顶点和所有以它为终点的有向边。</li><li>重复步骤 1 和 2 直到当前的 AOV 网为空。</li></ol><p>用拓扑排序算法处理 AOV 网时，应注意以下问题：</p><ol><li>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续。</li><li>若一个顶点有多个直接后继，则拓扑排序的结果通常不唯一；但若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的。</li><li>由于 AOV 网中各顶点的地位平等，每个顶点编号是人为的，因此可以按拓扑排序的结果重新编号，生成 AOV 网的新的邻接存储矩阵，这种邻接矩阵可以是三角矩阵；但对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立。</li></ol><p>TODO 逆拓扑排序DFS算法实现及其对环路的判断</p><h3 id="关键路径"><a class="header-anchor" href="#关键路径"></a>关键路径</h3><p>在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销（如完成活动所需的时间），称之为用边表示活动的网络，简称 AOE 网。AOE 网和 AOV 网都是有向无环图，不同之处在于它们的边和顶点所代表的含义是不同的，AOE 网中的边有权值；而 AOV 网中的边无权值，仅表示顶点之间的前后关系。AOE 网具有以下两个性质：</p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始；</li><li>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生。</li></ol><p>在 AOE 网中仅有一个入度为 0 的顶点，称为开始顶点（源点），它表示整个工程的开始；网中也仅存在一个出度为 0 的顶点，称为结束顶点（汇点），它表示整个工程的结束。</p><p>在 AOE 网中，有些活动是可以并行进行的。从源点到汇点的有向路径可能有多条，并且这些路径长度可能不同。完成不同路径上的活动所需的时间虽然不同，但是只有所有路径上的活动都已完成，整个工程才能算结束。因此，从源点到汇点的所有路径中，具有最大路径长度的路径称为<font color="#ea66a6">关键路径</font>，而把关键路径上的活动称为关键活动。</p><p>完成整个工程的最短时间就是关键路径的长度，即关键路径上各活动花费开销的总和。这是因为关键活动影响了整个工程的时间，即若关键活动不能按时完成，则整个工程的完成时间就会延长。因此，只要找到了关键活动，就找到了关键路径，也就可以得出最短完成时间。下面给出在寻找关键活动时所用到的几个参量的定义。</p><h4 id="事件-v-k-的最早发生时间-ve-k"><a class="header-anchor" href="#事件-v-k-的最早发生时间-ve-k"></a>事件 $v_k$ 的最早发生时间 $ve(k)$</h4><p>它是指从源点 $v_1$ 到顶点 $v_k$ 的最长路径长度。事件 $v_k$ 的最早发生时间决定了所有从 $v_k$ 开始的活动能够开工的最早时间。</p><h4 id="活动-a-i-的最早开始时间-e-i"><a class="header-anchor" href="#活动-a-i-的最早开始时间-e-i"></a>活动 $a_i$ 的最早开始时间 $e(i)$</h4><p>它是指该活动弧的起点所表示的事件的最早发生时间。若边 $\langle v_k,v_j\rangle $  表示活动 $a_i$ ，则有 $e(i)=ve(k)$)。</p><h4 id="事件-v-k-的最迟发生时间-vl-k"><a class="header-anchor" href="#事件-v-k-的最迟发生时间-vl-k"></a>事件 $v_k$ 的最迟发生时间 $vl(k)$</h4><p>它是指在不推迟整个工程完成的前提下，即保证它的后继事件 $v_j$ 在其最迟发生时间 $vl(j)$ 能够发生时，该事件最迟必须发生的时间。</p><h4 id="活动-a-i-的最迟开始时间-l-i"><a class="header-anchor" href="#活动-a-i-的最迟开始时间-l-i"></a>活动 $a_i$ 的最迟开始时间 $l(i)$</h4><p>它是指该活动弧的终点所表示的事件的最迟发生时间与该活动所需时间之差。若边 $\langle v_k,v_j\rangle $  表示活动 $a_i$ ，则有 $l(i)=vl(j)-\mathrm{Weight} (v_k,v_j)$)。</p><h4 id="活动-a-i-的时间余量"><a class="header-anchor" href="#活动-a-i-的时间余量"></a>活动 $a_i$ 的时间余量</h4><p>一个活动 $a_i$ 的最迟开始时间 $l(i)$和其最早开始时间 $e(i)$的差额 $d(i)= l(i)- e(i)$，它是指该活动完成的时间余量，即在不增加完成整个工程所需总时间的情况下，活动 $a_i$ 可以拖延的时间。若一个活动的时间余量为零，则说明该活动必须要如期完成，否则就会拖延整个工程的进度，所以称 $l(i)- e(i)= 0$ 即 $l(i)= e(i)$ 的活动 $a_i$ 是关键活动。</p><h4 id="求关键路径的步骤"><a class="header-anchor" href="#求关键路径的步骤"></a>求关键路径的步骤</h4><p>求关键路径的算法步骤如下：</p><ol><li>求所有事件的最早发生时间 $ve()$，从源点出发，令 $ve(源点)=0$，按拓扑有序求其余顶点的最早发生时间 $ve()$</li><li>求所有事件的最迟发生时间 $vl( )$，从汇点出发，令 $vl(汇点)= ve(汇点)$， 按逆拓扑有序求其余顶点的最迟发生时间 $vl()$</li><li>求所有活动的最早发生时间 $e()$，根据各顶点的 $ve()$ 值求所有弧的最早开始时间 $e()$</li><li>求所有活动的最迟发生时间 $l( )$，根据各顶点的 $vi()$ 值求所有孤的最迟开始时间的 $l()$</li><li>求所有活动的时间余量 $d( )$，求 AOE 网中所有活动的差额 $d()$，找出所有 $d()=0$ 的活动构成关键路径。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/%E6%B1%82%E8%A7%A3%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="求解关键路径的过程"></p><p>上图所示为求解关键路径的过程，简单说明如下：</p><ol><li>求 $ve()$ ：初始 $ve(1)=0$，在拓扑排序输出顶点过程中，求得 $ve(2)=3$，$ve(3)=2$，$ve(4)=max\{ve(2)+2,ve(3)+4\}=max\{5,6\}=6$，$ve(5)=6$，$ve(6)=max\{ve(5)+1,ve(4)+2,ve(3)+3\}=max\{7,8,5\}=8$。</li><li>求 $vl()$：初始 $vl(6)=8$，在逆拓扑排序出栈过程中，求得 $vl(5)=7$，$vl(4)=6$，$vl(3)=min\{vl(4)-4,vl(6)-3\}=min\{2,5\}=2$，$vl(2)=min\{vl(5)-3,vl(4)-2\}=min\{4,4\}=4$，$vl(1)=0$</li><li>弧的最早开始时间 $e()$ 等于该弧的起点的顶点 $ve()$，求得结果如上表所示</li><li>弧的最迟开始时间 $l(i)$ 等于该弧的终点的顶点 $vl()$ 减去该弧持续的时间，求得结果如上表所示</li><li>根据 $l(i)-e(i)=0$ 的关键活动，得到的关键路径为 $(v_1,v_3,v_4,v_6)$</li></ol><p>对于关键路径，需要注意以下几点：</p><ol><li>关键路径上的所有活动都是关键活动，它是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期。</li><li>但也不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动。</li><li>网中的关键路径并不唯一，且对于有几条关键路径的网，只提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</li></ol>]]></content>
    
    
    <summary type="html">图</summary>
    
    
    
    <category term="数据结构" scheme="https://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树与二叉树</title>
    <link href="https://halo123.top/2021/05/07/DataStructure/E_Tree/"/>
    <id>https://halo123.top/2021/05/07/DataStructure/E_Tree/</id>
    <published>2021-05-07T11:30:51.000Z</published>
    <updated>2021-05-14T11:53:33.321Z</updated>
    
    <content type="html"><![CDATA[<p>【考纲内容】</p><ol><li>树的基本概念</li><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol><p>【知识框架】</p><p>TODO 完成树与二叉树章节的知识框架</p><p>【复习提示】</p><p>本章内容多以选择题的形式考查，但也会出涉及树遍历相关的算法题。树和二叉树的性质、遍历操作、转换、存储结构和操作特性等，满二叉树、完全二叉树、线索二叉树、哈夫曼树的定义和性质，二叉排序树和二叉平衡树的性质和操作等，都是选择题必然会涉及的内容。</p><h2 id="树的基本概念"><a class="header-anchor" href="#树的基本概念"></a>树的基本概念</h2><h3 id="树的定义"><a class="header-anchor" href="#树的定义"></a>树的定义</h3><p>树是 $n \ (n\ge 0)$ 个节点的有限集。当 $n=0$ 时，称为空树。在任意一颗非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当 $n&gt;1$ 时，其余节点可分为 $m\ (m&gt;0)$ 个互不相交的有限集 $T_1,T_2,\dots ,T_m$，其中每个集合本身又是一棵树，并称为根的子树。</li></ol><p>显然，树的定义是递归的，即在树的定义中又用到了其自身，树是一种递归的数据结构。树作为一种逻辑结构，同时也是一种分层结构，具有以下两个特点：</p><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li></ol><p>树适合于表示具有层次结构的数据。树中的某个结点（除根结点外）最多只和上一层的一个结点（即其父结点）有直接关系，根结点没有直接上层结点，因此在 $n$ 个结点的树中有 $n-1$ 条边。而树中每个结点与其下一层的零个或多个结点（即其子女结点）有直接关系。</p><h3 id="基本术语"><a class="header-anchor" href="#基本术语"></a>基本术语</h3><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E6%A0%91%E5%BD%A2%E8%A1%A8%E7%A4%BA.png" alt="树的树形表示"></p><ul><li>考虑结点 K 。根 A 到结点 K 的唯一路径上的任意结点，称为结点 K 的<font color="#ea66a6">祖先</font>。如结点 B 是结点 K 的祖先，而结点 K 是结点 B 的<font color="#ea66a6">子孙</font>。路径上最接近结点 K 的结点 E 称为 K 的<font color="#ea66a6">双亲</font>，而 K 为结点 E 的<font color="#ea66a6">孩子</font>。根 A 是树中唯一没有双亲的结点。有相同双亲的结点称为<font color="#ea66a6">兄弟</font>，如结点 K 和结点 L 有相同的双亲 E，即 K 和 L 为兄弟。</li><li>树中一个结点的孩子个数称为该<font color="#ea66a6">结点的度</font>，树中结点的最大度数称为树的度。如结点 B 的度为 2，结点 D 的度为 3，树的度为 3。</li><li>度大于 0 的结点称为<font color="#ea66a6">分支结点</font>（又称非终端结点）；度为 0 （没有子女结点）的结点称为<font color="#ea66a6">叶子结点</font>（又称终端结点）。在分支结点中，每个结点的分支数就是该结点的度。</li><li><font color="#ea66a6">结点的层次</font>从树根开始定义，根结点为第 1 层，它的子结点为第 2 层，以此类推。双亲在同一层的结点互为<font color="#ea66a6">堂兄弟</font>，图中结点 G 与 E，F，H，I，J 互为堂兄弟。</li><li><font color="#ea66a6">结点的深度</font>是从根结点开始自顶向下逐层累加的。</li><li><font color="#ea66a6">结点的高度</font>是从叶结点开始自底向上逐层累加的。</li><li><font color="#ea66a6">树的高度</font>（或深度）是树中结点的最大层数。图中树的高度为4。</li><li>有序树和无序树。树中结点的各子树从左到右是有次序的，不能互换，称该树为<font color="#ea66a6">有序树</font>，否则称为<font color="#ea66a6">无序树</font>。假设图为有序树，若将子结点位置互换，则变成一棵不同的树。</li><li>路径和路径长度。树中两个结点之间的<font color="#ea66a6">路径</font>是由这两个结点之间所经过的结点序列构成的，而<font color="#ea66a6">路径长度</font>是路径上所经过的边的个数。注意：由于树中的分支是有向的，即从双亲指向孩子，所以树中的路径是从上向下的，同一双亲的两个孩子之间不存在路径。</li><li><font color="#ea66a6">森林</font>是 $m\  (m \ge 0)$ 棵互不相交的树的集合。森林的概念与树的概念十分相近，因为只要把树的根结点删去就成了森林。反之，只要给 $m$ 棵独立的树加上一个结点，并把这 $m$ 棵树作为该结点的子树，则森林就变成了树。</li></ul><p>度为 $m$ 的树与 $m$ 叉树：前者表示树中各节点最少存在一个最大为 $m$ 度的结点，而 $m$  叉树表示每个结点最多只能有 $m$ 个孩子的树</p><h3 id="树的性质"><a class="header-anchor" href="#树的性质"></a>树的性质</h3><p>树具有如下最基本的性质：</p><ol><li><p>树中的结点数等于所有结点的度数加 1 。</p></li><li><p>度为 $m$ 的树中第 $i$ 层上至多有 $m^{i-1}$ 个结点 $(i\ge 1)$。</p></li><li><p>高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点。</p></li><li><p>具有 $n$ 个结点的 $m$ 叉树的最小高度为 $\left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p></li></ol><h2 id="二叉树的概念"><a class="header-anchor" href="#二叉树的概念"></a>二叉树的概念</h2><h3 id="二叉树的定义及其主要特性"><a class="header-anchor" href="#二叉树的定义及其主要特性"></a>二叉树的定义及其主要特性</h3><h4 id="二叉树的定义"><a class="header-anchor" href="#二叉树的定义"></a>二叉树的定义</h4><p>二叉树是另一种树形结构，其特点是每个结点至多只有两棵子树（即二叉树中不存在度大于 2 的结点），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>与树相似，二叉树也以递归的形式定义。二叉树是 $n\ (n\ge 0)$个结点的有限集合：</p><ol><li>或者为空二叉树，即 $n=0$ 。</li><li>或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。</li></ol><p>二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一颗子树，也要区分它是左子树还是右子树。</p><p>二叉树与度为 2 的有序树的区别：</p><ol><li>度为 2 的树至少有 3 个结点，而二叉树可以为空。</li><li>度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。</li></ol><h4 id="几个特殊的二叉树"><a class="header-anchor" href="#几个特殊的二叉树"></a>几个特殊的二叉树</h4><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%87%A0%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="几个特殊的二叉树"></p><p><strong>满二叉树</strong>。一棵高度为 $h$，且含有 $2^h-1$ 个结点的二叉树称为满二叉树，即树中的每层都含有最多的结点。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为 2 （不存在度为 1 的结点）。可以对满二叉树按层序编号：约定编号从根结点（根结点编号为 1 ）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为 $i$ 的结点，若有双亲，则其双亲为 $\left \lfloor \frac{i}{2}  \right \rfloor$，若有左孩子，则左孩子为 $2i$ ；若有右孩子，则右孩子为 $2i+1$。</p><p><strong>完全二叉树</strong>。高度为 $h$、有 $n$ 个结点的二叉树，当且仅当其每个结点都与高度为 $h$ 的满二叉树中编号为 $1\sim n$ 的结点一一对应时，称为完全二叉树。就是对应相同高度的满二叉树缺失最下层最右边的一些连续叶子结点。其特点如下：</p><ol><li>若 $ i \le \left \lfloor \frac{n}{2}  \right \rfloor$，则结点 $i$ 为分支结点，否则为叶子结点。</li><li>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。</li><li>若有度为 1 的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。</li><li>按层序编号后，一旦出现某结点（编号为 $i$ ）为叶子结点或只有左孩子，则编号大于 $i$ 的结点均为叶子结点。</li><li>若 $n$ 为奇数，则每个分支结点都有左孩子和右孩子；若 $n$ 为偶数，则编号最大的分支结点（编号为 $\frac{n}{2}$ ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</li></ol><p><strong>二叉排序树</strong>。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上的所有结点的关键字均大于根结点的关键字；</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p><strong>平衡二叉树</strong>。树上任一结点的左子树和右子树的深度之差不超过 1 。</p><h4 id="二叉树的性质"><a class="header-anchor" href="#二叉树的性质"></a>二叉树的性质</h4><p>（1）<font color="#FF666">非空二叉树上的叶子结点数等于度为 2 的结点数加 1</font>，即 $n_{0}=n_{2}+1$ 。</p><p>证明：设度为 0，1 和 2 的结点个数分别为 $n_{0}$，$n_{1}$ 和 $n_{2}$，结点总数 $n=n_{0}+n_{1}+n_{2}$。再看二叉树中的分支树，除根结点外，其余结点都有一个分支进入，设 $B$ 为分支总数，则 $n=B+1$ 。由于这些分支是由度为 1 或 2 的结点射出的，所以又有 $B=n_{1}+2n_{2}$。于是得 $n_{0}+n_{1}+n_{2}=n_{1}+2n_{2}+1$ ，则 $n_{0}=n_{2}+1$。</p><p>拓展到任意一棵树，若结点数量为 $n$，则边的数量为 $n-1$。</p><p>（2）非空二叉树上第 $k$ 层上至多有 $2^{k-1}$ 个结点 （ $k \ge 1$ ），可扩至 m 叉树</p><p>（3）高度为 $h$ 的二叉树至多有 $2^h-1$ 个结点（ $h \ge 1$ ）。高度为 $h$ 的 $m$ 叉树至多有 $\frac{m^h-1}{m-1} $ 个结点，推出。</p><p>（4）具有 $n$ 个（$n&gt;0$）结点的完全二叉树的高度 $h$ 为 $\left \lceil \log_{2}{(n+1)}  \right \rceil $ 或  $\left \lfloor \log_{2}{n}  \right \rfloor +1$</p><p>证明：高度为 $h$ 的满二叉树共有 $2^h-1$ 个结点，高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，可得：$$2^{h-1}-1&lt;n\le 2^{h}-1$$ $$2^{h-1}&lt;n+1\le 2^{h}$$ $$h-1&lt;\log{2}{(n+1)} \le h$$ $$h=\left \lceil \log_{2}{(n+1)}  \right \rceil $$</p><p>高度为 $h-1$ 的满二叉树共有 $2^{h-1}-1$ 个结点，高为 $h$ 的完全二叉树至少有 $2^{h-1}$ 个结点，至多有 $2^{h}-1$ 个结点，可得：$$2^{h-1} \le n &lt; 2^{h}$$ $$h-1 \le \log{2}{n} &lt; h$$ $$h= \left \lfloor \log_{2}{n}  \right \rfloor +1$$</p><p>（5）对于完全二叉树，可以由的结点数 $n$ 推出度为 0、1 和 2 的结点个数为 $n_0$、$n_1$和 $n_2$。</p><ul><li>完全二叉树最多只有一个度为 1 1 的结点，即：$n_{1}=0或1$ ；</li><li>$n_{0}=n_{2}+1$，两边各加上 $n_2$ 可得： $n_0+n_2=2n_2+1$ 可推出 $n_0+n_2$ 一定为奇数；</li></ul><p>根据上两个推论得：</p><ul><li>若完全二叉树有 $2k$ （偶数）个结点，则必有 $n_1=1,\ n_0=k , \ n_2=k-1$</li><li>若完全二叉树有 $2k-1$ （奇数）个结点，则必有 $n_1=0,\ n_0=k , \ n_2=k-1$</li></ul><h3 id="二叉树的存储结构"><a class="header-anchor" href="#二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a class="header-anchor" href="#顺序存储结构"></a>顺序存储结构</h4><p>二叉树的顺序存储是指用一组地址连续的存储单元依次<wavy>自上而下</wavy>、<wavy>自左至右</wavy>存储完全二叉树上的结点元素，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中。（这种存储结构建议从数组下标 1 开始存储树中的结点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TreeNode t[MaxSize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MaxSize; i++) &#123;</span><br><span class="line">        t[i].isEmpty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</p><p>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为 $h$ 且只有 $h$ 个结点的单支树却需要占据近 $2^h-1$ 个存储单元。</p><h4 id="链式存储结构"><a class="header-anchor" href="#链式存储结构"></a>链式存储结构</h4><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点。在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含3个域：数据域 <code>data</code>、左指针域 <code>lchild</code> 和右指针域 <code>rchild</code>。$n$ 个节点的二叉链表共有 $n+1$ 个空链域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">    <span class="comment">// struct BiTNode *parent;  // 根据实际需求决定是否加父指针</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一棵空树</span></span><br><span class="line">    BiTree root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入根节点</span></span><br><span class="line">    root = (BiTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    root-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入新结点</span></span><br><span class="line">    BiTNode *p = (BiTNode *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BiTNode));</span><br><span class="line">    p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    p-&gt;lchild = <span class="literal">nullptr</span>;</span><br><span class="line">    p-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;lchild = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到指定结点的左右孩子结点十分容易，但如果要寻找父节点只能从根结点开始遍历寻找。可以在结构体中额外定义父节点指针（三叉链表）。</p><h2 id="二叉树的遍历和线索二叉树"><a class="header-anchor" href="#二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h2><h3 id="二叉树的遍历"><a class="header-anchor" href="#二叉树的遍历"></a>二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。</p><p>由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点 N、左子树 L​ 和右子树 R 的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）和后序（LRN）三种遍历算法，其中“序”指的是根结点在何时被访问。</p><h4 id="先序遍历"><a class="header-anchor" href="#先序遍历"></a>先序遍历</h4><p>先序遍历（ PreOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>访问根结点；</li><li>先序遍历左子树；</li><li>先序遍历右子树。</li></ol><p>对应的递归算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a class="header-anchor" href="#中序遍历"></a>中序遍历</h4><p>中序遍历（ InOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ul><li>中序遍历左子树；</li><li>访问根结点；</li><li>中序遍历右子树。</li></ul><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);            <span class="comment">// 访问根节点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a class="header-anchor" href="#后序遍历"></a>后序遍历</h4><p>后序遍历（ PostOrder ）的操作过程如下：</p><p>若二叉树为空，则什么也不做；否则，</p><ol><li>后序遍历左子树；</li><li>后序遍历右子树；</li><li>访问根结点。</li></ol><p>对应的递归算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);  <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);  <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);              <span class="comment">// 访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种遍历算法中，递归遍历左、右子树的顺序都是固定的，只是访问根结点的顺序不同。不管采用哪种遍历算法，每个结点都访问一次且仅访问一次，故时间复杂度都是 $O(n)$ 。在递归遍历中，递归工作栈的栈深恰好为树的深度，所以在最坏情况下，二叉树是有 $n$ 个结点且深度为 $n$ 的单支树，遍历算法的空间复杂度为 $O(n)$。</p><p>TODO 递归算法和非递归算法的转换</p><h4 id="层次遍历"><a class="header-anchor" href="#层次遍历"></a>层次遍历</h4><p>要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队；若它有右子树，则将右子树根结点入队。然后出队，访问出队结点…如此反复，直至队列为空。</p><p>二叉树的层次遍历算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InirQueue</span>(Q);  <span class="comment">// 初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, T);  <span class="comment">// 将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);  <span class="comment">// 对头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);       <span class="comment">// 访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);  <span class="comment">// 左孩子入队,入队指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);  <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="由遍历序列构造二又树"><a class="header-anchor" href="#由遍历序列构造二又树"></a>由遍历序列构造二又树</h4><p>若只给出一棵二叉树的前/中/后/层序遍历序列中的一种，不能唯一确定一棵二叉树。必须有中序遍历和其他任意一种遍历序列才能确定唯一一种二叉树。</p><p>先序序列和中序序列：在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。</p><p>类似，由二叉树的后序序列和中序序列，层序序列和中序序列也可以唯一地确定一棵二叉树。找到树的根节点，并根据<br>中序序列划分左右子树，再找至左右子树根节点。</p><h3 id="线索二叉树"><a class="header-anchor" href="#线索二叉树"></a>线索二叉树</h3><h4 id="线索二叉树的基本概念"><a class="header-anchor" href="#线索二叉树的基本概念"></a>线索二叉树的基本概念</h4><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列，使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继。</p><p>传统的二叉链表存储仅能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。前面提到，在含 $n$ 个结点的二叉树中，有 $n+1$ 个空指针。这是因为每个叶结点有 2 个空指针，每个度为 1 的结点有 1 个空指针，空指针总数为 $2n_{0} + n_1$ ，又 $n_{0}=n_{2}+ 1$，所以空指针总数为 $n_0+n_1+n_2+1=n+1$ 。由此设想能否利用这些空指针来存放指向其前驱或后继的指针？这样就可以像遍历单链表那样方便地遍历二叉树。引入线索二叉树正是为了加快查找结点前驱和后继的速度。</p><p>规定：若无左子树，令 <code>lchild</code> 指向其前驱结点；若无右子树，令 <code>rchild</code> 指向其后继结点。还需增加两个标志域（<code>ltag</code>、<code>rtag</code>）标识指针域是指向左（右）孩子还是指向前驱（后继）。当 tag 值等于 0 时，表示指针指向孩子，等于 1 时，表示指针指向线索。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="中序线索二叉树"></p><p>线索二叉树的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;  <span class="comment">// 左右线索标志，0指向孩子，1指向线索</span></span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br></pre></td></tr></table></figure><p>以这种结点结构构成的二叉链表作为二叉树的存储结构，称为<font color="#ea66a6">线索链表</font>，其中指向结点前驱和后继的指针称为<font color="#ea66a6">线索</font>。加上线索的二叉树称为<font color="#ea66a6">线索二叉树</font>。</p><h4 id="中序线索二叉树的构造"><a class="header-anchor" href="#中序线索二叉树的构造"></a>中序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);  <span class="comment">// 中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);             <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);  <span class="comment">// 中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T);  <span class="comment">// 中序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序线索二叉树的构造"><a class="header-anchor" href="#先序线索二叉树的构造"></a>先序线索二叉树的构造</h4><blockquote><p>当 <code>ltag == 0</code> 时，才能对左子树先序线索化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);                  <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>) &#123;        <span class="comment">// 注意：需要判断lchild不是前驱线索</span></span><br><span class="line">            <span class="built_in">PreThread</span>(T-&gt;lchild);  <span class="comment">// 先序遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);  <span class="comment">// 先序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T);  <span class="comment">// 先序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索二叉树的构造"><a class="header-anchor" href="#后序线索二叉树的构造"></a>后序线索二叉树的构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局遍历 pre 指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历二叉树并进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);  <span class="comment">// 后序遍历左子树</span></span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);  <span class="comment">// 后序遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);               <span class="comment">// 访问根节点并线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;lchild = pre;</span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;  <span class="comment">// 建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;  <span class="comment">// 将 pre 指针指向当前结点（即下一个访问结点的前驱结点）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T);  <span class="comment">// 后序线索化除最后一个结点的其他结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;  <span class="comment">// 注意：处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线索二叉树的遍历"><a class="header-anchor" href="#线索二叉树的遍历"></a>线索二叉树的遍历</h4><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序后继 <code>next</code>：</p><ol><li><p>若 <code>p-&gt;rtag == 1</code>，则  <code>next = p-&gt;rchild</code></p></li><li><p>若  <code>p-&gt;rtag == 0</code>，则  <code>next</code> 等于 <code>p</code> 的右子树中最左下的结点</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最左下结点（不一定是叶结点）</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// rtag==1 直接返回后继线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行中序遍历</span></span><br><span class="line"><span class="comment">// 利用线索实现的非递归算法 空间复杂度 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">NextNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中序线索二叉树中找到指定结点 <code>*p</code> 的中序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则  <code>pre = p-&gt;lchild</code></li><li>若  <code>p-&gt;ltag == 0</code>，则  <code>pre</code> 等于 <code>p</code> 的左子树中最右下的结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到以 p 为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)&#123;</span><br><span class="line">        p = p-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中序线索二叉树中找到结点 p 的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 左子树中最右下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// ltag==1 直接返回前驱线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对中序线索二叉树进行逆向中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RevInOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">LastNode</span>(T);p != <span class="literal">nullptr</span>;p = <span class="built_in">PreNode</span>(p))&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>先序线索二叉树找指定结点 <code>*p</code> 的先序后继 <code>next</code></p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code>；</li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子，分成两种情况考虑：<ul><li>若 <code>p</code> 有左孩子则先序后继为左孩子；</li><li>若没有左孩子则先序后继为右孩子</li></ul></li></ol><p>TODO 代码实现先序线索二叉树的后继遍历</p><p>在先序线索二叉树中找到指定结点 <code>*p</code> 的先序前驱 <code>pre</code></p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>next = p-&gt; lchild</code>；</li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子。二叉链表在先序遍历中，左右子树中的结点只可能是根的后继，不可能是前驱，故找不到先序前驱。三叉链表在先序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 为左孩子，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟为空，<code>p</code> 的父节点即为其前驱结点；</li><li><code>p</code> 是右孩子，其左兄弟非空，<code>p</code> 的前驱为左兄弟子树中最后一个被先序遍历的结点；</li><li>如果 <code>p</code> 是根结点，则 <code>p</code> 没有先序前驱。</li></ul></li></ol><hr><p>在后序线索二叉树找到指定结点 <code>*p</code> 的后序前驱 <code>pre</code>：</p><ol><li>若 <code>p-&gt;ltag == 1</code>，则 <code>pre = p-&gt;lchild</code></li><li>若 <code>p-&gt;ltag == 0</code>，则 <code>p</code> 必有左孩子，若 <code>p</code> 有右孩子，则后序前驱为右孩子；若 <code>p</code> 没有右孩子，则后序前驱为左孩子</li></ol><p>TODO 后序前驱遍历代码实现</p><p>在后序线索二叉树中找到指定结点 <code>*p</code> 的后序后继 <code>next</code>：</p><ol><li>若 <code>p-&gt;rtag == 1</code>，则 <code>next = p-&gt;rchild</code></li><li>若 <code>p-&gt;rtag == 0</code>，则 <code>p</code> 必有右孩子。二叉链表在后序遍历中，左右子树中的结点只可能是根的前驱，不可能是后继。三叉链表在后序遍历中，如果能找到 <code>p</code> 的父节点：<ul><li><code>p</code> 是右孩子，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟为空，<code>p</code> 的父节点即为其后继结点；</li><li><code>p</code> 是左孩子，其右兄弟非空，<code>p</code> 的后继为右兄弟子树中第一个被后序遍历的结点；</li><li>如果 <code>p</code> 是根节点，则 <code>p</code> 没有后继结点</li></ul></li></ol><h2 id="树、森林"><a class="header-anchor" href="#树、森林"></a>树、森林</h2><h3 id="树的存储结构"><a class="header-anchor" href="#树的存储结构"></a>树的存储结构</h3><p>树的存储方式有多种，既可采用顺序存储结构，又可采用链式存储结构，但无论采用何种存储方式，都要求能唯一地反映树中各结点之间的逻辑关系，这里介绍 3 种常用的存储结构。</p><h4 id="双亲表示法（顺序存储）"><a class="header-anchor" href="#双亲表示法（顺序存储）"></a>双亲表示法（顺序存储）</h4><p>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其<wavy>双亲结点</wavy>在数组中的位置。根结点下标为 0，其伪指针域为 -1。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="树的双亲表示法"></p><p>双亲表示法的存储结构描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;     <span class="comment">// 数据元素</span></span><br><span class="line">    <span class="keyword">int</span> partent;  <span class="comment">// 双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PTNode nodoes[MAX_TREE_SIZE];  <span class="comment">// 双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;                         <span class="comment">// 结点数</span></span><br><span class="line">&#125; PTree；</span><br></pre></td></tr></table></figure><h4 id="孩子表示法（顺序-链式存储）"><a class="header-anchor" href="#孩子表示法（顺序-链式存储）"></a>孩子表示法（顺序+链式存储）</h4><p>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 $n$ 个结点就有 $n$ 个孩子链表（叶子结点的孩子链表为空表）。这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 $n$ 个结点中孩子链表指针域所指向的 $n$ 个孩子链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;            <span class="comment">// 孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">// 下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>  <span class="comment">// 第一个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n, r;  <span class="comment">// 结点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%AD%A9%E5%AD%90%E5%92%8C%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="孩子和孩子兄弟表示法"></p><h4 id="孩子兄弟表示法（链式存储）"><a class="header-anchor" href="#孩子兄弟表示法（链式存储）"></a>孩子兄弟表示法（链式存储）</h4><p>孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span>  <span class="comment">// 第一个孩子和右兄弟指针</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><p>这种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个 <code>parent</code> 域指向其父结点，则查找结点的父结点也很方便。</p><h3 id="树、森林与二叉树的转换"><a class="header-anchor" href="#树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><p>由于二叉树和树都可以用二叉链表作为存储结构，因此以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树， 可以找到唯一的一棵二叉树与之对应。从物理结构上看，它们的二叉链表是相同的，只是解释不同而已。</p><p>树转换为二叉树的规则：每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="树与二叉树的对应关系"></p><p>树转换成二叉树的画法：</p><ol><li>在兄弟结点之间加一连线；</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉；</li><li>以树根为轴心，顺时针旋转45°。</li></ol><p>将森林转换为二叉树的规则与树类似。先将森林中的每棵树转换为二叉树，由于任何一棵和树对应的二叉树的右子树必空，若把森林中第二棵树根视为第一棵树根的右兄弟，即将第二棵树对应的二叉树当作第一棵二叉树根的右子树，将第三棵树对应的二叉树当作第二棵二叉树根的右子…以此类推，就可以将森林转换为二叉树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="森林与二叉树的对应关系"></p><p>森林转换成二叉树的画法：</p><ol><li>将森林中的每棵树转换成相应的二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线；</li><li>以第一棵树的根为轴心顺时针旋转45°。</li></ol><p>二叉树转换为森林的规则：若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开。二叉树根的右子树又可视为一个由除第一棵树 外的森林转换后的二叉树，应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林。二叉树转换为树或森林是唯一的。</p><h3 id="树和森林的遍历"><a class="header-anchor" href="#树和森林的遍历"></a>树和森林的遍历</h3><p>树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式（深度优先遍历）：</p><ol><li>先根遍历。若树非空，先访问根结点，再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则。其遍历序列与这棵树相应二叉树的先序序列相同。</li><li>后根遍历。若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则。其遍历序列与这棵树相应二叉树的中序序列相同。</li></ol><p>另外，树也有层次遍历（广度优先遍历），与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。</p><p>按照森林和树相互递归的定义，可得到森林的两种遍历方法。</p><ol><li>先序遍历森林。若森林为非空，则按如下规则进行遍历（效果等同于依次对各个树进行先根遍历）：<ul><li>访问森林中第一棵树的根结点。</li><li>先序遍历第一棵树中根结点的子树森林。</li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li><li>中序遍历森林。森林为非空时，按如下规则进行遍历（效果等同于依次对各个树进行后根遍历）：<ul><li>中序遍历森林中第一棵树的根结点的子树森林。</li><li>访问第一棵树的根结点。</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ul></li></ol><h2 id="树与二叉树的应用"><a class="header-anchor" href="#树与二叉树的应用"></a>树与二叉树的应用</h2><h3 id="二叉排序树（BST）"><a class="header-anchor" href="#二叉排序树（BST）"></a>二叉排序树（BST）</h3><h4 id="二叉排序树的定义"><a class="header-anchor" href="#二叉排序树的定义"></a>二叉排序树的定义</h4><p>二叉排序树（也称二叉查找树）或者是一棵空树，或者是具有下列特性的二叉树：</p><ol><li>若左子树非空，则左子树上所有结点的值均小于根结点的值。</li><li>若右子树非空，则右子树上所有结点的值均大于根结点的值。</li><li>左、右子树也分别是一棵二叉排序树。</li></ol><p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt; 右子树结点值，所以对二叉排序树进行中序遍历，可以得到一个<font color="#FF666">递增</font>的有序序列。</p><h4 id="二叉排序树的查找"><a class="header-anchor" href="#二叉排序树的查找"></a>二叉排序树的查找</h4><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。若二叉排序树非空，先将给定值与根结点的关键字比较，若相等，则查找成功；若不等，如果小于根结点的关键字，则在根结点的左子树上查找，否则在根结点的右子树上查找。这显然是一个递归的过程。</p><p>二叉排序树的非递归查找算法，最坏空间复杂度 $O(1)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉排序树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉排序树中查找值为 key 的结点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T != <span class="literal">nullptr</span> &amp;&amp; key != T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">            T = T-&gt;lchild;  <span class="comment">// 小于 在左子树上查找</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            T = T-&gt;rchild;  <span class="comment">// 大于 在右子树上查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉排序树的递归查找算法实现，最坏空间复杂度 $O(h)$ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> T;  <span class="comment">// 查找成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;key) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;lchild, key);  <span class="comment">// 在左子树中查找</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Search</span>(T-&gt;rchild, key);  <span class="comment">// 在右子树中找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的插入"><a class="header-anchor" href="#二叉排序树的插入"></a>二叉排序树的插入</h4><p>二叉排序树作为一种动态树表，其特点是树的结构通常不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的结点时再进行插入的。</p><p>插入结点的过程如下：若原二叉排序树为空，则直接插入结点；否则，若关键字 key 小于根结点值，则插入到左子树，若关键字 key 大于根结点值，则插入到右子树。插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访问的最后一个结点的左孩子或右孩子。</p><p>二叉排序树插入操作的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在二叉排序树插入关键字为 k 的新结点（递归实现）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 树为空，新插入的结点为根结点</span></span><br><span class="line">        T = (BSTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = T-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k == T-&gt;key) &#123;  <span class="comment">// 树中存在相同关键字结点。插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; T-&gt;key) &#123;  <span class="comment">// 插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;lchild, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BST_Insert</span>(T-&gt;rchild, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO 实现二叉排序树插入操作的非递归实现</p><h4 id="二叉排序树的构造"><a class="header-anchor" href="#二叉排序树的构造"></a>二叉排序树的构造</h4><p>构造二叉排序树的算法描述如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T, <span class="keyword">int</span> str[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T = <span class="literal">nullptr</span>;  <span class="comment">// 初始时T为空树</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123; <span class="comment">// 依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的删除"><a class="header-anchor" href="#二叉排序树的删除"></a>二叉排序树的删除</h4><p>在二叉排序树中删除一个结点时，不能把以该结点为根的子树上的结点都删除，必须先把被删除结点从存储二叉排序树的链表上摘下，将因删除结点而断开的二叉链表重新链接起来，同时确保二叉排序树的性质不会丢失。删除操作的实现过程按 3 种情况来处理：</p><ol><li>若被删除结点是叶结点，则直接删除，不会破坏二叉排序树的性质。</li><li>若结点 z 只有一棵左子树或右子树，则让 z 的子树成为 z 父结点的子树，替代 z 的位置。</li><li>若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）替代 z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ol><h4 id="二叉排序树的查找效率分析"><a class="header-anchor" href="#二叉排序树的查找效率分析"></a>二叉排序树的查找效率分析</h4><p>二叉排序树的查找效率，主要取决于树的高度。</p><p>若二叉排序树的左、右子树的高度之差的绝对值不超过 1，则这样的二叉排序树称为平衡二叉树，它的平均查找长度为 $O(\log_{2}{n})$ 。</p><p>若二叉排序树是一个只有右（左）孩子的单支树（类似于有序的单链表），则其平均查找长度为 $O(n)$。在最坏情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的单支树，此时二叉排序树的性能显著变坏，树的高度也增加为元素个数 $n$ 。</p><p>从查找过程看，二叉排序树与二分查找相似。就平均时间性能而言，二叉排序树上的查找和二分查找差不多。但二分查找的判定树唯一，而二叉排序树的查找不唯一，相同的关键字其插入顺序不同可能生成不同的二叉排序树，</p><h3 id="平衡二叉树⭐"><a class="header-anchor" href="#平衡二叉树⭐"></a>平衡二叉树⭐</h3><h4 id="平衡二叉树的定义"><a class="header-anchor" href="#平衡二叉树的定义"></a>平衡二叉树的定义</h4><p>为避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过 1， 将这样的二叉树称为平衡二叉树（Balanced Binary Tree），简称平衡树（ AVL 树）。定义结点左子树与右子树的高度差为该<font color="#ea66a6">结点的平衡因子</font>，则平衡二叉树结点的平衡因子的值只可能是 -1、0 或 1。</p><p>因此，平衡二叉树可定义为或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树的插入"><a class="header-anchor" href="#平衡二叉树的插入"></a>平衡二叉树的插入</h4><p>二叉排序树保证平衡的基本思想如下：每当在二叉排序树中插入（或删除）一个结点时，首先检查其插入路径上的结点是否因为此次操作而导致了不平衡。若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点 A，再对以 A 为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p><p>注意：每次调整的对象都是<font color="#ea66a6">最小不平衡子树</font>，即以插入路径上离插入结点最近的平衡因子的绝对值大于 1 的结点作为根的子树。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="最小不平衡子树示意图"></p><p>平衡二叉树的插入过程的前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。可将调整的规律归纳为下列 4 种情况：</p><ol><li>LL 平衡旋转（右单旋转）。由于在结点 A 的左孩子（L）的左子树（L）上插入了新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要一次向右的旋转操作。 将 A 的左孩子 B 向右上旋转代替 A 成为根结点，将 A 结点向右下旋转成为 B 的右子树的根结点，而 B 的原右子树则作为 A 结点的左子树。如下图所示，其中结点旁的数值代表结点的平衡因子，而用方块表示相应结点的子树，下方数值代表该子树的高度。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LL平衡旋转"></p><ol start="2"><li>RR 平衡旋转（左单旋转）。由于在结点 A 的右孩子（ R ）的右子树（ R ）。上插入了新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要一次向左的旋转操作。将 A 的右孩子 B 向左，上旋转代替 A 成为根结点，将 A 结点向左下旋转成为 B 的左子树的根结点，而 B 的原左子树则作为 A 结点的右子树。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RR平衡旋转"></p><ol start="3"><li>LR 平衡旋转（先左后右双旋转）。由于在 A 的左孩子（L）的右子树（R）。上插入新结点，A 的平衡因子由 1 增至 2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。先将 A 结点的左孩子 B 的右子树的根结点 C 向左上旋转提升到 B 结点的位置，然后再把该 C 结点向右上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/LR%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="LR平衡旋转"></p><ol start="4"><li>RL 平衡旋转（先右后左双旋转）。由于在 A 的右孩子（R）的左子树（L）。上插入新结点，A 的平衡因子由 -1 减至 -2，导致以 A 为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。先将 A 结点的右孩子 B 的左子树的根结点 C 向右上旋转提升到 B 结点的位置，然后再把该 C 结点向左上旋转提升到 A 结点的位置。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/RL%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC.png" alt="RL平衡旋转"></p><p>假设关键字序列为 <code>&#123;15, 3, 7, 10, 9, 8&#125;</code>，通过该序列生成平衡二叉树的过程如下图所示。(d) 插入 7 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的右子树，故执行 LR 旋转，先左后右双旋转，调整后的结果如图 (e) 所示。图 (g) 插入 9 后导致不平衡，最小不平衡子树的根为 15，插入位置为其左孩子的左子树，故执行 LL 旋转，右单旋转，调整后的结果如图 (h) 所示。图 (i) 插入 8 后导致不平衡，最小不平衡子树的根为 7，插入位置为其右孩子的左子树，故执行 RL 旋转，先右后左双旋转，调整后的结果如图 (j) 所示。</p><p><img src="https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@main/img/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%94%9F%E6%88%90%E8%BF%87%E7%A8%8B.png" alt="平衡二叉树的生成过程"></p><h4 id="平衡二叉树的查找"><a class="header-anchor" href="#平衡二叉树的查找"></a>平衡二叉树的查找</h4><p>在平衡二叉树上进行查找的过程与二叉排序树的相同。因此，在查找过程中，与给定值进行比较的关键字个数不超过树的深度。假设以 $n_h$ 表示深度为 $h$ 的平衡树中含有的最少结点数。显然，有 $n_0=0,n_1=1,n_2=2$ ，并且有 $n_h=n_{h-1}+n_{h-2}+1$ 。 可以证明，含有 $n$ 个结点的平衡二叉树的最大深度为 $O(\log_{2}{n})$，因此平衡二叉树的平均查找长度为 $O(\log_{2}{n})$ 。</p><h3 id="哈夫曼树和哈夫曼编码"><a class="header-anchor" href="#哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><h4 id="哈夫曼树的定义"><a class="header-anchor" href="#哈夫曼树的定义"></a>哈夫曼树的定义</h4><p>在许多应用中，树中结点常常被赋予一个表示某种意义的数值，称为该<font color="#ea66a6">结点的权</font>（如：表示结点的重要性）。</p><p>从树的根到任意结点的路径长度（经过的边数）与该结点上权值的乘积，称为该<font color="#ea66a6">结点的带权路径长度</font>。</p><p>树中所有叶结点的带权路径长度之和称为该<font color="#ea66a6">树的带权路径长度</font>，记为 $$WPL=\sum_{i=1}^{n} w_il_i$$ 式中，$w_i$ 是第 $i$ 个叶结点所带的权值，$l_i$ 是该叶结点到根结点的路径长度。</p><p>在含有 $n$ 个带权叶结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为<font color="#ea66a6">哈夫曼树</font>，也称最优二叉树。</p><h4 id="哈夫曼树的构造"><a class="header-anchor" href="#哈夫曼树的构造"></a>哈夫曼树的构造</h4><p>给定 $n$ 个权值分别为 $w_i,\ w_2,\dots ,w_n$ 的结点，构造哈夫曼树的算法描述如下：</p><ol><li>将这 $n$ 个结点分别作为 $n$ 棵仅含一个结点的二叉树，构成森林 $F$。</li><li>构造一个新结点，从 $F$ 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和。</li><li>从 $F$ 中删除刚才选出的两棵树，同时将新得到的树加入 $F$ 中。</li><li>重复步骤 2 和 3，直至 $F$ 中只剩下一棵树为止。</li></ol><p>从上述构造过程中可以看出哈夫曼树具有如下特点：</p><ol><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大。</li><li>构造过程中共新建了$n-1$个结点（双分支结点），因此哈夫曼树的结点总数为 $2n-1$ 。</li><li>每次构造都选择 2 棵树作为新结点的孩子，因此哈夫曼树中不存在度为 1 的结点。</li></ol><h4 id="哈夫曼编码"><a class="header-anchor" href="#哈夫曼编码"></a>哈夫曼编码</h4><p>在数据通信中：</p><ul><li>若对每个字符用相等长度的二进制位表示，称这种编码方式为<font color="#ea66a6">固定长度编码</font>。</li><li>若允许对不同字符用不等长的二进制位表示，则这种编码方式称为<font color="#ea66a6">可变长度编码</font>。</li></ul><p>可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。</p><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<font color="#ea66a6">前缀编码</font>。举例:设计字符 A，B 和 C 对应的编码 0，101 和 100 是前缀编码。对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样的解码操作。例如，码串 00101100 可被唯一地翻译为0，0，101 和 100。另举反例：如果再将字符 D 的编码设计为 00，此时 0 是 00 的前缀，那么这样的码串的前两位就无法唯一翻译。</p><p>由哈夫曼树得到哈夫曼编码是很自然的过程。首先，将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为 0 表示“转向左孩子”，标记为 1 表示“转向右孩子”。</p><p>注意：0 和 1 究竟是表示左子树还是右子树没有明确规定。左、右孩子结点的顺序是任意的，所以构造出的哈夫曼树并不唯一，但各哈夫曼树的带权路径长度 WPL 相同且为最优。此外，如有若干权值相同的结点，则构造出的哈夫曼树更可能不同，但 WPL 必然相同且是最优的。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>推导过程：$$\frac{m^{h-1}-1}{m-1}&lt;n\le \frac{m^h-1}{m-1}$$ $$m^{h-1}&lt;n(m-1)+1\le m^h $$ $$ h-1 &lt; \log_{m}{(n(m-1)+1)} \le h $$ $$h_{min}= \left \lceil \log_{m}{(n(m-1)+1) } \right \rceil $$ <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">树</summary>
    
    
    
    <category term="数据结构" scheme="https://halo123.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://halo123.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
